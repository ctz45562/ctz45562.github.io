{"meta":{"title":"ctz's blog","subtitle":"ロリは正義だ","description":"百合大法好！\\(⁎≧∀≦⁎)/♪","author":"ctz","url":"https://ctz45562.github.io","root":"/"},"pages":[{"title":"3.24 Butterfly","date":"2022-03-24T06:58:17.000Z","updated":"2022-03-24T07:39:55.492Z","comments":true,"path":"3-24-Butterfly.html","permalink":"https://ctz45562.github.io/3-24-Butterfly.html","excerpt":"挺久没有自言自语了，不是忙，一直不是很想说话其实是懒 跨年的时候还有点想写，结果想了想，这一年也没干什么，过了没有意义的半年高三，没有意义的暑假和……可能有点意义的半年大一。","text":"挺久没有自言自语了，不是忙，一直不是很想说话其实是懒 跨年的时候还有点想写，结果想了想，这一年也没干什么，过了没有意义的半年高三，没有意义的暑假和……可能有点意义的半年大一。 寒假末期粉毛落地，立绘真的戳我，尽管刚被限定池榨干，我还是强氪了出来。澄闪也是我第一个拉到90级和专九的。我也很少见地看完了那次活动剧情，当时在高铁上气得我差点把手机掰碎。 去年年底被憨憨忽悠去买了个板子，开始摸索画画。我这才明白画画真不简单，尤其是人体，难顶。 现在画的少了，但我还是希望能坚持，要不然我可太废物了。 这段时间基本没补过番，我可能变了吧，不想看太安静的日常，想找点致郁的。开补赤瞳，但是我看之前就知道主角团基本都没了，而且第一个被刀的明显逻辑有问题，没感觉，我就弃了。 前几天看了个up主，动漫配小品语音，有一个是妹抖龙S的，我突然就想去看看。看着看着我就想起来，小林家的龙女仆对我还真是意义非凡。初三那年的寒假，我表哥在补番，我凑上去问，他告诉我是小林家的龙女仆。暑假我无意间看到这部番，想起来我表哥看过，我就点了进去。当时彻底被迷住了，甚至在想“看一集少一集，我得省着点看”，但还是一天补完了，然后我就入宅了。 那时候我是托尔康娜双厨，有一半xp是她们给的（另一半是智乃），我的女仆，彩色头发，萝莉xp都是源于此吧。 我从小林了解了程序员这一工作，或者说是白领生活。我一直不想成为人们的交点，很想过上这种普普通通、无人知晓生活，哪怕没有龙女仆。于是我铁了心要学计算机，因此高中学了两年信竞，填志愿也只看计算机。 如果当年我没有点开小林家的龙女仆，或者再远一点，我都没有从表哥那里了解到这部番…… 我就不会收集这么多动漫周边，玩着二次元手游，歌单里不会全是日语歌。我也不会跑去学日语学画画。甚至，我可能不会碰信竞，不在ZJU，不在计算机专业。 也许这就是缘分吧。 以上。"},{"title":"分类","date":"2019-04-15T00:05:24.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"categories/index.html","permalink":"https://ctz45562.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2022-03-24T06:45:47.601Z","comments":false,"path":"about/index.html","permalink":"https://ctz45562.github.io/about/index.html","excerpt":"","text":"「自我介绍」 ctz，亦作Cortizy，来自ZJU计科。 原神咸鱼玩家，云顶&amp;大乱斗菜比玩家，方舟养老玩家。 二次元禁断综合征重度患者。本命作『请问您今天要来点兔子吗』。 受到入宅番『小林家的龙女仆』的影响希望成为一只程序猿。 曾经是一只蒟蒻OIer。 「关于博客」 平台：hexo 主题：sakura 高中时创建的，魔改至今。现在比较摸，随缘更新，有机会的话会考虑买个域名。 由于魔改了很多地方，而且预览都是在Firefox上，如果有什么bug或者看着不顺眼的地方请反馈给我。 如果您对某些魔改有兴趣的话，大部分都可以在这里找到。 关于这里的学术文章，由于博主打字不过脑子，如果有错误请尽管指出，直接在留言评论即可。"},{"title":"留言板","date":"2020-01-09T12:37:33.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"comments/index.html","permalink":"https://ctz45562.github.io/comments/index.html","excerpt":"","text":"一言Hitokoto Loading... update(); function update() { gethi = new XMLHttpRequest(); gethi.open(\"GET\", \"https://v1.hitokoto.cn/?c=a\"); gethi.send(); gethi.onreadystatechange = function () { if (gethi.readyState === 4 && gethi.status === 200) { var Hi = JSON.parse(gethi.responseText); document.getElementById('hitokoto').innerHTML = \"『 \"+Hi.hitokoto+\" 』\"; document.getElementById('from').innerHTML = \"——\" + Hi.from + \"\"; document.getElementById('from').style[\"margin-bottom\"]=\"15px\"; } } } 无论是对这个blog的改进意见，还是对博主垃圾水平的嘲讽，都欢迎你在下方留言吐槽 （之前一直把「关于」当留言板用，原先的评论都搬过来了qwq）"},{"title":"search","date":"2019-02-17T01:30:31.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"search/index.html","permalink":"https://ctz45562.github.io/search/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-02-17T09:24:38.000Z","updated":"2020-06-21T09:41:03.000Z","comments":false,"path":"tags/index.html","permalink":"https://ctz45562.github.io/tags/index.html","excerpt":"","text":""},{"title":"游戏","date":"2019-11-10T09:42:45.000Z","updated":"2021-06-18T05:07:31.000Z","comments":false,"path":"games/index.html","permalink":"https://ctz45562.github.io/games/index.html","excerpt":"","text":"高级剽客作品展 教程 2048 flappy bird 五子棋 生火间 水果忍者 希望有一天我能自己写出来游戏"},{"title":"友情链接","date":"2018-12-19T15:11:06.000Z","updated":"2021-09-26T12:52:29.649Z","comments":true,"path":"links/index.html","permalink":"https://ctz45562.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"离散英语及其应用学习笔记","slug":"离散英语及其应用学习笔记","date":"2022-03-21T14:43:05.000Z","updated":"2022-06-19T04:21:23.714Z","comments":true,"path":"2022/03/21/离散英语及其应用学习笔记/","link":"","permalink":"https://ctz45562.github.io/2022/03/21/%E7%A6%BB%E6%95%A3%E8%8B%B1%E8%AF%AD%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"但凡教材不是英文的","text":"但凡教材不是英文的 前言第一门需要做笔记的课程。 内容高中数学和OI都搞过，主要问题是英文授课，得能看懂题目。 下面全是从『离散数学及其应用（第八版）』和中文版『离散数学及其应用（第六版）』抠出来的。 重拾$\\LaTeX$。 英汉大词典（雾）1 命题逻辑和证明1.1 命题逻辑 proposition:命题 propositional variables/sentential variables:代指命题的字母（命题变量） truth value:命题的真假 atomic propositions:最简命题 compound propositions:复合命题 logical operators:逻辑运算符 connectives:二元以上的逻辑运算符 truth table:真值表 negation operator:非 conjunction:与（合取） disjunction:或（析取） exclusive or:异或 conditional statement/implication:$p\\rightarrow q$ hypothesis/antecedent/premise:$p$ conclusion/consequence:$q$ 当且仅当$p$真$q$假时$p\\rightarrow q$为假 人话:“if p, then q” “p implies q”“if p, q” “p only if q”“p is sufficient for q” “a sufficient condition for q is p”“q if p” “q whenever p”“q when p” “q is necessary for p”“a necessary condition for p is q” “q follows from p”“q unless ¬p” “q provided that p” converse:$q\\rightarrow p$（逆命题） contrapositive:$\\lnot q\\rightarrow \\lnot p$（倒置命题，与原命题等价） inverse:$\\lnot p\\rightarrow \\lnot q$（反命题） equivalent:等价 biconditional statement/bi-implications:$p\\leftrightarrow q$ 人话:“p if and only if q”“p is necessary and sufficient for q”“if p then q, and conversely”“p iff q.” “p exactly when q.” Boolean variable:布尔变量 bit operations:位运算 bitwise:按位 1.2 命题逻辑的应用 represent System Specifications:系统规范 logic circuit/digital circuit:逻辑门 inverter:非门 1.3 命题等价 tautology:永真式 contradiction:永假式 contingency:不永式 $p\\equiv q$:$p\\leftrightarrow q$永真（逻辑等价） $p\\rightarrow q\\equiv \\lnot p\\lor q$（conditional-disjunction equivalence） De Morgan’s Laws:$\\lnot(p\\land q)\\equiv\\lnot p\\lor\\lnot q\\\\\\lnot(p\\lor q)\\equiv\\lnot p\\land\\lnot q$ satisfiable:不永假 solution:让命题$T$的一组解 disjunctive normal form:$(p_1\\land p_2 \\land p_3)\\lor(\\lnot p_1\\land p_2\\land p_3)\\lor(\\lnot p_1\\land\\lnot p_2\\land p_3)$（析取范式） 列真值表，找$T$的行，行内合取，不同行析取 conjunctive normal form:$(p_1\\lor p_2 \\lor p_3)\\land(\\lnot p_1\\lor p_2\\lor p_3)\\land(\\lnot p_1\\lor\\lnot p_2\\lor p_3)$（合取范式） 列真值表，找$F$的行，行内取反析取，不同行合取 1.4 谓词和量词 predicate:谓词 quantifiers:量词 propositional function:命题函数 n-place predicate/n-ary predicate:n元命题函数 preconditions:输入满足的条件（前置条件） postconditions:输出满足的条件（后置条件） quantification:从命题函数产生命题（量化） predicate calculus:处理谓词和量词的逻辑领域（谓词演算） universal quantification:$\\forall xP(x)$（全称量化） domain of discourse/universe of discourse:论述范围 counterexample:反例 universal quantifier:$\\forall$（全称量词） 人话:“for all”“for every”“all of,” “for each,” “given any,” “for arbitrary,” “for each,” and “for any” existsential quantification:$\\exists xP(x)$（存在量化） existsential quantifier:$\\exists$（存在量词） 人话:“There is an x such that P(x),”“There is at least one x such that P(x),”“For some xP(x).” uniqueness quantifier:$\\exists !$（唯一量词） 1.5 嵌套量词 nested quantifier:$\\forall x\\exists y\\forall z$（嵌套量词） 1.6 推理规则 argument:论证 valid:有效性 premises:前提 argument form:论证中，命题变量代替命题（论证形式） fallacies:谬误（不正确推理） fallacy of affirming theconclusion:$\\because p\\rightarrow q,q\\therefore p$（肯定结论谬误） fallacy of denying the hypothesis:$\\because p\\rightarrow q,\\lnot p\\therefore \\lnot q$（否定假设谬误） Universal instantiation:$\\because\\forall xP(x)\\therefore P(c)$（全称例示） Universal generalization:$\\because P(c)\\ for\\ an\\ arbitrary\\ c\\therefore\\forall xP(x)$（全称生成） existsential instantiation:$\\because\\exists xP(x)\\therefore P(c)\\ for\\ some\\ element\\ c$（存在例示） existsential generalization:$\\because P(c)\\ for\\ some\\ element\\ c\\therefore \\exists xP(x)$（存在生成） universal modus ponens:$\\because\\forall x(P(x) \\rightarrow Q(x)),P(a)\\ where\\ a\\ is\\ a\\ particular\\ element\\ in\\ the\\ domain\\therefore Q(a)$（全称假言推理） universal modus tollens:$\\because\\forall x(P(x)\\rightarrow Q(x)),\\lnot Q(a)\\ where\\ a\\ is\\ a\\ particular\\ element\\ in\\ the\\ domai\\therefore\\lnot P(a)$（全称取拒式） 1.7 证明导论 theorem：定理 lemma：引理 corollary：推论 conjecture：猜想 direct proof：直接证明 same/opposite parity：奇偶相同/不同 perfect square：完全平方数 proof by contraposition：要证$p\\rightarrow q$，即证$\\lnot q\\rightarrow \\lnot p$（反证法） trivial proof：用$q$为真证明$p\\rightarrow q$为真 proofs by contradiction：要证$p$，即证$\\lnot p\\rightarrow(r\\land\\lnot r)$ begging the question/circular reasoning：证明中用到了未知正确性的待证论题（偷用论题/循环论证） 1.8 证明的方法和策略 $\\left(\\bigvee\\limits_{i=1}^np_i\\right)\\rightarrow q\\leftrightarrow\\bigwedge\\limits_{i=1}^n(p_i\\rightarrow q)$ exhaustive proof/proofs by exhaustion：测试所有情况以证明（穷举证明） perfect power：$n^\\alpha(n,\\alpha\\in Z,a\\gt1)$（全幂数） proof by cases：找出所有情况，分别证明（分情形证明） without loss of generality：证明一种情形，可以简单地推到另一种情形（不失一般性），简写为WLOG existence proof:证明$\\exists xP(x)$（存在性证明） constructive：找出$c$满足$P(c)$的证明（构造性的） witness:找到的$c$ nonconstructive：不找$c$的证明（非构造性的） uniqueness proof：证明$\\exists!xP(x)$（唯一性证明），有如下两步 existence：证明$P(x)$ uniqueness：证明如果$P(y)$，则$y=x$ forward and backward reasoning:前推和后推 rational number:有理数 arithmetic mean：$\\dfrac{\\sum\\limits_{i=1}^na_i}{n}$（算术平均数） geometric mean：$\\sqrt[n]{\\prod\\limits_{i=1}^na_i}$（几何平均数） harmonic mean：$\\dfrac{n}{\\sum\\limits_{i=1}^n\\frac{1}{a_i}}$（调和平均数） quadratic mean：$\\sqrt{\\dfrac{\\sum\\limits_{i=1}^na_i^2}{n}}$（平方平均数） tile：填充 checkerboard：若干方格组成的矩形棋盘 standard checkerboard:$8\\times8$的棋盘 domino：$1\\times2$的骨牌 Fermat’s last theorem：若$xyz\\neq0$，则$x^n+y^n=z^n(n\\ge2)$无整数解（费马大定理） 2 集合与函数2.1 集合 set:集合 contain：包含 elements/members：集合的成员 roster method：$\\{a,b,c,d\\}$（穷举表示集合） set builder:$\\{x|\\dots\\}$（构造符号表示） empty set/null set：空集 singleton set：只有一个元素的集合 universal set：全集 Venn diagram：维恩图 subset：子集 superset：超集 proper subset：真子集 finite set：有限集 cardinality：集合元素的个数，记作$|S|$（基数） power set:所有子集的集合，记作$\\Rho(S)$（幂集合） ordered n-tuple:$(a_1,a_2,\\dots,a_n)$（有序$n$元组） ordered pairs:有序二元组 Cartesian product：$A\\times B=\\{(a,b)|a\\in A\\land b\\in B\\};A_1\\times A_2\\times\\dots\\times A_n=\\{(a_1,a_2,\\dots,a_n)|a_i\\in A_i\\ for\\ i=1,2,\\dots,n\\}$（笛卡尔积） $A\\times B$的一个子集称为$a\\ relation\\ from\\ the\\ set\\ A\\ to\\ the\\ set\\ B$ $A\\times A$的一个子集被称为$a\\ relation\\ on\\ A$ truth set：$\\{x\\in D|P(x)\\}$（真值集合） 2.2 集合操作 union：$A\\cup B$（并集） intersection：$A\\cap B$（交集） disjoint：$A\\cap B=\\emptyset$ principle of inclusion–exclusion:$|A\\cup B|=|A|+|B|-|A\\cap B|$（容斥原理） complementof B with respect to A/difference:$A-B$（差集） complement：$\\overline{A}$（补集） membership tables：成员表，类似真值表 multiset:$\\{m_1\\cdot a_1,m_2\\cdot a_2,\\dots,m_n\\cdot a_n\\}$（可重集） multiplicities:元素出现的次数$m_i$ 并集$m_i$取$\\max$，交集$m_i$取$\\min$，差集$m_i$相减（最小为$0$），和集（sum）$m_i$相加 2.3 函数设函数$f$定义域为$A$，值域为$B$ domain:定义域 codomain:值域 image/preimage:$a/b(f(a)=b)$ injective/one-to-one:$f(a)=f(b)\\iff a=b$（单射） (strictly)increasing/decreasing:（严格）单增/单减 surjective/onto:$\\forall b\\in B,\\exists a\\in A,f(a)=b$（满射） one-to-one correspondence/bijection:双射（单射+满射） inverse function:反函数$f^{-1}$ $(f\\circ g)(x):f(g(x))$ graph:$\\{(a,b)|a\\in A,b=f(a)\\}$（图像） floor function/ceiling function:向下取整/向上取整函数 factorial function:阶乘函数 partial function/total funtion:定义域残缺/完整 2.4 数列与求和 sequence:数列 term:数列的项 geometric progression:几何数列（等比数列） initial term:首项 common ratio:公比 arithmetic progression:等差数列 initial term common difference:公差 recurrence relation:递推关系 solution of a recurrence relation:有递推关系的数列 initial conditions:递推的初始条件 Fibonacci sequence:$f_0=0,f_1=1$ iteration:递推公式推通项的一种方法，有下面两种（e.g. $a_n=a_{n-1}+3,a_1=2$）: forward substitution: $a_2=2+3\\\\a_3=(2+3)+3=2+2\\cdot 3\\\\a_4=(2+2\\cdot 3)+3=2+3\\cdot 3\\\\\\dots\\\\a_n=a_{n−1}+3=(2+3\\cdot(n−2))+3=2+3(n−1)$ backward substitution: $a_n=a_{n−1}+3\\\\=(a_{n−2}+3)+3\\\\=a_{n−2}+3\\cdot2\\\\=(a_{n−3}+3)+3\\cdot2\\\\=a_{n−3}+3\\cdot3\\\\\\dots\\\\=a_2+3(n−2)\\\\=(a_1+3)+3(n−2)\\\\=2+3(n−1)$ summation:求和（e.g.$\\sum\\limits_{i=m}^na_i$） index of summation:$i$（求和下标） lower limit/upper limit:$m$/$n$ 2.5 基数 countable:集合是有限集或其基数与自然数集相同（可数） uncountable:不uncountable aleph null:可数的无限集合用$|S|=\\aleph_0$表示其个数 $countable\\cup countable = countable$ computable:计算机已经算出来的函数 uncomputable:不computable 3 算法3.1 算法 pseudocode:伪代码 searching problems:在有序的列表中找特定元素 linear search/sequential search:暴力循环 binary search:二分 sort bubble sort:冒泡排序 insertion sort:插排 string matching:字符串匹配 pattern:模式串 text:母串 shift:匹配的首地址 naive string matcher:暴力$O(nm)$循环 greedy algorithms:贪心 optimization problems:找最优解的问题 cashier’s algorithm:用最少的硬币找零 halting problem:能否设计一个函数，传入任意源代码和其输入，判断程序能否在有限时间算出（无解） mode:众数 3.2 函数的走势 big-O notation:如果$\\exists C,k,|f(x)|\\le C|g(x)|$对$\\forall x&gt;k$成立，则称$f(x)\\ is\\ O(g(x))$ witnesses to the relationship f(x) is O(g(x)):$C,k$ $f_1\\ is\\ O(g_1),f_2\\ is\\ (g_2)$，则$f_1+f_2\\ is\\ O(\\max\\{g_1,g_2\\}),f_1f_2\\ is\\ O(g_1g_2)$ big-Omega notation:如果$\\exists C&gt;0,k,|f(x)|\\ge C|g(x)|$对$\\forall x&gt;k$成立，则称$f(x)\\ is\\ \\Omega(g(x))$ big-Theta notation:若$f(x)\\ is\\ O(g(x)),f(x)\\ is\\ \\Omega(g(x))$，则称： $f(x)\\ is\\ \\Theta(g(x))$ $f(x)\\ is\\ big-Theta\\ of\\ g(x)$ $f(x)\\ is\\ of\\ order\\ g(x)$ $f(x)\\ and\\ g(x)\\ are\\ of\\ the\\ same\\ order$ $f(x)\\ is\\ \\Omega(g(x))\\leftrightarrow g(x)\\ is\\ \\Omega(f(x))$ 3.3 函数复杂度 computational complexity:计算复杂度 time complexity:时间复杂度 space complexity:空间复杂度 worst-case complexity:最坏情况 average-case complexity:平均 brute-force algorithm:暴力算法 tractable:最坏$\\Theta(n^b)$ intractable:不tractable class NP:可以$\\Theta(n^b)$验证答案的问题 class P:tractable的问题 NP-complete problems:如果其中任何问题可用多项式复杂度解决，则所有$NP$都能用多项式复杂度解决（NP完全问题） P versus NP:$P$是否等于$NP$ 4 同余4.1 除和模 如果$a|b$: a divides b a is a factor or divisor of b b is a multiple of a dividend:被除数 divisor:除数 quotient:商 remainder:余数 a is congruent to b modulo m:$a\\equiv b\\pmod m$ 亦称a and b are congruent modulo m congruence:同余式 modulus(pl. moduli):m $a+_mb=(a+b)\\mod m$ $a\\cdot _mb=(a\\cdot b)\\mod m$ 4.2 整数的表示 base b expansion of n:$n=\\sum\\limits_{k=0}^{\\infty}a_kb^k$ decimal expansions:十进制展开 binary expansions:二进制展开 octal expansions:八进制展开 hexadecimal expansions:十六进制展开 Fast Modular Exponentiation:快速幂 4.3 质数&amp;最大公约数 prime:质数 composite:合数 trial division:用$\\le\\sqrt{n}$的质数判断$n$是否为质数 sieve of Eratosthenes:埃氏筛 $\\pi(x)$:$\\le x$的质数个数，接近于$\\dfrac{x}{\\ln x}$ greatest common divisor of a and b:$\\gcd(a,b)$ a and b are relatively prime:$a\\perp b$（互质） pairwise relatively prime：一堆数两两互质 least common multiple：$lcm$ The Euclidean Algorithm：辗转相除法 $\\exists s,t\\in\\mathbb{Z},\\gcd(a,b)=sa+tb$ Bezout coefficients of a and b:s,t Bezout’s identity:等式$\\gcd(a,b)=sa+tb$ 4.4 逆元 inverse：逆元 The Chinese Remainder Theorem：中国剩余定理$\\boxed{\\begin{matrix}x\\equiv a_1\\pmod {m_1}\\\\x\\equiv a_2\\pmod {m_2}\\\\\\vdots\\\\x\\equiv a_n\\pmod {m_n}\\end{matrix}}$ $\\boxed{\\begin{matrix}m=\\prod\\limits_{i=1}^nm_i\\\\M_k=\\dfrac{m}{m_k}\\\\y_k\\equiv M_k^{-1}\\pmod {m_k}\\\\x\\equiv\\sum\\limits_{i=1}^na_iM_iy_i\\pmod m\\end{matrix}}$ Fermat’s Little Theorem:费马小定理 $a^{p-1}\\equiv1\\pmod p(p\\in \\mathbb{P},p\\nmid a)$ $a^p\\equiv a\\pmod p(p\\in\\mathbb{P})$ pseudoprimes to the base b:满足$b^{n-1}\\equiv1\\pmod n$的合数$n$（伪素数） Carmichael number:满足对$\\forall b\\perp n$有$b^{n-1}\\equiv1\\pmod n$的合数$n$ primitive root：原根 若$g^k\\mod m(0\\le g,k\\le m-1)$两两不同，则$g$为模数$m$的原根 若$g^b\\equiv a\\pmod m$，则称b is the discrete logarithm of a modulo m to the base g 4.5 同余的应用 Hashing Functions：哈希 Pseudorandom Numbers：伪随机数 linear congruential method：$x_{n+1}=(ax_n+c)\\mod m$ modulus:m multiplier:a increment:c seed:$x_0$ pure multiplicative generator:$c=0$ 5 归纳&amp;递归5.1 数学归纳法 mathematical induction：数学归纳法 设$P(n)$ $Basis\\ Step:P(1)\\ is\\ true$ $Inductive\\ Step:\\forall k,P(k)\\rightarrow P(k+1)\\ is\\ true$ harmonic series:调和级数 5.2 强数学归纳&amp;井井有序 strong induction:强数学归纳 $\\forall k,P(1)\\land P(2)\\land\\dots P(k)\\rightarrow P(k+1)\\ is\\ true$ 5.3 递归定义&amp;结构化归纳 recursion/inductive definition：递归定义的函数 basis step：初始定义 recursive step：递归规则 exclusion rule：例外规则 6 数数6.1 数数基础 product rule:乘法原理 sum rule：加法原理 the subtraction rule/principle of inclusion–exclusion:容斥原理 tree diagrams：树状图 6.2 抽屉原理 The Pigeonhole Principl：抽屉原理 n个物品放到n+1个盒子里，则至少有一个盒子有不少于1个物品 k+1个元素的集合到k个元素的集合的函数一定不单射 n个物品放到k个盒子里，至少有一个盒子有不少于$\\left\\lceil\\dfrac{n}{k}\\right\\rceil$个物品 任何长为$n^2+1$的实数列一定存在一个长为$n$的严格单增或单减的子数列 6.3 排列组合 permutation：$P(n,r)$（排列） r-permutation:r个数的排列 combination：$C(n,r)\\dbinom{n}{r}$（组合） binomial coefficient：二项式系数 combinatorial proof:组合数证明 6.4 二项式系数和一堆等式 The Binomial Theorem：二项式定理 pascal’s identity:$C_{n+1}^m=C_n^m+C_n^{m-1}$ Pascal’s triangle:杨辉三角 vandermonde’s identity:范德蒙德恒等式 $C_{n+1}^{r+1}=\\sum\\limits_{i=r}^nC_i^r$ 6.5 广义的排列组合？ with repetition：可重 $x_1+x_2+\\dots+x_n=r(x_i\\ge0)$:$C_{n+r-1}^{n-1}$ $x_1+x_2+\\dots+x_n=r(x_i&gt;0)$:$C_{r-1}^{n-1}$ Stirling numbers of the second kind:第二类斯特林数 8 进阶数数技巧8.2 线性递推关系 linear homogeneous recurrence：$a_n=c_1a_{n-1}+c_2a_{n-2}+\\ldots+c_ka_{n-k}$（线性齐次递推关系） root：方程的解 multiplicity：方程某个根的重数 对递推关系$a_n=c_1a_{n-1}+c_2a_{n-2}+\\ldots+c_ka_{n-k}$，解特征方程方程$r^k-c_1r^{k-1}-\\ldots-c_k=0$得根$r_1,r_2\\ldots r_t$和对应重数$m_1,m_2\\ldots m_t$，则$a_n=\\sum\\limits_{i=1}^nr_i^n\\sum\\limits_{j=0}^{m_i-1}\\alpha_{i,j}n^j$，$\\alpha_{i,j}$的值由初始条件确定 linear nonhomogeneous recurrence relation with constant coefficients：$a_n=c_1a_{n-1}+c_2a_{n-2}+\\ldots+c_ka_{n-k}+F(n),F(n)\\neq0$且$F(n)$只与$n$有关（常系数线性非齐次递推关系） associated homogeneous recurrence relation：上面那个去掉$F(n)$的递推关系（关联齐次递归关系） 对常系数线性非齐次递推关系，若$\\{a_n^{(p)}\\}$为其一个特解（即忽略初始条件的解），$\\{a_n^{(h)}\\}$为其关联齐次递推关系的解，则其解为$a_n=a_n^{(p)}+a_n^{(h)}$ 若$F(n)=s^n\\sum\\limits_{i=0}^tb_in^i$，$s$为关联齐次递归关系的特征方程根且重数为$m$，则有特解$a_n^{(p)}=n^m\\sum\\limits_{i=0}^tp_in^i$；否则有特解$a_n^{(p)}=\\sum\\limits_{i=0}^tp_in^i$（即$m=0$） 若$F(n)=G(n)+H(n)$，$a_n=\\sum\\limits_{i=1}^kc_ia_{n-i}+F(n),p_n=\\sum\\limits_{i=1}^kc_ip_{n-i}+G(n),q_n=\\sum\\limits_{i=1}^kc_iq_{n-i}+H(n)$，则$a^{(p)}_n=p^{(p)}_n+q^{(p)}_n$ 8.4 生成函数 generating function for the sequence ：数列的生成函数$\\sum\\limits_{n=0}^\\infty a_nx^n$ ordinary generating function:普通型生成函数 extended binomial coefficient：广义二项式系数$C_n^k=\\begin{cases}\\dfrac{n(n-1)\\ldots(n-k+1)}{k!}&amp;k&gt;0\\\\0&amp;k=0\\end{cases}$ the extended binomial theorem:广义二项式定理 8.5 容斥 the principle of inclusion-exclusion:容斥原理$|A_1\\cup A_2\\cup\\ldots\\cup A_n|=\\sum\\limits_{1\\le i\\le n}|A_i|-\\sum\\limits_{1\\le i&lt;j\\le n}|A_i\\cap A_j|+\\sum\\limits_{1\\le i&lt;j&lt;k\\le n}|A_i\\cap A_j\\cap A_k|-\\ldots+(-1)^{n+1}|A_1\\cap A_2\\cap\\ldots\\cap A_n|$ derangement:错排 9 关系9.1 关系和其性质 binary relation from A to B：$A\\times B$的一个子集 A relation on a set A：$A\\times A$的一个子集 reflexive：$\\forall a\\in A,(a,a)\\in R$ symmetric:$\\forall a,b\\in A,(a,b)\\in R\\leftrightarrow (b,a)\\in R$ antisymmetric:$\\forall a,b\\in A,(a,b)\\in R\\land(b,a)\\in R\\rightarrow a=b$ transitive:$\\forall a,b,c\\in A,(a,b)\\in R\\land(b,c)\\in R\\rightarrow (a,c)\\in R$ composite:若关系$R:A\\rightarrow B,S:B\\rightarrow C$，则$\\forall b\\in B,(a,b)\\in R\\land(b,c)\\in S\\rightarrow (a,c)\\in S\\circ R$ $R^{n+1}=R^n\\circ R$ $R\\ is\\ transitive\\leftrightarrow\\forall n,R^n\\subseteq R$ 9.3 表示关系 Matrix：矩阵表示$A=\\{a_i\\},B=\\{b_i\\},m_{ij}=\\begin{cases}1&amp;(a_i,a_j)\\in R\\\\0&amp;(a_i,a_j)\\notin R\\end{cases}$ digraph/directed graph:用有向图表示 vertex(pl. vertices)/node:节点 edge/arc:边 initial vertex：边的起点 terminal vertex/end vertex：终点 loop：自环 9.4 传递闭包 transitive closure：传递闭包$R^\\ast$ path：图的路径 circuit/cycle：起点和终点相同的路径（环） $R^\\ast=\\bigcup\\limits_{i=1}^nR^i$ Warshall algorithm：$W_k=[w_{ij}^{[k]}]$表示只允许走编号不超过$k$的节点作为中间节点的路径（不包括起终点），$i,j$的连通性矩阵，则$M_{R^\\ast}=W_n,w_{ij}^{[k]}=w_{ij}^{[k-1]}\\lor(w_{ik}^{[k-1]}\\land w_{kj}^{[k-1]})$ 9.5 等价关系 equivalence relation：reflexive, symmetric, and transitive（等价关系） equivalent:两个元素能被等价关系关联，记为$a\\thicksim b$ equivalence class:在等价关系$R$中与$a$关联的所有元素的集合，记为$[a]_R$（只考虑$R$时可省略$R$） 9.6 偏序关系 partial ordering or partial order：reflexive, antisymmetric, and transitive（偏序关系） partially ordered set/poset：集合$S$和一个偏序关系$R$，记作$(S,R)$ comparable:要么$(a,b)\\in R$，要么$(b,a)\\in R$ incomparable:$(a,b)\\notin R,(b,a)\\notin R$ totally ordered/linearly ordered set/chain:$(S,R)$中所有元素对都$comparable$，$R$被称为total order/linear order（全序集） upper bound:$(S,R)$中，$A$为$S$的一个子集$\\forall a\\in A,a\\preccurlyeq u$的$u$ lower bound：上面的反义 least upper bound：所有的upper bound中最小的 greatest lower bound：上面的反义 maximal：没有$a\\prec b$ minimal:没有$b\\prec a$ greatest element:$\\forall b,b\\preccurlyeq a$ least element:$\\forall b,a\\preccurlyeq b$ dual:$(S,R^{-1})$，其中如果$(a,b)\\in R$，则$(b,a)\\in R^{-1}$ Hasse diagram：哈斯图 y covers x：y覆盖x，$x\\prec y$且不存在$z$使得$x\\prec z\\prec y$ 构造哈斯图：如果y覆盖x，则把y画在x上面并用无向线段连接x,y 10 图论10.1 图 endpoints：边两边的端点，边connect its endpoints infinite graph:边集或点集无限 simple graph：无重边无自环的无向图（简单图） simple directed graph:简单有向图 multigraphs：允许有重边无自环的无向图 pseudograph:重边自环都允许的无向图 mixed graph：既有无向边又有有向边 10.2 图的术语和常见的图 adjacent/neighbors:无向图中两点相邻，连接它们的边被称为incident with the vertices uand v neighborhood：与$v$相邻的点集$N(v)$ degree:度数$\\deg(v)$，自环算2度 isolated：度数为0 pendant：度数为1 $\\sum\\limits\\deg(i)=2m$ 无向图中，奇度数的点有偶数个 有向图中有边(u,v)，则称u is adjacent to v或v is adjacent from u in-degree:入度$\\deg^-(v)$ out-degree:出度$\\deg^+(v)$ $\\sum\\limits\\deg^-(v)=\\sum\\limits\\deg^+(v)=m$ complete graph:完全图，记作$K_n$ cycle:环，$V=\\{(v_1,v_2),(v_2,v_3)\\ldots,(v_n,v_1)\\}$，记作$C_n$ wheel:记作$W_n$ n-dimensional hypercube/n-cube：记作$Q_n$ bipartite graphs:二分图 一个简单图是二分图等价于能给每个点黑白染色且相邻点异色 $K_{m,n}$:两边分别有$m,n$个节点的完全二分图 subgraph：子图 subgraph induced by a subset W：点集为W，边集为所有连接W中的点的边 union：两个图组合，记作$\\cup$ 10.3 图的表示 adjacency lists：邻接表 无向图 有向图 adjacency matrix：邻接矩阵 incidence matrix:$m_{ij}=\\begin{cases}1&amp;e_j\\ is\\ incident\\ with\\ v_i\\\\0&amp;otherwise\\end{cases}$ isomorphic：对于图$G_1(V_1,E_1),G_2(V_2,E_2)$，若存在双射函数$f(n):V_1\\rightarrow V_2$，使得任意$G_1$中相邻的$v_i,v_j$，有$G_2$中$f(v_i),f(v_j)$相邻，则$G_1,G_2$同构，函数$f$称为isomorphism 10.4 连通性 simple path/circuit:路径或环中没有同一条边 connected：无向图中任意两点都有路径 cut vertices：割了就不连通的点（割点） cut edge/bridge:割边 nonseparable graph:无割点的连通图 strongly connected：有向图中，任意两点$a,b$都有路径$(a,b),(b,a)$ weakly connected:有向图中任意两点间有路径 10.5 两个回路 Euler circuit：包含所有边的简单环（欧拉回路） Euler path：包含所有边的简单路径（欧拉路径） 一个连通multigraph有欧拉回路当且仅当所有点度数为偶数 一个连通multigraph有欧拉路径但没有欧拉回路当且仅当恰好有两个点度数为奇数 Hamilton circuit:包含所有点的简单环（哈密顿回路） Hamilton path：包含所有店的简单路径（哈密顿路径） dirac’s theorem：若所有点度数不低于$\\dfrac{n}{2}$，则存在哈密顿回路 ore’s theorem:若所有不相邻的点$u,v$有$\\deg(u)+\\deg(v)\\ge n$，则有哈密顿回路 10.7 平面图 planar：平面图，能在平面中画出来且没有边交错的图 regions：平面图中，被边分割出的区域，其度数为包围它的边数，且$\\sum\\deg(R)=2m$ 简单连通平面图中，$r$为区域数，$e$为边数，$v$为点数，则$r=e-v+2$（欧拉公式），$e\\le 3v-6$ 若$G$为简单连通平面图，则有一个度数不超过5的点 一个图是非平面图当且仅当它有一个子图与$K_{3,3}$或$K_5$同构 11 树11.1 树树 树是没有简单环的连通无向图 一个无向图是树当且仅当任意两点间都有且仅有一条简单路径 rooted tree：有根树 parent：父节点 child：子节点 siblings：兄弟节点 ancestors：祖先 descendants：子孙 leaf：叶子节点 internal vertices：内部节点（不是叶子的节点） ordered rooted trees：儿子有序 m-ary tree：m叉树 full m-ary tree:满m叉树 binary tree：二叉树 subtree：子树 有i个内部节点的满m叉树一共有mi+1个节点和(m-1)i+1个叶子 level：节点深度 height：树高 高为h的m叉树最多有$m^h$个节点 11.3 树的遍历 preorder traversal：先序遍历（先父后子） inorder traversal:中序遍历（先第一个儿子，再自己，最后其他儿子） postorder traversal：后序遍历（先子后父） Polish notation:前缀表达式 reverse Polish notation:后缀表达式 prefix/infix/postfix form:以先序/中序/后序遍历一个表达式的树 11.4 生成树 spanning tree：包含所有节点且为树的子图（生成树） 简单图连通当且仅当其有生成树 depth-first search：深搜 breadth-first search：广搜 minimum spanning tree：最小生成树（Prim和Kruskal）","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ctz45562.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"12.25 女装の初体验","slug":"12-25-女装の初体验","date":"2021-12-25T03:45:14.000Z","updated":"2021-12-26T05:50:33.379Z","comments":true,"path":"2021/12/25/12-25-女装の初体验/","link":"","permalink":"https://ctz45562.github.io/2021/12/25/12-25-%E5%A5%B3%E8%A3%85%E3%81%AE%E5%88%9D%E4%BD%93%E9%AA%8C/","excerpt":"好像打开了什么不得了的开关。","text":"好像打开了什么不得了的开关。 NOIP2018前，我立下flag：超过200分就女装。结果我甚至超过了300分… 其实我立下这个flag时，就是想试一次女装。然而高中三年受限于财力和精力，一直没有机会。 上大学后莫名其妙进了团工委活动组织部，要举行新年晚会。按照惯例，我们部门要出两个女装，甚至还能报销。发红包决定人选，非常可惜我没有抽中，于是我直接找部长要求女装。另一个部门的花妹直接跑我们部来也要女装，属于是志同道合了。 然后zju出了点疫情，窝在宿舍里上了快一个月网课。网课确实能让人变懒，我就没一直没管过女装的事。网课后只有一星期就新晚了，而且ddl堆了起来，又要忙新晚的工作，所以整个准备还是挺仓促的… 第一次女装我想走可爱风，搞个lolita或女仆装，或者直接cos，不过决定角色还是挺费时间的，就放弃了。先找憨憨，憨憨问学姐推荐的店铺，给了一家发货快、性价比高的lolita店。不过款式还是太素了点，没有那种惊艳的感觉。最后我在淘宝上自己找女仆装。丝袜必须要，知乎上还说得有裙撑。考虑到报销上限选了一款蓝粉色的，一百多，白丝裙撑猫耳都有。我知道这个价位质量肯定一般，但是穿一次还是ok的。 衣服凑合了点，假发还是得挑个好的。知乎上推荐了高性价比的大佬家。没找到我最爱的蓝毛，最后60拿下一款粉毛。 一开始还没啥感觉，假发到了我直接心动了，然后戴了一晚上…第二天衣服到了，要不是晚上还有节体育课我就穿一晚上了…我平时都不在意晒太阳，有点黑，也可能是光线问题吧。 这时我发现，加上裙撑我就没法坐下了，再一个还有走光问题，于是又买了一条安全裤。 然后开始考虑妆娘。这方面我是完全没经验。我去问花妹，花妹让我在闲鱼上找。我用英语课的时间找了好几个，但是都出不来，唯一一个能约的要报销一百多的路费。之后海王告诉我可以找zju的美妆部。我在美妆部的公众号里找到了约妆，顺利搞定。虽然价格贵了点，但本校的还是方便又省心。 花妹又找我问我的妆娘，我寻思他不是找好了吗，跟他说了美妆部。后来我们三个都找的美妆部… 还有两天的时候，突然想起来完全没有考虑过鞋子！我这种完美主义者（女装方面）肯定不能穿着黑色的运动鞋走可爱风，于是我直接找浙江的店，发现我想要的鞋（圆头小皮鞋或玛丽珍鞋）最大只有40码，而我的运动鞋是42码的…不过我发现有个宝贝叫光腿神器，既能保暖又能改善肤色还能压制我过于旺盛的腿毛（甚至能透过丝袜，我差点想剃了）。我还想找穿在胳膊上的让自己白一点，但不知道叫啥，告辞。 最后晚上的时候搜“大码玛丽珍鞋”找到了大号的，在浙江温州，第二天发货，我就只能祈祷快递能在晚会前到了。 新晚当天，上午安全裤和光腿神器到了，下午我就一直在看淘宝等着鞋子。幸运的是，去找妆娘的时候鞋子到了。 这里我要吹一吹美妆部的姐姐，她大二开始接妆，现在马上研究生毕业了，然而是第一次给男生化女妆。她真的好专业！化妆用了一个多小时。姐姐说我皮肤挺好的，也不算黑，就是太干了。这也难怪，我平时一直很糙，脸都懒得洗的。现在打算学着保养一下皮肤为以后的女装做准备。姐姐还说我睫毛很长，很适合做妆造。我本来还觉得自己不适合女装，现在突然有了信心，也许是有这方面的潜力 化妆感觉和画画有点像？我甚至有点想去美妆部学习学习？ 最后姐姐还帮我带了假发，我之前都直接套上去，不知道假发能卡在上面…我俩都没梳子，假发就很乱，炸毛了。后来我去隔壁寝室借了一把。 然后我要顶着妆容和粉毛去取快递，不能戴口罩不然粉底会掉，戴帽子也压不住假发，就只能放平心态享受这一过程（？）回寝的时候有俩男的看到我愣住了，我经过他俩的时候听到一句“我靠，女装大佬”。 晚饭将就一下，吃了半个面包，我这个形象肯定不能去食堂，而且会把口红弄掉。鞋子虽然是42的，但还是小了，有点挤脚。而且质量一般，它的魔术贴太松了，走几步就会掉。我收拾好东西就出发了，路上明显感觉到很多人的视线… 提前了半个小时到，有个妹子一看到我就惊呼“太美了”。本来是定在508换衣服，我一看，508墙是透明的，里面还有人，就跑到厕所里。换衣服用了将近半小时，毕竟衣服太杂了，厕所里也没有很多挂衣服的地方。换完衣服对着镜子梳头发，突然一个妹子进来了，我出去一看，原来我进了女厕所…不过她可能没看出来我是男的？ 回到会场，我是三个女装里最骚惊艳的了。我是可爱风；花妹是性感风，他身材很好，甚至穿的露脐装；wkx是搞笑风，毕竟他这个脸太爷们了，而且头发买成发片了。在会场门口就被负责签到的妹子围住了。进了会场没座位了，我就站在后面，不时有人回头瞟一眼。整个晚会一直有妹子找我合影，说我比她们都漂亮。原来女装就能跟妹子合照吗，那我以后天天女装 晚会我们部门要出两个节目，一个是跳舞，一个是反串剧。跳舞的时候我把裙撑卸了，换回了运动鞋。反串我饰演泰坦尼克号里的肉丝，剧本取自岳云鹏的相声，不过当然是没有wkx的女儿国国王骚，毕竟他那个是真压轴的。 晚会结束后我意犹未尽（？），本来想穿着女装回寝，但是今年最低温度不允许，不过裙子还是露在外面的。还梳子的时候那四个同学的眼神… 果不其然，我上十大了（浙大朵朵校友圈十大热帖），还有人想加我好友…直到快睡了我才把妆卸了、衣服换掉。 我是真没想到女装能这么爽（？）。 不过在女装的道路上我还有很多要学的，尤其是妆容和拍照，希望以后还有机会（？）。 感谢ljl姐姐教我自拍： 放飞自我了属于是。","categories":[{"name":"日常","slug":"日常","permalink":"https://ctz45562.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"女装","slug":"女装","permalink":"https://ctz45562.github.io/tags/%E5%A5%B3%E8%A3%85/"}]},{"title":"11.8 I used to ...","slug":"11-8-I-used-to","date":"2021-11-18T14:34:40.000Z","updated":"2021-11-21T04:09:02.071Z","comments":true,"path":"2021/11/18/11-8-I-used-to/","link":"","permalink":"https://ctz45562.github.io/2021/11/18/11-8-I-used-to/","excerpt":"看到七都贴吧里都在说你游要凉了，大概是想起了什么吧。","text":"看到七都贴吧里都在说你游要凉了，大概是想起了什么吧。 先祝贺EDG夺冠吧，本来想比赛当天就说说的，后来忘了，现在补上。 其实我一直不大关心赛事，不过想到也是大学狗了，时间总是多了点，今年还是跟着千珏海王和懵逼看的。 第一场EDG赢了后还是很激动的，但是后面两场连败，觉得没什么希望了，懵逼走了，我也打算洗洗睡了，等着明天早上看到DK夺冠的头条。 结果还在看比赛的海王说第四把赢了，然后又跑回来看最终局。 这BP差点又给我劝退，然而EDG最后一把打的是真好，五个人没有一个拖后腿的。 那晚贼激动，两点睡下。 EDG牛逼！ 没有干劲，微积分课上摸鱼看到七都要凉。查了查，原来是周年庆复刻了去年的内容。 都是情怀啊，初四的时候憨憨给我推荐的。 虽然卡池和养成很毒，但剧情和角色做的挺好的，况且这是我第一次接触二次元手游。当时作为月卡党玩了一年，进了信息组后时间越来越少就退坑了。 高一的时候有段时间不适应高中生活，怀念着初中生活，就想起来了七都，回去玩了一段时间。 记得每两周休息的一天里，下午都会推一个周目。 其实推完新结局很快又长草了，但是玩的时候就老是想着初中，放学后和憨憨一块绕着小区边骑车边聊天…… 高二又回去玩了玩，那时候就当个纯咸鱼，不求强度，就冲着厨力，最后是拿自选S换了璃璃子，到20年的疫情后就弃了。 后来…就没再玩了吧，接触了PCR和原神，也高三了，没时间再玩这种需要大量时间挂机的游戏了。 最近游戏荒的时候会突然想回去再看看，但还是没回去，也许……也许我变了吧，也许我已经不适合了…… 我记得刚玩的时候濑由衣是真神，自己就一个碎片，盼了好久，某天抽了一发出了一个碎片，我想着不会再抽一发出了吧，结果真出了……虽然她后来也退环境了…… 我记得高中在宿舍里狠心把攒的欧泊扔进源千雪的up池，结果直接出了个源千雪，当时好像是第一次出整S吧…… 我记得我很咸，玩了那么久才有一个七阶专武…… 我记得憨憨很喜欢羽弥，资源都给了她，虽然当时是下水道。他跟我说，羽弥是七都亲女儿，以后必将翻身，于是我也跟着练。后来羽弥开了觉醒，果然干到天花板上了……我那唯一一个七阶专武就是羽弥的…… 我手机里还存着一些七都的图片，节奏榜和一些弔图，也许是懒得删，也许是想偶尔再看两眼。 我不信七都会凉，它苟了那么久，尽管流水一直不行，但不是一直在撑着吗…… 但是周年庆都做不出新内容了…… 我不再玩七都了，但那也是我的情怀啊，我只想知道它还活着……毕竟我怕那天我真的失去了情怀。 某天发现自己也退了PCR的坑了。 上次天蝎座会战，跑到后排养生，18刀全auto，每天十分钟就下班。 后来某天没有干劲，睡前想着今天不玩PCR了吧，就想着退坑的事情了，得找个时间把公会退了。 结果没过几分钟就上线退掉了公会。后来…就再也没玩过。 一个月前捣鼓kwgt的时候专门弄了半页放游戏，原神、PCR、方舟三个大图标，中间的图标就这么再也没碰过。 其实当我从抽卡中感受不到乐趣时，我就知道会有这一天的。 第一次开服玩家，第一个也是最后一个良心游戏。 我喜欢怀旧。 最近从淘宝上买了一箱魔法士。 我小学时流行魔法士的q版三国杀卡片，当时只集了三十多张，还被老师没收过。我觉得这是魔法士出的卡片里质量最高的一套了。在闲鱼上看到有卖全套的，200一套，差点没忍住。 上了初中就开始怀念小学，直到遇见憨憨。 上了高中就开始怀念初中。 上了大学……也不怀念高中2333 但还是会常常想着，我过去…… 我现在拥有的也终将成为过去吧。 以上。","categories":[{"name":"日常","slug":"日常","permalink":"https://ctz45562.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"公主连结","slug":"公主连结","permalink":"https://ctz45562.github.io/tags/%E5%85%AC%E4%B8%BB%E8%BF%9E%E7%BB%93/"},{"name":"二次元","slug":"二次元","permalink":"https://ctz45562.github.io/tags/%E4%BA%8C%E6%AC%A1%E5%85%83/"},{"name":"LOL","slug":"LOL","permalink":"https://ctz45562.github.io/tags/LOL/"}]},{"title":"403の蛤话","slug":"words-of-403","date":"2021-10-20T15:37:03.000Z","updated":"2022-03-05T16:29:39.202Z","comments":true,"path":"2021/10/20/words-of-403/","link":"","permalink":"https://ctz45562.github.io/2021/10/20/words-of-403/","excerpt":"翻日记的时候被一些机房蛤蛤言论笑到了。 于是开了这个来记录403的蛤话。","text":"翻日记的时候被一些机房蛤蛤言论笑到了。 于是开了这个来记录403的蛤话。 海王（调戏小爱同学*）：小爱今天冷吗？ 海王：小爱我感冒了。 giegie：海王说“小爱我感冒了”，然后小爱说“我已将你的健康打卡改为感冒” *小爱同学：小米手机的语音助手 ctz拿出华为手机，点开浏览器，搜索翻译。 ctz：嘿，Siri！ Siri（百度翻译）：我在。 ctz：给我说点新闻。 Siri（百度翻译）：世界最长的男人！来自美国的Sea King以43.2cm的长度创造世界记录 ctz：再来点新闻。 Siri（百度翻译）：吴签选妃被查有男性参与，吴亦凡因涉嫌强奸同性被判无期徒刑。 ctz：再来点新闻。 Siri（百度翻译）：世界最长的男人记录被打破！来自中国的giegie以1.14514光年的长度创造新高！ 千珏：怎么都是女装？ 千珏：都没个男的。 giegie（看小说ing）：woc，大干一场 ctz：woc，传下去，giegie要大干一场 giegie：woc，是主角 ctz：woc，传下去，giegie要大干一场主角 giegie：woc，主角是男的 ctz：woc，传下去，giegie要干所有男的 giegie：woc，千珏和ctz也是男的 ctz：woc，传下去，千珏和ctz把giegie大干了一场，giegie变成了男的 giegie（原神中）：哪里可以碎大石头？ ctz：胸口。 海王（巡查鱼塘）：这条没回，这条回过了，这条没回…… giegie：我爱洗澡，洗澡好好~ ctz：我爱洗澡，皮肤好好~ 千珏：什么？屁股好好？ ctz：我爱洗澡，屁股好好~ giegie：原来ctz是捡肥皂的那个。 ctz：我爱肥皂，屁股好好~ （对味了） 千珏（把ctz晾着的内裤碰下来了）：woc，ctz我把你内裤干下来了 giegie：这不对着来一发 海王：都洗过了没意思了 giegie：嘿，Siri，ctz的jb有多长？ 真·Siri：为您搜到以下结果…… ctz：你这个Siri不行 ctz（打开百度翻译）：嘿，Siri，giegie的jb有多长？ Siri（百度翻译）：对不起，我读不出那么大的数字 giegie（做每日委托）：这任务还tm要木头，还好这岛上就是木头，要不我把木匠的头砍下来 千珏：你砍他头干吗？ ctz：木匠的头，简称木头 ctz：海王为什么一边掏裤裆一边看我啊？ ctz：woc，海王还tm一边掏裤裆一边银笑 两个憨批设计班级logo： 千珏：这tm怎么这么像国徽 过了一会… ctz：把这个人民大会堂往下移…… 又过了一会… ctz：我觉得懵逼比较有代表性，应该把懵逼的头放上去…… 又双过了一会… 又双叒过了一会… slyz信息组传统艺能： giegie：别人怎么什么都会啊，我什么都不会 ctz：你会“什么都不会”，这是别人都不会的 千珏：给我整不会了 ctz：噫，好，我中了！ 千珏：畜生，你中了甚么！ giegie：大乐透~ 快乐网课： giegie：woc我一觉醒来怎么十二点了 giegie：昨天又是看小说看到三点 懵逼：我中午十一点多路过你们寝室，为什么你们灯是黑的 （十二点）千珏：走，恰饭去 （一点）ctz：为什么我们吃完饭giegie还在睡 giegie：要恢复线下上课了，我得把作息调过来 （第二天）giegie（睡眼朦胧）：现在几点了？ ctz：十二点二十 giegie：woc不能熬夜，不然明天就爬不起来了 千珏：这句话我昨天好像听过 （第二天）giegie：woc一点半了 千珏：你终于醒了，我终于可以外放了 giegie：昨天晚上睡得有亿点点迟 giegie：明天一定 海王：刚刚吃饭排队，有两个男的很大声地喊“渣男渣男”，然后我旁边那个哥们回头跟他们打招呼。然后他身后的女朋友问他为什么他们叫你渣男 海王：所以公众场合不要叫我（海王） giegie：首先你要有一个带的出来的女朋友 giegie：我要回去了，你们会想我吗？ 千珏：好耶！十二点前终于可以开灯了！ ctz：好耶！十二点前终于可以外放了！ 千珏：你坐飞机回去吗？ ctz（胡言乱语）：我开飞机，我买了张机长票 ctz（胡言乱语）：你不知道吗？现在机场都卖机长票，租一架飞机自己开回去 ctz（胡言乱语）：有汽车驾照就行，你看图图都有 千珏：图图tm酒驾 （寒假前）千珏：家里的网我千珏一定大开杀戒 （寒假后）艾克：千珏狗都不玩 艾克（看云顶视频）：…7辛迪加… giegie：七辛 迪加？ ctz：你断句错了，是七辛迪 +，就跟互联网+一样 艾克：七星迪迦？这要多少个迪迦合出来啊？ ctz：为什么我的膜片越吃越少了？ 艾克：你tm还能越吃越多的？","categories":[{"name":"日常","slug":"日常","permalink":"https://ctz45562.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"梦结束的地方","slug":"梦结束的地方","date":"2021-10-20T14:17:45.000Z","updated":"2021-11-06T08:20:32.676Z","comments":true,"path":"2021/10/20/梦结束的地方/","link":"","permalink":"https://ctz45562.github.io/2021/10/20/%E6%A2%A6%E7%BB%93%E6%9D%9F%E7%9A%84%E5%9C%B0%E6%96%B9/","excerpt":"我有点搞不懂pcr国服改英文是什么意思。","text":"我有点搞不懂pcr国服改英文是什么意思。 “new”改成“新内容”，“win”改成“战斗胜利”，“critical”改成“暴击”，这些就算了。开始界面的“Princess Connect Re:Dive”直接删掉算什么？现在每次打开pcr，少了原来的logo，就感觉少了灵魂。mars讲过一段电影情节，是地下党员冒死展示党旗。现在有点感觉了。 我看不出来这是什么文化自信，这整改就像是生怕国人看英文看多了就嫌弃中国文化了，这到底是自信还是自卑？ 我希望至少不要看到游戏里出现这种弔图： 我也没想到和谐的魔爪会伸向pcr。我一直觉得pcr的立绘主要是萌系的，最多是几个泳装有点出格。所以一开始说要改立绘的时候，我以为就是改改水吃水猫这种，我也习惯了。 结果吃货被改了： 吃货的立绘已经算很正常的了，就这胸有问题？现在的未成年已经nb到看到露一点胸就学坏了？况且pcr又有多少未成年玩家呢？ 这只是个开始，如果吃货的立绘都能改的话，恐怕其他绝大多数立绘都要遭毒手了。 pcr是我第一个从开服玩的游戏。去年四月被恶zhuoer拉进了坑，一直玩到现在。甚至到高三，我还坚持每天清体力，每期会战认真出刀。 我还记得有次放假恰逢伊利亚池，用一个下午冲到jjc榜一。 我还记得刚开始打会战不懂抄作业，试了好几种排列组合，自己摸轴，就为了打出高一点的伤害。 我本来想说pcr是我二次元启蒙手游，又想到我第一个二次元手游是七都。但从pcr开始，我确实玩了很多同类型的抽卡游戏。 我能玩这么久，一个很大的原因是pcr对玩家是真的好。钻石一直在送，不肝不氪，大部分池子都抽了，余钻依然充足。经历其他手游的毒打后我体会更加明显。（原神说你呢！） 像这样让人放松的游戏真的很少见了。 虽然如此，我对pcr的热情也渐渐衰减了。 高三一直没时间看主线，想高考后再补。但真的放假后，我也没有兴趣看主线了。 会战也越来越摸，原来只要放假就全天守着，三道手动刀；现在能auto就auto，甚至经常拖到深夜让会长代刀。（话虽如此，上期会战还是体验了连续四天时停刀，也算是圆满了）jjc不怎么打了，已经掉到500名了。 最近越来越忙了，也许很快我就要弃坑了，但我不希望看到pcr变了味。毕竟她曾陪我走过最苦的一年。 我不怪策划，谁导致的懂的都懂。 我有点对这类手游失去希望了吧，在国服这种环境下。 梦开始的地方？梦结束的地方。 以上。","categories":[{"name":"杂物","slug":"杂物","permalink":"https://ctz45562.github.io/categories/%E6%9D%82%E7%89%A9/"}],"tags":[{"name":"公主连结","slug":"公主连结","permalink":"https://ctz45562.github.io/tags/%E5%85%AC%E4%B8%BB%E8%BF%9E%E7%BB%93/"},{"name":"二次元","slug":"二次元","permalink":"https://ctz45562.github.io/tags/%E4%BA%8C%E6%AC%A1%E5%85%83/"}]},{"title":"9.8 The End of Military Training","slug":"9-8-The-End-of-Military-Training","date":"2021-09-08T08:07:52.000Z","updated":"2021-09-09T02:20:52.569Z","comments":true,"path":"2021/09/08/9-8-The-End-of-Military-Training/","link":"","permalink":"https://ctz45562.github.io/2021/09/08/9-8-The-End-of-Military-Training/","excerpt":"最后一次军训。高中我没军训，这次新鲜感十足。","text":"最后一次军训。高中我没军训，这次新鲜感十足。 一开始还是挺累的，练军姿、齐步、正步，一方面是脚疼，每天要走两三万步，而且鞋子邦硬，加鞋垫，垫五层卫生纸还是跟板砖一样；另一方面是热。东营8月已经不用开空调了，杭州还是热的要死，而且还要求穿外套，裤子也不透气，在外面站一会就成水人了。不过后来我走步总是高低肩，不能走方阵，进了表演方阵打拳，基本上每天都是在摸鱼摆烂；而且之后也让我们脱外套，天也没那么热了。 睡眠严重不足。每天五点二十起床晨训，晚上说是十点熄灯，实际上每天晚上还要去教室看红色视频、练合唱、听辅导员讲废话，十点才能回来，睡下已经十一点多了。合唱比赛后早了点，九点就能回来，不过还是会玩到十一点多。 说到这里不得不说一说我的辅导员。四十多岁，在zju匿名教师评分系统上骂声一片。我也是体会到了，自以为是，老是说自己硕士学位。而且很能讲废话空话，从游泳讲到阿富汗，一个小时不带停的， “左边的同学你会发现你左边的人比你矮，右边的人比你高；右边的同学你会发现你左边的人比你高，右边的人比你矮…” “我们连有的班人很少，只有8个人；有的班人很多，有14个人。但是人多的班也要把互评认真完成…” 内务要求很奇怪，水池里不能有水，晾衣架上不能有衣服，电脑桌上不能有电脑，垃圾桶里不能有垃圾…一米高的桌子只能放两个杯子，还必须放书，要不然说你没有生活氛围。好在我不用叠豆腐块，因为我的被子太薄了，枕头压着根本看不见。 不过军训还是有很多快乐的事。 我寝室里除了我有两个玩原神的，还有一个海王每天忙于聊天。czf有着神秘力量，只要是他看着别人抽卡就能欧。方舟70抽出了棘刺和山，原神110抽出了二命雷神（不过专武吃了大保底），pcr43抽出了nnk。yly是来这后开始玩原神的，14抽阿莫斯，氪了个雷神。czf自己就比较非，他心心念念的雷神小保底歪了，一气之下手滑了，换了28个相遇之缘，好在最后找客服换了回来，至今还没有雷神。 雷神确实香，我一开始不喜欢这种高冷御姐，不过仔细看了看她的服饰和沟、听了影的语音后立马就把心海换成了专武。 顺便吐槽一下稻妻剧情。真的是全员小丑。心海带领的反抗军和神里，这些冲在前面反抗的人最后居然都没戏份？特别是心海，天才军师，就只给主角发了个任务？反倒是八重神子，前面塑造得像个局外人，最后一番嘴遁就轻松解决了眼狩令。还有女士，蒙德和璃月就感觉她做事有隐情，深藏不露，以后要么洗白，要么做点大事，结果在稻妻就死了，而且死的那么狼狈。 总之人设崩坏，剧情狗血，rnm退钱！ 训练休息的时候会有歌会，自愿起来唱歌。不过唱的都是些有年代的歌，我多年不碰华语歌坛依然有不少熟悉的。我自己也跃跃欲试了，最后也没有唱。 早饭有很多花样，每种都想尝尝，结果就吃的很多。每天午晚饭都会喝饮料，刚训练完热的不行，喝一杯冰镇饮料真的爽，虽然不健康就是了。高中三年没吃过冰糕，军训时也吃了两次。 zju里打游戏的真不少，到处都是玩原神和lol的。打拳的时候经常跟宣传委员lzl聊lol。lzl比较胖，声音低沉，跟他聊天感觉心里很踏实。他脚上长了两个血泡，为了分请了两次假后不敢请了。我一来就看出来海王喜欢薇尔莉特，他的手机壳和聊天背景是薇妹的。但是我给他放京紫的oped他居然没听出来。 我旁边有一个叫励精图的，偏胖，看着肉嘟嘟的。总是摆着一副无辜的表情，但是嘴是歪的，戴上帽子显得很憨，每次看他的脸我都会笑。他也很能出汗，脸上胳膊上挂满了水珠，手一甩地上就全湿了。 有一次他用肚子顶了我一下，神似“肉弹冲击”，后来我们就都叫他酒桶。 我们还学了打枪，练了一次就要测试。我的眼镜洗澡的时候摔坏了，换了备用的，结果打枪的时候完全看不清靶子。第一枪脱靶，好在旁边的教官提醒我往下打，最后混到78.6环，还算能看吧。 说到海王，他是真的闷骚。看起来挺正经的，不玩游戏，其实每天都在跟妹子聊天。高三的时候zhuoer喜欢翻牛津看那些有颜色的词，我也跟着学了几个。于是我问室友fellate是什么意思，结果他答了上来，还说他把牛津上所有这种词都记在笔记本上。还有一次我在宿舍群里分享了学习资料，只有他下载了。 打拳队列里我旁边是个大二的妹子（大二的要补上去年的军训），人挺好的，跟我们聊了很多。我大概是第一次跟妹子正常聊天。 正式表演前，不知道为啥，教官让我们互相捶背。妹子给我捶背的时候说她知道怎么让我舒服。然后我给她捶背，看到了她披肩的长发。感觉一言难尽 我们连有两个教官，一个连长，一个排长叫阿栋。阿栋一直带我们排，后来带我们打拳的。阿栋人也很好，说着站军姿的时候不许笑，自己却一直在开玩笑。他记住了我们很多人的名字，包括我。我们也和他聊过军队里的生活，原来军队里也能玩手机，他还说自己是国服夏侯惇。阿栋还跟我们讲了军队里奇怪的规定，比如休息的时候可以玩，可以躺着，但是不准睡觉。阿栋说他训练的时候基本上都是坐着，因为都会了。但他不想继续了，因为没有自由，想回来读书。本来他马上就要退役了，不知道为什么又签了两年合同。希望他最后能找到属于自己的自由吧。 军训虽然比暑假累很多，玩的时间也变少了，但还是很充实的。感觉我一年没锻炼的身体健康了点。比起暑假里每天昏昏沉沉的，现在精神了太多。跟同学玩也比在家更有意思。 也许有一天，我能过上真正有意义的生活。 以上。","categories":[{"name":"日常","slug":"日常","permalink":"https://ctz45562.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"8.19 Hello, World!","slug":"Hello-World","date":"2021-08-19T10:04:20.000Z","updated":"2021-08-21T03:30:16.105Z","comments":true,"path":"2021/08/19/Hello-World/","link":"","permalink":"https://ctz45562.github.io/2021/08/19/Hello-World/","excerpt":"起得很早。 我盯着指向6与7中间的时针，突然想到，高三的我每天十二点多睡，不到六点醒，中午还睡不着。","text":"起得很早。 我盯着指向6与7中间的时针，突然想到，高三的我每天十二点多睡，不到六点醒，中午还睡不着。 起得早是为了参加我爸医院的助学座谈会。本来我还要作为学生代表发言，后来推掉了。 座谈会也就是走走形式，客套话，虚言。 回来的路上看到一个帖子，回忆过去的。 圆卡，溜溜球，小金鱼，三国杀，小陀螺，电人口香糖，冒险小虎队，阿衰…… 黄金蟹钳，拖肥，五彩绳，雪莲，魔法士，一根葱，啤酒豆，秀逗…… 我的小学初中生活有这么多东西吗…… “到slyz了。” 我放下手机，往窗外看。 “看到了。” 其实我没看到，我只看到了slyz旁边的毓圣花苑，和slyz附近突兀耸立着的“西格尔电梯”的高楼。 所以我也知道slyz在那儿了，我也看到很多学生在里面补课。 中元节，给姥娘上坟。 高中时我还是很想在作文里写写她的，遗憾的是高中只写议论文。 她以前常说，想看到我考上大学。 我快要中考的时候，她进了医院。 我没时间看她，只听说她神志不清的时候天天念叨我的名字。 中考后，我很兴奋，跟同学去上海玩了几天。 回来后我在病房里陪着她，直到第二天。 第二天她走了。 甚至连我考上高中都没等到。 下雨了。 没有回老家，和我爸在路边给爷爷烧纸。 雨越下越大了。 我们打着雨伞，看着黄色的纸钱熔化在火焰中，看着四炷香渐渐缩短。 “四炷香是为了连接天地的。” 有光焰往上飘，据说这样纸钱就能飘到天上死者那里。 直到火焰熄灭，残余一地灰烬。 “你就要上大学了，有什么感受吗？” “……没感觉……” “你去了大学后，你妈肯定难受死。” 我当然知道。 “我还没去她就受不了了。” 她在家就哭过好几次了。 我把桌子上8本点兔漫画、3本画集和手办收进柜子里。我不希望半年后我回来看到它们落了灰。 #include&lt;iostream&gt; using namespace std; int main(){ cout&lt;&lt;&quot;Hello, World!&quot;&lt;&lt;endl; }","categories":[{"name":"日常","slug":"日常","permalink":"https://ctz45562.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"2021年1月番剧简评","slug":"2021年1月番剧简评","date":"2021-07-23T04:44:17.000Z","updated":"2021-12-15T10:17:36.793Z","comments":true,"path":"2021/07/23/2021年1月番剧简评/","link":"","permalink":"https://ctz45562.github.io/2021/07/23/2021%E5%B9%B41%E6%9C%88%E7%95%AA%E5%89%A7%E7%AE%80%E8%AF%84/","excerpt":"我想抽卡！（震声）","text":"我想抽卡！（震声） 堀与宫村恋爱番。本来看前半段是狗粮番的，不过后半段表现还是偏向恋爱的。 所以恋爱和狗粮有啥区别呢？恋爱番（急得）胃疼，狗粮番（撑得）胃疼。 我从来没见过这么顺的恋爱，有全世界的助攻，最关键的是男女主都打直球，所以六集就完事了，甚至上垒了。想起了带我入纯爱坑的『月色真美』，月色真美青涩真实，堀与宫村则是更为理想化。 因此，虽然番名叫「堀与宫村」，但是配角的戏还是不少的。 男二的线挺胃疼的，由纪老是憋着，二选一总有一个人会受伤，虽然樱最后说是释然了，但我觉得她心里还是会难受。 不过整体风格还是很轻松的，夹杂了大量的搞笑日常，时不时发一波男女主的糖。整体观感还是很好的。 评分：9分 Re：从零开始的异世界生活 第二季第二季分为上半和下半，上半去年就出了，一月出的下半。 异世界题材已经不够新颖了，剧情也很少有吸引我的，不是龙傲天就是搞笑向的。但re0是个例外。 「死亡回归」，这个能力非常特殊。自己没有正面对抗敌人的能力，只能默默承受痛苦，找寻拯救所有人的道路。这是真正的用血与泪铺设的路。 所以re0的格局小不了。更何况它还提到了别的异世界番没提过的——亲情。 第四话讲述了486在试炼中重见父母。我记得上一个这么做的是『异度侵入』第十话，那一话封神了。 我也是看完这一话才开始考虑这个问题，那些穿越到异世界的，原来的世界会如何呢？ re0是我刚入宅不久就补完的番，所以其实看第二季的时候很多设定已经忘了，但它依然十分吸引我。 制作组非常良心，虽然经费明显不多，作画不算优秀（但也没崩），但是为了把内容极多的圣域篇讲好，下半几乎每集都是近30分钟，而且大部分直接跳了op、ed。 最后还是想说点问题。有的情节人物心理活动和意图不明显，必须弹幕科普；下半嘴遁和回忆太多，我还是更喜欢看现实中更激烈的情节。 评分：9分 回复术士的重启人生挺重口味的，某种意义上也是神作了。 我是真的没有想到这种类型的小说会动画化，不想做评价。 辉夜大小姐想让我告白第二季好像混进来一个不是一月番的东西 突然想起来辉夜第二季看了几集就不看了，于是临时决定先补完。 前十集还是原汁原味的沙雕，不过会长和辉夜终于有进展了虽然几乎没有 最后两集一改以往搞笑风，先讲了石上优的过去和现在，有点沉郁，但是更多能感受到的是人物的升华；之后是辉夜换手机，也是很温馨的。有深度了。 评分：9.5分 进击的巨人最终季 上半我要做皮克姐姐的狗！ 虽然漫画烂尾了，不过前面还是老样子，爽。 但是无敌的兵长死了很难受。 不多说，就是无脑吹。 评分：10分 摇曳露营第二季第一次在A站上补番，不知道为啥虽然是A站独播但是少了一集。 能让人心静下来的日常番，我见过的这种日常番不多，但都是宝藏。 音乐是烘托平静氛围的主力，第二季音乐质量还是高。 可能是时间太久远了，感觉第二季对cp和美食的刻画更多了。 美中不足的是前几集感觉经费略有不足，不过在日常番里『摇曳露营』画质还是顶尖的，可能是我期望太高了吧。 评分：9.5分 无职转生留坑待填 工作细胞第二季留坑待填 悠哉日常大王第三季留坑待填 致不灭的你留坑待填 本田小狼与我留坑待填","categories":[{"name":"动漫","slug":"动漫","permalink":"https://ctz45562.github.io/categories/%E5%8A%A8%E6%BC%AB/"}],"tags":[{"name":"二次元","slug":"二次元","permalink":"https://ctz45562.github.io/tags/%E4%BA%8C%E6%AC%A1%E5%85%83/"},{"name":"番剧","slug":"番剧","permalink":"https://ctz45562.github.io/tags/%E7%95%AA%E5%89%A7/"}]},{"title":"Re:高三回忆录","slug":"高三回忆录","date":"2021-07-12T15:44:12.000Z","updated":"2021-08-16T02:53:52.490Z","comments":true,"path":"2021/07/12/高三回忆录/","link":"","permalink":"https://ctz45562.github.io/2021/07/12/%E9%AB%98%E4%B8%89%E5%9B%9E%E5%BF%86%E5%BD%95/","excerpt":"幸好，在我遗忘前，我有勇气写出这篇回忆录。 我想通过日记的形式，反映我高三各个阶段的状态。","text":"幸好，在我遗忘前，我有勇气写出这篇回忆录。 我想通过日记的形式，反映我高三各个阶段的状态。 前言 以下内容充满了负能量 我的高三生活没有任何参考价值 日期可能不准确 July 21st,2020我A掉一道min_25筛的题，写了题解，上传到博客。我从未想到这是我最后一道OI题和题解。 loli说今年SD的D类可能没有了，让我和烜先回去学文化课，等他的消息。 August 6th,2020暑假在学校补课什么的，作为竞赛生大概早就习惯了。 假期在学校上课其实还是比较轻松的。退役什么的，也没那么可怕。 昨晚又是背了一个多小时单词，啥时候能来一次听写满分啊。 今天上课继续偷着写一点“蛤富翁”，吃完饭找人玩一玩。偶尔也会想着，一年后高考结束，我们会不会一块玩“蛤富翁”呢。啊，高考还是太远了。 大课间是例行的观赏螳螂和蛐蛐。我又跑到绿化带里抓了几只蛐蛐，螳螂还是太少见了。 宿舍里几个人一块偷着颓手机还是很有氛围的。清日常，逛b站。起身上厕所，透过窗户看不到天空的尽头。 September 13th,2020开学后，时间突然被大量占用。每天辛苦奔波装出一个正常，或者说上进学生的样子。 过完一个大周，我突然很厌恶这种生活，很痛恨这样的自己，积累的负面情绪爆发了出来。 一整天我都在这种情绪下度过。我暗暗下定了决心。 晚上我告诉我妈我所有的想法，我想在家自学。她并不是很能理解，给我请了假。 October 1st,2020国庆节+中秋，难得的假期，我回了趟老家。 坐在大爷家院子里补『进击的巨人』，也是种享受。 乡下，湛蓝天空，明媚阳光。 我坐在屋檐下，看不到，感受不到。 October 19th,2020和往常一样，昨晚买好面包，中午在宿舍里边吃边颓手机。 但我没想到mars会在这个点来，因为我们宿舍太乱了。 我承认我慌了，因此也导致了最坏的结果。中午没睡着。 下午和晚上装成无所谓的样子。 November 22nd,2020作业越来越多了，早读提前了十五分钟。不过还好，手机回来了。 我才刚刚适应。 mars说因为校门口堵车太严重，要分批放学。高一高二十点，高三普通班十点五分，重点班十点二十。 这一听就是学校为了延长在校时间编出来的说辞。还好我坐校车，不用跟着这个时间走。 November 23rd,2020给坐校车的学生家长一个个打电话我是没想到的。 “克服一下。” 结果是重点班所有人都十点二十放学了。 我本来白天就严重睡眠不足，现在更是雪上加霜。 我从来不是顺从的人。我从来不会听从我认为不合理的规定。更何况，学校是用巧妙的说辞推迟放学，我很不满。 slyz想让我多学点，那我就故意少学点。 我对自己说，放学后，我绝对不会做与学习有关的事。 我突然想起来初中夭折的日语学习。 December 4th,2020早读后例行和Bj2002统计数学作业。 “今天几号来着？” “我看看……4号。你看秀的日历，上面……” 12月4日。这段时间过得浑浑噩噩，整个人都麻木了。 买来『标准日本语初级』已经有段时间了，我早就预料到会发展成上课不务正业。先是对着假名歌词记忆五十音图，后来就正式学习了。 今天终于可以稍微放放日语学习了，我得写一篇博客。 晚上更完博客已经十二点半了，还好，平时就是十二点睡的，习惯了。 December 10th,2020slyz专门为重点班盖了一栋楼，名为“英才楼”。我们搬了过去。 厕所是新的，终于有单间了。教室是新的，终于有塑料桌椅了。 除此之外没有优点了。更难见到普通班的朋友。最难受的是我们离食堂更远了。本来为了赶着上晚读就只有二十分钟时间吃饭。 December 18th,2020slyz向来是两周休一天的。听莹莹说以前还会额外休一个下午，不过现在高考卷的厉害，也成过去式了。 其实这样大部分学生根本休不够的，所以对我们来说在家的时间都是务必宝贵的颓废时间。网课期间颓废现象严重，大周作业基本都是水掉的，这都与这个安排有密不可分的联系。 算了，尽管有不满，都上了两年多了，习惯了。 只是我没想到，这一天时间居然还要减半，理由是这届学生学得不如往届好。 在校时间长就意味着成绩好吗？ 我身边不少人都不乐意。我再次选择了反抗。 我一直有一项消遣，每个大周过完了，撕下一张纸条，对折。正面写备忘录，一半写学习的，一半写颓废的；背面写大周计划，让我更充分利用大周的时间。 我记得前两天我刚写上“合理睡眠，调整生物钟”。 我把这句话用红笔划掉，写上了通宵。 我把“大周计划”里的“大周”划掉。 我和一些同学约好了这个大周（已经称不上是大周了）今晚通宵，凌晨互发消息问问还醒着吗。 然而凌晨四点，只有我醒着。 January 29th,2021两个星期前mars就说因为疫情很大概率寒假不能在校补课，只能上网课。我期待着很久了，打算在家正好调整一下情绪，下学期好好学。 普通班也一直闹，不让重点班回学校补课，扬言要举报。这事也挺严肃的，毕竟涉及疫情的事。看来上网课基本上是定了。 zxf上午兴高采烈地跟我们说，她问了twj上网课的事，twj回答已经定下了。她说今天不论发生什么事都影响不了她的好心情。我也受她影响高兴了起来。 但她说错了。放假前mars突然说网课这事有变动，只要没人举报，我们就偷偷回来补课。他又一再强调不要把这事说出去。 他随即笑了，“虽然这么说，不过我还是相信你们的。” 回家路上烜看起来有点失落。我想起来前两天我妈说的话。 “网课这事你就别操心了。普通班闹成这样，自然会有人举报的。” 所以我其实没那么难受，还是充满了希望的。我跟烜说，“这事必有变数。” January 30th,2021晚上八点重点班被偷着召回。 □□□□□□□□ 我病了，请了假。 February 9th,2021在表哥家吃了顿饭。 回家的路上我对我妈说，我想转到普通班去。 Bj2002已经转到了普通班，听说之后他的成绩一路飞升。 February 11th,2021自从看了可莉的官方视频就一直静不下来。 等复刻不知道猴年马月了。突然我想起来有个东西叫初始号。 未成年还不能买初始号，最后我找了憨憨帮我买的。 因为疫情过年没回老家。或者，我也不愿回去了。 我逐渐变得孤僻。 February 19th,2021早上六点二十起，对着摄像头水一水早读。 上课也是划水，作业也是乱水。 这样的生活还是因为我在实名调查问卷「是否愿意在校补课」上勇敢的写了否。大部分人不敢拒绝，比如临走前懊恼不已的zhuoer。 学校额外加了录屏和话筒，这样我们写“否”的几个人相当于在家上网课了。 网课群里，zxf说今天上课时印度人说“他们（上网课的）回来后要是考的比你们（在校补课的）好，你们得多难受”。zxf很气愤，觉得我们被印度人蔑视了。我可能是语文课水得太厉害了，没印象。而且我本来就是基本放弃了语文的，没放在心上。后来大家一块在群里控诉slyz不合理的管理。 February 27th,2021百日誓师本来算是比较庄重的，但是这次闹了不少幺蛾子，不知道往届怎么样。 我其实根本没想真心喊出来的，不过还是被这气氛感染了点，扯着嗓子喊了出来。 但我很清楚，我确实容易被这种宣誓或演讲感动，不过最多五分钟就忘了。果然。 不过还是很有感触的。 回来的路上看到路边的树已经长出了一点绿芽。 英才楼的高考倒计时翻到了100天。 March 2rd,2021心态慢慢平和了。 不，并没有。我只是寒假后，太累了而已。 作业已经多到写不完的程度。但是放学后不学习，我还在坚守。 下了早读就往鹅的办公室跑——要作业。 上午的课还算ok，有数学物理，都是好偷着写作业的课。一上午写完了英语作业，预处理了一部分化学作业。天胡开局啊。 中午去于哥家的小饭桌。我妈居然来了，庆祝我18岁的生日，尽管我说了很多遍不愿意过生日。但是还是挺惊喜的。 于妈还买了个本子让每个人签了名送给我。 晚上难得写完作业还剩了点时间。但我脑子越来越迟钝了，早已没有兴致学日语或写一些乱七八糟的东西了。 March 26th,2021大周来了。时针指向五点——通知的放学时间，twj准时下了课。但是学生都没动。 mars已在门外等候多时了。他走进教室，对着twj礼貌地笑了笑，从电脑上调出一份成绩表。 讲台上是他严肃沉稳的讲话声，其中大部分都是无用的毒奶或鸡汤；讲台下是中性笔与纸张摩擦的声音，夹杂着书包拉链被拉上的声音。 mars应该是知道，每次放假前他占用假期时间的班会，从来没有人在听。甚至学生连头也不抬。但他还在讲着。 “这次大休作业，回来后会严查。大休作业必须重视，如果不认真做，回来那天讲作业就听不了，相当于浪费了两天时间……” 这段话，他几乎每个大周都会复读。 时针指向六点。mars话音未落，就有学生冲出了教室。 校园空荡荡的，校门外还有一些家长已等候了很久。 晚上，我匹配上lol。趁着匹配的时间，我拿出作业，打开了作业帮。 April 14th,2021在校车上一直眯着眼补觉，虽然只有十来分钟。最近司机老是走一条很颠的路，睡不着。 下了校车，往英才楼走的路上依然是睡着，扣上帽子，戴着口罩。眼睛睁开一条缝，以便看到烜的脚，像个机器人一样木然地跟着走。 朦胧中有人狠狠地撞了我一下，不用想就知道是zhuoer。 进了英才楼才慢慢醒过来。 又是英语早读。我强撑着精神，机械地背着5页维克多，半小时后应付过听写。 然后再读着各种材料，最后用5分钟背一篇作文。等下课铃一响，我立马从座位上弹出去，抢先给鹅背完作文。 随后到教室外面翻了翻数学作业，带来两份和烜一块剽小题。把六科作业分好交齐后，拿上卫生纸上厕所，今天数学课代表的任务依旧是咕了。 隔着墙和cyf、mwh、Gary等“厕友”闲扯。 “咋办啊，鹅又要听写单词……” “啥？不是刚听写了维克多吗？” “没关系，我现在正背着呢。” “Gary你不会又把书放到脚底下背的吧……” “当然……woc谁把我书从门缝底下抽走了——” 回去就是英语连堂。从开学到现在，鹅上连堂从来没下过课，每个周一和周三都从早上六点站到九点。 英语课是我唯一认真听的课了，或者说英语是我唯一认真学的科目了。我喜欢学我擅长的科目，我英语底子也好，所以英语成为了我高三唯一的寄托。 跑完操精神了一点。下一门是物理。所以我赶紧去办公室要来了英语作业。物理是第二好写作业的课，不能浪费了。 虽然是班主任的课，但我只关注是否容易被抓。mars不经常往下走，板书也很多，自然好写作业。 写两道就抬头看看mars。完形填空的题目和文章不在一面上，不要紧，我拿了两张卷子，一张看文章一张做题。最后写了一大半英语作业。真是越来越熟练了啊。 然后是化学生物，写完了英语，顺便写了点化学作业。烜则是干掉了一道导数大题和有机。 中午又失眠了。习惯了，寒假后我变得非常敏感，午觉越来越难睡着了，有一点声音或光线都不行。我两个耳朵戴着耳塞，床头用外套遮蔽阳光，却还是因为厨房里短暂细微的流水声一中午没睡。 下午有例行的数学周测。我其实不反感，每次数学考试我都觉得时间流逝很快，也许这样就能离高考更近一点。 这次题有点难，做到圆锥曲线也没多少时间了，又一次只写了圆锥和导数的第一问。 打铃收卷。大家凑一块改改答案，主要是那种错了会被秀去世的题。然后跑去食堂吃饭。 我买了一个6块钱的汉堡，和稳稳、zhuoer、烜等人对几何答案。我的数和稳稳一样，稳了，烜的几何则是连着好几次挂了。 zhuoer看了眼表，说没多少时间了，尽管我们还没吃几分钟。匆匆忙忙扒拉完饭赶紧走，吃的最慢的zhuoer一边端着碗吃一边走向剩饭桶。 出了食堂就撞上了大波往来的学生，我指着一个妹子问稳稳，“你看这石雕怎么样？”“这也能算石雕？” 远远就看见智慧哥和潮走在前面。zhuoer再次催我们说时间不多了，我们都加快了脚步。 我又开始咳嗽干呕了，小学落下的病，吃完饭就干呕，吃的太快或者运动干呕得更厉害，但我只能逼着自己走快点。 厕所里智慧哥的戏剧『xz登机』又开始了。这大概是在学校里唯一快乐的事了吧。 我笑得受不了，一进教室，看到印度人已经摆着不耐烦的表情等我们上晚读了。 我把生物选择摆在桌子上，捧着晚读材料读了起来。过了一会在第一道题上画了个D，瞟了一眼发现烜选的C。我又检查了一遍，发现是我sb了。 今晚没有晚自习时间，但是鹅依然布置了英语作业。下午秀又强调了数学作为150分的主科，晚上放学后的时间应该给数学。那么如果我没有提前写作业，英语作业该如何完成呢？ 先拿来了cyf的英语作业对答案，sb错误我自己改掉了，圈出来不一样的还给他。他告诉我都不太确定，那就不管了。随后我把我的和cyf的英语给了烜，他缝合了一下用2分钟解决了英语作业。 物理作业还是老规矩，先从大题开起。一边做一遍看烜的。我少分析了重力，改了一片；烜读数挂了，我告诉了他，不然明天会被干。 就这么互帮互助写完了实验题和大题，写了几道选择感觉时间不太够了，回头看两眼cyf，写完了。 生物胡编乱造一通，语文也是编一堆瞎话，实在编不出来了就对着烜和cyf的编。然后是五分钟的休息时间。上个厕所让脑子清醒了点。 数学第一道导数题挺水的，第二道思索了一会（大约半小时）突然灵光乍现，整了个巧妙的做法，感觉明天数学课我会大nb。剩下一堆小题，还是明天早上剽吧。 终于到英语练字时间了。先前鹅听从lbh的建议，让我们在练字时原创一些句子。我干脆写起了小说，题材类似于『魔女之旅』。不知道为啥第一章莫名其妙就开始暗讽slyz了，虽然本意不是这样。 虽然练字只要求三行，我还是对着草稿认真写了一页小说，期间来回翻牛津大词典修改，就这么用了一小时，放学了。 车上拿手机清pcr日常，回家又是刷火本，没出货。又是零提升的一天。 躺下很快就睡着了。 这样的日常，已经重复了多少次呢？ May 24th,2021早读又晚了十分钟。挺好。现在早读能比较清醒了。 上半场化学早读，尽量读了读课本，尽管我知道我过目就忘；下半场语文早读，解决历史遗留问题，背过了《阿房宫赋》。 我没有去要英语作业，因为楠楠已经抱过来了一摞卷子。数学课上基本做完了。 离高考只有十几天了。不过我们班丝毫没有紧张的氛围，依然嘻嘻哈哈的。 折腾这么久，有点累了吧。以前上课时的娱乐活动也很久没进行了，现在要么是认真听，要么神游，想象着高考后的生活。 突然想起来，我一年多没去游泳了。我抽出笔袋里暑期计划写上了游泳。 笔袋里还有另一张纸，对折了两次，写着「STRUGGLE」。高三以来我做题时常常对一些基础知识、题型和奇怪的地方不明白，以前没在意，打算最后一块解决。于是我整了这么一张纸记录问题。 晚自习都是限时练，到时间就收，不留额外的作业。各科老师都按照这个时间来布置，除了英语。所以我现在白天也只会写完部分英语作业。 最后剩了半小时自由复习时间。连着很多次英语续写都因为情节不合理爆炸了（虽然我怀疑是鹅批的太严了），我又翻出一张报纸，限时写完了上面的续写。 回家是长草的pcr和原神。 June 3rd,2021往年slyz的高考前一周应该是学生自主复习时间，主要任务是看课本。我也打算在这段时间解决完所有「STRUGGLE」上的问题，背完所有我没背过的文言文知识。 我不知道为啥就变成了6天考完两次周测。 上午是化学生物试卷讲评和语文考试。语文依然是没有长进呢，还是在往答题卡上随机输出字符。下午考物理。 晚上安排没变，还是限时练。只好用多出来的半小时解决问题，继续做化学的凤凰台。 June 4th,2021最后一次数学考试。秀说这次考试很有纪念意义。 我跟她开玩笑，“那我干脆考零分庆祝一下。” 这次题目出奇的简单，我甚至所有题都做完了还剩了十分钟。 晚上对了对答案，说不定能满分。那这还是挺有纪念意义的。 最后还是因为数列题有一步不严谨扣了一分。 June 6th,2021给了我们一天的自由复习时间。但我别无选择，只能干语文。 从早到晚，我先背完了二十多张知识小卷上的文言文字词，然后又背了我没背过的文言文。脑子差点宕机。 随机挑了几道文言文题做，我背的字词一个没用上哈哈哈。 明天就高考了，但我心情没有丝毫的波澜。 前几天感冒了，嗓子痒。今天晚上突然加重了，痒的睡不着。咳不出来，吃药也没用。折腾到凌晨三点才睡着。 June 10th,2021还有一分钟。遗传大题没有搞出来，我随便编了几个数蒙了上去。 我的手在颤抖。 我一年前幻想着的。 我三年前梦想着的。 我入学来每时每刻都在想着的。 June 25th,2021我没有从劳累中恢复过来。 我没有过上我曾梦想着的生活。 好像今天能查高考成绩的。但是一直以来我对成绩都不关心，高考也是。网上的答案我甚至从来没碰过。 下午五点我刚打完一把lol，看到群里正在讨论成绩。楠楠好像在做什么统计，给了我查成绩的网站。 反正也没事干，我把成绩查完了发给他，聊了两句，接着打lol。 后记也许高三应当是一段拼搏与奋斗的时光。 也许高三应当是充满欢笑与情谊的路途。 但这都不是我的高三。 高考完的一段时间，我甚至不敢去回忆。 我痛恨着衡水模式。 我厌恶那个虚伪的我。 如果再给我一次机会，我还是会选择放弃。但人生不能重来。 Remember&amp;Restart 以上 附： 一些纪念品","categories":[{"name":"日常","slug":"日常","permalink":"https://ctz45562.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"回忆录","slug":"回忆录","permalink":"https://ctz45562.github.io/tags/%E5%9B%9E%E5%BF%86%E5%BD%95/"}]},{"title":"零·日记","slug":"零·日记","date":"2021-06-16T16:10:11.000Z","updated":"2021-08-19T12:55:03.278Z","comments":true,"path":"2021/06/17/零·日记/","link":"","permalink":"https://ctz45562.github.io/2021/06/17/%E9%9B%B6%C2%B7%E6%97%A5%E8%AE%B0/","excerpt":"高考后毫无意义的颓废生活？ 经过一年的学习我的语文水平甚至倒退了。","text":"高考后毫无意义的颓废生活？ 经过一年的学习我的语文水平甚至倒退了。 6.15特殊的日子。“洗心革面，重新做人”的一天。（其实就是收拾房间+改改形象） 上午先洗抱枕，没想到一洗就是一个半小时。 下午开始收拾房间，整了大概四个半小时。扔了些没用的东西，房间布局精简了些。然后把桌子上的书和笔都试试起来，光明正大地放上智乃的手办和点兔画集、单行本，真爽。 顺便学习了吸尘器的用法，这玩意可比扫把得劲多了。 晚上刮掉了胡子。本来今天是星期二，理发店休息，还好我常去的没关，成功理了发。 其实高考前就一直憧憬着这一天了，本来打算高考第二天就开始，不过还有个国科大面试就推到今天。我一直希望有这么一次“翻新”，象征着高中生活的完结，象征着我的重启吧。 桌子上还只有『Cafe du Lapin』，睡前去会员购和淘宝上逛了逛，『Cafe du Soleil』和『Cafe de Etoile』加起来起码三百。还好，找个时间把这两本入了。 6.16和憨憨出去玩。 和以往一样，老地方的集合，和不知道去哪玩的俩傻子。 于是上午在银座一直聊天。总的来说，两点感受： 妈耶，yhy管理居然比slyz都严 妈耶，憨憨简直是yhy的一股清流，拼命程度不亚于我们隔壁重点班 中午去吃华莱士。贼巧，星期三+16号双重优惠。 下午去憨憨家里玩。他下了个lol，然后我在恕瑞玛开了个新号。他叫“我是龙马”（我也不知道有啥含义），于是我起名“龙马是我”，我俩就一块打。。。人机。还是挺愉快的 出了个阳寿苍白花，好起来了，终于能勉强给优菈凑个四苍白了。 一次没歪，但是数值低了点，不过有个充能。 翻某个壁纸网站的时候翻到一张图，感觉见过几次。设成壁纸，越看越有味，后来到了一看桌面就发情的程度吧。 大概是某个点戳我了，真的好可爱啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊 忘了说了，就是这个日记的头图。 6.17 ——如何快速毕业活动商店？ ——去考一次口语就行了（ 去二中考并没有卵用的口语。作为（原）slyz的学生，我们拥有强大的客场优势：先等二中的考完了才轮到我们。然后我在等着的一个多小时里把刚开的活动商店毕业了。 整个考试很水，先排队交智商税35元，然后发两篇文章提前看着。第一篇做过阅读理解，讲的是作者母亲最爱的狗被撞死了，司机没有逃逸而是主动道歉提供帮助，作者对此大加赞赏。第二篇讲的是疫情的事，不过我光注意发音了没有细看。 考官戴着口罩，说话呜噜呜噜的。他先是把一篇倒着放的文章推过来，指了指。我猜是让我读，读了第一段用含混不清的声音说了些啥，我辨认了一会才明白是”stop”。然后开始问问题： 考官：&amp;%^&amp;@#*$!…… 我：啊？ 考官：Say something about yourself. 我：Err……My name is cst. I’m from Shengli……(草slyz咋说，算了随便编一个吧)No.1 Middle School. I have learned computer during my senior high school life. My dream is to be a computer engineer…… or a programmer. 考官：OK. You can go back. 让我自我介绍的时候真的是梦回两天前的国科大面试。大概是觉得我太菜了吧很快就结束了。 我终于抢到中单了！这次的永恩对线依然被打爆了，依然是队友带躺。 练了快两个小时吉他。真的不行了，弹不动了，从b站上换了好几首曲子都被卡了。最后还是打算学学『红莲の弓矢』，希望能练出来。 6.18整理了一下博客，更新辣！其实高考后偷偷更过一次 去济南山大面试。 好家伙，于哥居然开始玩原神了。 一群人不知道为啥不点外卖在街上到处找吃的，还差点进了一家奢侈饭店，最后吃的肉夹馍。 晚上和zhuoer、wwr愉快地…联机打元气骑士。本来想联机红警，但是zhuoer没带电脑。 话说德鲁伊新技能有点逆天啊，根本不掉血，虽然最后还是在2-1团灭了红红火火恍恍惚惚。 6.19嘤嘤嘤被羞辱了。 六个考官面试一个人。正对着我的是一个四十多岁的男的。然而我每回答一个问题他就用不同的表情嘲讽我。 而且不光是学术问题，开放性问题都在用鄙夷的眼神看着我。 最后他问了我个学术问题：你是学计算机的，那我考你个专业问题，你有10个砝码，其中有一个砝码不一样。你要用一个天平称出来不一样的砝码，怎么做？ 这是OI问题？而且没有给我思考时间，我就随口胡了一个。然后他又追问我为什么这么分，如果是8个、12个怎么分？ 这不会是想让我生成通项吧？大概是看我挺拉的，就让我走了。 国科大真好 下午就回家了。 好累啊摸了摸了。 6.20woc我的电脑椅上居然缠了根数据线？ woc这根数据线居然连着靠垫？ woc接上电还能震动按摩的？ 中午去姥爷家给他过父亲节。 书房里很多我以前喜欢看的书都找不到了，趣味科学故事、哈利波特、三本意林，除了哈利波特都是看过十几遍的。现在只找到一本意林。 封面是个日系画风少女，看起来还不错？ 在淘宝上买了『Cafe du Soleil』和『Cafe de Etoile』。347软妹币。 新电脑到了。联想拯救者R7000+R7处理器。配置够用了（指能打原神） 还送了个机械鼠标（这辈子第一次见机械鼠标） 尝试用网线把两台电脑连起来。失败，告辞。 今天是我妈生日。和我爸去买蛋糕。震惊，好利来和蒲公英是一家蛋糕店。 晚上吃的「是火锅，不完全是火锅」，还有表哥。 我亲自切蛋糕，虽然不是第一次切了但是切的跟屎一样（ 整了一晚上电脑还没弄完，github老是上不去。 终于见到苍白的暴击头了，虽然不如原来的角斗士暴击头，但是这样可以把垃圾的攻击杯换下去了。 我也没想到今天发生这么多事。 6.21正在玩解谜突然得知『Cafe du Soleil』和『Cafe de Etoile』到了。这也忒快了吧== 又一个愿望实现了。 还差两本公式书和三本单行本。 吃完晚饭开始欣赏画集，虽然看不懂日文原版（ 尽管学了一年语文我依然只会用nb形容koi老师的插画。虽然大部分我以前看过，但是在纸质书上看细节还是觉得很赞。 我从未想到优菈会比迪奥娜先小毕业，至今都没刷出来千岩的生命杯 看完公子剧情，对公子印象有所好转。特别是最后魔王武装那段，有点帅。 整体剧情还可以，除了托克这熊孩子烦死了。 上了次洛谷，我关注的人除了杜爷都没有动静了。啊，还有个花和鳖对话。 然后又去翻了我的OI回忆录，有点伤感，真怀念在机房的那段时光，和同学天天吹水颓废，虽然不能整天想颓啥就颓啥、不能自由支配金钱、不能一天睡9小时、没有高性能的新电脑…… emm…好像不是那么怀念了 开玩笑的。 三年就这么过去了。时间真的可以磨平一个人，无论是靠OI还是高三。 突然想写写高三的回忆录了。本来因为不敢回忆那个时期就一直没动笔，这里留个坑吧。 6.22研究了一上午动态壁纸，最后换了个智乃2021愚人节的。 强行毕业猫猫，虽然杯子副词条差点儿事，不过最多就少个1k生命。最后3w5的血1w的盾。 有点后悔钟离池子没抽个二命猫猫。 然后推了猫猫的一条线。 终于补完了『满溢的水果挞』。 不知道为啥打大乱斗的时候玩AD手感特别好，走A贼流畅。然后回去玩永恩又被打爆了 出了一个阳寿乐团暴击头，想换给优菈，然而苍白攻击杯实在是太拉了，最后还是没换。 6.23没想到还会有毕业典礼。然而mars不在，我们班连座位都不够，只好坐在最后颓手机。T代替领花就不管了，最后毕业证毕业照都没有。 然后去了机房，去了超市。 以后大概就与slyz再无关系了吧。 之后和烜zhuoer稳R去万达。一开始也没啥事干，于是在电影院外的椅子上联机打元气骑士。 吃完饭去玩密室逃脱。实在是没有什么水准，大部分机关要么碰巧要么爆搜搜出来了。结果不到一小时就出来了。 之后五个人打扑克，我教他们玩加减乘除。 啊，还记得初中新概念班上我们每次都玩这个。 玩了一半zhuoer变成zzq了。后来被稳稳拉去玩剧本杀。 第一次玩非常菜，剧本没说全，最后去世了。 晚上回家联机红警，结果先折腾了一小时，各种bug。我的网路点不进去，最后发现是按钮和点击位置错位了，必须点网路右边的黑色区域…… 6.24打疫苗去了。不是新冠，是乙肝。 上学之后好像就没打过疫苗。 我本来是很怕打针的，然而居然一点感觉都没有。就是回来后胳膊一直疼，这个就无所谓了。 时隔多年终于和徐哥再次开黑打lol。 大乱斗星妈也太猛了吧，出完狂徒就是移动泉水。 6.25终于出了个苍白攻击杯，比原来强一点点。算了就这样吧实在是不想刷苍白了 捣鼓评论系统。Valine好像不能邮件提醒了，干脆换成gitalk。折腾了一会没整上，而且Valine好像还能邮件提醒，放弃了。然而Valine邮件提醒也没整出来，明天再弄。 下午四点出高考成绩。我妈不敢查，我也懒得查，下午一直在打lol。 五点的时候看到群里在讨论成绩，murmur还问我成绩，于是我顺便查了一下。 668分，402名，比我预想的要高不少。 后来国科大打来电话了，一家人饭都没吃就去见国科大的老师。总结来说就是我能去国科大了。 从未设想的道路。我本来想着山大再见的。 我以前说过我绝对不会去北京上学，绝对不会去很顶尖的学校，然而现在我默许了。 人生就是这么充满矛盾吧。 6.26去表哥家吃饭。给我讲了一堆红警心灵终结。 打lol感觉不在状态，队友也经常挂机。 平静的一天。 6.27分数压在线上被迫去考清华强基。 和cyf一块去。交流了一些番剧（虽然我最近没补多少番）和分数，才发现我们班好diao啊。 神奇，酒店前台在六楼，而且在一个房间里，甚至有微波炉和床。 突然想起来我想玩明日方舟，于是下了个玩玩。 感觉我像个傻子。 6.28起得很早，昨晚也没睡好，考试时特别困。 本来就没去培训，我也没打算走强基，就是来混混。不过考四个小时可真难受。 感觉历城二中比slyz气派多了，有好多石雕。 考试在电脑上，都是选择题。 首先是三小时的理科测试，35道题。奇怪，怎么都是数学题。大概跳了一半多题，极少数我能靠OI和高中知识瞎搞出来，好得没有荒废。 此时还有45分钟，我往下一翻，居然还有20道物理题。我再翻，居然还有18道化学题！！！ 化学还算能看懂，虽然高中化学就不咋地，随便蒙了蒙。物理浏览了一遍，都是些没学过的东西，几乎全是蒙的。 然后就是一小时的综合素质测试。我本来以为我这辈子都不用碰语文了，然而我又要写两篇小作文。 第一篇介绍我报考的专业内容和我学习它的优势，第二篇讲我学这一专业的原因和我的梦想，每篇500字以内。 从大脑里抠出来为数不多的汉字，随机排列了一下就放了上去。 强基就这么马马虎虎地结束了。 回来后就一直在研究方舟初始号。方舟的首次十连六星和游客号机制真的很适合搞初始号。我第一个号出的能天使，能玩，但我其实挺想要小羊的。 最后干脆买了个初始号，带着四个幻神的。 6.29和徐哥一块上分（打定级赛） 我的永恩居然c了！ 晚上和murmur联机MC，虽然我以前没大玩过。 总是进不了murmur的房间，整了一个多小时，最后Ciyang整好了。 玩的是murmur从初中开始整的模组。拿枪做任务。Ciyang玩喷火枪一直在烧自己人，我拿个锤子近身搏斗顺便破坏地图。挺快乐的。 6.30补点兔3简评。 7.1摸了摸了。 7.2看牙。 我的牙杀过神经，18岁以后要做个guàn（不知道是哪个字），就是个保护牙的套子。 医生看了看说我的牙还没张好，还不能做，顺便发现了一个洞。 顺便去洗牙，喝了一堆水，吐了一堆血。 然后补牙，喝了些不明液体，大概是双氧水。 看牙真的是对听觉味觉的双重折磨。 7.3莎弥拉玩着真爽。 对线强势，可半肉，不怕刺客（自己就是个刺客），又一个我心目中的理想ad。 瞎按一通拿到了人生第三个五杀。 7.4和zhuoer、Ciyang联机MC，玩的盘灵古域。 缺一个t所以我选的人族战士虽然我也没打算穿肉装 地图太大了，老是迷路。 7.5做梦梦到我高考。大概是出台了什么新政策，我在家写的语文卷子。不知道为啥我写作文先写的右半边而且不按段落顺序写，还剩五分钟的时候发现错位了，非常慌。第二天上语文课（为啥高考完了还上课）就很抑郁，乱翻桌子上的卷子，被Indian发现了，她说上课这么久还没找到卷子，然后说了些狠话。 凹了一上午FIN-TS没过。 晚上突然很难受，一定是发烧了，虽然没量体温。蚊帐里又发现蚊子了。折磨。 7.6一觉醒来不烧了。 和zhuoer、R、Ciyang又整活MC，房间里始终只能存在两个人，玩了一下午bug。 7.7去知乎上转了转。果然我还是不适合国科大。 于是最终选择了不报国科大。不过提前批已经报上了，有可能还是会被录上。顺其自然吧。 『红莲の弓矢』差不多是练好了吧。难度其实一般。 继续找下一个谱子。 『unravel』，好听，很酷，但是太难了。 『secret base』，好听，有人工泛音，告辞。 最近有种空调病的感觉，于是要了个蓝牙耳机，开始跑步。绕着小区就跑了一圈差点累死。 7.8又听了一遍『secret base』，跑去学人工泛音了。一激动花5块钱买了谱子。 其实我缺的不光是手，还有设备 突然被拉去打新冠疫苗。签字的时候发现自己已经快不会写字了。 看到憨憨发动态问有没有人和他一块玩糖豆人。原来是steam夏促最后一天。 然后我俩一块买了糖豆人玩了一晚上。真菜啊。 之后憨憨给我开了steam共享，我能玩他有的游戏。我是知道为什么他的电脑空间不够了。 7.9没睡好。睡了一会被热醒了，开空调继续睡。 又睡了一会，做梦，梦里我腿很痒，一直挠，然后发现这不是梦。不会是打疫苗过敏了吧。这是我突然想到什么，打开灯，在蚊帐里干掉了一只蚊子。 初中同学聚会，虽然只来了17个，但是挺热闹的。 不少人都变了。比如变成巨人的dzf，精通游戏、电脑的wgq，两道杠的wfy，以及变成熟的女生（虽然只来了5个） 也有没变的，渣哥，外貌身高性格一点没变，还是那么矮，还是很爱吹牛逼 饭桌上没有严肃的话题，就是吹比瞎扯，和初中一样。渣哥很有领导风范，高谈阔论，领头干杯。 上了高中才发现，再也找不到初中那种天天胡扯的感觉了。 也许，我还是希望站在低一点的位置。 7.10&amp;7.11回老家给奶奶过生日。 听亲戚们在饭桌上聊天也挺有意思的。 本来打算在来回的路上补完点兔的漫画，结果连旅行篇都没看完。 「复苏的魔女」公测。我预约过，当时实在是游戏荒，现在反而没时间搞了。 评分不算高，不过还是先试试，游客号云玩了一下。玩法和立绘还行，剧情看着挺迷的。 100抽的时候看中了枕头，第一反应是布丁。贪了，想要枕头+一个SSR，最后变成连SSR都没有。反正是云玩游客号，直接弃了。 发现雷电模拟器有个同步器功能，多开了五个模拟器整复苏的魔女初始号。一个号有88抽能保底一次，但是太非了，没有三黄的。 补完了咒术回战。终于填上了10月番剧简评的坑。 7.12睡梦中突然想起来昨天没上原神。 闲的没事刷复苏的魔女初始号，刷了两波（10个号）出了一个四黄，而且有枕头海豚脱解能组法队了。然而我第一次知道b服的游客号不能绑已有的b站号。而且转了转感觉这游戏评价并不好，主要是数值和bug问题。弃了。 7.13我真的挺喜欢小羊的，突然想把小羊精二（尽管我的进度完全没到），看了看材料差不多，然后去抄术士芯片的作业。 两个狙。克天使，能天使。 两个群法。因为有小火龙一直没拉过正经群法。临时拉了个12F，哎呀还差一个。算了小羊也能当个群法。 可是小羊当了群法就差一个单法了。不管了。 最后拼拼凑凑瞎打居然过了。。。 游泳。我居然还会游泳。高中只去过一次水上乐园。 小时候我爸教的我游泳，野路子，头永远在水面上。至今只会蛙泳和仰泳。 我想学潜泳，依然没法把身子潜下去，游了两小时出来了。 不知道为啥点进橘子怪的直播，看着看着b站炸了。然而我还在直播间里，就是弹幕没了。 标题一多我的博客目录就出界了。研究了一下，给目录加一个overflow:scroll再限制一下max-height就行了。实际上我光限制了max-height就行了。根据黄金分割比我把max-height调成了372px，搞定。 我甚至尝试改变滚动条格式，失败了。 7.14高中同学聚会。17个人，还有一个咕了。 不过还是挺快乐的（指调戏楠楠）。 博哥和楠楠献上了美妙的舞蹈。之后一块玩多人游戏。 我、稳稳、楠楠、博哥玩剧本杀，抽了个妹子，居然是内鬼。线索实在是少得可怜，编了一堆不靠谱的瞎话最后成功了。 后来所有人一块玩狼人杀，玩到三点服务员说再往后要加时费，于是跑到外面小树林旁边玩。最后回家快六点了，回来还去理发，累死了。 填机房人物列传的坑，去群里问成爷的事结果死群突然活了。阿块好像还挺想看我的高三回忆录，那就立个flag，明天搞出来。 本来打算早睡的，结果刷到了这个，我tm差点笑死。 7.15想喝茶了。茶壶镀了一层茶垢，按知乎的方法，牙刷+牙膏+开水，刷了挺长时间。 「伊甸园的骄傲」公测。这游戏在b站上宣传很久了，高考前我就经常看见广告。不过那时评论就一般，因为这游戏本来是主打涩情立绘的，若是到了国服嘛。。。 不过还是下了个玩玩。感觉非常微妙。 立绘果然是和谐了，但是动画没有。这两个不一样就很奇怪。 战斗方式是纯回合制，画面也一般，这个就完全吸引不了人了。 主线我还没推多少，暂时没看出来剧情有什么深度。 live2d还好，就是埃普丽尔胳膊上的一大团棉花还是啥看着太变扭了，不得不关掉live2d过剧情。 评论区里还有抱怨这个体力机制的，升级只会补满体力，如果已经满了就不加体力了。 整个游戏体系上我有一种pcr的既视感，包括jjc工会战，包括角色养成和宝石获取。不过说真的，立绘被和谐后，pcr是完胜的。 然而我最后还是被伊万斯吸走了。女神这立绘这设定这强度真香，要是不被和谐就更香了doge 刷初始号挺简单的，开同步器十分钟5个，我还整了些改ip的工具。大概一小时刷了个女神初始号。这次学乖了，不玩b服了。 pcr这波sp整新机制，护盾重伤。猫拳猫剑直接再就业。哎呀这个重伤好烦啊，抄了半天作业。 因为有公会开挂被封，我们公会成功挤进前1200。 不愧是flag，回忆录咕掉了。 7.16伊甸园的骄傲玩不下去了。 复苏的魔女刚更新，修了一堆bug，也优化了体力消耗啥的，也是解决了不少问题。事实上我还挺喜欢它的立绘的。 然后就石乐志，刷了一天的初始号，一边刷号一边写回忆录。 我只想要个抱枕海豚脱解的初始号，然而这次比较非，刷了几十个都没出。越来越熟练了，学会了换ip，甚至录了几个脚本。 这游戏必然有彩点。每次出UR都是一起出。 我！的！小！羊！精！二！啦！ 我这个阶段搞个精二挺伤的，这大概就是厨力吧。 7.17昨天吃了鸭头导致我早上七点就起来了。 小！羊！要！出！新！皮！啦！ 今天约好信息组一块去万达玩。和烜一块坐公交去的。 我俩转了一圈没找到人，他们说在看老年表演团。于是我们在舞台旁边会师。 好久（其实也没多久）没见到块了，也没怎么变。 完美复刻了上次来万达玩的流程，先在电影院外的椅子上联机元气骑士等zhuoer来。我体验了把游侠三技能，真的无敌。 zhuoer到了后一块去吃的火锅。下午又被稳稳拉去玩剧本杀。我说别玩民国题材的了，老板就给我们推荐了『朝夕村』。 给了我一个44岁女人的角色。这本刺激，ntr、雷普、下药。我这个角色很尴尬，说多了我就成凶手了，说少了我又找不出凶手。 成爷拿了个挺重要的角色，全程基本不说话。最后实在推不出来了，票了最没有嫌疑的稳稳，果然是他。 又刷了两组初始号，啥都没有。 发现了更好的换ip方法。原来是从网上找ip代理软件，但是都只能试用一会，而且每个软件都得实名一次。现在发现手机开关飞行模式，其热点的ip会变。 7.18起来就刷初始号。第一波5个没出。 尝试了雷电模拟器的小磁盘模式，本来磁盘空间限制每次只能刷5个，这回能复制好多个了，直接开了8个（单个ip最大注册的游客号数量），终于出了。算起来刷了快一百个号了。肝疼。 之前尝试用重启路由器换ip，没成功，现在明白了，我原来重启的是中继路由器。。。 7.19终于写完了高三回忆录。想配一张黑暗一点的图，发现我居然没有这种图，找了一下午。 分类有点多了，归档拉下来的子菜单太长了，于是把“游记”变成了一个标签，全放进了“日常”里。顺便追加了一个标签“回忆录”。 开始吃吴签的瓜。 7.20lol莫名其妙进不去了，快四点了，干脆等着方舟更新买小羊皮肤。 该换手机了。 我一直是忠实的华为党，要不是没货我就直接买了。看了一晚上的手机推荐。小米11配置确实高，但是系统也确实烂。vivo、oppo、一加的旗舰机总是有一些我不满意的地方。 反倒是华为mate40和mate40pro，背面的圆环瞬间吸引了我，这设计太漂亮了，而且性能方面我也很满意，除了买不到就没有别的缺点了。 7.21又看了一上午的手机。还是华为最香。 去华为官网上看了一眼，发现明天mate40开售。真是巧了，希望能抢到吧。 我有亿一点点想抽神里了。还差十来发大保底。想了想之后的甘雨雷神心海，我还是把手收了回去。 早就听说要出圣遗物三换一，攒了一堆金的没喂。整了一堆宗室，出了几个小极品，本来宗室是给莫娜的，突然想起来新圣遗物更适合莫娜。不过北斗行秋也能用。 推了一下午原神稻妻。 7.2210:08开售，我10:08去看，已售完。看到mate40pro 4G版有货，我犹豫了，4G不太行，而且也太贵了。 最后跟着我爸线下买mate40的，贵了几百块钱。然后我爸去开会，我本来打算坐公交车回家，突然想起来没带钥匙。于是到振华转了会，到四楼找到个能坐的地方等我爸。 晚上网卡的要死。 7.23咕咕咕。 7.24想抽个洁哥歪了帕拉斯。我一急把加急许可都用了，第一次见到高资，能出能天使赛爹，但我都有了，干脆什么标签都不带，出个能天使，淦。 7.25也许因为疫情去不了cj了。票也不好退。 被拉去和亲戚吃饭。 突然想写点东西，比如二次元游戏评测。 7.26收到浙大的录取通知书了。我妈一直抱怨通知书不是立体的，太普通了。 好像又能去cj了。 打算补re0第二季，发现还有两个OVA没看。先补了一个ova，堂堂一个ova居然跟剧场版一样长。 憨憨24抽出了天空弓，酸了。 拉肚子，贼难受。 玩了两把智慧末刃飓风巨九老鼠，好像还挺好玩的，但一直没等到出巨九，不是碾压就是被碾压。 7.27终于推完稻妻主线了。图做的挺好，但是人变懒了。 话说我现在除了lol所有游戏都长草了。 出水电了！攒了12w石头，终于可以享受抽卡的快感了。 先玄学一张券，一星。然后开始冲十连。结果一发十连就出了，索然无味，毫无抽卡体验。 7.28既然换手机了，那该研究之前不能搞的东西了。比如美化桌面。 我以前搞过兽耳桌面，在桌面上添加一个梦梦奈，后来为了省电不用了。 搜了一下，现在第三方桌面不被允许了，兽耳桌面成了纯净版，梦梦奈没了，那还用啥。 我又想起来之前在贴吧看到过一些很酷很炫的桌面，用某个软件搞出来的。我一搜，原来是kwgt，立刻开始整活。 很快上手了，很快又上瘾了，这玩意跟搭博客有点像。大概又开了个大坑。 听到『キネマ』，想起来CSP2019 Day1爆炸后的下午，我坐在床上平复心情，听的就是这首歌。 7.29最终还是没去cj，我也没得选择。 “烟花”来了，外面下着雨，有点惆怅。 一起来就开始玩kwgt，整了几小时只出来个半成品。 感觉太紧凑了，我也不会设计只会瞎摆。 昨天就构思好了星期的排布，有一张点兔2021愚人节「Seven Rabbits Sins」的图片，正好有七个人，能对上星期。 雨停了，Tian-Xing问我能不能出来玩。可惜我有点事。 之前我跟他说我要给他点东西。寒假的时候他说想把我的英语积累本传下去，当时我还没想传，只是给他拍了照。后来我也想在cj买点礼物把本子一块给他。可惜没去成。 突然想起来我的英语续写了。因为初中学过新概念，语法底子不差，句式随便用，但是词汇量不大。于是我准备了积累本，记下那些又酷又炫的词组和句子。平时不背，考前十分钟使劲背，开考先看续写，把可能用到的写下来。最后写续写的时候不是根据内容用词，而是根据这些词编内容。其实背上几次就形成长期记忆了。 一开始这法子还挺有用的，后来情节上开始出问题，积累本上的基本都掌握了，我就开始先考虑情节。大概是企鹅比较蛤，总是在一些莫名其妙的地方给我的情节挑刺，语言好了也没用，而且她每次都能说服我…… 高考时写到第二段就剩十分钟了，写的很草，升华的时候手都在抖。也不知道怎么样，不过看总分应该是没爆炸，我想是因为不是企鹅批的我的续写吧。 徐哥终于找我打lol了！他最近一直在玩比尔吉沃特的小号，推荐我也来比尔吉沃特玩玩。 起名还是老规矩，他叫“我就这么比丶”，我没想到很好的，起名“你就这么比丶”。 虽然是小号，不过大家都是小号，玩起来和大号也没啥区别。 攒了七千多精粹打算买个英雄，皎月破败王赛娜莎弥拉都挺好的，想了想既然是小号就玩点新的，厄斐琉斯我挺想玩玩的，不过我这个分段玩这种ad没人保我的，最后买了塞拉斯。不得不说，虽然很菜，还是挺爽的。 能天使精二了。打算把桃子拉起来。 其实牛牛这种教官近卫对我这种不动脑子的还挺好用的，但只能以后再拉了。 复苏的魔女出了个面具。 玩的人确实少，也没有评测，不过都说是人权辅助，物理队终于起飞了。 手里有二百多抽，有龙女，要是抽了面具，还差个暗奶，凑不了顶配物理队了，可惜。 不过既然是人权，还是先抽一个吧，不行用琴女或绷带替一下暗奶。 抽卡其实应该是索然无味，80抽保底UR，160抽保底up，怎么都能抽出来了。不过要是歪个暗奶……那是不可能的。 扔了6个十连冒彩光了……歪了……卧槽歪了个暗奶？这抽卡可有意思了。 又扔了4个十连出了面具，这波啊，这波法队物队人齐了，直接起飞飞飞飞飞飞飞 前几天状态一直很差，作息不太好。这两天特意早睡了，果然有精神了。 有精神了干啥都爽，那些不快的事也都消散了。 7.30打第二针疫苗，一边打一边整kwgt。不知道是什么bug，所有的图标突然不能显示了，我直接从iconfont上下了图片硬核加图标。 玩了把塞拉斯打野。没法打野，前期太伤了，刷完一组野差点死了。幸亏徐哥不在，匹配的都是些新手。 徐哥居然玩原神了。想起来当初班里只有潮、zhuoer和我玩原神，后来潮不玩了，zhuoer因为被缴械玩的少了，只有我一直在玩。高考后我身边的人一个个的跳进原神的坑里。 后来我和憨憨进了徐哥的世界，当然是乱杀。带他上了雪山，开了璃月。原神联机还是开语音舒服。 徐哥沉迷于抽卡，一整天都泡在原神里，憨憨最近也是一直在肝原神，我突然想起寒假的自己。 7.31凹了一上午龙门市区终于过了。 呜呜呜法队倒了，呜呜呜物队崛起了。 又被拉去联机。 8.1补完了re0 ova2。感觉emt过于善良了，这样自己反而会很痛苦。虽然是前传，但是有些地方还是挺迷的，再出个前传的前传好了 8.2我是赛娜，对面有劫、亚索、永恩，我家后排还有霞和有金身的莫甘娜。而且我走的海妖爆炸输出流（说真的，玩过一次海妖赛娜就在也不想出半肉混了），我知道打团肯定是先搞我。 突然想到，赛娜技能都有ap加成，于是我做了个金身。我都佩服我的理解。 以后赛娜就这么出，海妖火炮羊刀金身。 8.3 看到徐哥抽卡我也想抽了，但不想把大保底用掉，抽了常驻池。然后迪奥娜二命了，高兴。 买了点兔单行本78册。还有特装版的，多了海报吊坠之类的。 欧了，但是欧得很难受。 一发十连给新池子，出了水月，但从强度上来说我并不想要。 又一发十连给普池，想抽洁哥，歪了早露。 8.4石乐志。 8.5家里一直是用投影仪代替电视的。有一点好处是可以把电脑连上，躺在沙发上用大屏补番，很爽。 不过很久没有这么干过了，高三补番越来越少，最近也懒得去客厅，都是对着电脑看的。今天又重温了这种感觉。 8.6整了个rss。 8.7又上头了去抽常驻池。 出了个痛苦弓。香啊，甘雨有武器了。 8.8b站原来有windows客户端。下了一个。 用起来很别扭，有些设计很不顺手，还是继续用浏览器了。 8.9水狼来了。 一张厕纸。 一发十连。 出了。 完美复刻抽水电的剧情。 8.9找到一首歌，TheFatRat的『Jackpot』，纯音乐，但是混了一些女声。开头有声“哈”，中间有几句“A!O!”。感觉很萌，因为这个中毒了。 8.10心疼脸黑的憨憨。 大乱斗玩了局卡特，虽然卡特重做后我从来没玩过。瞎按一通拿了个五杀。 有点想玩卡特。 8.11肝了一下午，大概把稻妻的大支线做完了，然后捡岩神瞳把岩神像升满了。 憨憨说供奉岩神像给的九个追叙之石可以开一个高难本。找九个柱子就挺费劲了，每个柱子还要播一遍动画。副本其实不算难，除了优菈大招爆炸的时候增幅石突然刷新了。最后给了几十原石，十八万摩拉和五个仙跳墙。 8.12~8.14普通的颓废日常。 8.15我初中的物理老师被亲切地称作“伟哥”。有人偶然打听到伟哥lol铂金段位，于是中考后徐哥和他加了好友。 高中时我还听说鹅是伟哥的老婆。 今晚我、憨憨、徐哥有幸和伟哥一起开黑。 伟哥应该是有着神秘力量，一开始徐哥客户端直接出bug了。 第一把我掏出了我最拿手的英雄——玩了一把的锤石，徐哥掏出了卡牌打野，伟哥上单瑞兹。伟哥大概是发动神秘力量，开局我就被卡掉线了。最后血崩。 第二把我认真玩了，选一手莎弥拉，伟哥给我拉克丝辅助。此时伟哥再次发动神秘力量，徐哥卡牌打野没带惩戒。 8.16夏日限定池子最后一天。从强度上来说，我还是很想要水陈的。但是一直歪。资源所剩无几。 这600合成玉是我最后的倔强。 …… 出了啊啊啊啊啊啊啊啊啊啊—— 我终于见识到了单抽出奇迹 最后的最后毫无意义的暑假。 Hello, World!","categories":[{"name":"日常","slug":"日常","permalink":"https://ctz45562.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"日记","slug":"日记","permalink":"https://ctz45562.github.io/tags/%E6%97%A5%E8%AE%B0/"}]},{"title":"YELL","slug":"YELL","date":"2021-06-12T04:19:48.000Z","updated":"2021-06-18T04:48:46.000Z","comments":true,"path":"2021/06/12/YELL/","link":"","permalink":"https://ctz45562.github.io/2021/06/12/YELL/","excerpt":"","text":"我喜欢听外语歌，尤其喜欢那种听不懂的感觉。我的歌单里大部分我都不知道在说啥。 我偶尔会有兴致点开某首歌的歌词，所以有一小部分我是知道说啥的。『YELL』是其中一首。 啊，原来是说毕业的。 毕业…真好啊…… 我毕业的时候，一定要写点什么，再配上这首歌。 可是这无尽头的高中到底什么时候结束啊…… 现在，我在青岛的宾馆里，单曲循环着『YELL』，写着我幻想过无数次的文章。 也许这首歌并不能准确表达我的内心，但至少它的名字足够了。 Yell，呐喊 也许我有很多感想，也许我有很多想说的。但也许我太累了，脑子里空空如也。 高中结束了。 Remember &amp; Restart. 就这样吧。 最后一道数学题 《 祝 福 》 Eternal Protein Queen さようなら","categories":[{"name":"日常","slug":"日常","permalink":"https://ctz45562.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"『请问您今天要来点兔子吗？BLOOM』简评","slug":"BLOOM","date":"2021-02-11T03:28:10.000Z","updated":"2021-07-01T05:58:17.412Z","comments":true,"path":"2021/02/11/BLOOM/","link":"","permalink":"https://ctz45562.github.io/2021/02/11/BLOOM/","excerpt":"永恒的点兔。","text":"永恒的点兔。 前言其实这是『请问您今天要来点兔子吗？BLOOM』（以下简称『点兔BLOOM』）简评的重制版。我又双推了重写的。 本来是有每一集的抠细节+对比漫画。后来想了想，这也没什么意义，还是想说啥就说啥吧。所以这更像是一篇杂谈吧。 我之前写的评价总是太客观，个人情感太少。我想尝试写一次主观的观后感，但是客观的评价不能少。 然后我的主观抒情都写到b站长评里了，所以这还是篇客观的评价红红火火恍恍惚惚 漫画索引番剧每一话对应的漫画话数。反正都整理了，干脆写上来吧。 漫画标题（应该）是萌萌路汉化组的翻译。 动漫 漫画 第1话 57话『夏日制服制作大作战』63话『杂货中的宝物』 第2话 54话『怪盗兔来袭』58话『夏日惊悚纳凉大作战』 第3话 65话『文化祭的战斗：前篇』64话『大家的升学方向』 第4话 65话『文化祭的战斗：前篇』66话『文化祭的战斗：后篇』 第5话 56话『马拉松大赛前的地狱操练』69话『追捕青山性骚扰山？』 第6话 67话『我们中出了个叛徒』70话『棒棒个棒面包祭』 第7话 71话『Trick or Treat』72话『万圣节的奇幻之夜』 第8话 68话『大家的理世老师』73话『小豆子队与老师们』 第9话 75话『千夜是学生会长候补！？』81话『萝丝酱再临』 第10话 76话『神秘的圣诞老人』77话『圣诞前夕·兔之屋危机？』 第11话 78话『圣诞前夕·支援到来』79话『平安夜·礼物交换』 第12话 80话『温暖烘培屋』84话『点兔市第一次王冠战争』 总评尽管有一点瑕疵，但点兔3依然达到了我的期望。 情节&amp;主题如果对比漫画的话，动漫其实有不少改动的地方。例如试胆大会上千纱对白、理世与父亲的对白都是动漫原创的，第六话结尾智乃说的「欢迎光临」也是另加上的。 很多改动都是这样的，减少了一些轻松搞笑的情节，增添了温馨和橘味。 其实两种风格我都喜欢。无论是漫画还是动漫，都贯彻着「陪伴与成长」这一主题。第三话原创的凛酱的演讲就概括了主旨： 与人相遇 能发现自己隐藏的可能性而得到成长 漫画和动漫慢慢地不再只是简单地讲述日常，与前两季相比，很明显智乃改变了许多，越来越爱笑了，学会了恶作剧。第七化和第十二话更是转折点。分别代表着智乃与过去告别、迈向新世界。 点兔是一部有深度的日常番，这是它能在众多日常番中脱颖而出的原因。点兔的世界背后暗含着生离死别，但是这些从未被提过。相反，点兔用充满温情的日常静静讲述着，人生总会有离别，但更多的是新的邂逅。 动漫抓住了点兔最重要的内涵，尽力去创造一个温情的氛围承载这一主题。在这一点上，动漫已经成功了。 作画&amp;配音我对点兔动漫的作画是非常挑剔的，不过整体上来说，我看着还是很舒服的。线条和颜色流畅。 但我前面提到的一点瑕疵就是这里了，有少数画面人物面部小崩，特别是那种拉开距离、容纳多人的镜头。 配音方面，声优还是给我带来了一些惊喜的，比如十一话智乃哭泣，听得我心都化了。 不过第六话智乃学不良和第十话纱路学心爱、千夜学理世，在漫画里看着是很有感觉的，可惜声优的声线其实不适合，观感一般。 旅行篇就像漫画一样。尽管理世毕业了，小豆队分开了，但是点兔的故事不会完结。 第十二话明示了动漫还会有后续，也就是旅行篇。 旅行篇有19话，其实我很希望出一个超长的剧场版的，现在看来不现实。而且距离旅行篇还有十几话的漫画，做不成一季。如果真要做剧场版的话，至少要交代一下小豆队升学考试，只能先出个OVA。 所以还是很可能把旅行篇放到第四季里。 但把这么完整的一段分集说还是好变扭啊。 511の细节受我以前写的一篇题解猛男必刷——「みずしろごちうさクイズ」14题题解的启发，我打算找一找『点兔BLOOM』里的细节。虽然这很无聊 第一话心爱买的门把手，七种颜色的门把手正好代表了七个人。 怪盗lapin名字的由来：lapin在法语中是兔子的意思，同时与lapin的原型lupin（法国作家莫里斯·卢布朗创作）谐音 关于第二话心爱放错的录像带： 我尝试找其出处，怀疑和『鲁邦三世』（讲的是怪盗lupin之孙的故事）有关，但我没有看过，不能确定。 电视上怪盗lapin的CAST，其实就是点兔的CAST。可以依稀辨认出来几个： 麻耶邀请智乃上同一所学校的时候： 麻耶：小豆队 三人一起说贵安吧麻耶：贵安惠：贵安智乃：你们两个都贵安症候群了 智乃没有说贵安，暗示了三人最终的去处。不过漫画里智乃直接拒绝了，理由也很现实： 所以动画将智乃决定志愿的时间延后了，虽然也很容易猜出来应该是和心爱一起的。 第四话啤酒馆的巴伐利亚服饰，其实在漫画之前的插画里就出现了。 单行本第一卷COMIC ZIN插画 TV动画第一季公式书『Memorial Blend』封面 我特意查证了一下，第一幅插画是2012年的（虽然和动漫服饰有一些区别），第二幅是2014年的，而漫画66话是2016年6月的，所以在这一话之前服装就已经画好了。 如果看价格的话，万圣节菜单和普通菜单是一样的。 但是万圣节菜单右边就是普通菜单。 我特意翻译了一下，然而这个名字太中二了，并不能清楚这两份是不是真的只是改了名字。 这是71话头图： 这是动漫： 这是漫画： 麻耶和惠的尾巴，漫画和动漫一样，狼尾巴一般是下垂的，狐狸尾巴大而蓬松，狗尾巴一般上翘。推测应该是狗尾巴。 头图中麻耶和惠的尾巴较细，应该是猫尾巴了。 头图的服饰上也有差别：麻耶和惠在头图中戴领带，漫画和动漫中戴蝴蝶结；千夜在头图中戴兔耳朵，服饰上也有一些点缀。 我真无聊 右上的键线式结构简图有两个O成了四条键，还有三个O少了H。 左上的一个N少了个H。 左下的N、O都少了H，还多出来了个莫名其妙的C。 太不专业了（ 第八话这里智乃拿的笔是第二季第八话收拾烂摊子小分队一起买的笔。 都是第八话，起名风格也一样： Stamp Sleep Study Smile Sneaking Stacking Staker Story 一定是有意为之。 第九话千夜笔记本上的传统艺能，在漫画中本来只是纱路想象的： 智乃的国王权利在第十二话就用掉了（要求所有人都去rabbit house玩），然而漫画里直到旅行篇110话才用掉（要求所有人跟着智乃游玩）。不知道之后会怎么处理。 阅读理解BLOOM的含义第三季的标题没有像第二季一样再加一个问号。当然这样也不合适，不然若干年后，点兔就叫「请问您今天要来点兔子吗??????????」，我都怀疑这是不是日常番了。 第三季名为BLOOM。BLOOM原意是开花，这里应该是象征着成长。智乃的改变、小豆队初中毕业、理世高中毕业、旅行，这都是成长的标志。事实上，成长也是整个点兔的主题。 另外，BLOOM还有一个引申义：青春。虽然点兔没有刻意强调过青春这一主题，但任何描绘中学生日常的作品，一定会展现青春。只是不像那种热血激情的青春，点兔的青春是温馨治愈的。正如大部分人的青春，在平静的日常中慢慢成长。 ed解析主题很明显是爱丽丝梦游仙境。不过服饰是来源于单行本第3卷Melonbooks的插画： 没见过麻耶和惠的类似插画，大概是基于此原创的。 整个ed是根据智乃的经历制作的。 智乃困在瓶子中，提比想要打开瓶子，没有成功。 ——智乃母亲去世后封闭自我、沉默寡言。而爷爷后来也去世了，担心智乃孤独附身于提比陪伴智乃。但是智乃一直没有敞开内心。 结伴而行的麻耶和惠发现了智乃，把她从瓶子里救了出来。 ——麻耶和惠本来是青梅竹马，初中入学时发现了不善言语的智乃，主动与她交朋友。 小豆队一同在绚丽的星空下奔跑。这里智乃的表情没有完全舒展，带有一点惊讶. ——小豆队度过了快乐的初中时光。不过智乃依然是被动与人交往。 小豆队的特写。这里智乃的表情是舒展了的。 ——这段应该是初中即将结束。期间心爱的参与，让智乃慢慢改变，走出了内心的阴霾。 小豆队停下脚步，望向星空的尽头。智乃回过神时，麻耶和惠却已消失不见。 ——初中毕业，麻耶和惠与智乃去往不同的高中。 一滴咖啡滴下，麻耶和惠还在，智乃眼角带泪，跑到麻耶和惠身边。 ——滴下咖啡一般是指从回忆回到现实（例如剧场版智乃回忆与理世刚开始的相处）。面对即将到来的毕业与分离，智乃心中还是有伤感与不舍吧。 相比第一季的打扑克、第二季的跳舞，第三季的ed更有深度。第一次看的时候直接泪目了。 结语不容易啊，2月就开始动笔写了，直到高考后才有机会补完。 总体来说，我是很满意的，欢笑与感动，和我当初看漫画时是一个感觉。每次看第六话结尾和第七话都忍不住泪目。 再次感谢koi，感谢桥本裕之。 以上。","categories":[{"name":"点兔","slug":"点兔","permalink":"https://ctz45562.github.io/categories/%E7%82%B9%E5%85%94/"}],"tags":[{"name":"二次元","slug":"二次元","permalink":"https://ctz45562.github.io/tags/%E4%BA%8C%E6%AC%A1%E5%85%83/"},{"name":"请问您今天要来点兔子吗","slug":"请问您今天要来点兔子吗","permalink":"https://ctz45562.github.io/tags/%E8%AF%B7%E9%97%AE%E6%82%A8%E4%BB%8A%E5%A4%A9%E8%A6%81%E6%9D%A5%E7%82%B9%E5%85%94%E5%AD%90%E5%90%97/"},{"name":"番剧","slug":"番剧","permalink":"https://ctz45562.github.io/tags/%E7%95%AA%E5%89%A7/"}]},{"title":"2020年10月番剧简评","slug":"2020年10月番剧简评","date":"2021-01-01T01:58:11.000Z","updated":"2021-12-15T10:18:48.112Z","comments":true,"path":"2021/01/01/2020年10月番剧简评/","link":"","permalink":"https://ctz45562.github.io/2021/01/01/2020%E5%B9%B410%E6%9C%88%E7%95%AA%E5%89%A7%E7%AE%80%E8%AF%84/","excerpt":"第一次挂树:手机屏幕朝下放结果没挂上 第一次成功挂树:因为成功挂上树非常高兴 什么鬼","text":"第一次挂树:手机屏幕朝下放结果没挂上 第一次成功挂树:因为成功挂上树非常高兴 什么鬼 魔女之旅 そう，私です! 一个屑魔女旅行者——伊蕾娜的旅行故事。 关于『魔女之旅』的评价，一开始写了个原稿，太乱了，主要是可圈可点的地方太多了，综合起来没法写，干脆分开写好了。 作画细致。不用说同期新番，就是和以往的番比那也是一流的。我甚至感觉快有京都（我一直视京都为最高作画水准）的水平了，流畅细腻，非常舒服。 女主的人设。这是最先吸引我的方面。首先我对白毛萝莉毫无抵抗力，但是这个伊蕾娜的性格设定很少见。伊蕾娜人设的基调是善良热心、乐于助人的，但其特别之处在于融入了一点「坏心眼」：自恋、贪财、爱占小便宜。正是这些「奇怪的元素」，伊蕾娜的形象更为真实鲜活，有一种别样的可爱。 再搭上这个作画，伊蕾娜成为了行走的表情包： 上面两条很多番都能做到，但『魔女之旅』最吸引我的地方，在于其精妙的剧情设计和其表现力。『魔女之旅』是类似『紫罗兰永恒花园』的单元剧，每一集是一个独立的故事。但这些故事时间上是乱序的，风格从「治愈」到「致郁」、从「喜剧」到「悲剧」、从「搞笑日常」到「黑暗童话」，跨度非常大。这听起来很乱，但『魔女之旅』成功的把它们综合了起来。无论单看每种风格的故事，还是从整体来看，『魔女之旅』都处理的很棒。 Ⅰ 这些旅行故事一类是压抑黑暗、结局并不圆满甚至残酷、具有深刻意义的，我姑且称之为「悲剧」（与「喜剧」相对）。在这方面，『魔女之旅』在细节上的表现令人惊叹。从人物的眼神到环境的描写，情感极具张力，给我一种强烈的代入感。我尤其喜欢第9话「回溯之叹」——饱受争议的一话，而对我来说是封神的一话，可以说是我补过的番里情感展现的最淋漓尽致的一集，艾丝黛儿的绝望感、伊蕾娜的无力感，渲染的无比真切饱满（于是我自闭了一天）；再一点「悲剧」的剧情构思上也很巧妙。第3话「瓶装的幸福」从头至尾都是悲剧，但它以伊蕾娜的视角平静地叙述，首尾用另一个故事极力暗示结局，但到最后戛然而止。那个女仆最后会怎么样成了谜，但我们都清楚只能走向毁灭，其致郁感和深刻含义不言而喻。但从「悲剧」的表现力上，『魔女之旅』绝对值得一看。 Ⅱ 另一类是轻松愉快的治愈「喜剧」，多为带有沙雕剧情的奇遇。这方面『魔女之旅』也毫不逊色于我看过的治愈番。一方面得益于高质量的作画和高人气的女主；另一方面『魔女之旅』融入了百合元素和搞笑元素。适量的百合足以吸引我这种百合党，伊蕾娜特别的人设也创造了很多搞笑剧情。哪怕单拿出这部分「喜剧」做一部番，依然不失为一部优秀的轻百合。 Ⅲ 如果仅仅是把这两种风格混在一起，未免很突兀。为什么「回溯之叹」里伊蕾娜还在为自己的弱小痛苦，再出场时就变回自恋狂魔了？为什么伊蕾娜在不同故事里截然不同？为什么每个故事风格差异这么大？而第12话给前11话一个————平行世界。其实在第9话里也有暗示，伊蕾娜的不同选择创造出无数条世界线，而最终话不同世界线的伊蕾娜相会，将零散的碎片整合，集成一部『魔女之旅』。世界观瞬间升华了，整部番也有了其合理性，以此收尾再合适不过了。 补完之后，我对这紧凑丰满剧情架构叹为观止，甚至第一次去看轻小说。从各种方面上，『魔女之旅』值得我给它满分。 评分：10分 无能力者娜娜 「ナナさんを返してください——」 ——犬饲满 预计杀害15万 （涉及剧透） 如果让我推荐十月番，那我会一并推荐『魔女之旅』和『无能力者娜娜』。前者是“黑马”，后者则是“逆袭”。 『无能力者娜娜』在前半段的表现却是不尽人意。但是，就前半段的主要任务——铺垫来说，做的还是不错的。 第一话先是一个反转。创设一个完美具备各种主角元素的“男主”——主角专座、能力者学校里的“无能力者”、身世不凡、善良老实……然后在结尾“男主”就死了，死透了，告诉你娜娜才是主角。 这个反转怎么样呢？还好，惊了我一下，但是暗示太过了。现在很少有番敢拿这么套路化的人当主角了，所以还是猜到有反转，效果也就没那么好了。 但是！第一季不是为了惊到你而反转的，而是为了立刻塑造好娜娜残忍冷酷、双重人格的形象，并引出世界观： 青少年中不断有人变为超能力者。他们年轻气盛，常常惹出事端，所以政府编造了危害人类的“人类之敌”，将能力者骗到一座孤岛上培训，并派出谎称自己有读心能力的娜娜杀掉所有能力者。 为什么非要绕一圈，而不是直接告诉你呢？这就是作者高明的地方了。开局“男主”祭天，说实话不常见。按照常理，一部番剧情会有一些亮点。新颖的反转和“无能力者智斗能力者”的题材，足以撑起属于这部番的亮点了。不算套路化，发挥空间很足。再者，就像同样开局反转的『学园孤岛』第一话定下的基调——日常背后残酷的现实，『无能力者娜娜』则让你以为它的核心是“欺诈与内鬼”。 于是你对这一世界观深信不疑，幕布已经拉开，你已经就位，就等台上人表演了。 随后的情节是按剧本演的，主题是「娜姐，今晚刀谁？」。但是剧本一般，因此这一段争议很大。主要是两方面。 有人认为这一段三观不正。这点我是完全否认的。首先，角色和剧情的三观不能决定作者和整部作品的三观。阿Q三观不正，难道『阿Q正传』和鲁迅三观就不正了吗？作品的三观除了看人物和情节，更应该看作者的态度。『无能力者娜娜』并没有倾向于哪一方，没有支持娜娜的行为。而且，剧情在发展，角色是会成长的，如何断定娜娜就不会转变、一恶到底？以反面角色为主角的作品不在少数，怎么就能说反面角色不能体现正能量主题呢？仅仅从作品的一部分看全局实在是荒谬。相反，我认为娜娜这一反面角色正是『无能力者娜娜』一大亮点，看的爽快，主题也深刻。 智斗不智。这个我认可。一方面，前面的剧情太赶了，平均一集刀一个；另一方面，那几个被刀的能力者脑子确实不太好，尤其是“时间回溯”和“预知未来”这两个，已经算不上斗了，纯粹是这俩脑子有坑、娜娜智商碾压。娜娜和京谷的对峙确实精彩，但景谷每次就差临门一脚，猜不到动机于是作罢。我觉得那么多次证据都指向娜娜，动机反而不是首要的了，最终京谷错失了揭发娜娜的机会。所以说这一段确实有点降智，观感一般，b站上一度降到8.2分。 但是，这些问题不算什么，因为作者其实是“醉翁之意不在酒”——压根不是为了给你看智斗的。说到底观众会在意这两个问题，是源于作者在前两集把一条完善的“假”主线完美地构建了出来。 我设想过后续的剧情发展，也许娜娜会一黑到底，杀掉所有人（京谷另说）；也许京谷最后揭开了真相成为赢家……我想到过娜娜会转变，但也仅限于在整部作品的结尾。前半段已经加够好了道路，剧情正常发展，总不会把主线说推翻就推翻吧？ 这时候转折意味着什么？原来的主线根本就不是作者想讲的，但作者真的摧毁了原有的基础。学长和小满，这两个角色是转折点，主线直接被拉到另一头：娜娜的觉醒。 这是『无能力者娜娜』的高潮部分，也是它逆袭的关键。真的惊艳到了我。 有人会说了：“你太菜了，按套路主线显然会是这样的。”确实，上面这些是我个人感受，可能作者也没想那么多。但这也无妨。『无能力者娜娜』能逆袭，仅靠剧情的“形”是不够的，而它表现力的“神”同样优秀。 首先是大篇幅的娜娜的心理描写。本身娜娜具有双重人格，如果内心戏写得足够好，那是很吸引人的。『无能力者娜娜』这方面从始至终做的都很好，将娜娜的转变刻画的淋漓尽致。 再一个是犬饲满这一角色的设计。这是十月番里我最喜欢的两个角色（另一个当然是屑魔女）。其萌点很好地抓住了lsp的心：谁不想要一只完全信任你、百依百顺、竭尽全力帮助你你受伤了还会舔你的小可爱呢？而且小满与娜娜的亲密关系，在后半段一直在发糖，在这压抑的世界观里带来一丝温暖。 但是，鲁迅说过：“悲剧就是把美好的东西毁灭给人看。” 从她一出场，我就知道，如果想让主题更深刻，就只有两种可能：要么小满是双重人格，不过这个已经有娜娜了，所以不太可能；要么她注定以悲剧收场，或黑化，或死亡。 但唯有悲剧，才能让“娜娜的觉醒”更合理，更震撼人心。也许小满只是一个工具人，一个将主题推向顶峰的工具人罢了。『无能力者娜娜』的结尾，是小满的悲剧，也是主旨的至高点。 像这样敢不惧刀片、敢发这么毒的刀升华主题的，我见过的最强的只有老虚。我认为『无能力者娜娜』这一点上不输老虚。 但这并不妨碍我寄刀片。我还是希望存在一个让小满幸福的世界啊。 『无能力者娜娜』在一季里承载了很多内容，智斗能力者、学长的故事、小满的毁灭、娜娜的觉醒……但是它在后半段很稳，剧情推得很快，节奏却把控得恰到好处、有条不紊，看得爽。 因此，『无能力者娜娜』完结后，评分涨到了9.4分。也不算很高，但毕竟前半段在那，有人没看完就评分，也有执着于前半段的。我觉得它值得更高的评价。 评分：$\\lim\\limits_{x\\rightarrow1}\\dfrac{(3x^4+8x^3+18x^2-72x+43)e^x}{12e(x\\ln x-x+1)}$分 我给娜娜的『无能力者娜娜』，其实是突发奇想用高（毕）中（生）知（所）识（学）造了个极限。如果洛必达几下的话，这个极限无限趋近于10。 这就是我眼中的『无能力者娜娜』——瑕疵很多，谈不上完美。但它出色的方面完全可以掩盖那些无关紧要的缺陷，无限趋近于完美。 请问您今天要来点兔子吗？BLOOM重头戏，必须另起新文细说。 『请问您今天要来点兔子吗？BLOOM』简评 忧国的莫里亚蒂 上半莫里亚蒂是『福尔摩斯探案集』的大boss，和福尔摩斯同样智力超群，只不过一个策划犯罪，一个侦破案件。 我们一直惊叹于福尔摩斯高超的推理能力，但如果从莫里亚蒂的角度去看会怎么样呢？ 『忧国的莫里亚蒂』就是以莫里亚蒂为主角的智斗推理番。19世纪末的英国阶级观念非常严重，3%的贵族支配着社会、鄙视平民，平民敢怒不敢言。莫里亚蒂表面上是一名贵族教授，实际上是一名犯罪咨询师，为平民提供手刃贵族、完美犯罪的机会，将选择权交给平民；亦或是精心策划“戏剧”，揭露贵族的罪行，以此追求“混沌正义”。 『忧国的莫里亚蒂』基于福尔摩斯的老ip，但并非照搬。莫里亚蒂的人设比原作丰富了很多，剧情上也有一定改动。这个设定很新颖，如果你是福尔摩斯的爱好者，『忧国的莫里亚蒂』值得一看。 不过，和『无能力者娜娜』一样，『忧国的莫里亚蒂』同样存在一个价值观的问题，毕竟是以反派为主角。我认为『忧国的莫里亚蒂』处理得很好。它的态度是中立的，没有偏向哪一方。莫里亚蒂追求的“混沌正义”，福尔摩斯追求的“守序正义”，暴乱中的平衡or秩序中的不公，究竟哪一边才是真正的正义？是非善恶的界限，本身就是模糊的。 剧情上，『忧国的莫里亚蒂』在“智”的方面其实一般，没有什么特别惊艳的手法。但它胜在表现力，就像一场戏剧，分镜、音乐、细节处理得很好，氛围渲染的很出色，依然可以令人沉浸其中。 客观来说，我应该给『忧国的莫里亚蒂』更高的分。但是说实话，『忧国的莫里亚蒂』略有女性向。毕竟几乎所有角色都是男的。这点就见仁见智了，我确实不爱看全是鲜肉的番。好在『忧国的莫里亚蒂』重在设定，外貌方面的感受就冲淡了。 评分：8.5分 总之就是非常可爱『总之就是非常可爱』设定是很好的：开局结婚，全程恰柠檬。 开播之前，『总之就是非常可爱』可谓十月热度最高的番，b站也是大力推广。作为纯爱狗粮番的爱好者，我是不请自来。 但是在我看来，，这一手好牌打烂了。 柠檬恰的还算满意，但是作画实在拉胯。不求作画多么精致，至少不能崩啊。越到后面越显得贫穷，11话甚至直接把真正的游戏画面糊了上去。 我特意去看了一些漫画。画风属于简约的浅色调，动画的色彩也沿用了这种风格。可能这种画风会使作画略显简陋。但这没问题，朴素一点更能营造温馨的氛围。但是能不能麻烦把五官、肢体和背景画的协调点呢？ 『总之就是非常可爱』番剧还没开主线，偏向日常风格，女主又是其一大卖点，作画绝对不能崩。“总之就是非常可爱”，没有“可爱”，哪来的代入感？哪来的观感？ 漫画人气很高，起码我没看到漫画有崩的地方。动画做成这样，尽管评分很高，我还是想说“惨遭动画化”。 至于剧情，我不多评价。这方面个人因素太多，因为我本身更喜欢像『月色真美』这样简单纯真的恋爱，就是冲着这个方向来的，所以对比较夸张的剧情没啥感觉。可能『总之就是非常可爱』本身就不是这种类型的吧，风格完全不一样，而且毕竟种种暗示和伏笔，都指向一条大主线。 总之，我不愿看到靠着新颖的设定和高人气，动画制作就放低标准。至少对我这种非常重视作画的人，我不敢随大流给它高评价。看在它发糖的情节还是有甜（酸）到我，姑且给个6分。 评分：6分 One Room第三季泡面番的巅峰。 第一人称视角下你和众多妹子的故事。 然而前两季我已经忘了，稀里糊涂就当爹了，吓得我赶紧重温了一遍花坂结衣的剧情。齁死了。第三季还是和第二季一样做个第0话回顾更好。 不扯了不扯了。泡面番里我还是首推『One Room』的。第一人称视角还是很新颖的，看点有三： 制作水平高，代入感强。并且画风很细腻，非常舒适。其实光看这个作画质量已经值得看了。而且第一人称视角很真实，剧情也很会抓lsp的心，观感很好。你就是男主，然而你又不是男主。我酸起来连自己都能酸 搞笑。你没看错，就是搞笑。你没有声优，说话都是靠脑补。于是弹幕里主要就是脑补说话，而且大部分都是恶搞的直男发言。虽然现在b站弹幕风气不好，有一些我觉得太过了的弹幕，但还是有不少很有意思的。 福利。『One Room』配有一流的色影师——或者说，因为你是lsp，所以你的视角有时候会很奇怪。而且，不像那些那些假的福利，『One Room』真开车、开真车。有几处都明示了，就差把过程放出来了。 当然第一人称视角的弊端很明显，和我看pcr的剧情感觉一样——有时候男主的话不好脑补，需要女主复述一遍。事实上，现实中说话不会有很多复读，所以会有点别扭。不过感觉第三季有意缓解这个问题，复读少了，留下了更多的想象空间。 评分：9分 在魔王城说晚安我在看b站的新番清单时，一般看到这种日常治愈向的都会追。同时我清楚，一般来说这种番因为受众比较小，播放量会很低。事实往往都是这样。 所以当我看到『在魔王城说晚安』即使是“会员专享”（不是“抢先”），仍能播放量4000w、9.8分时，我就知道这番不一般。 确实是不一般。 『在魔王城说晚安』是一部沙雕日常番。设定上把“沙雕”发挥到了极致：魔王把公主抓走当人质祖宗，脑子不好使的勇者为了救公主踏上了冒险之路。然而，公主为了能舒适地睡觉在魔王城到处整活，甚至成为了团宠。 看的时候我还在想，一个睡觉能讲啥。结果还真就讲出花了，每一话情节都够沙雕。而且并不是纯日常，有人魔共存的主线。最后一集差点泪目。 貌似这种涉及种族和平的日常（小林家的龙女仆既视感）播放量都很高？（狗头） 画风也很神奇。乍一看好像挺崩，其实很细。该沙雕的时候一定会爆出最夸张的表情，该萌的时候就细腻，跟『为美好的世界献上祝福』有异曲同工之妙不对啊，素晴好像只有崩坏的表情。 我一般不太关心声优，但是公主刚出来几秒钟，我立刻去看了声优表。还真是水濑祈配的，完全是智乃声线。公主说话时我老是出戏。 不过『在魔王城说晚安』争议还挺大的，如果较真的话，公主对待魔王城的魔物还是挺……残忍的，特别是哈比那一集。不过沙雕番都比较夸张，和『男子高中生的日常』有点像吧，我确实有一点反感，但放轻松点看，『在魔王城说晚安』仍不失为一部优秀的沙雕日常。 评分：9分 满溢的水果挞这一季度的芳文社之一。 题材上没啥亮点，成为偶像拯救老鼠庄，不过整体风格上还是偏轻松的。其实『满溢的水果挞』主打的是卖肉和百合。卖肉程度和百合氛围在我看过的芳文社作品里算是非常高了。 当然对于日常番，这些都不重要。其实大部分日常番就是设定个背景再套上日常剧情。只有那些题材新颖或描绘细致的能出彩，不过这样的确实是少。 『满溢的水果挞』的最大问题在于经费不足，这点太明显了。 贴图衣服。衣服动图案不动，就很违和。而且这番里带花纹的衣服还不少，基本上都是贴图。 火柴棍人。不少包含多个人的场景，人物就保留一个头，身体用一根棍代替。 大概是一开始经费就没多少吧，所以好钢用在刀刃上。偶像题材最重要的舞蹈场景倒是做的可以，2d动画但是很流畅。也算是一种明智的选择了，但我还是希望别的场景能更好一些。 评分：7分 咒术回战类型上有一点像『鬼灭之刃』。都是热血战斗番，播放量都高的离谱，评分也都很高。忍不住把这俩放到一块比较。 其实看鬼灭的时候并没有什么感觉，我一直对这种番不感冒，热血悲惨搞笑这些元素掺到一块我就觉得怪怪的。不过『咒术回战』给我的观感还行。第一季从头到尾“捏”了好多人，而且不是随便说说，每个角色背后都有很深的故事。 打斗做的也很炫，虽然没有鬼灭那样的特效，但是每场战斗都是逐步释放实力与潜力，看着很爽。 oped也很值得赞扬，所有的都很优秀，尤其是第一个ed，每次看到“悟悟悟悟悟悟~”那段就想笑。 最后我还是想明白了为什么对这类热血番不感兴趣。我还是不喜欢看正义与邪恶的战斗。 本来就不存在绝对的正义与绝对的邪恶。 评分：8.5 我心目中的十月霸权在我看来，『魔女之旅』和『无能力者娜娜』是非常优秀的作品。 但是点兔作为我的本命作，『请问您今天要来点兔子吗？BLOOM』只要达到了我的预期，就能够胜出。 事实上它做到了。点兔3足够成为十月霸权。","categories":[{"name":"动漫","slug":"动漫","permalink":"https://ctz45562.github.io/categories/%E5%8A%A8%E6%BC%AB/"}],"tags":[{"name":"二次元","slug":"二次元","permalink":"https://ctz45562.github.io/tags/%E4%BA%8C%E6%AC%A1%E5%85%83/"},{"name":"番剧","slug":"番剧","permalink":"https://ctz45562.github.io/tags/%E7%95%AA%E5%89%A7/"}]},{"title":"12.4 wishes&worship,recollection&restart","slug":"12-4","date":"2020-12-04T15:23:47.000Z","updated":"2021-07-01T04:27:53.078Z","comments":true,"path":"2020/12/04/12-4/","link":"","permalink":"https://ctz45562.github.io/2020/12/04/12-4/","excerpt":"「重生之后，还是原来的我吗？」","text":"「重生之后，还是原来的我吗？」 今天早上和BJ2002统计数学作业的时候： “今天几号来着？” “4号吧…对，4号。” “12月4号吗…” 我立刻意识到，那是我常常默念的日期。幸好，没有错过。 Best wishes to my redemption 还记得上次智乃生日的时候，我在机房写下CSP2019游记，附上我的生日祝福 今天，我在教室写下这些文字，为了用回家为数不多的时间上传到博客 OVA，第三季，一年前还在盼望着的都已实现了。 第三季我还没看，在这留个坑，等完结后慢慢品味，附带一篇感想和十月番剧总评。期待第三季带给我的惊喜与感动。 前段时间精神状态一直不太好，很消沉，发生了很多事，一直没补番。 有一天我突然发现自己忘了智乃的声优是谁了。我想了很长时间，最后从床上爬起来百度才知道。不仅如此，我去回忆点兔的很多东西，纱路的姓氏，心爱、千夜、纱路的生日，惠的声优。。。我太久没关注点兔了。。。 我一直觉得我把点兔作为自己的信仰，但这么看来，我到底在追求些什么呢？也许，这一切都只是我的虚荣心罢了。 我离二次元越来越远了。。。 那时候很迷茫，现在大概是看开了，悟已往之不谏，知来者之可追。 我希望信仰终成信仰。 我希望再次启程。 我希望，我会的。 「Slow Restart」 以上。 附： 头图pixiv id：86074380 插图pixiv id：86074640","categories":[{"name":"日常","slug":"日常","permalink":"https://ctz45562.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"二次元","slug":"二次元","permalink":"https://ctz45562.github.io/tags/%E4%BA%8C%E6%AC%A1%E5%85%83/"},{"name":"请问您今天要来点兔子吗","slug":"请问您今天要来点兔子吗","permalink":"https://ctz45562.github.io/tags/%E8%AF%B7%E9%97%AE%E6%82%A8%E4%BB%8A%E5%A4%A9%E8%A6%81%E6%9D%A5%E7%82%B9%E5%85%94%E5%AD%90%E5%90%97/"},{"name":"番剧","slug":"番剧","permalink":"https://ctz45562.github.io/tags/%E7%95%AA%E5%89%A7/"}]},{"title":"10.2闲扯","slug":"10.2闲扯","date":"2020-10-02T10:42:50.000Z","updated":"2021-06-18T04:25:52.000Z","comments":true,"path":"2020/10/02/10.2闲扯/","link":"","permalink":"https://ctz45562.github.io/2020/10/02/10.2%E9%97%B2%E6%89%AF/","excerpt":"死人更博了，太晦气了（","text":"死人更博了，太晦气了（ 尝试白嫖「dual existence」的时候从本地音乐里翻到了这首歌，很合我口味，但是不记得什么时候下的这首歌。 也许是当初听到这首歌时出了些事故来不及处理，于是下载下来希望未来哪天意外翻到的时候能想起来。 也可能仅仅是网易云在我听的时候自动保存的，只是我的口味变了。 暑假之后我立下flag，如果再有超过两天的假期我就更博。没想到这么快灵验了。 国庆整整两天假，我已经不敢想象长达两天的假期有多爽了。 从头说起吧。 暑假过得还算舒服，虽然一直在学校里补课，但是毕竟是假期，管理还是很松的。而且诸如捕捉昆虫、写蛤富翁这类娱乐项目也增添不少乐趣。 然后就开始高三生活了。 真的很累。 早读时间逐渐提前，晚自习和早读无缝接轨指日可待。 听写、测试接踵而至。前一秒以「人类在25分钟里能背过多少页维克多？」为主题的英语听写刚结束，下一秒马上要准备以「人类在不背的情况下能yy出什么阴间东西？」为主题的生物听写。 更不必说写不完的作业。妈妈再也不用担心我上课走神了，不想听课，那就偷着写作业，今天的，昨天的，甚至是前天的。我甚至没有时间走神。 有时候会觉得自己像个木偶，被拽着行动，尤其是写作业的时候，感觉每一道做完的题、每一个算出来的数都很陌生，好像只是在我无意识间做出来的。 我心态一直不太好，只是我一直藏在心里。 开学后第一个大周是一个导火索，我的心态、形象、世界全崩塌了，直接请了四天的假，发生了很多事，心态才好了些。 但我怕这只是表象，我非常怕哪天突然会再发生一遍。 还是谈一谈我的传统艺能颓废吧。 刚开学的时候晚上回家写完作业就没事干了，随便逛逛b站。后来实在没啥意思干脆打lol，然而这样玩了几天感觉上课状态不好，很燥。最后终于恢复了老本行——补番。 结果过了几天我又开始打lol了。大周之后干脆卸了，专心补番。League of Legends，一年后再会。 pcr混得是风生水起，从暑假以来就一直比较欧。水吃池抱着试试看的态度抽了30连，然后出了。水黑池30连歪了纯，50连出了水黑。水猫剑20连出了，不过因为是三星概率翻倍，水又很多，加上白嫖的免费十连一共是抽了一井，最后十连出了xcw。 再加上期间拼的和歪的，余钻10w6只缺智、yls和水女仆，自我感觉十分良好，对未来充满希望。虽然根据欧非守恒定律，我马上就要吃井了。 上次会战本来想着高三没时间了，混一混好了。但还是经不住摸轴和rank的诱惑，最后混了个会里rank2. 提前开专确实对我有点影响，碎片啥的都没大刷，好得吃货早5x了。最后勉强整出了3x剑圣、4x铃铛和5x猫拳。 今天下午大碎钻冲了一波pjjc，终于挖完了，不容易啊。 聊一聊最近看的番剧吧。 先是重温了点兔，又补了几集「放学后海堤日记」，出乎我的意料，本来是冲着绅士pv追的，但现在看来从作画到人设再到oped制作都很优秀。 看了几集「刀剑神域 爱丽丝篇 异界战争 终章」，其实点进去看到4.8分和一些长评就感觉不太好了，本来觉得终章的前半段还是可以的，但是后半段实在看不下去了，我真的看不出这些剧情的意义所在，我也不做过多评价了，告辞。 补完了「某科学的超电磁炮T」。挺好，作画正常，剧情虽然感觉略有瑕疵，但整体上都很吸引人的。还有就是我爱女王啊啊啊啊啊啊啊啊—— 开始看「进击的巨人」了。只看了前几集我就认为名副其实了，这种粗线条的画风，放到今天依然是一流的；这个剧情，悲怆而真实，正是一首人类的史诗；这个音乐，词穷了，只能再感叹一遍泽野弘之nb啊。不过一开始还是觉得艾伦的设定还是有点别扭，毕竟我不是很喜欢主角有异于常人的特殊能力。不过再想想这样设置挺合理的，毕竟只靠一个普通人的力量抗衡巨人太扯淡了。 最后我想扯点关于世界的思考。 我特别能胡思乱想，有时候就会有一些关于世界的乱七八糟的想法。 1 前两天看了个毕导的视频时间之矢与自由意志，关于自由意志讲了这样一种观念（可能概括不准，大概是这个意思）： 假如你抛出一枚硬币，如果我知道你对硬币的力、硬币受到的阻力等等一系列物理量，我就能算出最终硬币落地时是正面朝上还是反面朝上，这一切已经由所有的物理量决定好了。 但是人呢？人不过是由无数多的原子构成的，如果我知道你的每个原子的各种物理量，只要我算力足够强，我可以算出你接下来所有的行动。换言之，人的行动和硬币的正反是一样的，是早已经由这无数的物理量决定了的。 由此看来，人真的有自我意识吗？我们觉得自己是有意识的，是有自由意志的，但既然这一切都已经被决定了，控制人的行动的，究竟是我们所谓的自由意志，还是这宇宙的基本规律呢？ 这和我某个设想很像，于是我这两天就老琢磨这个事。我觉得这个观点很深刻，也很恐怖。 2 有一个悖论叫「色盲悖论」。 大概说的是，有一个人从出生起就有种奇怪的色盲症，他和别人看到同一种颜色时，叫法是一样的，但是实际上在大脑内看到的颜色是不一样的。比如他看到的天空是绿色的，但他管这种绿色叫蓝色；他看到的小草是蓝色的，但他管这种蓝色叫绿色。怎么让他知道他看到的颜色和别人不一样？ 我从这个问题联想到：人是不能与其他人交换意识的。 我在这个世界上只能感受自己的意识。 再往深处想，既然我只能确定我是有意识的，是不是有可能其实这个世界完全是我自己的精神世界，只有我自己拥有意识，而其他人只是我精神世界创造的东西？毕竟我没有任何方法确认别人是否真的有自我意识。 这个观点好像在「凉宫春日的忧郁」里提到过。 3 宇宙的规律法则为什么会如此完善？ 举个最简单的例子，人的每个细胞，细胞内外的协调合作如此完美，组成的这样繁杂精密的系统，告诉我这是自然选择进化而来的，我实在是难以相信。 人类已经发现了夸克，那么夸克再往下分，小到不能再分，也就是宇宙最基本的单位，它的本质是什么？它是怎么被创造出来的？ 我一直不完全反对七都的箱庭理论，我觉得，这个世界存在箱庭的可能性，宇宙及其法则是被创造出来的，我们只是被观测的对象。 我从不否认那些天马行空的想法，因为包括我在内的所有人，都只能凭借这个世界的规律思考，我们可能真的处于底层，而无法想象上层的世界。 也许真的只是一坨原子在驱动我写了这些东西，也许这个世界真的只是我的意识所创造的，也许现在正有个观测者正在嘲讽我现在的想法或者做出凭借人类认知无法想象的事情。 但归根到底，我也只是一个愚昧无知的人类，无法理解世界的本质，又何必想这么多呢~","categories":[{"name":"日常","slug":"日常","permalink":"https://ctz45562.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"UOJ #188.【UR #13】Sanrd","slug":"UOJ-188-【UR-13】Sanrd","date":"2020-07-19T03:12:39.000Z","updated":"2020-07-21T07:11:50.000Z","comments":true,"path":"2020/07/19/UOJ-188-【UR-13】Sanrd/","link":"","permalink":"https://ctz45562.github.io/2020/07/19/UOJ-188-%E3%80%90UR-13%E3%80%91Sanrd/","excerpt":"传送门 第一次在uoj上交题？","text":"传送门 第一次在uoj上交题？ 把题面翻译成人话：求$[l,r]$中所有数的可重次大质因子之和。 设$i$的次大质因子为$f(i)$。$f(i)$虽然不积性，但还是可以考虑$min\\_25$筛的思想。 设$S(n,k)=\\sum\\limits_{i=1}^n[minp(i)&gt;P_k]f(i)$，答案就是$S(r,0)-S(l-1,0)$。 因为质数和$1$的$f$都是$0$，所以只需要考虑合数的贡献，枚举最小质因子及其次数$P_i^j$。$P_i^j$有两种贡献： $P_i$就是次小质因子：此时因子中除了$P_i^j$，就只会有一个大于$P_i$的质数$P_x$且$P_i^jP_x\\le n$，也就是$\\max\\left\\{g_0(\\dfrac{n}{P_i^j},+\\infty)-i,0\\right\\}$。而如果$j&gt;1$，还要算上$P_i^j$自己。这部分贡献就是$P_i\\times\\left(\\max\\left\\{g_0(\\dfrac{n}{P_i^j},+\\infty)-i,0\\right\\}+[j&gt;1]\\right)$ $P_i$不是次小质因子：这部分就和$P_i$没啥关系了，因为最小质因子为$P_i^j$，次小质因子一定在上面，贡献为$S(\\dfrac{n}{P_i^j},i)$ 综上，$S(n,k)=\\sum\\limits_{i&gt;k,P_i^2\\le n,P_i^j\\le n}P_i\\times\\left(\\max\\left\\{g_0(\\dfrac{n}{P_i^j},+\\infty)-i,0\\right\\}+[j&gt;1]\\right)+S(\\dfrac{n}{P_i^j},i)$ 而且因为只需要考虑合数，当$P_k^2&gt;n$的时候就可以返回$0$了。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 400005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } template&lt;typename T&gt; inline T read(){ T x=0; int y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } long long n,g[maxn&lt;&lt;1]; int prime[maxn&gt;&gt;2],sq,cnt; bool is[maxn]; inline int id(long long x){return x&lt;=sq?x:sq+n/x;} long long S(long long n,int k){ if(1ll*prime[k]*prime[k]&gt;n)return 0; long long ans=0; for(register int i=k+1;i&lt;=cnt&amp;&amp;1ll*prime[i]*prime[i]&lt;=n;++i){ long long base=prime[i]; for(register int j=1;base&lt;=n;++j,base*=prime[i]) ans+=(max(g[id(n/base)]-i,0ll)+(j&gt;1))*prime[i]+S(n/base,i); } return ans; } long long solve(long long N){ n=N,sq=sqrt(n); for(long long l=1;l&lt;=n;l=n/(n/l)+1)g[id(n/l)]=n/l-1; for(register int i=1;i&lt;=cnt;++i) for(long long l=1;1ll*prime[i]*prime[i]&lt;=n/l;l=n/(n/l)+1){ int k=id(n/l); g[k]-=g[id(n/l/prime[i])]-i+1; } return S(n,0); } int main(){ for(register int i=2;i&lt;maxn;++i){ if(!is[i])prime[++cnt]=i; for(register int j=1;j&lt;=cnt&amp;&amp;i*prime[j]&lt;maxn;++j){ is[i*prime[j]]=1; if(i%prime[j]==0)break; } } long long l=read&lt;long long&gt;(),r=read&lt;long long&gt;(); printf(&quot;%lld\\n&quot;,solve(r)-solve(l-1)); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"min_25筛","slug":"min-25筛","permalink":"https://ctz45562.github.io/tags/min-25%E7%AD%9B/"}]},{"title":"min_25筛学习笔记","slug":"min-25筛学习笔记","date":"2020-07-16T07:52:53.000Z","updated":"2020-09-15T03:32:52.000Z","comments":true,"path":"2020/07/16/min-25筛学习笔记/","link":"","permalink":"https://ctz45562.github.io/2020/07/16/min-25%E7%AD%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"前几天看贴吧才知道弃坑不久后朝奈就觉醒了。 于是回去蝗了一波顺便抽了个爱心厨娘（真香）","text":"前几天看贴吧才知道弃坑不久后朝奈就觉醒了。 于是回去蝗了一波顺便抽了个爱心厨娘（真香） 前言$min\\_25$筛是一种在亚线性复杂度内计算积性函数单个前缀和的算法。 我也不知道为什么要学这个。反正NOI就是去玩玩，所以就随便学点算法玩玩吧。 抄袭来源 https://www.cnblogs.com/cjyyb/p/9185093.html https://www.luogu.com.cn/problem/solution/P5325 https://challestend.github.io/min-25-sieve-learning-notes/ #define$P$：质数集合 $P_i$：第$i$小的质数。特别的，$P_0=0$ $p$：若未特别说明，$p$均代表质数 $minp(i)$：$i$的最小质因子 min_25筛适用条件 $f(x)$为积性函数 $f(p)$可以用关于$p$的简单多项式表示 $f(p^k)$能快速算出 模板先绕个弯，不妨设$S(n,k)=\\sum\\limits_{i=1}^n[minp(i)&gt;P_k]f(i)$ 答案就是$S(n,0)+1$（$+1$是因为$1$没有最小质因子，不会被算进$S(n,0)$里，要额外加上） 考虑怎么求$S(n,k)$。分个类，分别求质数和合数的贡献： 质数部分因为$minp(p)=p$，所以$\\sum\\limits_{i=1}^n[i\\in P\\land minp(i)&gt;P_k]f(i)=\\sum\\limits_{i=1}^n[i\\in P]f(i)-\\sum\\limits_{i=1}^kf(P_i)$ 光看前面的$\\sum\\limits_{i=1}^n[i\\in P]f(i)$，后面的$\\sum\\limits_{i=1}^kf(P_i)$最后会提到可以预处理。 根据$min\\_25$筛的适用条件：$f(p)$可以用关于$p$的简单多项式表示。如果我们计算出$\\sum\\limits_{i=1}^n[i\\in P]i^k$，就能用$\\sum\\limits_{k=0}^\\infty F_k\\sum\\limits_{i=1}^n[i\\in P]i^k$得出$f(i)$的和（其中，$f(p)=\\sum\\limits_{k=0}^\\infty F_kp^k$）。 本题中$f(p)=p^2-p$，符合条件。接下来只需要考虑怎么计算$\\sum\\limits_{i=1}^n[i\\in P]i^k$ 再绕个弯，不妨设$g_k(n,j)=\\sum\\limits_{i=1}^n[i\\in P\\lor minp(i)&gt;P_j]i^k$ 初始值$g_k(n,0)=\\left(\\sum\\limits_{i=1}^ni^k\\right)-1$（$-1$是因为这两个条件$1$都不符合） 考虑转移：$g_k(n,j)$相较于$g_k(n,j-1)$，去掉了那些最小质因子等于$P_j$且不为质数的数。 如果$P_j^2&gt;n$，显然不会有合数的最小质因子等于$P_j$，于是$g_k(n,j)=g_k(n,j-1)$ 如果$P_j^2\\le n$，把最小质因子$P_j$提出来，有$P_j^k$的贡献，让剩下的数最小质因子不小于$P_j$即可，即$g_k\\left(\\dfrac{n}{P_j},j-1\\right)$。但是由于$g_k$的定义中有一条$i\\in P$，小于$P_j$的质数不应该被算上，所以要减去$g_k(P_{j-1},j-1)$，显然$g_k(P_{j-1},j-1)=\\sum\\limits_{i=1}^{j-1}P_i^k$ 综上，$g_k(n,j)=\\begin{cases}g_k(n,j-1)&amp;P_j^2&gt;n\\\\g_k(n,j-1)-P_j^k\\left(g_k\\left(\\dfrac{n}{P_j},j-1\\right)-\\sum\\limits_{i=1}^{j-1}P_i^k\\right)&amp;P_j^2\\le n\\end{cases}$ 而$g_k(n,+\\infty)=\\sum\\limits_{i=1}^n[i\\in P]i^k$，即为我们最初想要的答案。当然这个转移需要优化： 由于只有$P_j^2\\le n$时会进行转移，所以只需要用到不大于$\\sqrt n$的质数，$\\sum\\limits_{i=1}^jP_i^k$也可以预处理了。 注意到整个转移中的$n$只出现过$\\left\\lfloor\\dfrac{n}{i}\\right\\rfloor$的形式，根据整除分块的性质这个值只有$O(\\sqrt n)$个。利用一个$trick$：$i\\le\\sqrt n$时存到下标$i$里；$i&gt;\\sqrt n$时存到下标$\\sqrt n+\\dfrac{n}{i}$里。同时我们只想知道$g_k(n,+\\infty)$，第二维可以滚掉。这样时空都能被大大优化。 至此，质数部分就计算完了，复杂度是$O(\\dfrac{n^{\\frac{3}{4}}}{\\log n})$（不会证） 合数部分类比上文$g_k$的转移，枚举最小质因子，假设为$P_i$。因为有$minp(i)&gt;P_k$的限制，所以要从第$k+1$个质数开始枚举。但不同于$g_k$的是，这不是完全积性函数，$f(P_i)$不能随便提出来，所以还要枚举其次数$j$，把$f(P_i^j)$整个提出来，这样就符合积性函数的性质了。 接下来要保证的就是剩下的数最小质因子大于$P_i$（注意，这里是把$P_i^j$整个提出来了，所以剩下的数里不能有$P_i$），也就是$S\\left(\\dfrac{n}{P_i^j},i\\right)$。不过这里有一个问题：如果$j&gt;1$，$f(P_i^j)$也应该被算进$S(n,k)$里（$j=1$在质数部分算过了），也就是$f(P_i^j)\\times f(1)$。但是$S$并不会计算$1$的贡献，所以这里应该是$S\\left(\\dfrac{n}{P_i^j},i\\right)+[j&gt;1]$。 根据质数部分的经验，只有$P_i^2\\le n$时才会有贡献，所以还是只需要用到不大于$\\sqrt n$的质数。 于是我们得到了合数部分的贡献：$\\sum\\limits_{i&gt;k,P_i^2\\le n,P_i^j\\le n}f(P_i^j)\\left(S(\\dfrac{n}{P_i^j},i)+[j&gt;1]\\right)$ 根据$min\\_25$筛的条件，$f(P_i^j)$可以快速计算，或者能从$P_i$递推到$P_i^j$，这部分就能快速递归计算了。 整合把式子的完全体写出来： $S(n,k)=\\sum\\limits_{k=0}^\\infty F_kg_k(n,+\\infty)-\\sum\\limits_{i=1}^kf(P_i)+\\sum\\limits_{i&gt;k,P_i^2\\le n,P_i^j\\le n}f(P_i^j)\\left(S(\\dfrac{n}{P_i^j},i)+[j&gt;1]\\right)$ 自始至终$n$都只取到过$\\left\\lfloor\\dfrac{n}{i}\\right\\rfloor$，$g_k$也恰好只计算了$\\left\\lfloor\\dfrac{n}{i}\\right\\rfloor$处的值；而由于只用到了$\\sqrt n$以内的质数，$k$不会很大，$\\sum\\limits_{i=1}^kf(P_i)$也可以预处理了。这样这个式子就没有问题了。 复杂度是$O(\\dfrac{n^{\\frac{3}{4}}}{\\log n})$（不会证），甚至不用记忆化。 代码#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 100005 #define inf 0x3f3f3f3f const int mod = 1e9 + 7; const int inv2 = 500000004; const int inv6 = 166666668; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } template&lt;typename T&gt; inline T read(){ T x=0; int y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } long long n; int f[maxn],g[2][maxn&lt;&lt;1],prime[maxn&gt;&gt;2],pw[2][maxn],cnt,sq; bool is[maxn]; inline int qm(int x){return x&gt;=mod?x-mod:x;} inline int id(long long x){return x&gt;sq?sq+n/x:x;} int S(long long N,int k){ if(prime[k]&gt;=N)return 0; int ans=qm(qm(g[1][id(N)]+mod-g[0][id(N)])+mod-f[k]); for(register int i=k+1;i&lt;=cnt&amp;&amp;1ll*prime[i]*prime[i]&lt;=N;++i) for(long long j=prime[i];j&lt;=N;j*=prime[i]){ int b=j%mod; ans=qm(ans+1ll*b*(b-1)%mod*qm(S(N/j,i)+(j&gt;prime[i]))%mod); } return ans; } int main(){ for(register int i=2;i&lt;maxn;++i){ if(!is[i])prime[++cnt]=i,pw[0][cnt]=qm(pw[0][cnt-1]+i),pw[1][cnt]=qm(pw[1][cnt-1]+1ll*i*i%mod),f[cnt]=qm(f[cnt-1]+1ll*i*(i-1)%mod); for(register int j=1;j&lt;=cnt&amp;&amp;i*prime[j]&lt;maxn;++j){ is[i*prime[j]]=1; if(i%prime[j]==0)break; } } n=read&lt;long long&gt;(),sq=sqrt(n); for(long long l=1,r;l&lt;=n;l=n/(n/l)+1){ int x=n/l%mod,k=id(n/l); g[0][k]=qm(1ll*x*(x+1)%mod*inv2%mod+mod-1); g[1][k]=qm(1ll*x*(x+1)%mod*((x&lt;&lt;1)+1)%mod*inv6%mod+mod-1); } for(register int i=1;i&lt;=cnt;++i) for(long long l=1,r;l&lt;=n&amp;&amp;1ll*prime[i]*prime[i]&lt;=n/l;l=n/(n/l)+1){ int k=id(n/l); g[0][k]=qm(g[0][k]+mod-1ll*prime[i]*qm(g[0][id(n/l/prime[i])]+mod-pw[0][i-1])%mod); g[1][k]=qm(g[1][k]+mod-1ll*prime[i]*prime[i]%mod*qm(g[1][id(n/l/prime[i])]+mod-pw[1][i-1])%mod); } printf(&quot;%d\\n&quot;,qm(S(n,0)+1)); } 水题【模板】杜教筛根据小学二年级数学： $\\varphi(p)=p-1,\\varphi(p^k)=p^k-p^{k-1}$ $\\mu(p)=-1,\\mu(p^k)=0$ 这样就可以做了。而且由于$\\mu(p^k)=0$，筛$\\mu$的合数部分甚至不用枚举$P_i$的指数。 简单的函数$f(p^k)$表达式已经明确告诉你了，只需要考虑$f(p)=p\\oplus 1$的表示。而$p$为偶数时$f(p)=p+1$，否则$f(p)=p-1$。 因为所有的质数里只有$2$是偶数，所以可以得到： $f(p)=\\begin{cases}3&amp;p=2\\\\p-1&amp;ohterwise\\end{cases}$ 所以： $\\sum\\limits_{i=1}^n[i\\in P]f(i)=\\begin{cases}0&amp;n&lt;2\\\\g_1(n,+\\infty)-g_0(n,+\\infty)+2&amp;n\\ge2\\end{cases}$ 梦中的数论显然答案是$\\sum\\limits_{i=1}^nC_{d(i)}^2$，$d(i)$为$i$约数个数。 而$C_{d(i)}^2=\\dfrac{d(i)(d(i)-1)}{2}=\\dfrac{d^2(i)-d(i)}{2}$不积性，但是$d^2(i)$和$d(i)$是积性的。 $d(p^k)=k+1$，筛出$d^2(i)$和$d(i)$作差除以$2$即可。 DIVCNTK如果你跑去spoj看原题的话，其实只有$n\\le 10^4$时$T\\le 10^4$，而$n=10^{10}$时$T\\le 5$。 然后$d(i^k)$积性，$d((p^c)^k)=kc+1$，没了。 三倍经验：DIVCNT2 DIVCNT3 有点卡常。 Sanrd题解","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ctz45562.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"min_25筛","slug":"min-25筛","permalink":"https://ctz45562.github.io/tags/min-25%E7%AD%9B/"}]},{"title":"7.10闲扯","slug":"7.10闲扯","date":"2020-07-10T06:25:09.000Z","updated":"2021-06-18T04:35:11.000Z","comments":true,"path":"2020/07/10/7.10闲扯/","link":"","permalink":"https://ctz45562.github.io/2020/07/10/7.10%E9%97%B2%E6%89%AF/","excerpt":"省选之后好久没更博（其实也就20天），好像我已经从OIer名单上被抹杀了一样（其实也差不多是退役了），突然想扯点什么证明一下我还活着。","text":"省选之后好久没更博（其实也就20天），好像我已经从OIer名单上被抹杀了一样（其实也差不多是退役了），突然想扯点什么证明一下我还活着。 说点啥呢，扯一扯我最近都在干啥吧。 省选前已经看淡了（我对进入省队的渴望却渐渐沉了下来），省选排名出来后内心一直挺平静的。 22名，能买D，但从现实出发意义不大。 我和asuldb都有买D的机会。asuldb因为和省队失之交臂很难受。 我们一直不能决定要不要买，mars甚至专门给我们放假和家长商量。 想了想我作为OIer，能去一次NOI，OI生涯就没有遗憾了。再一个也算是满足Tian-Xing的期望（好吧，我承认D和正式队员相差很大）。但是我还是清楚形势的，只是打算去NOI玩玩，不打算投入多少时间准备了。 这之后我就一直在补课，第一次体验全天上文化课。以前我还觉得要是学一天文化课去不了机房岂不是要疯。现在看来文化课也挺快乐的。 夏天苍蝇太多了。 还记得去年暑假补课时，我用生物书活捉了一直绿苍蝇被众人与水池中玩弄致死。 某个晚自习，我在108教室活捉了三只苍蝇，分别命名为别西卜、特朗普和普朗克，可惜它们住在我专门制作的房车里都没能活到下晚自习。我很期待即将到来的普京、凝胶色谱、特征光谱、线状谱、太阳光谱和雷普。 某天我把午饭喝完的豆浆（插着吸管）放在生物竞赛室的桌子上，一中午后一只苍蝇钻进去出不来了。后来asuldb用他的豆浆也捕获了两只苍蝇。 通过这段时间对苍蝇的观察，对苍蝇产生了浓厚的兴趣。 放假时特意去查阅了苍蝇的相关资料。整理一下笔记： 飞檐走壁能力EX 雌蝇能把雄蝇的精液贮藏在体内，一辈子都能用它产卵 边吃边吐边拉，几秒吃完一顿饭 特朗普和我去年暑假抓的那只苍蝇都很逊，是中华绿蝇，中国特有；别西卜和普朗克则是最常见的家蝇 主席某天教我们玩一种纸上游戏，姑且称之为“海战”。 双方每个人有一片10*10的海域，以及相同长度和数量的1*n的船，在自己的海域摆放这些船，轮流炮击一个位置，被炮击的人要报出是否有船被命中，船先被打没的输。 联想到了神代梦华谭。 后来我们把这个游戏改进了一下，引入了航母、战列舰等带有技能的船，之后还加入了角色技能，没事就玩。 其实还有很多补课期间事，懒得说了。 之后就是9天的高考假了。作为半退役选手，loli和mars都限制不了我们，成为了最快乐的人。 不过还是要看录课写作业，然而毕竟是在家，效率确实一般，所以我现在在写这玩意。 其实是可以继续写日记的，但是并没有多少空闲时间所以弃了。 随着7月6号服务器的开放，pcr迎来了新时代。然而花了221抽才出。母5花了一小时jjc登顶。我们一群抽了yly在前排集体降智，双充yly防守只会用yly硬怼，完全忘了充电扇的存在。 真正受益者其实是扇子，那天我们场几乎全都是yly防守，直到现在也是。 打算趁这个假期热热身把lol铂金晋级赛打完。 匹配一直在用赛娜混。后来偶然玩了把丛刃卡莎，真tm猛。以前我带强攻前期就特难受，现在有了丛刃前期嘎嘎地。于是转行玩卡莎去了。 因为海战重温了神代梦华谭，不出意料没更过新卡。 我都高三了怎么还这么颓啊啊啊啊啊啊啊啊啊啊啊 算了就扯这么多吧，学生物去了。","categories":[{"name":"日常","slug":"日常","permalink":"https://ctz45562.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"SDOI2020退役游记","slug":"SDOI2020退役游记","date":"2020-06-21T10:01:30.000Z","updated":"2021-07-19T09:15:39.139Z","comments":true,"path":"2020/06/21/SDOI2020退役游记/","link":"","permalink":"https://ctz45562.github.io/2020/06/21/SDOI2020%E9%80%80%E5%BD%B9%E6%B8%B8%E8%AE%B0/","excerpt":"结束了。 开始了。","text":"结束了。 开始了。 Day -??生病回家了。欲仙欲死，以为去不了省选了。 Day 0晚上开始翻自己的博客。感觉自己的水平大不如从前，原来我曾经还能切掉这些题。又发现多项式全家桶忘干净了，反正生成函数也忘干净了，干脆只背了遍NTT板子。 翻到去年6月没干劲了，颓到10点。 翻来覆去睡不着。躺了一会鼻子破了，起来消毒。又躺了一会嗓子痒得难受，起来含了片金嗓子。又双躺了一会感觉非常热，一直在出汗，折腾到不知道几点睡着的。 Day 1困。喝了杯咖啡。 恶心，一点胃口都没有，想起来asuldb在重要比赛的早晨也没胃口，大概就是这种感觉吧。 在本校考，亏了。 时隔不知道多少年终于见到了活的成爷，整个人都大了一圈。但我怀疑是假的，因为这个成爷话很多。 很巧的是zhuoer和我坐同一张桌子。 考前打了个SA和SAM求本质不同子串，把对拍打好两个拍了起来。lct板子写了一半没时间了。找了找windows自带游戏但是并没有。 监考老师写密码的时候q写得跟9完全一样。密码我也没看出来有啥意义。 T1看起来很可做，但是$2\\times 10^6$的数据范围而且不开O2看起来又不太可做。想了个$\\log^2$的二分+树状数组，觉得过60分的$2\\times 10^5$不太稳，树状数组换了个分块前缀和，实际上效率并没有什么差别，$1s$左右。又搞了个$\\log$的线段树二分，写出来还没编译，浏览了一下代码，一看就过不去，60分跑路了。 T2瞎化式子化不动，打了$n\\le1000$和$m=0$的40分跑了，可惜并没有想到$m\\le5$的矩乘和$x=1$的第二类斯特林数。 T3题意感觉有歧义。 在此基础上，两人还要求购买到的礼品数尽可能多。 S没有超集符合条件（极大集合） S是所有符合条件的集合中最大的（最大集合） 纠结了很久还是按后者处理的。因为这个没去想$m\\le2$的点。 打了个搜，结果没开unsigned long long。 期望100+?分。水平确实是下降了很多。 真的是暴力大赛，除了杜爷切了T2貌似没人切题。 下午和晚上就是颓颓颓。 Day 2又喝了杯咖啡。 这次和Tian-Xing同一张桌子。瞥见Tian-Xing在玩国际象棋，去c盘搜索搜出来了，顺便把扫雷搜了出来。 昨天没串和树，于是还是先打了SA、SAM和lct。 冲着打满暴力来的，然而三道题看起来都挺可做的，感觉这两天的题被调换了。 T1一开始没啥思路，先打了个全排列去看T2。想了一会链和$v_i=1$，一直被卡在全局加1全局异或和上（是我傻了，没想到trie），最后10分暴力跑路。 T3打了个搜，打了个基环树，$w_i$相等推一下发现就是个矩阵树定理，但是我好久没用已经忘了辗转相除法的高斯消元了。。。 研究了一会还是拼出了高斯消元，拍了一下WA了。以为是自己yy的高斯消元挂了，然后为了验证猜的行列式结论写了个暴力求行列式的值，结果写挂了。手忙脚乱间改对了暴力求行列式，高消没问题，发现是矩阵树定理挂了，写成了邻接矩阵加上度数矩阵。拍了一会没问题50分跑了。此时已经11:40了。 回去搞T1。数据范围明显是状压，搞了个$O(m^22^m)$的状压$DP$想拿60分，这复杂度有点高还不开O2，$1.6s$有点虚，试图剪枝优化，结果跑的更慢了，最后还是优化了常数，稳定在$1.5s$，又算了遍复杂度其实是$O(m^22^{m-1})$的，虽然还是有点虚但也没时间了。剩了20分钟上虚拟机试编译，检查文件，最后玩扫雷。 期望120分，虽然很普通但也是尽力了。 后记本来就是打算尽力去考，进了队就再学（颓）一段时间，没进也不留遗憾，滚回去学文化课。 这个分数平平无奇，csp分数也是，到底何去何从只能听天由命。 感觉都看开了，回来的时候真的是没有感觉。。。其实是有一点难受的，两年的OI生涯就这么突然结束了。 就这样吧。有缘高考再会。 后后记rank22，可以苟D了。 然而看形势的话，买D没什么卵用了。况且我本来是决定如果能买D也不买。 可是我作为一个OIer，要是此生能去一次NOI，也就不留遗憾了。 这是一个OIer最后的苟延残喘。","categories":[{"name":"日常","slug":"日常","permalink":"https://ctz45562.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://ctz45562.github.io/tags/OI/"},{"name":"游记","slug":"游记","permalink":"https://ctz45562.github.io/tags/%E6%B8%B8%E8%AE%B0/"}]},{"title":"OI走马灯","slug":"OI走马灯","date":"2020-06-15T01:35:43.000Z","updated":"2021-07-19T09:25:30.024Z","comments":true,"path":"2020/06/15/OI走马灯/","link":"","permalink":"https://ctz45562.github.io/2020/06/15/OI%E8%B5%B0%E9%A9%AC%E7%81%AF/","excerpt":"这是某个不知名的OIer的回忆录。 有一种说法，人死前会将一生的经历在脑中快速回放一遍，称之为「人生的走马灯」 那这就是「OI的走马灯」了。","text":"这是某个不知名的OIer的回忆录。 有一种说法，人死前会将一生的经历在脑中快速回放一遍，称之为「人生的走马灯」 那这就是「OI的走马灯」了。 尽管这个OIer还没有退役，但是他的心态相比去年的这个时候，发生了一点微妙的变化，促使他2月开始就动笔了。 不，可能不仅仅是一点微妙的变化吧。 Ⅰ我第一次对OI产生兴趣，是八年级的暑假。 确切来说，我那时候并不了解OI，所以应该是对信息行业产生兴趣。 我的入宅番「小林家的龙女仆」，带我了解了程序猿的生活。（或者说是一般白领的生活） 早出晚归，周末休息，薪水尚可。 我发现这就是我向往的生活，默默无闻、一成不变的日常。没有人会注意到我，我能享受独来独往的快乐。 于是我梦想着当一名程序猿，而且不是引人注目的管理者，一定是底层的码农。与之萌生的想法就是高中加入信息竞赛了。 Ⅱ中考结束，迎来了期待已久的暑假。 我从来都不是个勤奋的人——这话说的可能有点轻了，从初三开始，我的心思从来就不在学习上。 这个时候我对OI还完全不了解，无论是学习内容，还是时间的安排。所以我已经做好了享受假期的准备。 颓了半个月后去高中报道。填了一张表，有一栏问我有没有意愿参加竞赛。我果断填了信息。 之后开了个大会，loli也去发言了，就是那种给信息小组招生的发言。尽管现在会认为这就是忽悠，但是对当时的我起了很大的鼓舞作用。是的，我被八皇后问题骗走了。 loli接着说出了报名的三个条件，数学成绩、物理成绩、数理化成绩。我中考总分不低，全校前50，然而各科成绩都很平均，一个都不满足。 算了，也算是保全了暑假。大学再学也不迟。 报道后很快竞赛学习开始了。到了第三天，loli突然给我家长打电话，问我有没有意愿参加。 我妈说可能是看我在报道的表上填了信息，中考总分也不低，所以想让你试一试。（我很久之后才得知是我妈看我想学主动找loli说的） 当时我正在补番，相比惊讶，我更多的是犹豫。如果去了，假期就没了。 我问每天的学习时间，得到了一个最差的回答：早上7点到晚上10点。 我沉默了。 又补了一个小时的番，我咬了咬牙，“去。” Ⅲ我们这一届信息组是按档次来分的。自主招生一档优惠4月来，二档优惠中考完来。而我们这些7月来的被称为三档。 平时在使用的机房有两个。我们机房里大部分都是三档的，当时人还挺多的，学长和一、二档的都在隔壁机房。 刚一来被分到了zhuoer旁边，和其他的三档里的都挺远的。 zhuoer也是个宅，我俩渐渐熟了起来。 7月基本上都是在OpenJudge上做题，8月开始入驻洛谷。 当然我的颓废之心还未消退，所以挤出所有空闲时间颓废。包括中午不休息，晚上12点睡。多出来的时间我能补至少6集番。 熬了一个月撑不住了，偶然在超市里发现了咖啡，养成了喝咖啡的习惯。 当时的我并不知道11月就要比赛了，所以整个暑假过得比较休闲吧，甚至写过2个游戏。 loli组织过几次测试，无非搜索模拟专场。像这种套路化的、具体的、简单易懂的算法，我能比别人更快地掌握。所以在测试中成绩还是不错的，大概是有吸引到loli注意的，而我也是有点飘，觉得自己或许很有天赋。 转眼间暑假就这么过去了。开学后的生活我没有适应，学习OI的时间大幅减少，只有音乐、信息课和晚自习的一些时间能来机房，而文化课我还是和初中一样有所抵触。 我依然不午休，晚上12点睡，有时候甚至熬夜到1、2点。 当时喝咖啡一事我印象是很深的。是那种雀巢的纯咖啡，18块9一盒，一盒20包，每包3g左右，配料只有速溶咖啡和咖啡豆提取物。用少量开水泡开，一口闷，早上一包，下午一包。有时候甚至生吃咖啡，把咖啡到嘴里用水冲下去。虽然精神上还是浑浑噩噩的，但起码不会上课打瞌睡了。（我还是劝告一句，这样喝纯属作死，但我当时只是为了能颓废而不择手段罢了） 9月就这么过去了，无论是精神还是肉体我都不好受，又怀念起无忧无虑、拥有朋友的初中生活了。。。 Ⅳ国庆信息组只放了一天假，不过对当时的我来说，只要是在机房里学OI，不放假也行。 马上开学的时候，loli突然说要停课。我第一次知道为了竞赛甚至可以停掉文化课，也意识到了临近比赛的危机感。 一开始先停政史地，后来全停。以前学搜索的时候总是说数据范围再大点DP能解决，于是停课期间开刷DP。当时我做题没啥章法，随便从洛谷上捡题做。 快比赛的时候学了线段树，埋下伏笔。 （包括后面的比赛）比赛过程不详细说了，游记里有。 我是三档里唯一一个拿省一的，我更是沾沾自喜。虽然现在想想，我不过是运气好，碰巧做过原题、碰巧数据水没卡掉暴力而已。 回来后补课，去不了机房，我怀着极大的自满之情顺着线段树继续把数据结构攻读完了，从此开了个大坑。 很快来到了月考，尽管政史地我压根没学，数理化也一般般，但是凭借着初中的底子拿了英语年级第六，再加上我们班实在太差，倒数的那种，所以班主任和英语老师对我大加赞赏。甚至英语老师说她做梦梦到我了。 那会儿算是我的第一个辉煌时刻了吧。本以为我会退役，现在都可以参加省选了。 Ⅴ寒假去郑州培训，也是我第一次出去培训。每天和Ciyang、zhuoer、阿潮取乐，颓到一两点。而且以我当时的水平课也不太能听懂。 寒假期间我们集体搬到了隔壁机房，左指挥右稳稳。受到这俩人的影响，再加上那时候做的题有点难度了，我开始写题解了。 很快我不满足于洛谷博客，于是开了我OI生涯最大的坑：搭建hexo博客。这东西太合我口味了，我是个注重于维护形象的人，不一定是什么好形象，但是对特定的人我就一定要表现出我想表现的、一成不变的形象。 高一下学期分班，我顺理成章进入了竞赛班，半天学文化课，半天学OI，我对此很满意。 一直到省选，我基本上都是在做数据结构，然而做的题都是偏模板，思维方面依然没有长进。同时写写题解，搭搭blog。 我的水平太低，一轮省选的结果并不理想，然而还是在D2力挽狂澜擦边进了二轮省选。 我深知二轮省选不可能翻盘，于是学了SA和SAM。那时候为了保证精力，除了中午趁吃饭补一集点兔我在家不再颓废。这确实很有成效，SA和SAM学习进展得都十分顺畅，也不像数据结构那样只会打板子，习题基本都能独立思考出来。 二轮省选的结果出乎意料。直接爬了三十多名，我也再次被loli大奶。然而我知道，我靠的还是运气，不过是签到成功加上未能卡掉的爆搜罢了。 我成为了loli的重点关注对象，这也是我的第二个辉煌时刻。 我必须有成就感的刺激才能学下去，失败只会让我停滞不前。因此这两次比赛给了我极大的动力学OI。 之后我开始中午留在机房，那时候我的博客开始使用sakura主题，所以中午的时间基本上都是在美化blog。 Ⅵ合格考之前高考要开始了。我们学校作为考场之一，高考这么正规严肃的事情，怎么可能不放假？然而loli做出了一个到现在我都认为不恰当的决定：高考期间不放假，偷偷溜进来学竞赛。 由于临近合格考，我对历史地理越来越担忧——从入学到现在我几乎就没上过。我确实是想放假颓废，但是我也想着手准备合格考，于是我们机房联合起来搞事，在放假当天下午，一个个地偷着跑路了（除了主席）。 loli难得生气一次，晚上就把他最看好的几个——鳖、慎老师和我（当时魏老师和块儿在省队集训）——叫回来，声称不回来就踢出信息组。 当晚下着大雨，鳖来之前还在和同学玩。他表示非常愤怒，让我一会不要说话，他要与loli理论一番。 结果他争论了一会，被loli说服了。我突然站了出来，和loli舌战，反复表达临近合格考，我要学文化课的意愿。总之就是死皮赖脸，loli不放假我就一直说。 结果最后也放假了，只不过要求我们既然对合格考这么担心，那么到合格考之前都不能再开电脑。 我并没有啥意见，正好我能静下心来准备合格考了。 这是我第一次反抗loli，凭着我的地位与自大，因此也是最后一次成功反抗loli。 合格考有惊无险，我回归了正常的竞赛学习生活。以前我总是执着于专精某种算法，现在会的东西太少了，所以开始拓宽算法知识面。 暑假还是留校学竞赛。然而我每天都会颓到很晚，我们宿舍甚至还比谁睡得晚，大部分时间都是我冠军，而且中午也不睡觉继续颓，所以白天都没有精神，难题做不动，经常颓废，越来越懒散——又是一个伏笔。 暑假末Tian-Xing找我问关于blog的事，成为了我俩交往的契机。 Ⅶ转眼间来到高二。我中午不待在机房了，开始了半走读的生活。 CSP即将到来，我不再学习新算法，还是继续老本行——刷DP。 暑假懒散的习惯延续了下来，我刷题干劲不足，颓废时间越来越长，至少晚上的时间一定是用来颓废的。 其中还有一个更重要的原因：我从二轮省选之后渐渐发现了我真实的学习能力。 我曾在洛谷日报上看到过一种算法：B*搜索。这简直太像我的学习能力了。 我能通过短时间的学习取得一个较好的成果，但是这就是极限了，继续学习成效是微乎其微的。或者说，我的下限很高，上限也很低。 更要命的是，我发现只擅长模仿，只会搬套路。我缺少OI最需要的创造性思维。 我在刷DP的时候尤其能体会到，难题做多了，我依然只会做同类型的难题。因为我是需要成就感的人，所以刷题也陷入死循环：难题不会做，而且由于学习能力的缺陷，看了题解既没成就感，我也还是做不出难题；简单题做出来没成就感，还是没干劲。 我越来越迷茫。 我可能不适合继续学下去了，我看不到希望；但我当时还是不想这么快投入文化课。 CSP的结果也进一步打击到了我。没有做出的D1T2，再次提醒了我智商不够；中规中矩的成绩，往前走前途渺茫，往后退又不甘心。 我最终还是留了下来。但CSP之后，我再无信心可言。 机房走了一大批人，高二剩下的只有我、asuldb、zhuoer、主席、魏老师、慎老师和不太常见的块儿和成爷。 补了一段时间的课后，因为冬令营再次停课。我这个成绩擦边进了WC，THUWC、PKUWC当然是去不了。 我开始照着任务单填坑，更广泛地学习算法。我没有能力深究算法，只有尽可能多学算法才能看见一丝希望。 然而一个没有干劲的人又能学进去多少呢？学一种算法，不过是敲了板子，做几道例题罢了。每天在学习与颓废之间游离。后台模拟器挂着七都，水blog，水知乎，水群，水图片。 一水水到了寒假，只有七天假期，然而Covid-19和强基计划来了。 Ⅷ疫情爆发，开始了家里蹲的生活。 由于WC还没举行，所以我们还是处于停课状态。 然而跟大部分OIer一样，一放假在家就毫无干劲，根本学不下去，况且本来我就缺乏干劲，所以从二月到四月，除了颓还是颓。 每天上午网上四处瞎逛，偶尔有兴致做一道题（一共做题量不到20道，而且几乎都是水题），下午打lol，晚上逛b站、看lol直播。后来上午都没事干了，开始搜刮单机游戏，日系rpg、95版pvz、王国保卫战、奥里与黑暗森林、Undertale。期间参加过两次培训和一些比赛，我也没有认真对待。 随着时间推移，我逐渐感到了恐慌。还有一年就高考了，我文化课还水当尿裤的。而压垮骆驼的最后一棵稻草——强基计划——随着病毒席卷而来。 从我学OI开始，jyb就一直在打压竞赛，降分政策越来越差。我对强基计划了解不多，但也明白这几乎是抹除OI了。 于是，与去年的相比，我的态度发生了完全的转变。现在的我只想补文化课，不想学OI了。哪怕给我一个省队名额，我也不愿去NOI了。 所以，我其实从1月开始就退役了。 我一直关注着其他人的学习情况，高二除了主席做题都不多，应该是在家的缘故。学弟们都很勤奋，我能看到Tian-Xing的做题量甚至比我在学校里的都多，就好像看到了曾经的自己。 Tian-Xing有时候会问我题，尽管很多时候我都答不上来吧。他后来知道我在家几乎不做题、也不打算争省队的事，还一直劝导我，认为我很有希望。 我很感谢Tian-Xing，还能对我抱有希望。但是很抱歉，我已经认清了自己的水平，我再也无法成为那个「渴望在OI方面寻找自我的人」了。 好在文化课已经在来的路上了，先是上早读，然后下午开始补课。虽说在家学习状态确实远不如学校，但开始补课后，我至少有在学习，不像之前那样不学无术了。然而，在此之后，除了打了场NOI-ONLINE，我几乎再没碰过OI。 五月初（那时高三已经开学了），loli想让我们回机房。asuldb、主席、ZUTTER_回去了。一方面是为了颓，另一方面是怕回去后在loli的管理下学不了文化课，我拒绝了。 更重要的是，几个月的时间里，我对OI的兴致达到了最低点。 五月中旬，开学了。 我怀着一种退役选手的心态返校，我的计划只有学文化课和消磨在机房的时间。 然而一颓就停不下来了，文化课也没怎么学，就这么混了一段时间。 Ⅸ五月底的时候突然就下了通知6月20号省选，只有3个星期了啊。 也许是最后一次停课了吧。和之前一样，我一直在颓废。 写人物列传，写日记，水贴吧水知乎，玩游戏，日子就这么过去了。 放了一个大周，还有12天省选了。 我清楚地记着回来的那天晚上，Tian-Xing突然很激动，整个晚上极力劝说我不要退役。 他否认我的自卑，说我的智商很高 他甚至认为我比杜爷和烜强。 他觉得我人很好，尤其是去年国庆培训和他住一块的时候 他说如果我退役他会非常难受。 我一直注重自己的形象，没想到会能有这么重视我的人。 我一直都很随心所欲，不愿接受别人的劝谏。但是因为这番话，我早读的时候向自己发问：我真的是我认为的那样智商不够吗？ 如果只是我太消极了，那我尚有余力可以一搏；如果确实是这样，我以往的比赛和模拟赛，不说优秀，总体上也是高于普通水平的。 我又想起来银牌扩增的事，而国赛也不会推迟很久，并不会耽误很多文化课。 也许我可以选择不放弃。 尽管我的水平大不如从前，最后我还是决定了，把已经遗忘的板子打一打，一切听天由命，省队能进就进，进不了就滚回去学文化课。但至少，如果给我一个省队名额，我现在已经能接受了。 Ⅹ世上本没有奇迹。 省选前一天晚上翻阅自己的博客，才发现我的水平退化得有多厉害。 省选既没有超常发挥，也没有丢分，最后还是和烜苟了个D。没敢放下文化课，而且D类一直没有消息。补完课以后，和以前一样，还是下午去机房学竞赛。 用了大概一星期的时间学了min_25筛，某个下午我写完了最后一道min_25筛的题解，loli突然对我们说，SD的D类可能没有了，让我们先回去学文化课，有消息了再去找我们。 于是又滚回去学文化课了。 Ⅺ最后的最后，我们也还是没有见到loli。文化课紧张的安排也逼迫我看淡了一切，去了还会耽误补课，挺好的。 Ⅻ我的OI生涯到底是什么时候算作结束了呢？ 也许是那天下午，loli告诉我们没有D类名额的那一刻 也许是SDOI2020走出考场的那一刻 也许是CSP2019走上大巴车的那一刻 又或许，我的OI生涯还未开始就已结束了 两年究竟有多长，究竟有多短 我趴在机房的桌子上、戴着耳机、披着校服睡过的一整个夏天的午觉 TIM上群里无数条聊天信息，无数次截图作表情包 第一篇NOIP2018游记到最后的SDOI2020退役游记 最初的洛谷博客到现在倾注大量心血的hexo-sakura博客，从第一篇动态逆序对的题解到现在已经过百的文章 一切的一切，都随着时间消逝在记忆中。 结束了？开始了？ 结束了。结束了。","categories":[{"name":"日常","slug":"日常","permalink":"https://ctz45562.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://ctz45562.github.io/tags/OI/"},{"name":"回忆录","slug":"回忆录","permalink":"https://ctz45562.github.io/tags/%E5%9B%9E%E5%BF%86%E5%BD%95/"}]},{"title":"LOJ#6517 「雅礼集训 2018 Day11」字符串","slug":"LOJ-6517-「雅礼集训-2018-Day11」字符串","date":"2020-06-12T12:10:41.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2020/06/12/LOJ-6517-「雅礼集训-2018-Day11」字符串/","link":"","permalink":"https://ctz45562.github.io/2020/06/12/LOJ-6517-%E3%80%8C%E9%9B%85%E7%A4%BC%E9%9B%86%E8%AE%AD-2018-Day11%E3%80%8D%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"传送门 阿块刚才突然问我有什么歌听，那就推一首我正在听的歌吧：終わりの世界から。大魔王麻枝准的歌，歌词直接讲了个故事。","text":"传送门 阿块刚才突然问我有什么歌听，那就推一首我正在听的歌吧：終わりの世界から。大魔王麻枝准的歌，歌词直接讲了个故事。 这种前缀关系一看就是上$trie$树了。 如果知道集合$G$，答案就随便求了。记$f(n)$为区间$[1,n]$的子区间个数，$f(n)=\\dfrac{n(n+1)}{2}$。把集合元素排序，用所有方案减去不合法方案就是答案，即$f(\\max\\{|s_i|\\})-\\sum\\limits_{i=1}^{n+1}f(a_i-a_{i-1}-1)$，其中$a_0=0,a_{n+1}=\\max\\{|s_i|\\}+1$ 求$G$有一个暴力做法：用set维护$G$，把每个前缀代表的节点加上对应串的权值，如果某个节点满足要求就把对应的$g_{len(S)}$扔进set里，扫一遍就是答案。 这个做法可以用莫队优化，但是移动一次端点要把整个串都算一遍，复杂度不对劲。套路地把每个字符都从串里拆出来，拼成一个新串，在新串上跑莫队。这样单次转移是set的$O(\\log n)$。 考虑去掉set的$\\log$。如果换成链表，可以$O(1)$删除，但难添加，于是可以上回滚莫队。复杂度$O(m\\sqrt {\\sum|s_i|})$。 第一次写只删除的回滚莫队，细节有点多，代码丑的一批： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 300005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } #define son(x,y) son[x][y] int son[maxn][26],len[maxn],pos[maxn],id[maxn],v[maxn],deep[maxn],g[maxn],be[maxn],a[maxn],sta[maxn][3],cnt=1,A,B,C,k,ml,top; long long ans[maxn]; bool vis[maxn],flag; char s[maxn]; struct query{ int l,r,id; bool operator &lt; (const query &amp;x)const{ if(be[l]!=be[x.l])return be[l]&lt;be[x.l]; return r&gt;x.r; } }q[maxn]; void insert(int l,int r){ int node=1; for(register int i=l;i&lt;=r;++i){ if(!son(node,s[i]-&#39;a&#39;))deep[son(node,s[i]-&#39;a&#39;)=++cnt]=deep[node]+1; node=son(node,s[i]-&#39;a&#39;),pos[i]=node; } } inline long long sec(int n){return 1ll*n*(n-1)&gt;&gt;1;} struct Mo{ int tax[maxn],pre[maxn],nex[maxn]; long long sum[maxn],ans; bool vis[maxn]; inline void erase(int x){ ans-=sec(x-pre[x])+sec(nex[x]-x)-sec(nex[x]-pre[x]); pre[nex[x]]=pre[x],nex[pre[x]]=nex[x]; if(flag)sta[++top][0]=x,sta[top][1]=pre[x],sta[top][2]=nex[x]; } void add(int x){ int node=pos[x]; sum[node]+=v[x]; if(!vis[node]&amp;&amp;sum[node]*B+1ll*A*deep[node]&gt;=C){ vis[node]=1; if(!tax[deep[node]])a[++k]=g[deep[node]]; ++tax[deep[node]]; } } inline void del(int x){ int node=pos[x]; sum[node]-=v[x]; if(vis[node]&amp;&amp;(!sum[node]||sum[node]*B+1ll*A*deep[node]&lt;C)){ vis[node]=0,--tax[deep[node]]; if(!tax[deep[node]])erase(g[deep[node]]); } } inline void back(int x){ int node=pos[x]; sum[node]+=v[x]; if(!vis[node]&amp;&amp;sum[node]*B+1ll*A*deep[node]&gt;=C)vis[node]=1,++tax[deep[node]]; } inline void back(){ int x,l,r; while(top){ x=sta[top][0],l=sta[top][1],r=sta[top][2]; ans-=sec(r-l)-sec(x-l)-sec(r-x); nex[x]=r,pre[x]=l,pre[r]=x,nex[l]=x,--top; } } void init(){ sort(a+1,a+1+k); pre[a[k+1]=ml+1]=a[k],nex[0]=a[1]; for(register int i=1;i&lt;=k;++i){ pre[a[i]]=a[i-1],nex[a[i]]=a[i+1]; ans+=sec(a[i]-a[i-1]); } ans+=sec(a[k+1]-a[k]); } }o,u; long long gcd(long long a,long long b){return b?gcd(b,a%b):a;} int main(){ int m,sq,sl,n=read(); A=read(),B=read(),C=read(); for(register int i=1;i&lt;=n;++i)a[i]=read(); for(register int i=1;i&lt;=n;++i){ scanf(&quot;%s&quot;,s+len[i-1]+1),len[i]=strlen(s+len[i-1]+1),ml=max(ml,len[i]),len[i]+=len[i-1],insert(len[i-1]+1,len[i]); for(register int j=len[i-1]+1;j&lt;=len[i];++j)id[j]=i,v[j]=a[i]; } for(register int i=1;i&lt;=ml;++i)g[i]=read(); n=len[n],m=read(),sq=n/sqrt(m),sl=n/sq+bool(n%sq); for(register int i=1;i&lt;=m;++i)q[i].l=len[read()-1]+1,q[i].r=len[read()],q[i].id=i; for(register int i=1;i&lt;=sl;++i) for(register int j=(i-1)*sq+1,r=min(j+sq-1,n);j&lt;=r;++j) be[j]=i; sort(q+1,q+1+m); for(register int i=1;i&lt;=n;++i)o.add(i); o.init(); int l,r; for(register int i=1;i&lt;=m;++i){ if(be[q[i].l]!=be[q[i-1].l]){ l=(be[q[i].l]-1)*sq+1,r=n; for(register int j=max((be[q[i-1].l]-1)*sq+1,1);j&lt;l;++j)o.del(j); u=o; } while(r&gt;q[i].r)u.del(r--); flag=1; for(register int j=l;j&lt;q[i].l;++j)u.del(j); flag=0; ans[q[i].id]=u.ans; for(register int j=l;j&lt;q[i].l;++j)u.back(j); u.back(); } long long f=sec(ml+1); for(register int i=1;i&lt;=m;++i){ long long d=gcd(f-ans[i],f); printf(&quot;%lld/%lld\\n&quot;,(f-ans[i])/d,f/d); } }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://ctz45562.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"trie树","slug":"trie树","permalink":"https://ctz45562.github.io/tags/trie%E6%A0%91/"},{"name":"莫队","slug":"莫队","permalink":"https://ctz45562.github.io/tags/%E8%8E%AB%E9%98%9F/"}]},{"title":"洛谷 P3233 [HNOI2014]世界树","slug":"洛谷-P3233-HNOI2014-世界树","date":"2020-06-11T07:56:22.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2020/06/11/洛谷-P3233-HNOI2014-世界树/","link":"","permalink":"https://ctz45562.github.io/2020/06/11/%E6%B4%9B%E8%B0%B7-P3233-HNOI2014-%E4%B8%96%E7%95%8C%E6%A0%91/","excerpt":"传送门 Enchant Arrow!","text":"传送门 Enchant Arrow! 虚树显然。用虚树上的边长表示原树上的距离。 考虑每条虚树上的边的贡献。记边$(x,y)$在虚树上距离两端点最近的点分别为$u,v$。换根$DP$可求。 分类讨论： $u=v$，原树上路径$(x,y)$的所有点包括挂着的子树都归$u$管理，直接查即可 $u\\neq v$，原树上路径$(x,y)$一部分点包括其子树归$u$管理，剩下的归$v$管理。显然从$x$开始的$\\dfrac{dis(u,v)+1}{2}-dis(u,x)$（根据$u,v$大小向上/下取整）个点包括其子树归$u$管理，剩下的归$v$管理。找个$k$级祖先子树和相减即可。比较懒倍增求的$k$级祖先。 有一个问题是虚树端点处会算重。可以只计算下面的端点，不管上面的端点。但是这样根节点的贡献算不上，建一个虚点和根节点连边作为新的根节点即可。 代码写了一天题解这么短，口嗨就是这么简单其实细节巨多 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #define maxn 300005 #define inf 0x3f3f3f3f #define px putchar #define pn px(&#39;\\n&#39;) using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int seg[maxn],siz[maxn],deep[maxn],root; namespace origin{ int top[maxn],son[maxn],fa[maxn][20],h[maxn],num,cnt; struct edge{int pre,to;}e[maxn&lt;&lt;1]; inline void add(int from,int to){e[++num]=(edge){h[from],to},h[from]=num;} void dfs1(int node=root){ siz[node]=1; for(register int i=1;i&lt;20;++i)fa[node][i]=fa[fa[node][i-1]][i-1]; for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(siz[x])continue; fa[x][0]=node,deep[x]=deep[node]+1,dfs1(x),siz[node]+=siz[x]; if(siz[x]&gt;siz[son[node]])son[node]=x; } } void dfs2(int node=root){ seg[node]=++cnt; if(!son[node])return; top[son[node]]=top[node],dfs2(son[node]); for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(!seg[x])top[x]=x,dfs2(x); } } inline int lca(int x,int y){ while(top[x]!=top[y])deep[top[x]]&lt;deep[top[y]]?y=fa[top[y]][0]:x=fa[top[x]][0]; return deep[x]&lt;deep[y]?x:y; } inline int dis(int x,int y){return deep[x]+deep[y]-(deep[lca(x,y)]&lt;&lt;1);} inline int anc(int x,int k){ if(!k)return x; for(register int i=19;~i;--i)if(k&gt;&gt;i&amp;1)x=fa[x][i]; return x; } inline int sum(int x,int k){return siz[anc(x,k)]-siz[x];} } namespace virt{ int h[maxn],p[maxn],sta[maxn],ans[maxn],rec[maxn],s[maxn],num,n,top; bool key[maxn]; struct edge{int pre,to,l;}e[maxn&lt;&lt;1]; struct near{ int d,x; near(int D=inf,int X=0){d=D,x=X;} bool operator &lt; (const near &amp;X)const{ if(d!=X.d)return d&lt;X.d; return x&lt;X.x; } bool operator == (const near &amp;X){return d==X.d&amp;&amp;x==X.x;} bool operator != (const near &amp;X){return !(*this==X);} near operator + (const int &amp;X){return near(d+X,x);} }f[maxn]; inline bool cmp(int x,int y){return seg[x]&lt;seg[y];} inline void add(int from,int to){ int l=origin::dis(from,to); e[++num]=(edge){h[from],to,l},h[from]=num; e[++num]=(edge){h[to],from,l},h[to]=num; } void push(int node){ h[node]=0; int l=origin::lca(node,sta[top]); if(l==sta[top]){sta[++top]=node;return;} while(seg[l]&lt;seg[sta[top-1]])add(sta[top],sta[top-1]),--top; if(sta[top-1]!=l)h[l]=0,add(l,sta[top]),sta[top]=l; else add(sta[top],l),--top; sta[++top]=node; } void build(){ sta[top=1]=1,h[1]=h[root]=num=0; sort(p+1,p+1+n,cmp); for(register int i=1;i&lt;=n;++i){ key[p[i]]=1,ans[p[i]]=0; if(p[i]==1)continue; push(p[i]); } for(register int i=1;i&lt;top;++i)add(sta[i],sta[i+1]); add(root,1); } void dp(int node=root,int fa=0){ s[node]=siz[node]; if(key[node])f[node]=near(0,node); else f[node]=near(); for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(x==fa)continue; dp(x,node),s[node]-=siz[origin::anc(x,e[i].l-1)]; f[node]=min(f[x]+e[i].l,f[node]); } } void check(near &amp;m1,near &amp;m2,near d){ if(d&lt;m1)m2=m1,m1=d; else if(d&lt;m2)m2=d; } void _dp(int node=root,int fa=0,near F=near()){ if(key[node])F=near(0,node); near m1=F,m2; for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(x==fa)continue; check(m1,m2,f[x]+e[i].l); } for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(x==fa)continue; _dp(x,node,(m1==f[x]+e[i].l?m2:m1)+e[i].l); near t=min(f[x],m1+e[i].l); if(t.x==m1.x)ans[t.x]+=s[x]+origin::sum(x,e[i].l-1); else { int d=t.x&lt;m1.x?(origin::dis(t.x,m1.x)+2&gt;&gt;1):(origin::dis(t.x,m1.x)+1&gt;&gt;1),k=origin::sum(x,d-1-deep[t.x]+deep[x]); ans[t.x]+=s[x]+k; ans[m1.x]+=origin::sum(x,e[i].l-1)-k; } } } void solve(){ build(),dp(),_dp(); for(register int i=1;i&lt;=n;++i)printf(&quot;%d &quot;,ans[rec[i]]),key[rec[i]]=0; pn; } } using namespace origin; int main(){ int n=read(); root=n+1; for(register int i=1,x,y;i&lt;n;++i)x=read(),y=read(),add(x,y),add(y,x); add(root,1),dfs1(),dfs2(),n=read(); while(n--){ virt::n=read(); for(register int i=1;i&lt;=virt::n;++i)virt::p[i]=virt::rec[i]=read(); virt::solve(); } }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"虚树","slug":"虚树","permalink":"https://ctz45562.github.io/tags/%E8%99%9A%E6%A0%91/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://ctz45562.github.io/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"换根DP","slug":"换根DP","permalink":"https://ctz45562.github.io/tags/%E6%8D%A2%E6%A0%B9DP/"}]},{"title":"洛谷 P4075 [SDOI2016]模式字符串","slug":"洛谷-P4075-SDOI2016-模式字符串","date":"2020-06-10T02:32:40.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2020/06/10/洛谷-P4075-SDOI2016-模式字符串/","link":"","permalink":"https://ctz45562.github.io/2020/06/10/%E6%B4%9B%E8%B0%B7-P4075-SDOI2016-%E6%A8%A1%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"传送门 一边听主席的故事（本子）会一边调出来了。","text":"传送门 一边听主席的故事（本子）会一边调出来了。 题解里都是哈希，我这个大常数SAM+kmp就显得很另类（ 考虑点分治时如何把两条路径拼起来。用$[P_i]$表示前缀，$[S_i]$表示后缀，$a[S]$表示$a$个$S$相连（$a\\in\\mathbb{Z}$），一定是形如$a[S]+[P_i]$和$[S_{i+1}]+b[S]$的两条半路径拼成的路径符合要求： $T_x$表示分治中心到点$x$的路径形成的字符串。如果$T_x$形如$[S_{i+1}]+b[S]$，则用$sl_x$表示$S_{i+1}$的长度。 对$S$串建$SAM$，并把$S$代表的节点（最后插入的字符新建的节点）及其$parent\\ tree$上的祖先都打上标记。如果把$T_x$在$SAM$上跑一遍走到了有标记的节点，则$T_x$为$S$的一个后缀，$sl_x=deep_x$。 解决了后缀的问题，只要找出$[S]$即可。$kmp$匹配一下就行。如果$T_x$正好匹配$S$，则$sl_x=sl_y$（$y$为$x$的$m$级祖先）。 而$a[S]+[P_i]$就把$S$反过来做一遍。开个$sl$的桶统计答案就做完了。 复杂度$O(n\\log n)$，成功挤进了最优解最后一页。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 1000005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } char s[2][maxn],t[maxn],a[maxn]; int m; struct SAM{ #define son(x,y) son[x][y] int son[maxn&lt;&lt;1][26],fa[maxn&lt;&lt;1],len[maxn&lt;&lt;1],cnt,last; bool en[maxn&lt;&lt;1]; void clear(){ for(register int i=1;i&lt;=cnt;++i)memset(son[i],0,sizeof son[i]),fa[i]=len[i]=en[i]=0; cnt=last=1; } int insert(int c){ int p=last,ne=last=++cnt; len[ne]=len[p]+1; while(p&amp;&amp;!son(p,c))son(p,c)=ne,p=fa[p]; if(!p)fa[ne]=1; else { int q=son(p,c); if(len[q]==len[p]+1)fa[ne]=q; else { int sp=++cnt; memcpy(son[sp],son[q],sizeof son[q]); len[sp]=len[p]+1,fa[sp]=fa[q],fa[q]=fa[ne]=sp; while(p&amp;&amp;son(p,c)==q)son(p,c)=sp,p=fa[p]; } } return ne; } void init(char *s){ clear(); for(register int i=1;i&lt;m;++i)insert(s[i]); int node=insert(s[m]); while(node)en[node]=1,node=fa[node]; } }S[2]; int siz[maxn],h[maxn],st[maxn][2],tax[2][maxn],q[maxn],sl[maxn],nex[2][maxn],tail,num,mx,root,all,cnt; long long ans; bool vis[maxn]; struct edge{int pre,to;}e[maxn]; inline void add(int from,int to){e[++num]=(edge){h[from],to},h[from]=num;} void getroot(int node,int fa=0){ int ma=all-siz[node]; for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(vis[x]||x==fa)continue; getroot(x,node),ma=max(ma,siz[x]); } if(ma&lt;mx)mx=ma,root=node; } void modify(int id,int len){ if(len==-1)return; ans+=tax[id^1][(m-len)%m]; st[++cnt][0]=len,st[cnt][1]=id; } void calc(int node,int fa,int sam,int len,int id){ q[++tail]=node,sam=S[id].son(sam,a[node]); while(len&amp;&amp;s[id][len+1]!=a[node])len=nex[id][len]; if(s[id][len+1]==a[node])++len; if(len==m)sl[node]=sl[q[tail-m]],len=nex[id][m]; else if(S[id].en[sam])sl[node]=tail%m; modify(id,sl[node]); for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(x==fa||vis[x])continue; calc(x,node,sam,len,id); } --tail,sl[node]=-1; } void dfs(int node,int fa){ siz[node]=1,sl[node]=-1; for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(x==fa||vis[x])continue; dfs(x,node),siz[node]+=siz[x]; } } void solve(int node){ vis[node]=1,cnt=0,modify(0,0); ++tax[0][0]; int sam=S[1].son(1,a[node]),len=(s[1][1]==a[node]),last=1; long long rec=ans; bool flag=0; if(len==m)len=nex[1][m]; else if(S[1].en[sam])sl[node]=1%m; modify(1,sl[node]); for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(vis[x])continue; for(register int j=last+1;j&lt;=cnt;++j) ++tax[st[j][1]][st[j][0]]; last=cnt; calc(x,node,1,0,0); q[++tail]=node,calc(x,node,sam,len,1),--tail; } dfs(node,0); for(register int i=1;i&lt;=last;++i)--tax[st[i][1]][st[i][0]]; for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(vis[x])continue; all=siz[x],mx=inf,getroot(x,node),solve(root); } } int main(){ memset(sl,-1,sizeof sl),sl[0]=0; int t=read(); while(t--){ memset(vis,0,sizeof vis); memset(h,0,sizeof h),num=ans=0; int n=read(); m=read(); scanf(&quot;%s&quot;,a+1); for(register int i=1;i&lt;=n;++i)a[i]-=&#39;A&#39;; for(register int i=1,x,y;i&lt;n;++i)x=read(),y=read(),add(x,y),add(y,x); scanf(&quot;%s&quot;,s[0]+1); for(register int i=1;i&lt;=m;++i)s[1][i]=(s[0][m-i+1]-=&#39;A&#39;); S[0].init(s[0]),S[1].init(s[1]); int j=0; for(register int i=2;i&lt;=m;++i){ while(j&amp;&amp;s[0][i]!=s[0][j+1])j=nex[0][j]; if(s[0][i]==s[0][j+1])++j; nex[0][i]=j; } j=0; for(register int i=2;i&lt;=m;++i){ while(j&amp;&amp;s[1][i]!=s[1][j+1])j=nex[1][j]; if(s[1][i]==s[1][j+1])++j; nex[1][i]=j; } dfs(1,0),mx=inf,all=n,getroot(1,0),solve(root); printf(&quot;%lld\\n&quot;,ans); } }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://ctz45562.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"点分治","slug":"点分治","permalink":"https://ctz45562.github.io/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"},{"name":"后缀自动机","slug":"后缀自动机","permalink":"https://ctz45562.github.io/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"KMP","slug":"KMP","permalink":"https://ctz45562.github.io/tags/KMP/"}]},{"title":"hszxの胡策 Endless","slug":"hszxの胡策-Endless","date":"2020-06-08T05:54:19.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2020/06/08/hszxの胡策-Endless/","link":"","permalink":"https://ctz45562.github.io/2020/06/08/hszx%E3%81%AE%E8%83%A1%E7%AD%96-Endless/","excerpt":"大概是最后一次写题解了吧。（并不是）","text":"大概是最后一次写题解了吧。（并不是） 题目规定的形如$AA$的串自然可以想到优秀的拆分，根据套路，枚举$A$串的长度$len$，每$len$的长度设置一个关键点，$AA$串一定会跨过关键点。 对于每个相邻关键点$i,j$，若$lcs(i,j)+lcp(i+1,j+1)\\ge len$就可以产生$AA$串，且左右端点在$[i-lcs(i,j)+1,i+lcp(i+1,j+1)]$内移动，于是$\\forall k\\in[i-lcs(i,j)+1,i+lcp(i+1,j+1)]$，需连边$(k,k+len)$。 考虑这个操作：一个区间与另一个区间对应连边，容易想到萌萌哒。 用$f(i,k)$表示点集$[i,i+2^k-1]$，把每次连边拆成两次$ST$表上的连边。 最后从高层往底层推下去。若有边$(f(i,k),f(j,k))$，则必有边$(f(i,k-1),f(j,k-1)),(f(i+2^{k-1},k-1),f(i+2^{k-1},k-1))$。不过直接把边推到底层边数还是爆炸的，所以可以对每层做一遍最小生成树，把有用的边下放，可以保证每层的边数都是$O(n)$的。 枚举$AA$串长度是调和级数的$O(n\\log n)$，$ST$表的下放是$O(n\\log^2n)$的，总复杂度$O(n\\log^2n)$，空间复杂度$O(n\\log n)$。 为了卡时间卡空间，线段树替换$ST$表求$lcp$，归并排序合并边集，写垃圾桶回收废弃边，代码丑的一批： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #define maxn 300005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int lg[maxn],fa[maxn],s[maxn],pool[maxn*30],edg[maxn&lt;&lt;4],rec[maxn&lt;&lt;3],top,n,m,cnt,all,num; struct edge{ int x,y,l; bool operator &lt; (const edge &amp;X)const{return l&lt;X.l;} }e[maxn*40]; vector&lt;int&gt;ed[21]; struct Suffix_Array{ #define ls(x) x&lt;&lt;1 #define rs(x) x&lt;&lt;1|1 int sa[maxn],rk[maxn],tp[maxn],tax[maxn],hei[maxn],mi[maxn&lt;&lt;2]; void Rsort(){ for(register int i=0;i&lt;=m;++i)tax[i]=0; for(register int i=1;i&lt;=n;++i)++tax[rk[i]]; for(register int i=1;i&lt;=m;++i)tax[i]+=tax[i-1]; for(register int i=n;i;--i)sa[tax[rk[tp[i]]]--]=tp[i]; } void Ssort(){ for(register int i=1;i&lt;=n;++i)rk[i]=s[i],tp[i]=i; m=n,Rsort(); for(register int k=1,p=0;p&lt;n;m=p,k&lt;&lt;=1){ p=0; for(register int i=1;i&lt;=k;++i)tp[++p]=n-k+i; for(register int i=1;i&lt;=n;++i)if(sa[i]&gt;k)tp[++p]=sa[i]-k; Rsort(); for(register int i=1;i&lt;=n;++i)tp[i]=rk[i]; rk[sa[1]]=p=1; for(register int i=2;i&lt;=n;++i) rk[sa[i]]=tp[sa[i]]==tp[sa[i-1]]&amp;&amp;tp[sa[i]+k]==tp[sa[i-1]+k]?p:++p; } } void get_height(){ int k=0,x; for(register int i=1;i&lt;=n;++i){ if(rk[i]==1)continue; if(k)--k; x=sa[rk[i]-1]; while(i+k&lt;=n&amp;&amp;x+k&lt;=n&amp;&amp;s[i+k]==s[x+k])++k; hei[rk[i]]=k; } } void build(int l,int r,int node){ if(l==r){mi[node]=hei[l];return;} int mid=l+r&gt;&gt;1; build(l,mid,ls(node)); build(mid+1,r,rs(node)); mi[node]=min(mi[ls(node)],mi[rs(node)]); } int query(int L,int R,int l,int r,int node){ if(L&lt;=l&amp;&amp;R&gt;=r)return mi[node]; int mid=l+r&gt;&gt;1,ans=inf; if(L&lt;=mid)ans=query(L,R,l,mid,ls(node)); if(R&gt;mid)ans=min(ans,query(L,R,mid+1,r,rs(node))); return ans; } inline int lcp(int i,int j){ return query(min(rk[i],rk[j])+1,max(rk[i],rk[j]),1,n,1); } void clear(){ for(register int i=1;i&lt;=n;++i)tp[i]=rk[i]=0; } void init(){ Ssort(),get_height(),build(1,n,1); } }pre,suf; inline int LCS(int x,int y){ if(!x||!y)return 0; return pre.lcp(n-x+1,n-y+1); } inline int LCP(int x,int y){return suf.lcp(x,y);} inline void add(int l,int r,int len,int w){ int k=lg[r-l+1]; e[++cnt]=(edge){l,l+len,w}; ed[k].push_back(cnt); e[++cnt]=(edge){r-(1&lt;&lt;k)+1,r+len-(1&lt;&lt;k)+1,w}; ed[k].push_back(cnt); } int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);} inline int newn(){return top?pool[top--]:++cnt;} void merge(vector&lt;int&gt;&amp;b){ all=0; int i=1,j=0; while(i&lt;=num&amp;&amp;j&lt;b.size()){ if(e[rec[i]].l&lt;e[b[j]].l)edg[++all]=rec[i++]; else edg[++all]=b[j++]; } while(i&lt;=num)edg[++all]=rec[i++]; while(j&lt;b.size())edg[++all]=b[j++]; } inline bool cmp(int x,int y){return e[x].l&lt;e[y].l;} int main(){ int t=read(); while(t--){ suf.clear(),pre.clear(); n=read(),cnt=top=0; for(register int i=1;i&lt;=n;++i)s[i]=read(); for(register int i=2;i&lt;=n;++i)lg[i]=lg[i&gt;&gt;1]+1; suf.init(); reverse(s+1,s+1+n),pre.init(); for(register int len=1;len&lt;=(n&gt;&gt;1);++len){ int w=read(); for(register int i=len&lt;&lt;1;i&lt;=n;i+=len){ int j=i-len,lcs=min(LCS(i,j),len),lcp=min(LCP(i+1,j+1),len-1); if(lcs+lcp&gt;=len)add(j-lcs+1,j+lcp,len,w); } } vector&lt;int&gt;::iterator it; long long ans=0; for(register int j=lg[n];~j;--j){ sort(ed[j].begin(),ed[j].end(),cmp),merge(ed[j]),ed[j].clear(),num=0; for(register int i=1;i&lt;=n;++i)fa[i]=i; for(register int i=1;i&lt;=all;++i){ edge E=e[edg[i]]; int u=find(E.x),v=find(E.y); if(u!=v){ fa[u]=v; if(j){ rec[++num]=edg[i]; int p=newn(); e[p]=(edge){E.x+(1&lt;&lt;j-1),E.y+(1&lt;&lt;j-1),E.l},rec[++num]=p; } else ans+=E.l; } else pool[++top]=edg[i]; } } printf(&quot;%lld\\n&quot;,ans); } }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://ctz45562.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"后缀数组","slug":"后缀数组","permalink":"https://ctz45562.github.io/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"},{"name":"ST表","slug":"ST表","permalink":"https://ctz45562.github.io/tags/ST%E8%A1%A8/"}]},{"title":"SLYZ·2018级机房人物列传","slug":"SLYZ·2018机房人物列传","date":"2020-05-28T11:00:53.000Z","updated":"2022-02-08T14:56:49.630Z","comments":true,"path":"2020/05/28/SLYZ·2018机房人物列传/","link":"","permalink":"https://ctz45562.github.io/2020/05/28/SLYZ%C2%B72018%E6%9C%BA%E6%88%BF%E4%BA%BA%E7%89%A9%E5%88%97%E4%BC%A0/","excerpt":"","text":"更新日志2021.11.7 正传·Tommy_clas条目更新《卢比扬卡扭蛋机》《柜子》《祖图安·布商·提宇珂》 正传·asuldb条目更新《烜式换元法》 正传·ZUTTER_&amp;shzr更新 2021.10.15 正传·Taduro条目更新《石雕鉴赏家》 正传·Tommy_clas条目更新《murmur》《xp癌》 序——ctz关于《SLYZ·2018级的机房人物列传》，在此我想说几句： 最初我们开始写人物列传的时候是csp2019前，当时因为我比较颓，这个任务是想让我完成的。但我认为我的文笔不够好，转而交给了「当代鲁迅」白爷。 但是我没有考虑到实际情况——白爷虽然文笔很好，但是停课时间不多，对我们了解甚少，因此第一版人物列传内容并不完善。这里我要向白爷道歉。锅在我身上，所以我之后陆续补充了部分人物的传记，并规划了排版。 在省选前，我想补全所有人的传记。但是白爷已经退役了，征求白爷建议后，我最终决定把原来的pdf改写成markdown放到博客上，同时也方便机房其他人转载。（因为github博客最近不稳定，所以我在洛谷也放了一份） 注部分人物称呼： loli：总教练 老孔,lix,lx：教练 mars/敬爱的物理马老师：班主任 zky：来讲过课的学长 scj：学弟 标题下的斜体字为作者，图片为qq头像（便于阅读表情包）。 传记顺序仅与写作时间有关。 正传——Bj2002,ctz,zhuoer&amp;Riverfun机房人物列传·Taduroctz,Bj2002 在各大同♂性♂交♂友网站上的常用id为Taduro和多弗桃（某俄罗斯OJ上叫TarudoYem），机房内被亲切地成为“稳稳”。 被潮称为“稳稳在留长头发的时候挺帅的，自从理了快秃了的头就跟QJ犯一样”。 天籁之音稳稳体内流淌着音乐之魂，一旦兴奋起来稳稳就会不由自主地唱歌。因为天生有一副完美的歌喉，稳稳的歌声总是如此美妙，被称为“天籁之音”。 当稳稳戴耳机时唱歌频率会大大提升，有时还伴有舞蹈。 睡眠带师稳稳是机房内睡眠时间第二长的人（第一是成爷），而且睡觉打呼噜。 从外表就能看出来稳稳一脸虚样。 稳稳睡觉属于标准的渐进式睡眠。从一开始就显得很虚，双眼逐渐闭合，最后趴在桌子上睡觉。 有时稳稳也会坐着睡觉。ctz曾亲眼见到过稳稳正坐着睡觉还打着呼噜。 稳稳与耳机的正确用法稳稳是机房几个耳机常客之一。 大部分时候稳稳是在听歌。但如果你看到他戴着耳机一边看题一边笑的话那就是在听相声。 稳稳还曾向ctz索要过R18音频听 三人颓，唯有稳稳被抓说到颓废，稳稳一般都是颓知乎或者浏览新闻，偶尔会看漂 亮 图 片。 颓废程度远不如机房内其他人。然而稳稳是最经常被抓颓的，因此在loli心里稳稳没啥地位。 经典桥段1asuldb、稳稳和ctz中午待在机房学习颓废。loli突然奇袭。 在loli进屋的几十秒前，asuldb正好刚打开一道题写代码，ctz在搭博客浏览自己的一篇题解，稳稳在颓知乎。 然后稳稳就被抓了。 经典桥段2某天早上，众人来到机房。asuldb、ctz、稳稳出于习性开始趴着睡觉。 过了一会ctz睡醒了，一看时间7:16，打算继续睡。由于这个时间loli会出现，所以在腿上放个演草本，转为了不会被发现的正坐睡姿。而asuldb应该是睡够了开始写题。 loli准时到来，只有熟睡中的稳稳被抓。 “yem怎么又（双叒叕敠）在机房睡觉了啊。要不要我联系一下班主任让你去上早读啊。” 成熟的稳稳只会看R100稳稳曾被潮钦定过“你也就看R100（养生类）”。 稳稳不光实际年龄较小，心理年龄同样很小。一开始他对R18的了解很少，但是拥有浓厚的兴趣，会在ctz颓图的时候好奇地凑上去找R18的，甚至会自行寻找R18。 目前稳稳在ctz、zhuoer和放的带领下已经实现独立在机房看本子的成就。 11.1日，某稳稳常用图片网站因为Ciyang爬虫被封了IP，稳稳成熟未遂，又退回到以前的水平了。 “你这图里都没有R18，有什么好看的。”——ctz在颓R15图片时 “zhuoer我可以给你u盘，但你得给我里面放满R18图片。”——稳稳面对索要u盘的zhuoer 稳稳的妻室稳稳是机房里后宫最庞大的人了。然而他的妻室都不在自己身边。 正妻：放的猫形抱枕。稳稳因为经常（有时是被迫在ctz的帮助下，虽然稳稳本人很乐意）尝试把自己的正妻剽窃过来，然后被放暴揍一顿。 小妾1：学长gay哥遗留下的棕色垫子。这是稳稳持有时间最长的后宫。后来（可能是失去性趣）一直在块的手里。目前下落不明。 小妾2：放的魔方。某天放带到机房里被稳稳钦定为小妾，后来就一直在放家里。 小妾3：放的耳机套。稳稳的耳机由于丢失了耳机套戴着很难受，有时会借用放的耳机套，因此稳稳钦定其为小妾。 水浒小名士暑假期间，没有带手机的稳稳在宿舍里借来了主席的《水浒传》，经过仔细研读成为了“水浒小名士”。 后来稳稳又借来主席的《三国演义》成为了“三国演义小名士”。 three kingdoms 10稳稳玩游戏比较杂，是雀魂玩家。目前他痴迷于一款单机战略游戏《三国志10》（被稳稳翻译成“three kingdoms 10”）并强烈向其他人安利。 就稳稳所说，他甚至在游戏里生过孩子。 “这个人今天中午被我干死了。”——稳稳中午请假回家，回来指着百度百科上的刘岱说道 十年饮冰，难凉热血。稳稳原先的博客签名。 后来因被嘲讽改为了“嘿嘿，抽到鬼牌的是我。” 之后又改成了“十年热血，难饮冰凉”。 现在香稳稳又改回了“十年饮冰，难凉热血”。 暴躁稳稳稳稳在临近CSP的时候性情突然暴躁。 但凡ctz盯着稳稳看，或者赞扬稳稳的天籁之声时，稳稳会暴揍ctz，并尝试把他的“对ctz宝具”用完的笔芯（现在稳稳把一个徽章套到笔芯上，形如棒棒糖）塞到ctz的嘴里。 然而稳稳好像只针对ctz，对其他人并不很暴躁。 “靠，我要把ctz打一顿。”——稳稳在ctz撰写传记的时候放言 现在ctz就是在稳稳旁边冒着生命危 “生时何必久睡，捅死必会长眠。”——Bj2002 十恶不🐍阿潮钦定稳稳因为有十种恶行，罪恶值已经达到了$+\\infty$，所以🐍不出来 后来阿潮又钦定稳稳的恶行不止十种，但是只要恶行少于9个，阿潮就会钦定稳稳十善可🐍。 稳稳的恶行有： 谋杀：稳稳每次手艺活就会杀死无数生命 反人类：稳稳呼吸使得宇宙熵增，导致人类加速灭亡 声音污染：稳稳说的话都是声音污染 浪费资源：稳稳使用电脑是浪费电，导致发电厂要多烧几十亿吨煤（稳稳为了改正决定砸了家里的电脑，被批判为破坏人类科技成果） 辐射源：稳稳散发热量，发射电磁波，造成辐射 ghs：传播银秽瑟琴信息，聚众银乱 胡编乱造：稳稳私自篡改历史，试图残害人类精神文明 反动：稳稳煽动国家反动势力，阻碍人类社会进步 故意伤害：2019年10月，稳稳太坏了，掐阿潮的胸，阿潮大喊：“靠，很疼！”稳稳被认定为主观犯罪，应当追究到这辈子结束 寻衅滋事 欠债不还：稳稳因为故意伤害阿潮应当赔偿，本来应该赔一百万，但是阿潮宽容大度，给稳稳打了折，只需要赔一百，但稳稳至今一直欠债不还 石雕鉴赏家某日升国旗，稳稳欣赏妹子，被发现后说自己其实是在欣赏广场上的十二生肖石雕。后来石雕成为了妹子的代称。 石雕是稳稳的精神寄托，据他所说，全学校的石雕都属于他。后来石雕的含义逐渐拓展，稳稳也会将他感性趣的男性称为石雕。 语录 “虚 稳 稳 。”——众人 “潮皇大帝阿稳。”——zhuoer 附录稳稳精选表情包： 机房人物列传·Bj2002ctz 当代鲁迅著有「颓废笔记」，「slyz人物列传」，「杨稳稳の三国志」，「loli三国杀」。其文笔幽默中暗含讽刺，令读者时而捧腹大笑时而陷入沉思，颇有迅哥儿之风，深受机房广大OIer喜爱。 “鲁迅”的称号经考证出自于Taduro博客友链的简介。 Bj2002+ctz=催更ctz在暑假时接取了每日任务：催更Bj2002。 内容为：只要不更博客，剥夺Bj2002当天上厕所、接水、吃饭的权利。标准为日更三篇。 尽管现在ctz没有每日任务了懒，他还是会时常坐到Bj2002旁边催更或者拦截Bj2002上厕所。 “R——R——R——R↘R↗R↗R~R~R——”Bj2002遇到别人时会RR乱叫。 不同于其他人类似于赶鸭子的声音，Bj2002会以随机曲调唱出来。 ctz认为这是仅次于稳稳“天籁之音”的美妙音乐。 乱拳当别人想靠近Bj2002干♂些♂儿♂事的时候，他会快速挥动拳头驱散敌人。 Bj2002还利用他的上衣发明出新的攻击方式：扭动躯体使用衣服上的两个松紧带攻击。他用这种方式多次成功击退了尝试拦截他上厕所的ctz。 天敌生物组的小郁同志是Bj2002的天敌。 ctz甚至以“不更博就把郁**放到你旁边监督你”要挟Bj2002。 “你把郁**放到我旁边比把loli放到我旁边都恐怖。” 每次同时见到小郁和Bj2002时一定是小郁趴在Bj2002身上捏他的脸，Bj2002则会一边享受地痛苦地RR乱叫一边苦苦求饶。 造成这种情况的原因是Bj2002的乱拳对小郁同志没有效果。ctz猜测是由于小郁同志体型过小导致乱拳无法命中，但更可能的是因为爱♂情。 资料库Bj2002经常在ftp上闲逛，掌握着各个年级的资料，包括但不限于所有人的照片和详细资料。 曾写过可以搜索slyz学生的程序。 颓废属于ctz的盲区了。笔者并不知道Bj2002颓废时除了逛ftp、写杂文、看小说还会干啥。 已知的是： Bj2002不属于死宅，但是看《魔法禁书目录》。 暑假期间，Bj2002在宿舍颓超级玛丽。 机房人物列传·Tommy_clasctz,Bj2002 又名“主席”，身材高大，体格健壮。 浩楠正气Tommy_clas，性格和善，道貌岸然。尊敬老师，团结同学，正直认真。听从各科老师、竞赛教练的话，担任着全科课代表、副班长、班主任、党支部书记、胜利一中24班委员会主席，深受各位老师的喜爱、广大同学的尊敬，是老师们的好帮手，同学们的好榜样。 附：《主席升旗被吹稿》 主席潮某年某月某日钦定Tommy_clas为主席。此后主席这一称号沿用至今。 省长没了主席自从得到“主席”的称号后，言行逐渐主席化。尤其是一句“阿谀奉承的人当不了省长”广为流传。每当食堂大妈给主席多打肉的时候，她的省长就没了。 带小说家当代著名科幻小说家，著有《潮色警戒》《潮特猎车手》。虽然这两部人气作品至今没有完结，但是主席又准备创作新小说《花花的奇妙冒险》。（主席的作品均连载于他的博客） 行走的b站主席及其擅长模仿，代表作有《If I had known that boys would have been sexually assaulted》《真夏の夜の淫夢》《zed》以及各种哲♂学、鬼畜作品。 搜索带师主席非常擅长搜索和暴力，经常在各种比赛中凭借暴力得到优异的成绩。尤其是他深厚的搜索功底，深得loli真传，是机房里第一个切了质数方阵的人。 聊斋小名士主席熟读《聊斋志异》，并常常给其他人推荐优秀篇目，比如《伏狐》《人妖》《凤仙》。 带画家主席擅长使用windows自带的画图软件进行艺术创作。以下为其代表作： 《带制作影片》 《忽悠ctz surviv更新了》 《接 头 霸 王》 《潮の奇妙冒险》 「比赛翻车狂补文化课组」群头像 主席cctalk头像（原型：野兽先辈） 主席原qq头像（原型：杰哥） 蛤特楠影业补课的时候，每次到上课的时间，主席总会说：“上课了，大家不要说话了。”接着潮就会跟一句：“蛤特楠影业”。这句话朗朗上口，清脆流利，深受广大语言带师喜爱。 综评打D主席身为体育委员，常常督促机房诸位跑操，甚至一度使用其掌管综合评价系统的权力威胁众人：“不跑操的综评系统都打D！” 家族力量主席家业雄厚，受到杨氏（本名）、李氏（loli）、马氏（班主任）、王氏（数学老师）等各大家族的支持，是slyz拥有姓氏最多的人。 主席家财万贯，家拥有一台比人类科技不知道高到哪里去的计算机。据主席介绍，该计算机能开下$2^{20}\\times10^9\\times10^9$大小的数组，而且任何时间复杂度在该计算机上都是$O(\\text{能过})$。 把药都吃了省队集训期间，众人沉迷于颓surviv.io。主席曾亲自指导R：“R，把药都吃了！”“把汽水都喝了！”“你们听我的吃药，能进前五” 希望你能理解疫情期间主席受到loli号召提前回机房，而蟹主任叮嘱主席不要把提前返校的事外传，有人举报。因此当ctz和慎老师问主席是否在机房的时候，主席都回答不在，同时多次重复“希望你能理解”一类语句，希望ctz和慎老师能明白他的意思。 然而主席第二天摸鱼将烜的游记翻译成多种语言后翻译回中文并且没有任何说明地发到群里，导致ctz和zhuoer结合主席种种怪异行为进行推理。真相大白后，“希望你能理解”成为热门语句。 隐藏宅主席外表正气凛然，但经过多年相处，逐渐暴露其宅的本性。阅番无数，读漫无数，看本无数，玩黄油无数，基本上随便提到一些冷门番剧、漫画、本子，主席都有接触过。 军事宅，热衷于各类军事题材的游戏以及硬核番剧、漫画。 在机房多次番剧、黄油交流大会中展现其饱读诗书、才高八斗、满腹经纶的形象。 murmur“主席”这一称号在高三后逐渐被“楠楠”取代。 而在维克多上有一个单词“murumr”，意为“喃喃”。因为“murmur”读音灵动悦耳，很快成为了主席的新称呼。 xp癌主席热衷于给众人讲一些奇怪的本子或视频，主题多为楠酮、炼铜、重口等。比较出名的有《哆啦AV梦》《八粒》《王爷，你下面的胡子都白了》《朴秀》。 卢比扬卡扭蛋机某段时间主席热衷于某部有关苏联的小说。其中有段情节是元帅被抓，在卢比扬卡监狱受到拷问，被带上皮革器具扭♂掉♂睾♂丸。 主席对该情节回味无穷。后来根据主席的人设，我们一度怀疑主席在slyz教学楼地下一层已建好了卢比扬卡监狱并且实施或被实施了扭蛋。 柜子主席很有钱，造了一个非常大的柜子，装着大约35亿的人，因为全世界男女比大约是1:1。 祖图安·布商·提宇珂某年某月，蛤蛤主席强制众人上体育课，导致了组团不上体育课起义。 语录 “yhn坏事做尽，证据确凿，百口莫辩，恐成全球公敌。”——潮 “都是yhn的错，带恶人。”——机房众人 “所有人必须5:20准时吃饭。”——主席 附录主席精选表情包： 主席全身照： 机房人物列传·Riverfunctz,Bj2002 又称放、邹家帆。曾用ID是stevebreaveman。前潮学学习群群主。青年数学家。身材瘦削而面庞不清秀。 放性格鲜明：心直口快，乐于助人，有点急性子。 邹家帆爱称“邹家帆”来源于loli纯正的口音。 嘴臭嘴臭是放的一大特点，频率和程度与潮不相上下。擅长将各种很香的话拼到一起，比如「tmdwoc」 数论+网络流小名士放的数论知识与其他领域相比十分突出。 “数学，即艺术！”——放曾经的qq签名 同时放精通网络流，基本刷遍了网络流24题并为其中大部分题撰写了题解。 颓废放对各种颓废方式均有研究，包括但不限于吃香料、喝香精、水知乎、搭博客、看动漫形象、装win10。 放是机房搭hexo博客的先驱者。曾协助Ciyang搭建slyzOJ。也是「P图小名士」。制作各种表情包： （这张表情包因为某些原因不会动了） “不要写很酷很炫的算法，不然你就失败了” “Sorry，当教练就是可以为所欲为” 因此放也经常被loli奶，得不到loli的爱戴。 机房外放是CSGO、Minecraft玩家。也是二次元新晋萌新，喜欢纱路、Kemomimi。最近又开始厨「游戏人生」。 睡眠放有时会在机房睡觉。这大概是由于走读生因颓废而缺乏睡眠。 不同于稳稳的渐进式睡眠法，放在睡前显得都很精神。之后他会突然将稳稳的老婆放到桌子上，有时会说一句“该睡觉了”，倒头就睡。 ctz独家资料放在心情愉悦的时候会吹口哨。经ctz识别吹的不是青花瓷就是刀剑神域op1。 不过最近放好像不大吹了，而是会模仿 目 力 先 辈 的 娇 喘。 语录 “放有一点……急公好义”——杨稳稳 “这样总行了吧，邹家帆。”——Loli “这个恶放剥削我的颓废时间”——wwr 附录放的精选表情包： 机房人物列传·ColorfulMistctz,Bj2002 常用名为“潮”“阿潮”。 阿潮作为行走的潮语机，创造的传奇故事与经典名句数不胜数，表情包数量在机房遥遥领先。可惜这里空太小了，只能列举一些经典片段。 （为了表示对阿潮的尊敬，所有的标题都带有书名号） 注：为了防止暴露隐私，下面一些图片中潮的面部已经过换头处理。 《赞颂阿潮》阿潮同学性格和善，道貌岸然。尊敬老师，团结同学，正直认真。听从各科老师、竞赛教练的话，担任着全科课代表、副班长、班主任、党支部书记、胜利一中24班委员会主席，深受各位老师的喜爱、广大同学的尊敬，是老师们的好帮手，同学们的好榜样。 《潮》“潮”这个爱称起源于“潮爷”。上古时代阿潮将两个裤兜翻到外面，非常地潮，因此得名“潮爷”，后来逐渐演变成“阿潮”“潮”。 《黑暗战神》阿潮曾放言“晚上去宿舍捅死你”，被众人认为阿潮在晚上战斗力暴增，因此得名曰“黑暗战神”。后来，阿潮与黑暗总会被认为死亡的象征，关于黑暗战神的话题在机房经久不衰。 《去去》阿潮获得参加SDOI2019的资格，loli询问潮去不去。潮以轻蔑的语调回答：“去，去。” “去去”二字内涵丰富，读音悦耳，直到今天热度不减。 《摸肚皮》摸肚皮是阿潮的招牌动作。阿潮饭后常常在机房转悠，停留在某人身后，抚摸肚皮，面带微笑。或双手撑腰，挺起腹部。或双手撑在桌子上近距离观察电脑。 《真的真的真的学不下去了》与摸肚皮配套使用。 阿潮常常一边摸肚皮一边说：“真的真的真的学不下去了”。 wwr&amp;明阳仿制版 《$C_n^{\\frac{n}{2}}$》 “对于一个数轴,从原点走n(n%2=0)步回到原点的不同方案数。” 阿潮对于此题的答案$C_n^{\\frac{n}{2}}$给出了严谨详细的证明，在学术界引起轩然大波，颠覆了机房OIer对组合数学的认知。可惜证明过程因为过于深奥而无法公开。 《X爷稳爷X爷稳&amp;$24=2^4$》阿潮创建的诗体。（被称为“潮诗”） 例： 潮爷稳爷潮爷稳 zhuoer爷稳爷zhuoer爷稳 块儿爷稳爷块爷稳 而这句话可以进行变换： “潮爷稳爷潮爷稳 稳爷潮爷稳爷潮 爷稳爷潮爷稳潮 …” 发明者阿潮说这句话有$2^4$种排列方式，后来又说有24种排列方式，因此这还为数学界留下了一个伟大的命题：$24=2^4$。 在文学界，这种诗体开创了诗歌界的新时代。创作者只需要填一个字（词）就能创作出24（$2^4$）句诗；读者也没有不被这种抑扬顿挫的诗句打动的。 《潮语》由于阿潮儒雅随和，谈吐有方，创造出了无数经典名句。因此ctz曾作《潮语》以记之。但《潮语》已经成为 国 家 非 物 质 文 化 遗 产 ，不能公开，只能选取一些阿潮的经典语录： “真是狗shi！该死的剖，loli得奶死我！啊，狗shi！”——阿潮在模拟赛上树剖写挂了 “这也太技巧了。”——阿潮对块的分块模拟赛上一道题的评价 “这一维是怎么省去的啊！状态不全乱了吗！”——阿潮请教烜某道DP题，对“f(i,j,k)中若j+k为定值可以省掉一维”不解 “你一辈子就0.9个算法”——阿潮潮讽指挥 “颓也没颓成，学也没学好，又荒废了。” “书陶哥~（指着化学资料）选择题8个错6个~”——暑假化学补课时 “SA不就是几个数组模拟一下吗”——阿潮潮讽asuldb “你SAM的A没了，就剩SM了，永远也A不掉了”——阿潮SDOI2019前一天潮讽asuldb，结果Day1 的SAM题asuldb没A。 “戴耳机，稳三年。”——阿潮面对机房戴耳机之风盛行这一情况的评价 “换个人消费吧。”——阿潮面对潮学之风盛行这一情况的评价 《稳》很长的一段时间，潮语在机房及其流行。阿潮对此心存不满，而他的反击方式为钦定其他人稳。 《潮语》作者ctz记载了“稳排行榜”： 经考证，稳基数起源于此： 《语言带师》阿潮在起名方面有极高的天赋。 victor_12369的名字简写为wwr，被阿潮称为“稳稳R”，沿用至今。 潮根据Genius_Z的姓氏美名其曰“zhuoer”（zhuoer的人物列传有记载） Tommy_clas“主席”的称号是阿潮起的，一直在使用。 asuldb“烜”与ctz“蟹”的称号也是阿潮所创作。 阿潮认为wawving像指挥，钦定他为这一届指挥，至今机房众人仍以“指挥“称之。 Ciyang“明阳妈妈”的称呼起源于潮。 毫不夸张的说，没有潮，我们就没有名字。 同时阿潮还擅长造字： 源于“zhuoer”，读音zhuò er 源于“胡块”，读音huài er 《ghs》i.郑州集训时，阿潮心怀宽广，友爱同学，每天前往ctz与明阳的房间分享网盘资源，共同观赏影片，与民同乐。后来阿潮大力发展文化建设，兴办小姐服务，努力造福人民群众。 ii.阿潮钦定稳稳只能看R100。 iii.阿潮认为“本子没意思，我在家都看3D的” 《浑身发热》阿潮骨骼惊奇，体质异于常人，体内含有丰富的热量，常常出现浑身发热的症状。 《酸脱羟基醇不脱》暑假化学补课时，阿潮独创潮式酯化反应： 《红警》国庆期间在青岛培训，包括阿潮在内，众人联机打红警。 阿潮与perhan同盟。开局perhan把阿潮的矿车全打没了，最后阿潮仅剩几十块钱，只能卖基地。随后可以清楚地听到阿潮对perhan的亲切问候。 《螳臂当潮》某日跑操后，众人发现一只螳螂。阿潮拿起螳螂，对螳螂亲切关怀。不想这螳螂恩将仇报，手起刀落划伤了阿潮的手指，留下了1mm的伤口。 阿潮大怒，扔下螳螂，一脚将螳螂踩到半死，又一脚把螳螂踢走。阿潮并未解气，上前又踩了好几脚。 回机房后，阿潮反复观察伤口并复读：“靠，这玩意不会有毒吧！” 《语录》“万物起源，引领时代潮流”——zhuoer “没有阿潮就没有快乐。或者说，没有阿潮，就不是完整的机房。”——ctz “lzj同学当世管仲。”——asuldb 《附录》《你好潮啊》——放 阿潮精选表情包： 机房调戏平衡树老哥时，阿潮作为主战力发表言论 阿潮带制作游戏《gta6》 机房人物列传·asuldbctz,Bj2002 被亲切地称为“烜”，亦可称为“鳖”。身材瘦削、眼睛小。 恒亘炫烜是asuldb名字最后一个字。 因为比较生僻容易被读错。 “接下来该谁了。。。这个wz什么，wz恒来回答一下。”——暑假补课时生物老师叫人回答问题 在loli标准的口音下被称呼为“wz炫。” 逼王喜欢装逼，并且扭转了OIer fake的习性，带起了同届的装逼风。 然而烜是真正有资本装逼的人。人形自走OJ，刷题量高于2k。多次在loli考试中崭露头角，在各种线上比赛中贡献一般最大。 （以上图片大部分都不是jc） 应烜的要求，放一整页的“吊”来形容他： 烜表示非常满意：“很合理。” 带发明家由于烜个人能力极强，知识储备和智力水平领先于当代科学，拥有多项发明的专利： 烜式合并单调栈烜发明的数据结构，并且烜是唯一掌握该算法的人。 第一次传播是在「[AHOI2013]差异」一题中，因为太受机房众人的欢迎而被踩到题解区最后一篇。 该算法有多种叫法：栈式合并单调恒、烜式单调合并栈 、恒式合并单调栈、炫式合并单调栈。。。 动态开点树状数组这是一种空间$O(n\\log n)$，时间$O(n\\log^2n)$的优秀数据结构，它具有常数小、代码简洁等各种优点，wwr 又T又M后对此大加赞赏。 烜式序列自动机在烜界面合格考前复习地理时，敏锐的烜发现莫霍界面和地壳之间多出来了一层，经过钻研烜发现了在烜界面，为探究地球奥秘做出了巨大贡献。 烜式换元法令t=x，代入原函数中即可解决各类复杂导数问题。 虽然看起来把x换成t是一样的（其实就是一样的），但这样做其实是换位思考，转换思维。烜式换元法实在是一种富有创造性的方法。 蛤（ge）王暑假补课时，烜多次持续打嗝，从上课到吃饭从未间断，余音绕梁三日不绝，有时甚至持续到晚上。因而获得蛤（嗝）王的称号。 2020年5月补课时，虽然不是同一个时间，但是是同一个竞赛室、同一个老师，我们有幸能看到蛤王再现。 女队进女队是烜毕生的梦想之一。其他的梦想有cf上紫（CSP前是完不成了），牛客上黄（已实现），AK loli的比赛（已实现），AK 线上比赛（已实现），进ZROJ首页（暂未实现，还有机会）。 “我要揭发出来，魏老师其实她不是人，她是只鸽子。然后我再证明我是个妹子，这样我就能进女队了。” 鳖被潮钦定为“鳖”（同时ctz被钦定为“蟹”） 但曾被学弟叫成“鳌”。 山东F队队长因为在省选中，除去进队的和退役的，烜的名次是最高的，所以自封为“山东省F队队长”。 而ctz排在烜后一名，被封为“山东省F队副队长”。 “今年NOI2019（同步赛）我山东省F队队长要带领大家夺金。” 而在NOI2019同步赛上，烜D2生病请假痛失金牌，成功打铁。 “D2T1T2我都能切，T3再随便搞一搞，我要是打了就金牌了。” 文科小名士烜的文科成绩极高（虽然选的理科）。 在历史合格考模拟测试中获得了接近满分的好成绩。 至今仍能熟练背诵初中课文。 在某次期末考试中，烜声称“老师没认真批”。经计算若正常批甚至可以进年级前20。 颓废在颓废之风盛行的机房中，烜是颓的很少的人。 一般颓知乎，逛博客。 很少玩游戏，对游戏不大了解，放假时玩三国杀。 然而在二轮省队集训时，烜可以凭借水qq和浏览看点和颓狗ctz颓到同一时间。在青岛颓三国杀能比初级颓狗zhuoer还精神。 “zhuoer你怎么这么早就睡了啊”。 语录“wzx你怎么上课睡觉呢？zyc我没有说你，你继续休息” “让你出比赛你也不出……不交总结” “zyc为什么在楼道里啊？wzx你去把他叫哄回来。 ——loli “大 吊 阿 烜”——zhuoer “是不是太吊了，都没啥可写的。”——asuldb “啊，母校。我亲爱的母校，你叛逆的儿女长大了。”——asuldb作为毕业生代表发言 附录烜的精选表情包（然而因为大部分时间在潜水所以不多）： 机房人物列传·ctzzhuoer,Riverfun 又称陶、chino陶、颓狗、蟹。偶尔喝香精。热衷于搭博客。经常颓废被各种教练抓。 ctz的名字有$2^4=24$种写法： ctz ctb cbz btz cbb bbc btb bbb _ctz _ctb _cbz _btz _cbb _bbc _btb _bbb ctz_ ctb_ cbz_ btz_ cbb_ bbc_ btb_ bbb_ 2018级最颓的颓狗。 曾经在二轮集训时，玩完电脑被抓后在底下玩手机又被抓，被loli奶：“怎么玩完上面玩下面啊”。 在loli查房时通过把手机放在枕头下面的方式来躲避抓颓。 暑假补课时因组织稳稳和R翘课，在完全不知情的情况下被敬爱的物理马老师查房，（稳稳）差点丧命。阿潮知道这个消息时出现了极度开心的症状，一边大笑一边浑身颤抖的用手挠腿。 因重装系统不愿还原与loli交涉，从而被loli奶：“瓦觉得吧，ctz还是很有潜力的，但是没有把精力全花费在学习上”（指不专心 他也是机房中为数不多的被老孔和mars抓颓的人之一。 陶痴迷于动漫形象，是萌豚中的豪杰。（在萌豚测试中分数rank1） 阅番无数，尤其喜欢看芳文社的日常百合番. 芳文社小名士，甚至专门写过相关颓文。 尤其喜欢点兔以及点兔中的香风智乃。 这是他的洛谷个人签名： 这是他博客的个人介绍： 甚至在他的代码中也体现了这一点： 除了收集动漫形象外，还为笔者（放）提供了所收集的语录截图。 DP带师，18年noip前一个月和19年CSP前爆刷各种DP，被zhuoer奉为DP爷。 英语水平极高，喜欢拿英语和点分治（指紫荆花之恋）来装逼。 重度萝莉控+重度百合控，曾和zhuoer多次进行某些网站的交换，其中ctz拿来交换的筹码多半是某些百合图片的网站。 ctz特别喜欢冲，但是身体不大行. 曾经被zhuoer给予过水龙头的称号（24小时都在冲） 因为冲的限度太低被潮怒斥： 他曾经还企图在学弟群伪装主席，以此来获得学弟们的崇拜： 擅长攻略学弟，目前已经和学弟刷满了好感度。 他在NOIp2018前立过女装flag，而他到现在还没在我们面前女装过。 在去青岛前曾说过：“你们给我买女装我就穿”。（虽然去了青岛以后因为颓上瘾都忘了给陶买女装了） 他也是个大嫖客，在Codeforce里先是从Specialist嫖上了 Expert，然后又从Expert嫖上了 Candidate Master，而且被他嫖的人大都没有上紫，被誉为“高级嫖客”。 他非常喜欢搭博客，每天的任务基本上除了做题就是搭博客，而且他在首次尝试搭博客中还被loli奶了。 他为了提高博客的访问速度，不惜一切代价：换图床、去掉很酷很炫的看板娘。。。 他还为了给博客增加非常酷炫功能，便去各个博客中剽js，css，html代码。 是机房里唯一切掉“紫荆花之恋”的人（其实指导教师李也切了），在众人拿做过的题装B时会搬出“紫荆花之恋”。 作为潮学大弟子，陶的代表作品是《潮语》。由于潮子的迫害，《潮语》几经变动，现已在网上失传。 “陶爷稳爷陶爷稳”——《潮语·杂文》 “争取进入清北冬令营”——loli “催更”——ctz 附录 ctz精选表情包： 机房人物列传·Genius_Zctz,Bj2002 常用称呼为“zhuoer”，曾经被称为“周儿爷”。 zhuoer由起名带师潮创作：周→周儿→zhuoer，读作“卓尔”（zhuoer不群）zhuoer是发音非常好听的双音节词语。因而衍生了多种快乐： zhuoerBzhuoer因为说了什么话引起潮的愉悦，给zhuoer赐名： zhuoerB读起来朗朗上口，深受机房众人喜爱，衍生出各种“*B”的称号： zhuoer买买提B来源于zhuoer的qq资料： 美名曰“zhuoer买买提”（亦作zhuoerMMT） 结合“zhuoerB”的名号，又称为“zhuoer买买提B”（zhuoerMMTB）。 zhuoer圾桶稳稳在比赛开黑时不止一次想出一个假做法或者很难写的做法，因为自己懒得写就把zhuoer传唤过来，教他这个做法并钦定zhuoer写。大部分时候因为思路本身的问题zhuoer都写不出来。 这个过程与扔垃圾有异曲同工之妙，zhuoer因此得名zhuoer圾桶。 四种国际计量单位 surviv莽单位：“枪给我，我要出去浪”“蛤蛤蛤我双持G18C无敌了” surviv勇单位：“R你苟算什么本事，出去就是干”（由于以上两条zhuoer联机打surviv的死亡速度极快） 上厕所时间单位：“我才不怕查宿，我在厕所里颓”“zhuoer呢？噢在厕所里。”“zhuoer都上了半个小时厕所了” 吃饭时间单位：“zhuoer怎么吃得这么慢啊” 图（树）论带师zhuoer去年noip前爆刷图论，进而深入学习了网络流，还曾经问过loli关于HLPP的问题导致loli自闭。 网络流凉凉后，zhuoer又精通了lct全家桶和圆方树。 R:“仙人zhuoer。” 链加链减出自二轮省队集训某一道考试题（正解为二维数点）。 zhuoer：“我做过原题，那题就是个链加链减！” 过了一会。 zhuoer：“草，看错了，题不一样。” 后来众人在鳖的帮助下都A了，但是链加链减却永存于我们心中。 zhuoer加zhuoer减 逆序对来源于R的转述。 某次zhuoer做了一道转化为求逆序对的题后。 R：“zhuoer觉得任何题都能转逆序对来做。” 不过逆序对的名气和适用性远不如链加链减。 腰带精zhuoer拥有一条类似腰带的东西（能量腰带？）每天都别在身上，看起来非常酷炫。 腰带上装着诸如水杯、笔一类日常用品。 后来稳稳在blog友链里称呼zhuoer为腰带精。 “腰带是我的本体。书包是蟹tz的本体。” 不过通过观察目前zhuoer脱离了本体也能生存。 gal小名士zhuoer精通galgame。 zhuoer有序定律zhuoer在食堂用膳时严格遵守美味值递增的顺序。 例如有鸡排和煎蛋的米线，zhuoer一定是先吃完所有米线，坚决不动鸡排和煎蛋，然后吃掉煎蛋，最后吃掉鸡排。 甚至zhuoer有时吃饼会先吃掉面饼，再吃里面的肉。 通过判断吃饭的顺序可以判断是不是真的zhuoer。 语录“周儿爷稳爷周儿爷稳”——《潮语·杂文》 “现在我是杨稳稳/潮爷/ctz/Ciyang/主席/胡块了。”——坐在别人座位上的zhuoer “我是真的写不动题了。” “我又来要（水）题了。” “给你推荐一道题。”（大部分都是lct、圆方树） ——到处闲逛的zhuoer “zhuoer不群，浩楠正气”——众人 附录zhuoer的精选表情包： 机房人物列传·victor_12369ctz,Bj2002 又名“wwr”“稳稳R”“R~”。 R起名带师阿潮根据victor_12369的名字简写wwr赐名“稳稳R”，随后衍生出了“R”的叫法。一般“wwr”为书面用语，“稳稳R”和“R”为口头用语。 全自动项目生成机器人这个词要分两部分来理解： 项目带师R精通c++工程，同时掌握python、html、js等各种语言，主要颓废内容为写项目，以下为R的部分作品。 太极桌宠R早期作品。打开后会有一个旋转的太极在屏幕上闲逛。配有手势指令，可以录制手势完成指定命令。 surRiR省队集训，机房众人沉迷于surviv.io。R因此开发了surviv简化版surRiR，玩法与surviv类似，通过学校局域网可以实现多人联机，同时配备有R和明阳共同开发的AI，在csp前一度成为热门颓废项目。 聊天室搭载于局域网的聊天室，使用了洛谷犇犇的外观，支持markdown和latex。 最初是R出于兴趣写的，后来成为了loli胡策时开黑的工具。虽然存在一些bug比如win10用户经常不能发消息 鸡你太美自动机机房盛行p图迫害之风时R所开发的项目，只要上传一个人的照片就能生成一张换头cxk打篮球的gif。 slyz资料库前文提到Bj2002曾写过查询slyz学生资料的程序，而其界面是R写的。 图片爬虫几何R板功能同几何画板。 然而目前几何R板仅支持创造点和直线而且R已经弃坑了。 RDerivation顾名思义，RDerivation是一款求导工具。效果如图： 由于R的颓废内容主要为写项目，所以从未被loli发现。 机器R经考证，R被称为“机器人”最初的起源是由于R一直过不去谷歌的人机验证，所以被zhuoer说“R一定是机器人”。 由于R开发过AI，且机器人的特性非常符合R的行为，所以至今机房众人依然认为R是机器人首领，并且有朝一日会带领它在《RR新闻》官方群的手下小冰、表情包老铁、Q群管家和爱小豆统治世界。 苟RR在联机surviv时的行为与zhuoer形成鲜明对比。R永远是藏在树下或草里苟，大大拖延了游戏时间。因此R一般是存活时间最长的。 “蛤蛤R，你这么苟着算什么本事？真男人就应该出来肛。”——zhuoer 潮文学家R精通潮文创作。 「人物列传•ColorfulMist」《红警》篇目里的三首潮诗也是R根据潮的言论创作的。 语录 “人科，人种智人，哺乳纲。”——潮 “我是稳稳R~，R~”——潮 附录R的精选表情包（由于R和烜一样经常潜水所以不多）： 机房人物列传·Ciyangctz,Bj2002 又名“明阳”“明阳妈妈”，面庞清秀，身形瘦削，骚气十足。 大骚货明阳拥有姣好的面容和性感的身材，散发着迷人的女性魅力，是他发骚的基础。 明阳常常以M字开腿、抚腿侧卧等骚态在床上玩手机，并用娇媚的语气说话，令人欲罢不能。 唱过学猫叫，可惜笔者还未听过明阳就不会唱了。 据说明阳还会会鸭子坐。 XXY丰富的情感生活有过女朋友，而且因为明阳颜值较高有很多迷妹，这体现了明阳男性的一面。 和perhan关系非常好，感情形同夫妻，尽管时常发生出轨事件，这体现了明阳女性的一面。 明阳妈妈csp前阿潮常常问明阳有关前端、工程的问题，稳稳对此作出形象的比喻：“明阳妈妈~”。 这个称呼和明阳的母性光辉十分贴切，因此流传至今。 必明阳发明了“必式说法”，在句子中加入“必”并重读，强化语气，能达到虽然明知不会实现却令人信服的效果。 明阳手把手教你“必式说法”： “今晚我必回宿舍。”——在机房待了一晚上 “我必颓。”——不敢颓 “loli10分钟不来我必颓surviv。” “loli20分钟不来我必颓surviv。” “loli30分钟不来我必颓surviv。” 。。。 暝阳·梅勒某天明阳放学前就回家了。不知情的阿潮呼唤明阳妈妈：“明阳~明阳~靠，明阳没了~” 经过ctz音译，“明阳没了”转变为“暝阳·梅勒”，而其变版“茨洋·梅勒”（Ciyang没了）被主席用于小说的角色名。 《RR新闻》官方群2018级轮换过多个qq群，csp前最常使用的群是明阳掌管的「《RR新闻》官方群」。 该群每天都会派发新闻，新闻来源大多是明阳所在的另一个ghs群「魔女咖啡屋」。 RR新闻职务表（并没有卵用）： 名称 职务 Ciyang 《RR新闻》收集员​ Tommy_clas 《RR新闻》鉴别员 ctz 《RR新闻》审核员 victor_12369 《RR新闻》机器R 大蛤蟆王 《RR新闻》宣传员 zhuoer 《RR新闻》评价员 大蛤蟆王 明阳双性体质的表现。 某天一个陌生人被拉进《RR新闻》官方群并任职管理员，后来甚至提拔为群主，群名片为“大蛤蟆王”。 此人名字很像网恋女生，说话如同初入社会懵懂无知的妹子，受到众人在群里和私聊调教戏。明阳表示此人确实是妹子。 由于《RR新闻》官方群经常开车，该人被猜测为干警伪装（我们干警24小时都在盯着这个群.jpg）。 最后此人被揭露为明阳的小号，尽管明阳一直否认这一事实，声称只是把她的qq号骗过来了。 目前大蛤蟆王被任职为“《RR新闻》宣传员”。 社 会 人明阳热衷于观看社会人视频，背诵社会语录，并积极运用于生活中。并且精通花手和激光雨，当过阿潮的舞蹈老师。 社会明阳，在线指导（以zhuoer为例）： （明阳走上前去拍zhuoer的肩膀）“哟，这不是zhuoer吗！这么多年没见，你还是和以前一样，让我看不起！” （大哥明阳拍小弟zhuoer的肩膀，zhuoer低下头）“铁子，送你一句话：‘辉煌时刻人人有，别拿一刻当永久。’” 项目带师明阳和R一样精通多门语言与项目工程。最出名的项目为一款图片爬虫spiking（被zhuoer译为“尖刺”，但明阳说是“脉冲”）。 然而明阳制作的大部分项目要么做完界面就弃了，要么bug百出。 例如各种乱码的聊天室，错误算法的surRiR AI。 语录 “人类美学缔造者。”——Tommy_clas “靠，大蛤。”——zhuoer “男的冲不出来。”——ctz 附录明阳在《RR新闻》官方群收集的社会语录： 明阳精选表情包： 机房人物列传·ArachnidaKingBj2002,ctz 又叫“perhan”。和明阳妈妈是夫妻。 带科学家是知名的民间科学家。代表成就是「共存多空间并发式气态硬盘理论」、「多肽无限聚变」、「C/C++内联变量」、「慢速幂」等。打破了能量守恒定律，解决了人类能源问题。 虽然Perhan的大多数科学理论不被众人接受，但他坚持“举世皆浊我独清”，为人类贡献自己的智慧，抨击“科奴”的打压。 爱斯基摩人perhan具有纯合的抗冻能力。身处华北地区，直到冬天还穿着短袖吹风扇吃冰糕。不过一个打破了能量守恒定律的男人需要衣服来保暖吗？ （11月份noip2018合照，左二身着夏季校服的人为perhan） 游戏带师perhan似乎并不是很擅长打游戏，打红警时受到了潮的批评。（见机房人物列传·ColorfulMist） perhan在进行其他多人运动游戏如打牌时表现也不佳，实际上perhan是为了营造沙雕氛围。 带模仿家perhan是资深李学家，擅长模仿loli。是一个成功的人。然而说到模仿，莫过于perhan在社交网络上的表现。 perhan每天处理QQ的消息时，都要过滤掉客服销售、骗子、单身男性（例如笔者）等的骚扰。有时perhan还和他们交流，言行举止非常真实，应该没有什么好怀疑的。 节肢动物癖perhan具有奇怪的爱好：节肢动物（似乎这东西可以吃？）。ArachnidaKing中文意思就是蜘蛛王，各大社交网站的头像都是蜘蛛。 为了其他人愉快的看博，配图就算了吧。 鬼畜码风 不说啥了，自己体会（代码为treap板子）： #include&lt;cstdio&gt; #define pritnf printf #define scnaf scanf #define retrun return #define sizoef sizeof #define inl inline #define br break #define con continue #define mst(mst_a,mst_b) memset(mst_a,mst_b,sizeof(mst_a)) #define fora(fora_x,fora_a,fora_b) for(re nti (fora_x)=(fora_a);(fora_x)&lt;=(fora_b);++(fora_x)) #define forb(forb_x,forb_a,forb_b) for(re nit (forb_x)=(forb_a);(forb_x)&gt;=(forb_b);--(forb_x)) #define foral(foral_x,foral_a,foral_b) for(re ll (foral_x)=(foral_a);(foral_x)&lt;=(foral_b);++(foral_x)) #define forbl(forbl_x,forbl_a,forbl_b) for(re ll (forbl_x)=(forbl_a);(forbl_x)&gt;=(forbl_b);--(forbl_x)) #define re register #define stt struct #define nms namespace #define gc getchar #define sl(sl_a) strlen(sl_a) #define gt(gt_a) goto gt_a #define rt return #define infa (0x3f3f3f3f) #define infb (0x7fffffff) #define infd (0x7f) #define abss(abss_x) ((abss_x)&gt;(0)?(abss_x):(-1)*(abss_x)) #define maxx(maxx_a,maxx_b) ((maxx_a)&gt;(maxx_b)?(maxx_a):(maxx_b)) #define minn(a,b) ((a)&lt;(b)?(a):(b)) #define in(in_a) freopen(&quot;D:/&quot;&quot;/in&quot;in_a&quot;.in&quot;,&quot;r&quot;,stdin) #define out(out_a) freopen(&quot;D:/&quot;&quot;/out&quot;out_a&quot;.out&quot;,&quot;w&quot;,stdout) #define filein(a) freopen(a,&quot;r&quot;,stdin) typedef long long ll; typedef int itn,nti,tin,tni,nit; using namespace std; const nit maxa=100004; const nit maxb=12; const nit maxc=4; const tni maxd=10004; #include&lt;cstring&gt; #include&lt;cstdlib&gt; #include&lt;ctime&gt; #define ceshi nms Treap { stt N { tni x,s[maxc],k,n,siz; }t[maxa]; tni num=0,rot; inl void Init(); inl tni niu(tni x); inl void js(tni d); inl void roll(tni &amp;d,tni k); inl void ad(tni &amp;d,tni x); inl void del(tni &amp;d,tni x); inl tni cx_th(tni x); inl tin cx_x(tni d,tni x); inl tin cx_pre(tni x); inl tni cx_nxt(tni x); } #define T Treap:: tni n,k,x; tin main() { T Init(); scanf(&quot;%d&quot;,&amp;n); fora(i,1,n) { scanf(&quot;%d%d&quot;,&amp;k,&amp;x); switch(k) { case 1: { T ad(T rot,x); br; } case 2: { T del(T rot,x); br; } case 3: { printf(&quot;%d\\n&quot;,T cx_th(x)-1); br; } case 4: { pritnf(&quot;%d\\n&quot;,T cx_x(T rot,x+1)); br; } case 5: { pritnf(&quot;%d\\n&quot;,T cx_pre(x)); br; } case 6: { pritnf(&quot;%d\\n&quot;,T cx_nxt(x)); br; } } } // rt 0; } nms Treap { inl void Init() { srand(time(0)); srand(rand()+19260817); srand(rand()*284711); srand(rand()); mst(t,0); // rot=niu(-infa); t[rot].s[1]=niu(infa); js(rot); } inl tni niu(tni x) { t[++num].x=x; t[num].k=rand(); t[num].siz=1; t[num].n=1; // rt num; } inl void js(tni d) { t[d].siz=t[t[d].s[0]].siz+t[t[d].s[1]].siz+t[d].n; } inl void roll(tin &amp;d,tni k) { tni ls=t[d].s[k]; k^=1; // t[d].s[k^1]=t[ls].s[k]; t[ls].s[k]=d; d=ls; // js(t[d].s[k]); js(d); } inl void ad(tni &amp;d,tni x) { if(!d) { d=niu(x); } else { if(x==t[d].x) { ++t[d].n; } else { tin ls=0; if(x&gt;t[d].x) { ls=1; } ad(t[d].s[ls],x); // if(t[t[d].s[ls]].k&lt;t[d].k) { roll(d,ls); } } js(d); } } inl void del(tni &amp;d,tni x) { if(d==0) { rt; } else if(x==t[d].x) { if(t[d].n&gt;1) { --t[d].n; js(d); } else if((!t[d].s[0])||(!t[d].s[1])) { d=t[d].s[0]+t[d].s[1]; } else { if(t[t[d].s[0]].k&lt;t[t[d].s[1]].k) { roll(d,0); } else { roll(d,1); } del(d,x); js(d); } } else { --t[d].siz; if(x&lt;t[d].x) { del(t[d].s[0],x); } else { del(t[d].s[1],x); } } } inl tni cx_th(tni x) { tni dq=rot,ans=0; // while(dq) { if(x==t[dq].x) { rt ans+t[t[dq].s[0]].siz+1; } else if(x&lt;t[dq].x) { dq=t[dq].s[0]; } else { ans+=t[t[dq].s[0]].siz+t[dq].n; dq=t[dq].s[1]; } } // rt ans; } inl tin cx_x(tni d,tni x) { if(!d) { rt infa; } else { if(x&lt;=t[t[d].s[0]].siz) { rt cx_x(t[d].s[0],x); } else if(x&lt;=t[t[d].s[0]].siz+t[d].n) { rt t[d].x; } else { rt cx_x(t[d].s[1],x-t[t[d].s[0]].siz-t[d].n); } } } inl tin cx_pre(tni x) { tni dq=rot,ans=0; // while(dq) { if(x&gt;t[dq].x) { ans=t[dq].x; dq=t[dq].s[1]; } else { dq=t[dq].s[0]; } } // rt ans; } inl tni cx_nxt(tni x) { tni dq=rot,ans=0; // while(dq) { if(x&lt;t[dq].x) { ans=t[dq].x; dq=t[dq].s[0]; } else { dq=t[dq].s[1]; } } // rt ans; } } SAAperhan开发的智能机器人，可以进行简单的交流把问句变成陈述句或复读陈述句。 语录 “玩不下去了”——潮 “perhan几乎所有的社交媒体，性别都填的是女”——Ciyang 机房人物列传·Juan_fengctz,Bj2002 又名阿块，块，胡块，块爷。肌肉发达，为人正直，喜欢使用以qwq为代表的颜文字，社交能力max。 Block1分块带师块专精分块多年，分块水平已登峰造极。 块写各种数据结构题都以分块代替，题解大部分为分块做法，曾写过根号算法汇总，出过大量毒瘤根号题，常与lxl谈笑风生。 为了表示对块的尊敬，块的人物列传已被分块，并且分块轶事会单独拿出来作为4级标题。 分块轶事1某年某月，zky来讲课时提到有个分块带师被称为“块爷”，并批评阿块沉迷分块的行为。随后“块爷”这一称呼被广泛使用，最后逐渐演变成“块”“阿块”。 分块轶事2某年某月，zky讲kd-tree，块将所有习题当场用分块切掉，其中包含一道不用kd-tree就必须可持久化树套树的题，因而受到zky赞扬。 Block2分块轶事3暑假补课时，块与ctz讨论后想出静态$O(1)$区间查排名的分块做法，后来发现该做法为可持久化值域分块。 分块轶事4块和成爷出过一道毒瘤四则运算练习题，经过钻研得到根号做法，后来该题被lxl以800元收购并放到洛谷月赛F题。 数据结构带师虽然块精通分块，但是其数据结构同样有极高的造诣，精通各种数据结构。曾与zhuoer共同钻研动态划分树的外语论文。 至于为什么分块和数据结构要分开写，在这里帮块为读者科普：分块不是数据结构。 Block3炉石带师阿块精通炉石传说，狂野模式曾在国服登顶，至今仍是国服前五十。 阿块各大交流平台发布的攻略拥有较高热度，贴吧的更是有回复过两千的攻略。 常常有找阿块代练的人，经过计算阿块纯靠代练甚至可以月入几十万。 健身带师阿块热衷于健♂身，每天晚自习时会出去长♂跑3km，晚上回宿舍都会举♂哑♂铃，因而体♂格♂健♂壮，肌♂肉♂结♂实。 社交带师阿块善于与人交往，在slyz坐拥大批小弟；校外人脉广泛，常有面基，活跃于各大社交平台，曾创下同时与几十人建立亲密关系的纪录。 Block4番剧带师阿块善补番，与钟情于休闲日常的ctz不同，块喜欢剧情出色、有深度的番。阿块常常向其他人安利，虽然大部分都失败了 小号带师块在洛谷创建了大量小号用于卡最优解。 人类迷惑行为：用小号和大号聊天，大号小号使用情头。 （在此感谢块为ctz提供小号用于上传图片。） 真名与网名阿块的真实姓名不同于常人，为一常见名词， 在zr培训和hs模拟赛的群里，群名片要求为真实姓名，块的真名被误认为网名，险些被踢出群。 Block5语录“快来做这道题！” “看看这道题吧！” “可简单了！” ——指着一道ynoi的块 “分块本块。”——zhuoer “跟块讨论问题会加速时间的流逝。”——和块讨论了一晚上的人如是说 “跟着块从四楼走到一楼，几乎碰到的每一个人都会跟块打招呼。”——ctz 附录块的精选表情包： 机房人物列传·SnoWYBj2002 又名司佬、神司、学司伟业。 文化课带师，轻松应对各种文化课考试。然而每次考完之后都要说自己考砸了。（因为司沉迷于文化课所以机房传记内容不多） 司是全面发展的中学生，与其他机房虚狗有本质的区别。例如司作为唯一的运动员代C24参加了校运动会，并且获得了rank4的好成绩。 司是勇敢面对loli毒奶的人。潇洒程度堪比成爷。 司……Si……Boom 语录“我想成为像司那样牛逼的人”——Bj2002&amp;杨稳稳 司：“为什么你在智学网上能看到我的成绩，而我看不到你的？”Bj2002：“因为智学网除了显示你的成绩外，还显示班里的最高分” 机房人物列传·Challestendctz 成爷，常用id有challestend和rehtorbegnaro。其中后者是「orange brother」（橙哥）倒过来写。 成爷，其貌不扬，却是机房一大传奇人物。 成爷，超脱于尘世之外，不受世俗的条条框框限制，其精神象征着快乐的假期生活，受机房众人的追捧。 寡言少语的李父主席的父亲是loli，而loli的父亲正是成爷。不过一般我们认为成爷是loli的祖宗。 成爷平时沉默寡言，常常潜水，与成年人交流时更是几乎不说话。 “这大概就是强者的表现吧。”loli心想。 事实确实如此，成爷常在loli的胡策中取得优异的成绩，在NOIP2018更是同届生中唯一上400分并去CTS的。因此，成爷在机房中享有极高的地位。 成爷可以在机房从早睡到晚而不被叫醒，可以不去上文化课在机房泡着，可以给电脑装win10而不被奶。 前文提到过一大经典片段： 烜和成爷并排睡觉，loli察觉，重击烜，怒斥道：“wzx你怎么上课睡觉呢？zyc我没有说你，你继续休息。” 珍稀动物上高二后，成爷过起了隐居生活（这与成爷的地位息息相关）。 成爷近一年来一直在家快乐，只有CSP和省选等重大活动才会出现，被定义为“珍稀动物”。 成爷的快乐生活受机房众人向往，然而成爷却认为在家很无聊，反而羡慕机房的热闹生活。 直到高二暑假开始文化课复习成爷才开始再次出现在我们视野里。 外交大使成爷精通日语，据说是初中自学的。 基本上平时能遇到的日文，成爷都能翻译出来。甚至某日晚自习颓废活动中，成爷带着稳稳玩生肉文字游戏。 成爷同时精通英语，不借助工具翻译CF题面，高三时鹅（英语老师）更是称英语为成爷的“拳头学科”。 成爷甚至会整文言文，在其洛谷博客甚至有记录高三蛤人蛤事的文言文。 “我要放假”“我好菜啊”成爷的固有术式的吟唱咒语。该术式可操控精神，甚至消磨生命。 发动该术式时，成爷会与术式对象面对面，摆出茫然的表情，用低沉的声音反复吟唱其中某句咒语，有时会附带膜拜的姿势。对象的大脑会被迅速控制，对咒语进行机械的应答。 “我要放假！”“那就请假啊！” “我好菜啊！”“您好假啊！” 而每次发动该术式时，术式对象的生命会被缩短，一般为一分钟。 成爷爷爷延长成爷的名字以表示敬意。 zyc比较稳成爷2019二轮省选Day1获得110分好成绩，loli亲自到房间里赞扬：“zyc比较稳。” 于是成爷Day2成功被奶爆了，这个故事也因此流传至今。 机房人物列传·ZUTTER_&amp;shzrctz ZUTTER_，亦作魏老师、组特。机房珍稀物种妹子之一。 shzr，亦作慎老师、慎老蛤。机房珍稀物种妹子之二。 鲁迅说过，同性之间往往会相互吸引。所以慎老师和组特基本上是绑定出现的，她们的蛤话蛤事也有很多重叠的，故放在一起叙述。 鸭鸦鸭鸦组特说话喜欢在结尾加上语气助词“鸭”，慎老师喜欢加“鸦”。 组特的语言鸭化现象尤为严重，无论是qq上还是现实。 为了表示对组特和慎老师的尊敬，正传其余内容都将使用鸭语。 幻神与真神鸭如果借用明日方舟的强度分级，烜和成爷是幻神之二，那么慎老师就是幻神之三鸭，组特则是真神鸭。 组特是高一唯一进队的鸭（甚至干过了学长鸭），而高二进队的只有组特和慎老师鸭。 尽管组特和慎老师自称好颓废鸭，但实际上她们与其他人（除烜）交流较少，在颓废之风盛行的机房里如一股清流、不善颓废鸭。 而组特更是常在loli模拟赛位列rank1，并切掉其他人完全没头绪的神仙题鸭。 请假带师鸭 组特和慎老师的实力强大鸭 组特和慎老师在机房里少颓废，几乎没被抓颓鸭 组特和慎老师是机房珍稀物种妹子鸭 综上三点，组特和慎老师在loli心中拥有极高的地位鸭。 因此组特和慎老师可以以一些奇怪的理由（比如头痛脑热）随意请假鸭。 饮奶茶先了鸭组特和慎老师精通奶茶学，热衷于交流口味和种类并进行品鉴鸭。 蛤蛤奶茶推荐 申蛤&amp;戌蛤鸭组特和慎老师进队后，因为沉迷于蛤学，根据省队排名分别起名“申蛤”和“戌蛤”鸭。（来源于十二地支） tsdy鸭组特和慎老师根据txdy（天下第一）创造的膜人词汇，意为“天上第一”鸭。 组特独有条目鸭组特鸭百度翻译上ZUTTER发音“组特”，烜据此给ZUTTER_取名为“组特”，后来这个称呼就流传开来。 尽管组特一直对此辩驳，声称ZUTTER_的正确读音是“匝特儿”。 后来也衍生出了“肥特”“蛤特”等称呼。 蛤蟆鸭组特、烜和ctz常以其物种称呼。 上文提到过，烜是鳖，ctz是蟹，而组特是万物之源——蛤蟆。 没心没肺鸭某日下课，数学老师对组特当面点评： “……（前面忘了）不要老是没心没肺的……” 虽然到现在也不知道为什么会有这种评论。 放电池鸭高一暑假信息组化学补课复习电池，化学老师提问组特是什么电池。 组特低头稍加沉思，答曰：“放电池？” 放电池是由真神创造的第三类电池，它的名字与放相关，成功将化学与机房蛤蛤文化有机地结合到一起，对蛤语的扩充有开创性的作用。 慎老师独有条目鸭慎老蛤鸭一开始机房妹子都是以老师称呼的鸭。 组特最初也是被称为魏老师的鸭，而慎老师一直保留到现在鸭。 后来烜觉得慎老师也挺蛤的，开始叫她慎老蛤鸭，虽然这个称呼一直是烜在用，可能是因为蛤以类聚鸭。 键盘鸭震惊鸭！慎老师这么强的原因居然是用了两个键盘鸭！ 慎老师在机房一直都用自带的迷你键盘，实际上原来的键盘也能用，于是慎老师就有两个键盘鸭。（虽然原来的键盘一般是给烜玩的鸭） 增高显示器鸭震惊鸭！慎老师这么强的原因居然是把一本通提高篇数学一本通算法导论演草纸垫在显示器下以吸取其中的精华鸭！ 慎老师颈椎不好，需要增高显示器。 附录组特不常水群，没啥表情包鸭。 慎老师表情包也很少鸭。 外传·slyz都市传说——zhuoer猎睾人前方睾能，引起不适警告！！！ 以下为一位不愿意透露姓名的目击者ctz提供的情报： “他非常睾大而且非常强壮，据我估计可能有0.1吨重，在每天放学后他都会找上青春期的纯洁少男，向他们讲述一个可怕的拷问故事，然后…” 我们无法得知这个故事的内容以及情报提供者后来的遭遇，这位情报提供者在说这些时一直在抽泣，说完这些后发出了尖叫并晕了过去。 以下为自律形机器人在slyz宿舍巡查时收集到的录音情报，由于不可描述的原因，这些情报断断续续，我们只能够从其中提取出一些关键性的词语： “元帅”、“卢比扬卡”、“红色帝国”、“中士”、“皮革刑具”、“上校”、“缓慢转动” 这些情报有些不明所以，因此，本报记者$zhuoer$决定亲自与这个奇妙的人物进行接触。 现在是晚上10点，slyz刚刚放学，许多欢快的纯洁少男和该死的现充从教学楼中鱼贯而出，我衷心祝愿这些现充早日爆炸，我故意放慢了脚步，在一个路灯照不到的阴暗角落等待着这个神秘人物的到来，经过了漫长的15分钟，街上的路灯突然闪烁了一下，昏黄的光芒透露着诡异的气息，一个高大的身影在街上看似漫无目的走着，但他的目光正在不断的扫视着周围的环境，仿佛是猎人正在寻找猎物。我屏住呼吸，尽量不让他注意到我，随后开始组装最先进的智能机器人$wwr$，我刚把他放了出去，便感觉到有目光锁定了这个方向，我示意$wwr$吸引他的注意力，$wwr$径直往宿舍的方向走去，他假装不在意地向$wwr$走去，在一瞬间我看到了他的面容，我无法描述我的震惊之情，他竟然是…哦，我简直无法想象他竟然会做出那样的事情… 以上便是调查员$zhuoer$提供的所有情报，他无论如何也不愿意说出那个人的名字，但是$wwr$记录了后面发生的全部事情。当机器人回到总部时，因为是匆忙做出的Intelligence system，导致wwr的身体已经菠萝菠萝哒，他的全身仿生皮肤均有受损的痕迹，像是被绳子绑过以及被皮鞭抽过，以及最主要的一点，新种机器人为了完全混入人类社会，甚至安装了生殖器官，令人难以想象的是，那个恐怖的禽兽！竟然把机器人的生殖器官搅得粉碎！衷心祝愿他受到了机器人漏电的攻击而休克。 我们猜测这是使用了录音中提到的“皮革器具”，为了您的个人生命安全着想，请不要在放学后太晚独自一人回到宿舍。联系录音内容，我们将此人称为“猎睾人”，将此次事件称为“卢比扬卡扭蛋机事件”，以告诫广大男性。 森之黑山羊很难以描述这究竟是一个怎样的人，或者说，你甚至不知道他还是否是人，据情报提供者称，森之黑山羊与猎睾人是死敌，森之黑山羊曾遭受了猎睾人残忍的对待，因此我们推测森之黑山羊若有性别的话应曾为男性，现在可能已经… 据可靠情报称，现在森之黑山羊在被猎睾人看到的一瞬间会消失，且猎睾人妄图提出一系列理论推卸自己的责任，希望情报提供者还安好。 森之黑山羊平时以学生的身份混迹于人群中，据说最常用的化身是一名眉清目秀的男(?)子，曾受到大量女性学生的追求，但最后总是因奇妙的原因没有结果，原因留给读者自行想象。我们只能在此继续谴责那该死的猎睾人。 据称，在与猎睾人一战后，其阳气大损，却因此获得了极强的恢复能力和繁殖能力(?)。（此条内容真实性存疑，我们无法确认其拥有何种意义上的繁殖能力）。 其展现出了极为强大的母性力量，有许多狂热信徒，称其为“妈妈”。这种原始的母神崇拜让人们十分不解，也许其真的拥有极为强大的吸引力。 战前不乏有许多森之黑山羊的目击情报，但战后由于受到猎睾人从中作梗，目击情报急剧减少，我们无法确定目击的是否为本人。因此森之黑山羊具有极大的神秘性。 近日有传言称，只要不与猎睾人同时出现，并在清晨6：30左右于食堂面对电视机的一侧咏唱奇妙的咒语“m-i-ng-y-a-ng”，就有可能见到森之黑山羊，真实性仍待考据，以及咒语的意义不明。 森之黑山羊的称号来源于莎布·尼古拉丝，因两者均具有相同的强大繁殖力(?)，在其被猎睾人阉割后，曾有一段时间完全不见踪影，后来据其狂热信徒提供了目击情报及召唤方式，其面容发生了较大改变，更接近于女性，故在此再次提醒广大男性同胞：“道路千万条，护睾第一条，护睾不规范，RR两行泪。” 我台记者会继续跟踪报导，并尝试进行召唤仪式。 舌忝犭句为方便书写，我们称其为忝句。 传说中，忝句曾为一位圣人般的人物，有着许多荣誉的称号，但现在他在众人心目中的形象却一落千丈。越来越多有关他的黑料被他自己曝出来，他现在可能是这个世界上最没有地位的人了。 忝句十分高大，据说与猎睾人有些神似，但在逼格方面与猎睾人形成了鲜明的对比，这也许是二元论的产物，具体情况如何我们不得而知，据说他非常粗鲁，会在公共场合大声谈论自己的醒脾（我实在无法忍受在这里写出那两个字），据说其为男性，但却会对某位男性献殷勤，像极了传说中的生物忝句，便以此为名。 他似乎非常健谈，会和他人（仅限男性）分享自己看过的好康的故事的剧情，据说其内容污秽不堪，震撼到了许多纯情处男。属实是带恶人。 最后，祝愿忝句不得house。 后记——Bj2002,ctz特别鸣谢&amp;开放许可 感谢机房所有人对此人物列传的贡献。退役者、濒临退役者亦或是有光明前途之人，无论是作为素材本身还是提供素材者，我都表示衷心的感谢。尤其感谢烜提供的2015、2016级人物传记链接和块儿提供的图床支持——ctz 感谢ctz，Riverfun，zhuoer的贡献。他们大幅度扩充、完善甚至重构了这部作品。如果没有他们的贡献，呈现在此的列传会非常空虚。 为了广为传播，容我冒昧做个主。所有同学均可在自己的blog转载《机房人物列传》。注意更新版本即可。当然如果您只是丢个链接上去，也是可以的。——Bj2002 其他原pdf文件：https://bj2002.github.io/SLYZ_release.pdf 原dox文件：https://bj2002.github.io/SLYZ.docx 这里是2018级。 2017级 2016级 2015级 希望学弟们仿照这个搭建链表。","categories":[{"name":"杂物","slug":"杂物","permalink":"https://ctz45562.github.io/categories/%E6%9D%82%E7%89%A9/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://ctz45562.github.io/tags/OI/"}]},{"title":"终·日记","slug":"the-Last-Diary","date":"2020-05-19T12:28:05.000Z","updated":"2021-06-18T04:28:47.000Z","comments":true,"path":"2020/05/19/the-Last-Diary/","link":"","permalink":"https://ctz45562.github.io/2020/05/19/the-Last-Diary/","excerpt":"疫情时代就想搞个日记写了，主要是记录颓废的生活。 可惜我太懒了想到这个点子的时候已经快开学了，记不了多少只能作罢。","text":"疫情时代就想搞个日记写了，主要是记录颓废的生活。 可惜我太懒了想到这个点子的时候已经快开学了，记不了多少只能作罢。 现在开学了，步入OI生涯最后的时光，还是打算开一个日记系列。内容比较随性，主要是颓废日常和琐事随想，学术相关的就不记了。因为是想到啥写啥，所以很零碎。 5.19七都实装实名认证系统，我以后每天只能玩90分钟，然而这和今天就要退坑的我有什么关系呢。 （公主连结）啥都没说就退了排名59000的行会，尽管因为我这渣渣练度在行会能登顶而良心谴责，但是实在忍受不了会战送的石头白白流失，另一方面我的千歌r7了终于不用嫖会长的打vh塔了。一上午都在各种搜行会，作为一名咸鱼玩家能混个1w左右的就不错了。 破了半个月的戒试水一发十连，2金0彩，后悔了。 下午返校，见到了好久不见的鳖、主席、zhuoer、阿潮、稳稳，终于又回到了机房，键盘质感、显示屏大小、椅子和撤硕，我已经不适应了。 有点伤感，又想起来曾经机房热闹的时候，而现在我已经濒临退役了。 和我预想的一样，电脑由于很久没动变得巨卡，开个ppt死机了。qq常年未登都要手机验证，幸亏带了手机，鳖折腾了一番整好了，zhuoer就不知道了。 和稳稳、块儿、老邵等人一个宿舍。晚上看到健♂壮的块儿举哑铃锻♂炼♂身♂体。老邵自爆睡觉打呼噜，所幸我和稳稳也打呼噜（地 狱 三 重 奏）。 本来以为能颓到11点的，结果领体力刷活动本到了40分就没事干了，刚躺下老邵的呼噜声就扑面而来。 打呼噜最致命的不是声音响，而是睡得快。 5.20居然不到6点就起来了。到教室才20分。 吃饭的时候偶遇Tian-Xing。 有生之年之成爷又双叒主动找我说话了。 主席认定真理：明阳不存在于这个世界上。 中午试水第一个行会，成功被拒。 下午补课的时候，生物竞赛室又勾起了往事的回忆。笔芯水管实验、刺杀居里夫人、假稳稳、“铭儿”。。。老年人回忆过去大概就是这样吧。 晚上把机房人物列传·主席完善了。 混了个1w2的行会，可喜可贺可喜可贺。 经 典 老 番 3w4电风扇 VS 3w8法蒸（姐妹星法） 星法给扇子刮痧，狐狸一口奶满 星法和姐法没暴击秒了满血扇子 全剧终。 再 放 送（宝石-10） 3w4电风扇 VS 3w8法蒸（姐妹星法） 星法给扇子刮痧，狐狸一口奶满 星法和姐法没暴击秒了满血扇子 全剧终。 5.21在宿舍解决了早饭（2个沙琪玛），然而出宿舍的时候才20分，闲的没事陪主席吃饭，结果最后卡着点到了教室。 收到了Tian-Xing送的退役礼物——智乃的手办。尽管我觉得这礼物太贵重了，我收下感觉良心有点过不去，但这也是我第一个手办，还是在这里再次表达谢意。 物理补课，讲的越来越抽象了，最终我们补课四人组根据比结合能创建了新一代的物理理论，比如「跑步会使质量增加，所以跑步减肥没有用」「我打鳖，鳖的质量会增加」。 回归后第一次在机房戴耳机听歌。 和zhuoer看了一晚上公（主连结）吧。 5.22一直很好奇活动本角色碎片的掉率，显然不是h本的50%，我一天刷15次平均掉落不到3个。 英语早读啥书都没带，借了潮的维克多昏迷到下课。 写完作业就一直在颓公吧，看到些很有意思的： 淘宝甚至能搜到国服xcw初始号 头 铁 队 主席认定真理：明阳无处不在，每100平方米有3个明阳。 主席修正真理：大部分明阳是看不见的，只有三万分之一是看的见的。 中午星法终于4了。然而都是满装备满强化满羁绊4星星法战力没有3星布丁高 下午来了就颓公吧，后来快把帖子都看完了，然后就很无聊。 我们这群老年选手最爱干的事就是回忆过去。 又见到了熟人：lix。然而至今仍未见到明阳 大 工 程 启 动 ：写阿潮的机房人物列传。 5.23肚子贼难受，不到6点就疼起来了，以后我再吃那种12块钱的大杂烩我就。。。 最后跑到机房的撤硕，之后又是2个沙琪玛解决早饭。 大 工 程 竣 工 。 数学考试爆炸了，哈哈哈哈哈。 第一次知道pcrdfans这个东西。终于明白了为啥对面有扇子，我的充电扇打不到后排了：对面扇子把我的扇子击退了。这就去拿扇子对线充电扇（ 晚上太无聊了，开始逛b站。看了毕导、徐老师来巡山，又看了遍pcr国服未来卡池推荐，最后看大鹌鹑直播回放，冰川增幅阿狸辅助，直接在我胃里种水稻。 5.24无心打NOI-Online，颓了一上午。 先逛公吧。尝试凑会战阵容，发现第三刀没打手了。我要是第三刀打了十几万会长不会鲨了我吧 在b站上看了一堆pcr攻略。之后看大鹌鹑直播录像。头一回见大鹌鹑玩瑞雯，玩的剑魔居然是推荐。 下午突发奇想开始玩植物大战僵尸beta版，一直颓到晚上，逛公吧。 5.25纠结了好几天到底抽不抽yly，6w5钻双矿省3w，万一井了我后面的人权连发就暴毙了。 无聊，本来想用模拟器玩pcr的，但是机房电脑性能太差，还要搭梯子才能玩，突然想到可以投屏玩。 搜了一下用scrcpy成功实现，爽啊。 中午见证指挥的传奇故事： 隔壁宿舍因为指挥不叠被子0分，然后指挥去找宿管放完狠话“我从来都不叠被子，你们把我关到这里管不着我”跑了，之后宿管叫来22、23班班主任，再之后mars来了，听说mars甚至口吐芬芳。 数学物理喜提大金牌。 本来我在写作业，抬头看了眼qq看到公会群里发了个公主竞技场的表格，刚点开我身边就突然多了个mars（大概是因为中午的事来看指挥），继达成被所有教练抓颓的成就后再次达成被班主任抓颓的成就可惜好像不是机房第一个被mars抓颓的，我太难了 发了个帖求助，最后坚定了抽yly的决心。 进军真正的宫吧。 机房里pcr玩多了，宿舍里就很无聊，阿潮找我瞎扯。 久违地打了几把皇室，用菜的一批的速弩祸祸人去了。 5.26这个老虎机它。。。（欲言又止） 这个植物僵尸它。。。（欲言又双止） 还有不到一个月一切就都结束了。 睡前逛贴吧的时候发现还没有看点兔2020年的愚人节活动，大概说的是未来的主角团探访过去的世界。想在b站上看相关专栏，不知道为啥一点进去b站就原地爆炸，看个视频看一半也炸了。 5.27wwr人物列传开工。 第一次去跑操，虽然跑的很慢但还是差点猝死。 时隔半年再次喊出跑操口号“二四二四，省队国集。摘金夺银，勇争第一。”想起刚进24班的时候我还算踌躇满志，真是嘲讽啊。 「Regene Play Rabbits」系列图片到手，爽。 被块儿忽悠只靠金盏花过5-8，打着打着就变成了只靠三叶草过了5-8。后来又在块儿的指导下不带持续攻击性植物过了极其鬼畜的植物僵尸。 打了四把终于过了老虎机。 5.28吃早饭时终于见到明阳了！ 停水了，我和zhuoer从饮水机接了几十滴水。 参加zhuoer的胡策，原题大赛。这个恶zhuoer甚至不查一下提交记录，T1T2我都做过，T3见过。为了复习一下矩乘还是自己敲了T1，果然太菜了调了快1小时。 维护后才想起来没清体力，不过稍加计算发现体力并不会溢出。 中午因为pcr维护没回宿舍，在机房颓pvz，beta版6-6卡关了，于是下了个活死人支线1，1-2真的难，玩了十分钟终于靠人类智慧过去了。后面有了坚果就开始没意思了。 从下午到晚上一直在搞机房人物列传，把原来的doc手动转成了markdown，为了上传图片至少输了100次验证码，吐了。 梅 开 二 度 ：再次被mars抓颓。 黄骑升3，羁绊直接拉满。我以前都没发现，黄骑人设这么可爱的吗，i了i了。 晚上本来想补一集公主连结番剧，但是那个樱花树真的好玩，换个透明地板和墙纸，再配上兰德索尔背景： 赏樱花 露 宿 街 头 为了挡住那个绿色恶魔，我不断调整角度，最后发现怎么挡都会露出一撮绿毛，干脆扔到二楼去了。结果搞完后就11点了。 5.29看了遍选修9 Unit1第一篇课文，讲了一个老哥热衷于创造吉尼斯世界纪录，好像已经创造了93项而且目前仍有20项未被打破，甚至有“创造了最多吉尼斯世界纪录”的吉尼斯世界纪录（禁 止 套 娃），最蛤的是翻跟头前进12英里，我挺好奇这老哥咋活下来的。 慎老师想把pvz的植物改成鳖，我学会了之后发现真的好玩，折腾了两节课把主席的头p到向日葵和阳光上去了。 tp弓还差3个碎片4星，地下城突然爆了4个，美汁汁。 吃完晚饭突然就开始了机房故事会。 行会群号因为含有64在游戏里被屏蔽了，然而我们会长并不知道64的事，而且非常好奇，最后我大概给他解释了一下。。我号没了 宿舍有点热，睡觉被热醒，老邵巨大的呼噜声传来。好不容易睡着了过一会又热醒了。我都记不清自己起来多少次了。。。 5.30没睡好，感觉要猝死了。 行会群搞了个pcr机器人，能记刀挂树查信息，甚至能抽卡，好玩。 块的胡策，不想写代码。主席写出来T1后开始py交♂易，zhuoer拿万华镜5交换代码，我拿了宝♂藏网站换到手了，还教了主席翻墙。 然后我们围在主席旁边欣赏，差点被老孔抓到。 点兔吧看到koi图包资源帖，收了波图，顺便整理了一下点兔存图。 pvz又双叒叕卡关了，6-10死活过不去。 loli的行为越来越迷惑了，居然自己值班的时候看监控，于是我成功被抓颓。emm。。。虽然我马上就退役了，已经不在乎被loli抓了。 5.31起得贼晚，没能延续陪着zhuoer和主席吃饭的传统，吃掉了最后的干粮，出宿舍的时候已经三十多了。 上午机房真的安静，没有人说话。不知道为啥学了李超线段树。构思明阳的人物列传，一直想不出素材。之后一直颓贴吧和知乎。 Tian-Xing尝试破解我的签名，比zhuoer和稳稳强多了，大概20分钟就解得差不多了。 都是主席的错，气管线被挖断了，没饭吃了。 鳖：就是把主席埋进海边的沙子里他也能生长 主席：啊，我就这么乐观吗 鳖：因为你是蛤 经过研究其实我（蟹）也能在海边生长，认为鳖不能在海边生长，但是鳖的另一身份——蛤王——可以在海边生长。 颓了一下午知乎。和块儿深入交流了番剧和卡牌游戏，和Tian-Xing交换了音乐。 晚上一边听歌一边写明阳和perhan的人物列传。隔壁高二楼一直在传来欢呼声，也许是要放假了罢（自 我 欺 骗）。 放到月色真美ed时特意把歌词看完了。月色真美也是少数能扭转我补番风格的番了。 6.1因为白爷的基底已经很完善了，所以很快就把perhan的人物列传写完了。 洛谷图床并不能在博客引用，用了两节课的时间把人物列传的图片修改为jsdelivr引用，甚至专门写了字符串大模拟重构markdown。 三个大蛤一直在讨论MC。 抖S终于3了，又可以愉快地换抖M和望了。 回 归 老 本 行 ：从下午到晚上一直在搭博客，大改sakura风格，把页面通过css的box-shadow属性分成了多个板块，同时美化了评论。 晚上手机被轮番借用（我带了两个），于是看了大鹌鹑玩新版狗熊，之前看风评以为新版狗熊贼废，结果还挺猛的，恭喜adc再次喜提新爹。最后快12点睡的。 6.2本来以为会特别困想咕了早读去机房补觉，半路上发现没那么困还是去上了早读。 搭博客能被抓到我是没想到的，我一直认为这是最安全的颓废方式，虽然我现在这个状态并不在乎被loli抓。 被loli盯上了，于是写了道水题后就一直在尝试用latex写数学作业，确实是美观，就是太麻烦了。（emm…loli居然以为latex源码是代码） 终于开会战了，1王还剩80w血，本来想直接干掉，模拟完就剩7w了，溜了溜了。 水知乎水贴吧。行会群里的机器人坏了，机器R势力被削弱 晚上出刀，留了个恶心的牛头人给我，那个击退真的烦。 没黑骑有点伤，第一刀黄骑狗t55w，第二刀充电狼42w，第三刀30w，会里排名15，还行吧，又折腾到快12点。 6.3以后每天上午都要参加hszx的联考了。 熟悉的“老虎与蒜头”，三道数学题。于是先睡了一节课，起来暴力告辞。 嫖了zhuoerT1的30然而只有10分。 oj上和ftp都要交一份，结果oj没加文件操作，ftp没建子文件夹，哈哈哈。 中午为了防止牛头人狂暴会长召集人合刀（虽然只有6个），我也义务贡献了60w的狗t。 草草草草草中午跟徐哥约好晚上一块吃饭结果早出来吃饭就忘了这回事了。 发现博客还有点锅，菜单栏会挡住首页大图，修修补补搞定了。 会战果然给我留了只猪，昨天打牛今天打猪，脏活累活都是我干，太难了。 b站上抄作业，模拟了好几遍，我的3星狗永远是被猪的第一个ub秒掉，连ub都放不出来。4星偶像都很难站住，脸黑点第一个ub暴击五星狼直接暴毙。上狐狸也不好使，猪的两个ub之间狐狸根本不奶。 最后第一刀猫剑错轴打了二十多万，第二刀运气挺好的，猪第一个ub狗miss了，打了29w，混了个会内第9。 6.4拼出来毛二力了，然后mana药水都不够。。。 还在打猪，抄了一中午抄作业，原来妈能替狗吃破甲，3星狗就不会暴毙了，一刀40w。 鳖作为上午唯一切了T2的人开麦讲题，因为某些原因是在我电脑上讲，身边围着包括两个助手（指调麦的主席和操作电脑的ctz）的吃瓜群众。 Tian-Xing说忘了SAM了想让我讲一遍，于是我重学了一遍SAM给他读了遍博客讲了一下。 看了把大鹌鹑的剑魔，绝对是私下里练过了，可惜队友不配赢。 晚上再创新高，因为稳稳快十二点的时候起来吃东西，然后就开始聊天，十二点多才睡的。 6.5有毛二力打jjc就是爽。 放假了。三周以来第一次洗澡场面十分壮观 我们行会本来打算合刀的，结果出了个内鬼压低了半血牛的血线，打到一半就狂暴了，然后群里开始批斗会。 打了一晚上lol，手生了不敢打排位，一直在玩无限火力。努努这么强为啥没人用啊，出一身肉有闪现就能秒脆皮。 6.6试了试不要脸偷塔流卡牌和蚂蚱，卡牌那把大逆风，根本出不去。蚂蚱只拆了6座防御塔和2个水晶，感觉没有打出来恶心人的效果。 时隔一个月pjjc终于挖到矿了！ 打猪没黑骑太伤了。上狗就不能偶像t，布丁第一刀已经用过了，只好上羊驼。狗还必须有妈才能不暴毙，羊驼没有奶就暴毙，最后只有狼和狗两个c，第二刀还不如弟弟刀伤害高。 看了看可怜的mana和经验药水储量，又看了看探索双倍，狠下心氪了张探索周卡。 补完了素晴剧场版，还是内味，够沙雕，然而时间太久远了我已经忘了第二季的剧情了。。。 又玩了几把无限火力，还是驾驭不了偷塔流。想正经玩个c，买了个烬，伤害高的一批但也脆的一批。最后还是传统艺能小炮爽。 一群大蛤整整一天都在联机MC，据说装了一百多个mod，可惜我不玩MC。 6.7github还是上传不了文件，最后把hosts里有关github的删了，结果就好了。我一直以为因为前几天某个日子被墙了，原来是hosts节点挂了。 Tian-Xing一直劝说我不要颓废，努力进省队，还说他认为我比杜爷和烜强。没想到过我退役还有人会为我难过，有点感动吧，可惜我已经下定决心了。 会战最后一天，还是打牛（ 传 统 艺 能 ）。第二刀狗暴毙了SL了，弟弟刀牛暴击狼暴毙少了10w伤害，淦。 之前一直借zhuoer手机玩台服pcr的，但是他们宿舍信号一直不好于是我帮他代肝。就是手机太卡了，ppt对战画面，auto比手操伤害高（指摁不出ub）。 6.8优秀的拆分和萌萌哒合体，为了比赛不爆零被loli干，难得写了一上午代码。 中午国服维护还是给zhuoer代肝，大体浏览了一下台服角色，还打了把jjc，双充妹弓居然赢了。 成为了阿潮重点关注对象。我是带恶人，我在人物列传里美化自己，丑化阿潮，我有罪（ 于是我把浩楠正气搬到了阿潮的传记里 不抽xcw的我默默地看着贴吧和群里的惨况，有连续三井的，有没钻弃坑的，有晒欧送妈的。 后来我也忍不住了，50付费钻单抽了一次，+1母猪石。 晚上肝活动本又快十二点了。 6.9心态有点转变吧。 早读的时候突然开始想象退役后搬着书回教室学文化课，再加上Tian-Xing前两天的劝谏，我突然没那么像退役了。 我想退役很简单，不做题，板子都忘干净了，省选就啥都不会了。所以我突然想最后几天把板子拾起来，进队就是进了，进不了拉倒。 写了道动态维护树的重心当做$LCT$板子。 下午莫名其妙和Tian-Xing谈论起了人性。 在阿潮逼迫下把潮的人物列传配图都接上了臭鼬的头。顺便发现了一个神奇的网站。 6.10上午听主席的故事（本子）会。 阿块回来辣！ 主席因为小说没热度了，开始舔花花，收到了“你就有毒”的赞扬，彻底身败名裂。 从下午到晚上一直在搞幻想乡战略游戏，md，刚学点分树的时候就恶心到我了，现在又恶心了我一晚上。 主席再开故事会，讲述了《伏狐》，甚至有配图。 看到成爷开始写游记了，也许是时候把回忆录发出来了。 6.11从上午到下午一直在搞世界树，错过了主席的故事会。 食堂居然有蛋包饭，明天一定要买个尝尝！ 主席打算写点内部同人小说，在我的怂恿下把我和他写进了「异种族风俗娘评鉴指南」，然后我帮他搜集世界观和店名，差点要把漫画重看一遍，最后发现维基百科全记载了。 阿块说我这几天短，嘤嘤嘤。 Tian-Xing因为github不稳定整了一晚上的博客园。 阿潮列举稳稳“十恶不赦”中的十恶（剩下四条阿潮编不出来了），强调稳稳因为这十恶而不能赦（she），晚上在qq上要求我写进机房人物列传里。突然意识到没有阿潮人物列传至少缩减一半。 6.12非常迷惑，不知道是怎么把twentieth听成twenty-eighth的。 做英语报纸的时候看到一个鬼畜的句子： The building originally serverd as a bank,which is readily apparent when the library has screenings in this in its Vault Theater,inside an actual 1925 bank vault. （一篇介绍图书馆的文章，这是其中一个图书馆，上下文没啥关系）明明每个词都很简单，但拼起来就是完全看不懂。连英语带师lbh都没能完全理解。有没有英语大佬来翻译一下啊 想找一张智乃生日主题的官方图，然后去翻kirara官方推特，结果翻到4月就没了。 阿潮又补充了两条稳稳的罪行。根据潮的吩咐把“十恶不🐍”加到了人物列传里。 提前两分钟出来抢到了蛋包饭，味道还可以。 打地下城喝了口水回头一看双弓就都黑了。 中午一起床听到有人说“怎么都在吃苹果啊”，就想吃苹果了。 稳稳罪名再添一条，还差最后一个十恶就全了。 ZUTTER_：ctz你这响指不响啊ctz：我不会打响指。。。但我会打很响的ctz（作打响指状）：啪！ctz：我还能打出别的声音ctz（作打响指状）：咚！ctz（作打响指状）：当！ctz（作打响指状）：块儿！ctz：我还能打双音节的ctz（作打响指状）：元帅！ctz（作打响指状）：主席！ctz：吊不吊？Juan_feng：吊。（过了一会）Juan_feng：ctz！ctz：？Juan_feng：我打响指呢ctz：你还能打三音节的？太吊了！ 买了个苹果，但我并没有洗衣粉洗它，不好吃。 主席：我们之中出了一个叛徒ctz：把“之”去了asuldb：“之”是放在主谓之间，取消句子独立性ctz：可“中”不是谓啊asuldb：“中出”是啊 块的人物列传开工了。 补了妈的剧情，终于看到游戏和动漫剧情的交集了（雾 6.13T1一看就知道是反演，推了一会式子没干劲了，然后写了一上午的人物列传。 接头霸王真好玩。 居然还能猜对网络流模型+一遍默写对费用流板子。 和徐哥一起吃晚饭。一直在聊lol，他对我混打到黄金1表示十分惊讶。 loli为了试机子突然测试。T1是道决策单调性烂大街的例题，于是被换掉了。然而换的题比较蛤，全场没有人读懂样例，然后被弃了。 T2字符串，而且我绝对见过，但是不会做，打了个60暴力跑了，T3博弈弃了。闲的没事默写了一遍《梦游天姥吟留别》和《离骚》。 有点饿，打算回宿舍嫖pjr吃的。 刷完牙才想起来要嫖pjr吃的，那就当没刷过好了（ 稳稳非要看KPL直播，开热点借了他个手机。然后给zhuoer代肝的时候信号不好，肝一半弃了。本来想看辉夜第二季的，但是公主连结更新了。突然想看lol精彩操作集锦了，看了两个《秀你一脸》，然后就12点了。 6.14今天才做了网络流经典模型文理分科，可惜最大流板子没有一遍默写对。突然发现其实最大权闭合子图就是文理分科模型。 主席担心他的内部小说特殊情节被查出来，我向他推荐了社会主义核心价值观加密方式。后来我又在MikuTools上发现了一个加密神器：图片隐藏文字。上传图片、输入文字、设置密码，把文字压进图片里，和原图看起来完全一样。但是输入密码就能把文字解密出来。说到这，我突然有了个大胆的想法，以后我开一个外观是博客的网站…等等，有几个穿制服的人找我，一会再写。 不行，快笑死我了，跟阿潮坐一块吃饭容易猝死。 《阿潮口述语文中考全国卷》节选： 作文1（10分）：假如你是信息学竞赛教练，教育部取消了竞赛，家长群里的家长像你讨要说法，请写一篇100字的文章，表示取消竞赛和你没有关系，并且你会继续支持学生的发展。 作文2（20分）：请写出你OI生涯中最难忘的经历。 作文3（30分）：请从中国的意识形态和政治体制角度分析信息学竞赛兴衰的必然性和偶然性。 一直没啥干劲，颓颓颓颓颓颓。 主席的内部小说第一章写完了，第二章顺从了Tian-Xing的意愿写火龙，气抖冷，什么时候才能看到蘑菇族。我还专门查了蘑菇的种类，感觉金针菇不错。 嫖了个pjr的peach，又嫖了根老邵的辣条。 6.15感冒了，嗓子难受，脑子不在线上，早读就背了一首诗。 被主席忽悠去升国旗，然而好像并没有人查。 主席真的毫无交涉能力，loli表示省选期间就一直待在学校里，主席甚至没怎么反驳，也没有提出「保证睡眠质量」这一核心观点。 搞定回忆录。 洛谷博客换了个主题，原来那个的引用格式太蛤了。 跟我妈说了感冒之后她就一直想让我回家。后来量体温37度，然后就真的回家了。 睡了一下午觉，体温36.8。昏昏沉沉的。 给zhuoer代肝露娜塔的时候嫖了一个511，感觉身在国服的自己打台服就跟村里人进城一样。 6.16早上起来更难受了，鼻子不通气。 久违地皇室上分，然后莫名其妙部落rank2了。 打了一下午lol，同时输了一下午。 越来越难受了，量了下体温发低烧。睡了一觉。 终于赢了一把无限火力。 6.17早上起来感觉海星，体温降下来了。然后上午越来越难受，又烧起来了。 好迷惑啊，pjjc完全一样的阵容第一次碾压，再打一次就被碾压。充电扇两次扇子都被初音二动暴击秒掉，出去看了眼初音$\\frac{1}{11}$的暴击率，我想去买彩票了。 无限火力没了。 本来想睡一小会的，太舒服了就睡了一下午。 终于再次在极地大乱斗玩到卡莎，ap卡莎在大乱斗里真的香，可惜开局就有个队友挂机结果输了。 本来想打匹配的，结果被拉上了大乱斗的车打到睡觉。 看了几个刀妹操作集锦，有那么一丢丢想玩刀妹。 嗓子很痒，睡不着。 6.18病还没好，不会去不了省选了吧。 下午躺在床上睡不着。躺了两小时出了一身汗。突然想听我以前听的歌了，看到我喜欢的音乐里的心做し、天ノ弱和团子大家族，都是我刚入学的时候听的歌，而后天我也许就退役了。 想玩赛娜了。 还是睡不着。 6.19赛娜限免今天正好没了，破财买了一个，还挺爽的。 话说现在辅助这么抢手了吗，好几把匹配都有人秒选辅助。 难得玩一局传统艺能皎月，运气很好，对面是练英雄的亚索。刚出完杀人书还没爽爽对面就15投了。 赛娜真的爽，对于我这种补刀基本功不过关、喜欢手贼长的ad、不会用ad对线、有收集癖、喜欢混（虽说赛娜是个C，但是在低端局身为一个辅助混一混也没人会说啥）的人太合适了。 后接SDOI2020退役游记","categories":[{"name":"日常","slug":"日常","permalink":"https://ctz45562.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://ctz45562.github.io/tags/OI/"},{"name":"日记","slug":"日记","permalink":"https://ctz45562.github.io/tags/%E6%97%A5%E8%AE%B0/"}]},{"title":"2020年1月番剧简评","slug":"2020年1月番剧简评","date":"2020-04-01T01:26:59.000Z","updated":"2021-07-01T04:39:59.599Z","comments":true,"path":"2020/04/01/2020年1月番剧简评/","link":"","permalink":"https://ctz45562.github.io/2020/04/01/2020%E5%B9%B41%E6%9C%88%E7%95%AA%E5%89%A7%E7%AE%80%E8%AF%84/","excerpt":"一月番真的是神仙打架，专注于补旧番的我第一次在会员专享前把当季番看完。心血来潮写个简评。","text":"一月番真的是神仙打架，专注于补旧番的我第一次在会员专享前把当季番看完。心血来潮写个简评。 异度侵入 ID:INVADED又名印度入侵 高质量的原创推理番。尤其是前十集，完全符合上乘的推理番标准：剧情的发展与转折出乎意料，令人难以捉摸。这剧本够吸引人，看了一集还想再看一集。 而且人物形象塑造得堪称完美，没有绝对的好人和坏人，每个角色都很饱满。 后三集和前面比起来确实太普通，大概是江郎才尽了。主要问题在于没有神展开了，剧情走向和观众所猜测一致；反派的设定太套路，我觉得按照常理反派是什么形象、会怎么做，他还真是这样的。总之缺少了惊艳的感觉。 当然，这绝对称不上烂尾。只是前十集的表现太亮眼了，相比之下结局显得普通。 异度侵入同时还具备催泪成分。从头到尾我一直对男主的设定耿耿于怀——太惨了。不仅过去遭遇悲惨，第十集还要虐他。结局虽然男主释怀了，但是现实还是现实，男主的过往和现状不可能改变了。 一部原创番能达到如此高的境界，墙裂推荐。顺便一提，一定要带着智商看，同时结合评论里的科普食用，否则你可能会因为看不懂而弃坑的。 评分：9分 恋爱小行星芳文社，百合工坊，懂？ 这一季度芳文社的番表现出色。作画上不说顶尖，也算是让我很舒适了。剧情秉承芳文社优良传统，JK+地学部。cp感浓厚，而且每对cp都超有爱，够热血！ 受到以「月色真美」为代表的几部狗粮番影响，我丧失了猛男体质，刚开始补「恋爱小行星」时没啥感觉。但看到米拉和苍同居的时候，我体内的猛男之魂再次燃烧了起来。 而且从「恋爱小行星」中甚至能学到天文地理，虽然专注于磕cp的我啥都没学会。 音乐不同于往届芳文社作品，非常小清新。 总之，达到芳文社优秀作品的水平，建议猛男食用。 评分：9分 魔法记录 魔法少女小圆外传我想大多数追这部番的人希望找到正传的味道吧，但很可惜，如果你是抱着这样的想法，这部作品可能会让你失望。 还是熟悉的苍树梅的扁圆脸，还是熟悉的新房风（虽然监督不是新房），还是熟悉的魔女和配乐，然而剧本不是老虚的，风格与正传大相径庭。 魔法记录讲述了焰第三次轮回的时间线里，神滨的魔法少女的故事。 正传的风格一直给人一种压抑、低沉的感觉，而外传相比之下更紧凑。尽管不是老虚的致郁风了，但是剧情依然精彩。前几集我以为只是很普通的魔法少女故事，不过越往后越好看。 还是围绕着“魔法少女最终会变成魔女”这一设定展开，同时添加了“传闻”“半魔女化”等新设定。揭露真相、拯救魔法少女、新势力的出现，外传与正传不一样的体验使它值得一补。 据说是个半年番，期待后续的表现。 评分：9分 虚构推理补完之后百感交集，优缺点都很明显。 设定新颖。虽说是推理番，但实际上讲的是虚构合理的谎言使人信服，达到掩盖真相、解决问题的目的。这种设定还是头一回见，新鲜。 女主人设好。外表萝莉的老司机，没事飙车，智力超群，东亚醋王。合我口味，i了i了。 大饱口福。时不时就发狗粮，而且都是高甜。 然而这些细节对我来说虽然很优秀，但是剧情上的问题太严重了，一个字，拖。 一共12集，概括起来就三段：交代设定，大蛇篇，钢人七濑篇。 而且从第3集到第12集一直在讲钢人七濑的事。不是因为剧情复杂，而是由于台词重复性过高。故事背景和设定重复说了好几遍，一些女主略显中二的台词我也觉得是画蛇添足，这一点使我观感欠佳。 有些评论说原小说和漫画就这么多台词，但是读文字一定比听文字快得多，小说和漫画文字多了影响不大，但动画就会拖时间，完全可以删减。 因此，如果只冲着剧情来的话，「虚构推理」的体验不算好。如果是冲着女主和狗粮来的话，这方面的质量还是很高的。 评分：7分 某科学的超电磁炮T写十月番剧总评的时候偶然看到超炮T的评价咕了一直没后续，于是回来填坑了哈哈哈哈哈（doge） 虽然已经过了快一年了，但『超炮T』的印象还是很深刻。 这年头出个续集都是喜忧参半。喜欢看的作品有了后续自然是高兴，但是不少续集又令人失望，比如至今我都没敢看的『约战』三和大起大落的『约定的梦幻岛』。 不过『超炮T』稳住了，质量爆炸。 还是熟悉的画风，作画质量也更高了。 两个故事的剧情无论内容还是节奏都很出色。和前两季一样，轻松的日常中逐步推进主线，穿插热血的战斗。特别是女王的故事，看完立刻路转粉。 就说这么多吧，超炮的魅力，永远也说不清、道不明。才不是我懒 评分：10分 压轴大戏：我的一月霸权如果单在b站上看的话，「异度侵入」无疑是我心目中的一月霸权了。 然而有一部番，从开播之前就备受关注，我时常在各种推送上见到它的身影。。。 掏出我压箱底的绝活了：「异种族风俗娘评鉴指南」。 听名字你以为是里番，其实它在tv上放送了哒！ 顾名思义，这部番架构了一个多种族共存的世界，风俗店被政府允许且支持。主角是几位冒险家，每集都体验不同的风俗娘并写评鉴赚钱。整体风格偏向于日常沙雕。 然而这部番的精髓不在于ghs，单纯的开车多没意思。其最大的亮点在于各色风俗娘的设定上。全番收录了数十个种族的风俗娘，而且各有特色，风格鲜明，合情合理。 我补这部番的感想： 卧槽，这设定有意思 卧槽，还有这种play 卧槽，作者脑洞真大 卧槽，这妹子真棒，我好了 引用泛式的观点：看「异种族风俗娘评鉴指南」有种看「动物世界」的感觉。 抛开设定，此番其他方面也是值得称赞的。画风比较独特，习惯了就好，至少作画绝对没有崩坏；高能的op、ed；音效和不ghs的搞笑日常都恰到好处。虽说是有颜色的番，但颜色之外的方面也没有拉胯。 我还特意补完了漫画。原来不仅作者有才，动画制作组也有才。原作基本都是省略过程，直接上评鉴，就跟一科普漫似的。动画制作组的细节和原创剧情一加，瞬间逼格就有了。 综上，我愿称之为我心目中的一月霸权。 评分：10分 最后来一波间接安利： 大概一年前，我一个朋友问我最想穿越到哪部番里的世界。 我一直都没有答案，直到我遇到「异种族风俗娘评鉴指南」。 8说了，我去梦里找有翼人、蘑菇族和火龙了","categories":[{"name":"动漫","slug":"动漫","permalink":"https://ctz45562.github.io/categories/%E5%8A%A8%E6%BC%AB/"}],"tags":[{"name":"二次元","slug":"二次元","permalink":"https://ctz45562.github.io/tags/%E4%BA%8C%E6%AC%A1%E5%85%83/"},{"name":"番剧","slug":"番剧","permalink":"https://ctz45562.github.io/tags/%E7%95%AA%E5%89%A7/"}]},{"title":"洛谷 P4546 [THUWC2017]在美妙的数学王国中畅游","slug":"洛谷-P4546-THUWC2017-在美妙的数学王国中畅游","date":"2020-03-28T02:26:38.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2020/03/28/洛谷-P4546-THUWC2017-在美妙的数学王国中畅游/","link":"","permalink":"https://ctz45562.github.io/2020/03/28/%E6%B4%9B%E8%B0%B7-P4546-THUWC2017-%E5%9C%A8%E7%BE%8E%E5%A6%99%E7%9A%84%E6%95%B0%E5%AD%A6%E7%8E%8B%E5%9B%BD%E4%B8%AD%E7%95%85%E6%B8%B8/","excerpt":"传送门 不多bb，直接安利","text":"传送门 不多bb，直接安利 一眼$LCT$，然而乍一看一堆函数求和没得搞。 题目下面给出了泰勒展开的式子。于是可以对$\\sin(ax+b)$和$e^{ax+b}$泰勒展开，用多项式拟合函数。 先求个导： $(\\sin(ax+b))^{(n)}=\\begin{cases}a^n\\sin(ax+b)&amp;n\\bmod4=0\\\\a^n\\cos(ax+b)&amp;n\\bmod4=1\\\\ -a^n\\sin(ax+b)&amp;n\\bmod4=2\\\\ -a^n\\cos(ax+b)&amp;n\\bmod4=3\\end{cases}$ $(e^{ax+b})^{(n)}=a^ne^{ax+b}$ 至于$\\xi,x_0$的取值，代个$0$就很方便。 现在要搞的就是一堆多项式求和，直接系数相加就能维护了。 由于分母上是阶乘，增长非常快，实测展开到$11$次项就能过。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 100005 #define inf 0x3f3f3f3f #define tp 11 using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } struct Poly{ double c[tp+1]; Poly(int t=3,double a=0,double b=0){ if(t==1){ double S=sin(b),C=cos(b),base=1; for(register int i=0;i&lt;=tp;i+=2,S=-S,C=-C)c[i]=base*S,base*=a,c[i+1]=base*C,base*=a; } else if(t==2){ double e=exp(b),base=1; for(register int i=0;i&lt;=tp;++i)c[i]=e*base,base*=a; } else{ c[0]=b,c[1]=a; for(register int i=2;i&lt;=tp;++i)c[i]=0; } } Poly operator + (const Poly &amp;x){ Poly ans; for(register int i=0;i&lt;=tp;++i)ans.c[i]=c[i]+x.c[i]; return ans; } }sum[maxn],dat[maxn]; #define son(x,y) son[x][y] #define ls(x) son(x,0) #define rs(x) son(x,1) #define whson(x) (son(fa[x],1)==x) #define root(x) (son(fa[x],0)!=x&amp;&amp;son(fa[x],1)!=x) int son[maxn][2],fa[maxn],rev[maxn]; inline void update(int node){sum[node]=sum[ls(node)]+sum[rs(node)]+dat[node];} inline void adde(int s,int f,bool wh){ if(s)fa[s]=f; son(f,wh)=s; } inline void rotate(int x){ int f=fa[x],gf=fa[f],wh=whson(x); if(!root(f))son(gf,whson(f))=x; fa[x]=gf; adde(son(x,wh^1),f,wh); adde(f,x,wh^1); update(f),update(x); } inline void rever(int node){ swap(ls(node),rs(node)); rev[node]^=1; } inline void pushdown(int node){ if(rev[node]){ if(ls(node))rever(ls(node)); if(rs(node))rever(rs(node)); rev[node]=0; } } inline void pushtag(int node){ if(!root(node))pushtag(fa[node]); pushdown(node); } inline void splay(int x){ pushtag(x); int y; while(!root(x)){ y=fa[x]; if(!root(y))rotate(whson(x)^whson(y)?x:y); rotate(x); } } void access(int x){ for(register int y=0;x;y=x,x=fa[x]) splay(x),rs(x)=y,update(x); } void makeroot(int x){ access(x),splay(x),rever(x); } int findroot(int x){ access(x),splay(x); while(ls(x))pushdown(x),x=ls(x); splay(x); return x; } void link(int x,int y){ makeroot(x),fa[x]=y; } void cut(int x,int y){ makeroot(x),access(y),splay(y); fa[x]=ls(y)=0,update(y); } void modify(int x,int t,double a,double b){ splay(x),dat[x]=Poly(t,a,b),update(x); } void query(int x,int y,double z){ makeroot(x); if(findroot(y)!=x){puts(&quot;unreachable&quot;);return;} splay(y); double ans=0,base=1,fac=1; for(register int i=0;i&lt;=tp;++i,fac*=i)ans+=base*sum[y].c[i]/fac,base*=z; printf(&quot;%.9lf\\n&quot;,ans); } int main(){ int n=read(),m=read(),x,y; double a,b; char s[10]; scanf(&quot;%s&quot;,s); for(register int i=1;i&lt;=n;++i){ x=read(); scanf(&quot;%lf%lf&quot;,&amp;a,&amp;b); dat[i]=sum[i]=Poly(x,a,b); } while(m--){ scanf(&quot;%s&quot;,s),x=read(),y=read(); if(s[0]==&#39;a&#39;)link(x+1,y+1); else if(s[0]==&#39;d&#39;)cut(x+1,y+1); else if(s[0]==&#39;m&#39;)scanf(&quot;%lf%lf&quot;,&amp;a,&amp;b),modify(x+1,y,a,b); else scanf(&quot;%lf&quot;,&amp;a),query(x+1,y+1,a); } }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"多项式","slug":"多项式","permalink":"https://ctz45562.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"LCT","slug":"LCT","permalink":"https://ctz45562.github.io/tags/LCT/"}]},{"title":"LCT重学笔记","slug":"LCT重学笔记","date":"2020-03-24T00:31:13.000Z","updated":"2020-06-21T10:15:58.000Z","comments":true,"path":"2020/03/24/LCT重学笔记/","link":"","permalink":"https://ctz45562.github.io/2020/03/24/LCT%E9%87%8D%E5%AD%A6%E7%AC%94%E8%AE%B0/","excerpt":"时隔半年再次来学习$LCT$，上次学是写紫荆花之恋的时候了。 本来还想顺便写个$splay$重学笔记的，然而维护数列调了一上午，从TLE到WA一直10分自闭了。","text":"时隔半年再次来学习$LCT$，上次学是写紫荆花之恋的时候了。 本来还想顺便写个$splay$重学笔记的，然而维护数列调了一上午，从TLE到WA一直10分自闭了。 #defineson[x][0/1]，son(x,0/1)，ls(x)/rs(x)：点$x$在$splay$中的左右儿子 fa[x]：爹 rev[x]：翻转标记 whson(x)：判断$x$是左儿子还是右儿子 root(x)：判断$x$是否为所在$splay$的根 注意区分“$splay$的根”和“原树的根”。 LCT板子 序$LCT$（$Link-Cut-Tree$）是一种动态维护树/森林的数据结构。 和树链剖分类似，把一棵树划分成若干条实链。把实链上的边称为实边，不在链上的边称为虚边。 但不同于树链剖分，实链是不断变化的。 每条实链用一棵$splay$维护，以深度为基准排序。 至于虚边，有“认父不认子”。 对于虚边$(x,y)$（$x$为深度较大的），$z$为$x$所在$splay$的根，则有$fa[z]=y$。但是$ls(y)$和$rs(y)$都不是$z$。 基本操作tips： 根据上面的“认父不认子”，判断是否为$splay$的根就不能用$fa$了，而是以儿子情况判断。 旋转时，有一步是和祖父连边。在普通$splay$中，如果fa[x]已经是根了，祖父就是$0$。但由于虚边的存在，祖父不一定是$0$，需要特判。 $LCT$里的$splay$函数是直接把$x$转成当前$splay$的根。 众所周知，$splay$前要下放标记，由于这里不找第$k$大，所以要额外写个函数放标记，递归或者栈模拟都可以。 #define son(x,y) son[x][y] #define ls(x) son(x,0) #define rs(x) son(x,1) #define whson(x) (son(fa[x],1)==x) #define root(x) (ls(fa[x])!=x&amp;&amp;rs(fa[x])!=x) int sum[maxn],son[maxn][2],fa[maxn],rev[maxn],dat[maxn]; inline void update(int node){sum[node]=sum[ls(node)]^sum[rs(node)]^dat[node];} inline void rever(int node){rev[node]^=1,swap(ls(node),rs(node));}//翻转 inline void pushdown(int node){ if(rev[node]){ if(ls(node))rever(ls(node)); if(rs(node))rever(rs(node)); rev[node]=0; } }//下放标记 inline void adde(int s,int f,int wh){ if(s)fa[s]=f; son(f,wh)=s; } inline void rotate(int x){ int f=fa[x],gf=fa[f],wh=whson(x); fa[x]=gf; if(!root(f))son(gf,whson(f))=x; adde(son(x,wh^1),f,wh); adde(f,x,wh^1); update(f),update(x); }//旋转 inline void pushtag(int node){ if(!root(node))pushtag(fa[node]); pushdown(node); }//下放整条链上的标记 void splay(int x){ pushtag(x); int y; while(!root(x)){ y=fa[x]; if(!root(y))rotate(whson(x)^whson(y)?x:y); rotate(x); } } accessctz来教你读英语：ě kē sài sì。 标准读音是/‘ækses/ 顾名思义，$access$是打通一条从树根到$x$的实链，并把多余的实边变为虚边。 先放代码： void access(int x){ for(register int y=0;x;y=x,x=fa[x]) splay(x),rs(x)=y,update(x); } 把$x\\ splay$上去，因为这条实链只能到$x$，所以把深度比$x$大的砍掉，rs(x)=y（此时$y=0$）。因为儿子变了所以要update一下。 因为接下来要把树根到$x$的$splay$串成一个，y=x用于记录当前$splay$的根节点，x=fa[x]跳到上面的$splay$上（$x$是$splay$的根所以一定是跳的虚边）。 此时我们要把虚边$(x,y)$变实，把$x\\ splay$上去，深度比$x$大的砍掉，换成实边$(x,y)$，rs(x)=y,update(x)。 不断重复这一过程直到树根，就能完成access。 makeroot有了access一切都变得简单了。 把$x$定为树根。 access(x)打通实链，$splay(x)$把$x$转上去。此时$x$为所在$splay$中深度最大的，直接把$x$翻转成深度最小的即可。 void makeroot(int x){ access(x),splay(x),rever(x); } findroot获取$x$所在的树的树根。 access(x)打通实链，此时$x$和树根在同一个$splay$中，而树根又是深度最小的，splay(x)后一直走左儿子就有了。 秉着splay要没事转一转的原则，找到根后把它转上来。 int findroot(int x){ access(x),splay(x); while(ls(x))pushdown(x),x=ls(x); splay(x); return x; } link连边$(x,y)$。 直接连一条虚边就好啦。 为了保证连之前$x$上头没有点（$fa[x]=0$），先makeroot(x)一下。 至于判断是否合法，findroot(y)看看树根是否为$x$检查连通性即可。 void link(int x,int y){ makeroot(x); if(findroot(y)==x)return; fa[x]=y; } cut先把$x,y$放到同一棵$splay$里。makeroot(x),access(y)即可。（由于access(y)在后面findroot(y)里出现了所以代码里不用写） 然后判断是否合法。首先findroot(y)检查连通性。由于在findroot时，经历了这样一个流程：access(y),splay(y) $\\rightarrow$找到树根$x\\rightarrow$ splay(x)。所以如果$x,y$之间有边，一定是$x$为$splay$的根，$y$为$x$的右儿子，且没有深度介于$x,y$的点（$ls(y)=0$）。 最后如果合法，直接切断$x,y$的父子关系并辅以update。 void cut(int x,int y){ makeroot(x); if(findroot(y)!=x||fa[y]!=x||ls(y))return; rs(x)=fa[y]=0; update(x); } split提取出链$x,y$以获得信息。 makeroot(x),access(y)打通实链$(x,y)$，然后splay(y)上去，$y$里面就存有整条链的信息。 其他复杂度世界上最无聊的复杂度分析之一就是$LCT$。 单次操作均摊复杂度$O(\\log n)$，以及一个巨大的常数。 维护边权转边为点即可。 维护子树上面只提到了维护链的信息，实际上$LCT$弱于维护子树。 当然也不是完全没办法。以求子树大小为例，额外维护一个lsiz表示虚子树大小。在虚实边转换的时候计算贡献就好了。 一些函数的修改： inline void update(int node){ siz[node]=siz[ls(node)]+siz[rs(node)]+lsiz[node]+1; } void access(int node){ for(register int y=0;x;y=x,x=fa[x]) splay(x),lsiz[x]+=siz[rs(x)]-siz[y],rs(x)=y,update(x); } void link(int x,int y){ makeroot(x); if(findroot(y)==x)return; fa[x]=y,lsiz[y]+=siz[x],update(y); } 而维护最大值就得套个set了，复杂度又多了个$\\log$。 水题现在已经不会了的题 由乃的OJ和起床困难综合征完全一致，维护全$0$和全$1$经过链变成什么。从高位到低位贪心，能填$0$就填$0$。 至于怎么维护，用$z_x$和$o_x$分别表示全$0$和全$1$经过$x$子树代表的链后的结果（从左子树走到右子树）。先把左儿子和$x$合并起来，分别记为$lz,lo$。再用$\\&amp;$分别提取出$0$位和$1$位，和右儿子合并。 $z_x=((\\sim lz)\\&amp;z_{rs(x)})|(lz\\&amp;o_{rs(x)})$ $o_x=((\\sim lo)\\&amp;z_{rs(x)})|(lo\\&amp;o_{rs(x)})$ 因为要翻转，还要维护从右子树走到左子树的结果。 在美妙的数学王国中畅游题解 首都动态维护树的重心。 考虑重心的一些性质： 去掉重心后剩下的子树大小均不超过$\\left\\lfloor\\dfrac{n}{2}\\right\\rfloor$ 连接两棵树，新的重心一定在原来两棵树重心的路径上 一棵树加一个点，重心最多移动一个点。 暴力的做法：暴力启发式合并把每个点$link$上去。复杂度$O(n\\log^2n)$。 更暴力的做法：提取出原来重心所在的链，三分。复杂度$O(n\\log^2n)$。 优美的做法：用$LCT$维护子树大小。连边时，提取出原来两个重心的路径。此时一定是一条链上，每个点挂着其他的一些子树。通过第一条性质判断重心，而根据第二条性质，挂着的子树一定不用考虑了，就只需要计算链上左右两端子树的大小，在$splay$上二分即可。复杂度$O(n\\log n)$。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ctz45562.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"LCT","slug":"LCT","permalink":"https://ctz45562.github.io/tags/LCT/"}]},{"title":"洛谷 P4586 [FJOI2015]最小覆盖双圆问题","slug":"洛谷-P4586-FJOI2015-最小覆盖双圆问题","date":"2020-03-04T03:14:35.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2020/03/04/洛谷-P4586-FJOI2015-最小覆盖双圆问题/","link":"","permalink":"https://ctz45562.github.io/2020/03/04/%E6%B4%9B%E8%B0%B7-P4586-FJOI2015-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%8F%8C%E5%9C%86%E9%97%AE%E9%A2%98/","excerpt":"传送门 hhhhhhhhhhhxswl","text":"传送门 hhhhhhhhhhhxswl Q：如果可以，你希望获得 LOL 中哪个英雄的能力？ A：妮蔻，变成美女，让兄弟们爽爽 兄弟们准备开始的时候，变成厄加特 （转自知乎） 一开始一个很森破的想法是，枚举分界点，左右两边分别做最小圆覆盖。 但是怎么分？以横坐标排序假的一批，样例都过不去。 原因是分界点可能不是竖着一刀劈，而是斜着砍。 于是可以转一转坐标系，每次转一下，最后转满一个$\\pi$。 这时复杂度不太对劲。实际上这个分界点不用枚举，可以二分。 经过实测，每次转$\\frac{\\pi}{100}$能过。少一点都不行，所以我猜std就是转这么多。。。 复杂度$O(100Tn\\log n)$。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #include &lt;time.h&gt; #define maxn 1005 const double eps = 1e-11; const double inf = 1e18; const double pi = acos(-1.0); using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } inline int cmp(double a,double b){return (a-b&gt;eps)-(a-b&lt;-eps);} struct point{ double x,y; point(double X=0,double Y=0){x=X,y=Y;} point operator + (const point &amp;a){return point(x+a.x,y+a.y);} point operator - (const point &amp;a){return point(x-a.x,y-a.y);} point operator * (const double &amp;a){return point(x*a,y*a);} point operator / (const double &amp;a){return point(x/a,y/a);} bool operator &lt; (const point &amp;a)const{return !cmp(x,a.x)?cmp(y,a.y)==-1:cmp(x,a.x)==-1;} double alpha(){return atan2(y,x);} }p[maxn],q[maxn]; struct line{ point a,b; double an; line(point A=point(0,0),point B=point(0,0)){a=A,b=B,an=(b-a).alpha();} }; struct circle{ point c; double r; circle(point C=point(0,0),double R=0){c=C,r=R;} circle(point A,point B,point C){ #define sqr(x) ((x)*(x)) double a=sqr(A.x)-sqr(B.x)+sqr(A.y)-sqr(B.y),b=sqr(B.x)-sqr(C.x)+sqr(B.y)-sqr(C.y),_c=A.x-B.x,d=A.y-B.y,e=B.x-C.x,f=B.y-C.y,m=2*(_c*f-d*e); c=point((a*f-b*d)/m,(b*_c-a*e)/m); r=sqrt(sqr(A.x-c.x)+sqr(A.y-c.y)); #undef sqr } }; typedef vector&lt;point&gt; polygon; inline double abs2(point a){return a.x*a.x+a.y*a.y;} inline double abs(point a){return sqrt(abs2(a));} inline double dis(point &amp;a,point &amp;b){return abs(a-b);} inline double dot(point a,point b){return a.x*b.x+a.y*b.y;} inline double cross(point a,point b){return a.x*b.y-a.y*b.x;} inline double angle(line &amp;a){return (a.b-a.a).alpha();} inline point rotate(point a,double b){return point(a.x*cos(b)-a.y*sin(b),a.x*sin(b)+a.y*cos(b));} inline point inter(line a,line b){ point A=a.b-a.a,B=b.b-b.a; return a.a+A*cross(B,a.a-b.a)/cross(A,B); } inline point project(line a,point b){ point c=a.b-a.a; return a.a+c*dot(c,b-a.a)/abs2(c); } inline double area(polygon &amp;a){ double ans=0; for(register int i=0,j=a.size()-1;i&lt;a.size();j=i++)ans+=cross(a[j],a[i]); return ans/2.0; } inline bool contain(point &amp;a,circle &amp;b){return cmp(abs2(b.c-a),b.r*b.r)&lt;=0;} inline double mini_circle(int n){ random_shuffle(p+1,p+1+n); circle ans; for(register int i=1;i&lt;=n;++i){ if(!contain(p[i],ans)){ ans=circle(p[i],0); for(register int j=1;j&lt;i;++j) if(!contain(p[j],ans)){ ans=circle((p[i]+p[j])/2,dis(p[i],p[j])/2); for(register int k=1;k&lt;j;++k) if(!contain(p[k],ans))ans=circle(p[i],p[j],p[k]); } } } return ans.r; } int main(){ srand(time(0)); int n; while(n=read()){ for(register int i=1;i&lt;=n;++i)scanf(&quot;%lf%lf&quot;,&amp;q[i].x,&amp;q[i].y); double ans=inf; for(register int a=1;a&lt;=100;++a){ for(register int i=1;i&lt;=n;++i)q[i]=rotate(q[i],pi/100); sort(q+1,q+1+n); int l=1,r=n; double r1,r2; while(l&lt;=r){ int mid=l+r&gt;&gt;1; for(register int i=1;i&lt;=mid;++i)p[i]=q[i]; r1=mini_circle(mid); for(register int i=mid+1;i&lt;=n;++i)p[i-mid]=q[i]; r2=mini_circle(n-mid); ans=min(ans,max(r1,r2)); if(cmp(r1,r2)==-1)l=mid+1; else r=mid-1; } } printf(&quot;%.2lf\\n&quot;,ans); } }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"计算几何","slug":"计算几何","permalink":"https://ctz45562.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"}]},{"title":"洛谷 P4250 [SCOI2015]小凸想跑步","slug":"洛谷-P4250-SCOI2015-小凸想跑步","date":"2020-02-28T02:41:38.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2020/02/28/洛谷-P4250-SCOI2015-小凸想跑步/","link":"","permalink":"https://ctz45562.github.io/2020/02/28/%E6%B4%9B%E8%B0%B7-P4250-SCOI2015-%E5%B0%8F%E5%87%B8%E6%83%B3%E8%B7%91%E6%AD%A5/","excerpt":"传送门 wwwwwwwwwwwwwwwwwww 我已经不知道这串w是什么意思了","text":"传送门 wwwwwwwwwwwwwwwwwww 我已经不知道这串w是什么意思了 一开始以为是什么高大上的东西，钻研了会$P$点的性质。后来发现就是列个式子的事。 三角形的面积，两边叉积的一半，把这个叉积写开： $\\overrightarrow{PP_i}\\times\\overrightarrow{PP_{i+1}}$ $=(p_i-p)\\times(p_{i+1}-p)$ $=p_i\\times p_{i+1}-p_i\\times p-p\\times p_{i+1}$ $=x(y_i-y_{i+1})+y(x_{i+1}-x_i)+p_i\\times p_{i+1}$ 再把条件“$p_0,p_1,p$围成的三角形面积最小”写开： $\\overrightarrow{PP_i}\\times\\overrightarrow{PP_{i+1}}&gt;\\overrightarrow{PP_0}\\times\\overrightarrow{PP_1}$ $x(y_i-y_{i+1})+y(x_{i+1}-x_i)+p_i\\times p_{i+1}&gt;x(y_0-y_1)-y(x_1-x_0)+p_0\\times p_1$ $x(y_i-y_{i+1}-y_0+y_1)+y(x_{i+1}-x_i-x_1+x_0)+p_i\\times p_{i+1}-p_0\\times p_1&gt;0$ 半平面交显然。由于点$P$要在凸多边形内，还要和凸多边形交一下。答案算个面积之比就好了。 然而很玄学的是不能直接代$x=0,1$（或者$y=0,1$）表示直线，貌似是因为坐标太大叉乘就炸了。然而代$x=0$和$x=0$加上向量$(b,-a)$就过了。。。 感觉两种方法没有本质上的区别啊，有没有大佬解释一下啊。。。 这题好就好在不怎么卡精度，开个long double就过了，甚至可以不设eps直接比。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #define maxn 200005 #define double long double const double eps = 1e-18; const double inf = 1e18; const double pi = acos(-1.0); using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } inline int cmp(double x,double y){return x-y&gt;eps?1:x-y&lt;-eps?-1:0;} struct point{ double x,y; point(double X=0,double Y=0){x=X,y=Y;} point operator + (const point &amp;a){return point(x+a.x,y+a.y);} point operator - (const point &amp;a){return point(x-a.x,y-a.y);} point operator * (const double &amp;a){return point(x*a,y*a);} point operator / (const double &amp;a){return point(x/a,y/a);} double alpha(){return atan2(y,x);} }p[maxn],P; struct line{ point a,b; double an; line(point A=point(0,0),point B=point(0,0)){a=A,b=B,an=(b-a).alpha();} }l[maxn],q[maxn]; struct circle{ point c; double r; circle(point C=point(0,0),double R=0){c=C,r=R;} circle(point A,point B,point C){ #define sqr(x) ((x)*(x)) double a=sqr(A.x)-sqr(B.x)+sqr(A.y)-sqr(B.y),b=sqr(B.x)-sqr(C.x)+sqr(B.y)-sqr(C.y),_c=A.x-B.x,d=A.y-B.y,e=B.x-C.x,f=B.y-C.y,m=2*(_c*f-d*e); c=point((a*f-b*d)/m,(b*_c-a*e)/m); r=sqrt(sqr(A.x-c.x)+sqr(A.y-c.y)); #undef sqr } }; typedef vector&lt;point&gt; polygon; inline double abs2(point a){return a.x*a.x+a.y*a.y;} inline double abs(point a){return sqrt(abs2(a));} inline double dis(point &amp;a,point &amp;b){return abs(a-b);} inline double dot(point a,point b){return a.x*b.x+a.y*b.y;} inline double cross(point a,point b){return a.x*b.y-a.y*b.x;} inline double angle(line &amp;a){return (a.b-a.a).alpha();} inline point rotate(point a,double b){return point(a.x*cos(b)-a.y*sin(b),a.x*sin(b)+a.y*cos(b));} inline point inter(line a,line b){ point A=a.b-a.a,B=b.b-b.a; return a.a+A*cross(B,a.a-b.a)/cross(A,B); } inline double area(polygon &amp;a){ double ans=0; for(register int i=0,j=a.size()-1;i&lt;a.size();j=i++)ans+=cross(a[j],a[i]); return ans/2.0; } polygon u,v; inline bool mmp(line &amp;a,line &amp;b){ if(a.an==b.an)return cross(b.b-a.a,b.a-a.a)&lt;0.0; return a.an&lt;b.an; } inline bool judge(point &amp;a,line &amp;b){return cross(b.b-a,b.a-a)&gt;0.0;} int main(){ int n=read(),cnt=0,h=1,t=0; for(register int i=1;i&lt;=n;++i){ P.x=read(),P.y=read(); v.push_back(P); } for(register int i=0,j=n-1;i&lt;n;j=i++){ l[++cnt]=line(v[j],v[i]); if(i==1)continue; double a=v[j].y-v[i].y-v[0].y+v[1].y,b=v[i].x-v[j].x-v[1].x+v[0].x,c=cross(v[j],v[i])-cross(v[0],v[1]); if(cmp(a,0))l[++cnt]=line(point(-c/a,0),point(-c/a+b,-a)); else if(cmp(b,0))l[++cnt]=line(point(0,-c/b),point(b,-c/b-a)); } sort(l+1,l+1+cnt,mmp); for(register int i=1;i&lt;=cnt;++i){ if(i!=1&amp;&amp;angle(l[i])==angle(l[i-1]))continue; while(t-h&gt;=1&amp;&amp;judge(p[t],l[i]))--t; while(t-h&gt;=1&amp;&amp;judge(p[h+1],l[i]))++h; q[++t]=l[i]; if(t-h&gt;=1)p[t]=inter(q[t],q[t-1]); } while(t-h&gt;=1&amp;&amp;judge(p[t],q[h]))--t; u.push_back(inter(q[h],q[t])); for(register int i=h+1;i&lt;=t;++i)u.push_back(p[i]); printf(&quot;%.4Lf\\n&quot;,area(u)/area(v)); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"计算几何","slug":"计算几何","permalink":"https://ctz45562.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"}]},{"title":"blogの搭建之sakura特别篇——授人以渔","slug":"blogの搭建特别篇——授人以渔","date":"2020-02-05T00:54:59.000Z","updated":"2021-07-01T04:33:20.374Z","comments":true,"path":"2020/02/05/blogの搭建特别篇——授人以渔/","link":"","permalink":"https://ctz45562.github.io/2020/02/05/blog%E3%81%AE%E6%90%AD%E5%BB%BA%E7%89%B9%E5%88%AB%E7%AF%87%E2%80%94%E2%80%94%E6%8E%88%E4%BA%BA%E4%BB%A5%E6%B8%94/","excerpt":"之前有一篇授人以鱼的教程，后来看到有人留言希望我授人以渔，再加上我本来就有这个想法，以此文作为退役前给后人的一点贡献吧。","text":"之前有一篇授人以鱼的教程，后来看到有人留言希望我授人以渔，再加上我本来就有这个想法，以此文作为退役前给后人的一点贡献吧。 前言我是作为一个OIer沉迷于搭blog的，没有过多的时间和精力系统地学习前端知识。本文旨在帮助和我一样不能专门学习搭blog的人（尤其是OIer）快速上手，能够对blog简单地个性化，所以里面都是我半吊子的知识，请技术大佬勿喷。 一点声明：我基本所有的精力都投入到sakura上了，所以涉及主题方面的也只能针对sakura来说，其他主题的还得读者仿照着去研究。 基础编辑器功能全面、界面美观的VScode是不错的选择。 不过VScode在机房的电脑略卡，所以再说一下我早些时候用的Notepad++。几乎不占用资源，打开上百个文件内存不到30M，一些基本的功能也挺全的。 三大语言html、css、javascript。 W3school、菜鸟教程等网站对这些语言的教程很详细。 这三种语言不要求完全掌握，如果搭blog只是你的一种兴趣，不要让它占用太多时间。 所以： 学会照葫芦画瓢，能模仿着原有的语句写出类似功能的语句，下面的东西，很多都是靠模仿学会的 不要死记硬背函数、语法，忘了或者不会不要紧，善用搜索引擎 html：网页的骨架乍一看画风很鬼畜，实际上很好上手。 要能够大致看懂一个html文件的构造并掌握创造一些常用元素如&lt;div&gt;,&lt;p&gt;,&lt;span&gt;,&lt;hr&gt;并添加属性。 为了更好地看懂hexo的html文件，了解了基础语法后，要掌握一种进阶的语法。 形如&lt;% ... %&gt;，&lt;%= ... %&gt;，&lt;%- ... %&gt;（也有主题是｛% ... %｝），后面会有说到。 css：网页的皮肤洛谷4.0之前应该还有一些人会css的，通过插件stylus/stylish基本就能掌握。 当然我还是推荐找专门的教程学一学。会给某一个或某一类元素添加一些基本的属性如background,color,font-size,height。至于其他你想要的效果，善用搜索引擎。 javascript：网页的血肉类似于c++，简单了解js的语法就能上手了。 但js相比于前两者更nb，也更难写，很多时候还是靠模仿。 只需要会最基础的函数getElement家族、createElement、setInterval等，以及最基础的语法如var的用法、循环遍历、定义函数。 其他的，搜索引擎帮你搞定。 F12大法在网页中摁下F12，打开开发者工具。 开发者工具用处非常大，一定要掌握。 不同浏览器外观不同，但功能是差不多的。这里以firefox为例，其他浏览器的差异请读者研究吧。 查看器 直接查看和修改内部html构造和css样式。 右键对指定元素操作。 点击最左上角的按钮（红色圈出来的），可以用鼠标定位元素。 搜索元素需要用css语法。 右边第二栏可以查看所有与指定元素有关的css样式并修改。修改已有规则或者添加新规则都可以。 点击规则左侧的对勾禁用/启用。 在右上角还能看到来源（文件:行数）。 至于第三栏，我基本用不到，就不说了。 控制台用于查看警告/错误信息和输出调试。 警告和错误都会在这显示，并在右侧标注文件。 而js里的console.log()函数就输出到了这里，可以用于调试。 下面的文本框用于输入js，定义变量、调用函数之类的。 调试器顾名思义，用于调试js。 可以看到网页引用的所有js并查看内容剽的一大利器 单击行数设置断点，和c++一样调试。 右边那个“异常处暂停”也很有用，最好勾上。 网络查看所有加载的文件以及加载效率，一般就是监测有没有加载奇♂怪的东西以及什么文件拖延了效率。 其他后面几项平时没怎么用过，感兴趣的自行探索吧。 btw，右上角有一个“响应式设计模式”，可以把电脑变为手机浏览。 用于改进移动端的体验。不过移动端的外观我已经完全抛弃了，所以丑的一批 甚至能进入一些只允许移动端访问的网页。 FontAwesome&amp;IconfontFontAwesome和Iconfont是两个图标库，通过&lt;i&gt;元素加一些简单的图形，非常方便。 包括sakura在内，大部分主题都支持FontAwesome，但不支持Iconfont（准确来说，Iconfont的图标实在是太多，一般是从中选一些用，所以需要自己设置），这里是添加Iconfont的教程。 用法很简单，FontAwesome就在上面的链接里找到需要的图标，点进去，复制源码，放到html文件里适当的位置即可。 Iconfont用法教程里写了，和FontAwesome没啥区别。 更深入一点，可以看到图标的格式都是&lt;i class=&quot;fa fa-*&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;（aria-hidden=&quot;true&quot;可以省略），了解这个后有助于读懂html文件以及修改。 hexoの构造非常重要，摸清了hexo的目录结构就能对症下药了。 注：我没有提到的文件就是我不懂或者用不着。 站点目录结构打开存放blog的文件夹，可以看到以下内容： .deploy_githexo d生成，hexo cl删除。 这是git上传用的文件夹，没啥用，不要管它。 publichexo g/hexo d生成，hexo cl删除。 hexo g会根据你的/source文件夹和主题生成静态的网页，即将要上传到github仓库，/public就是存放这些的。一般也没用。 node_modules用于存放插件。 可以修改，但是内容都比较深奥看不透，看个人水平。 scaffolds存放模板。你可以看到里面有几个markdown文件。当执行hexo new [title]或hexo new page [title]时会根据模板创建文件。 post.md是文章模板，page.md是页面模板，根据个人习惯改一下写东西更方便。 source,_config.yml这两个不用多说了吧。 把文件放在source里，可以直接通过链接/path（path为在source下的路径名）引用文件。例如，在source文件夹下创建文件夹images，里面放上文件1.jpg，就可以用路径/images/1.jpg引用图片了。甚至可以用博客网址/images/1.jpg在博客外的地方引用。 package.json记录所有已安装的插件和版本信息。 有的主题会提供整个博客文件夹（sakura就是），如果出了bug，可以对比一下package.json查看是否是缺少插件或插件版本不够导致的。 主题目录结构不同主题的目录结构是有差异的，但是思路是一样的。这里就以sakura主题为例讲解。 再一个，不同主题的html文件后缀名可能不同，例如sakura是.ejs，next是.swig，语法基本相同，以文件内容为依据。 打开/themes/sakura，你会看到： _config.yml关于主题配置文件，也是很常见了。但不得不提一嘴： 主题配置文件中的东西，是用于html文件直接引用的，语法格式为&lt;%= theme.* %&gt;。 甚至能用if语句。举个栗子，如果在_config.yml里写下testImg: /1.jpg，在某个html文件里写下： &lt;% if (theme.testImg &amp;&amp; theme.testImg.length){ %&gt; &lt;img src=&quot;&lt;%= theme.testImg %&gt;&quot; alt=&quot;&quot;&gt; &lt;% } %&gt; 这段话的意思就是，如果在_config.yml里有testImg的定义且不为空的话，就显示testImg代表的图片。 如果你回去看看我给归档页面添加配图的教程，你会发现我就是用这种方式添加的。这个还是很实用的，多模仿。 languages不多说了，写博客都能用到。 layout划重点。要考的。 这里存放了主题的骨架，也就是所有html文件，后缀名都是.ejs。一个一个说。 板子一些页面或重要部件的模板。 里面你可能会看到这样一种语法：&lt;%- partial(&#39;...&#39;) %&gt;。例如在layout.ejs里就有&lt;%- partial(&#39;_partial/head&#39;) %&gt;，它的意思是把_partial/head.ejs里的内容原封不动地搬过来。 layout.ejs：最重要的html文件。几乎所有页面和文章都以此为基础。如果有什么东西想对所有页面生效（比如看板娘），放在这里就行 category.ejs：某一分类下所有文章（例子） tag.ejs：某一标签下的所有文章（例子） _partial文件夹下： head.ejs：专门写&lt;head&gt;标签的内容。有了html基础就知道里面该写什么了 footer.ejs：专门写&lt;footer&gt;标签的内容。同上 header.ejs：顶部菜单栏 mheader.ejs：移动端下的顶部菜单栏 _widget文件夹下： 这里再说一种语法，&lt;%- post.* %&gt;和&lt;%- page.* %&gt;，这是在文章/页面markdown文件里的顶部，用---隔开的文章信息（称为front-matter），和上面主题配置文件说的一样用。 common-article.ejs：文章的通用模板 common-page.ejs：普通页面的通用模板 category-items.ejs：某一标签/分类下单个文章。就是这个东西： index-items.ejs：截图更明白： /search/insight.ejs：搜索 特殊页面这一类特殊页面仅靠markdown是不够的，都会有一个专门的html文件。 archive.ejs：归档 bangumi.ejs：番剧 donate.ejs：赞赏 index.ejs：主页 links.ejs：友链 零件_partial文件夹下： aplayer.ejs：音乐播放器 comment.ejs：评论 headertop.ejs：这个： startdash.ejs：顾名思义 source划重点，也要考的。 和前面的/source一样，主题文件夹下的source同样可以用来引用文件，格式完全一致。 普及一个常识：如果一个css/js文件后缀名前面有个min或mini，那是说它被压缩了。压缩文件是为了缩小文件体积，加快传输效率，但是也失去了代码可读性。我在教程最后给出的工具里有压缩和解压css/js的。但是js的压缩一般会把变量名和函数名压缩，这是不可逆的。。。注意一下。 css style.css：最重要的css文件。绝大多数样式规则都在这里。要修改或者添加就到这儿。其它的稍作了解即可，大部分看名字就知道是干啥的了 APlayer.min.css：音乐播放器 bangumi.css：番剧页面 donate.css：赞赏页面 font.css：iconfont相关。不要动它 insight.styl：搜索相关，不过看起来有些奇怪。这是另一种css，照葫芦画瓢造它就完了 jquery.fancybox.min.css：fancybox相关 lib.min.css：动态图标相关。不要动它 sharejs.css：转载相关 zoom.css：zoom相关 js sakura-app.js：最重要的js文件。大部分关键函数都在这里。和style.css一样，要修改或者添加就到这儿。其它的稍作了解即可，大部分看名字就知道是干啥的了 APlayer.min.js：音乐播放器 busuanzi.pure.mini.js：busuanzi访客量计数器 InsightSearch.js,search.js：搜索 jquery.fancybox.min.js：fancybox lib.min.js：很杂的基础函数，不要动它 valine.min.js：valine评论 zoom.min.js：zoom fonts用于存放fontawesome和自带的iconfont，不要管 扯两句我是怎么美化blog的1.创新 突然灵光一现，有了新点子。 刚加上主题工具的时候，“自由切换背景和字体很炫啊，那是不是还可以更进一步呢？”于是「主题工具-特效」诞生了。 当然这玩意的代码都得自己写，很费时间。本来我还想再加个「主题工具-鼠标」的，太累了写不动了。。。 2.修改 经常浏览自己的blog，看到不顺眼的就改掉它。 只要熟悉了hexo构造就很轻松了。 3.剽 这才是主要手段 没事多去逛逛别人的blog，或者看看hexo的其他主题和教程，发现很棒的东西就搬过来。 有教程的还好说，没有的只能靠F12生剽。但生剽不是Ctrl-C,Ctrl-V，考虑到兼容性，一般是了解了原理后自己写出来。所以这活儿其实很累。 比如我现在的标签样式，从spfk主题搬过来的，但是因为html构造不同，很多样式都要修改，再加上随机颜色和修复bug，基本都相当于自己写了。 搭blog很累想极致地美化blog确实很累，有时候比OI都难，完全靠兴趣支撑。 绝大部分的颓废时间，别人在水知乎水群，而我不是在找新点子，就是对着源码改来改去。周围有的人不太理解这有啥有意思的，我其实也不明白，大概只是享受blog称我心意的成就感吧。 如果你真的不想费劲还想美化blog的话，我只能说，别自己搞了，还是大佬的教程适合你。 注意性能尽管我现在能力不足，blog的效率并不高，但还是要说一说。 速度对访问体验的影响绝对比美观大。 如果第一次进入都要加载超过10s甚至失败，那很可能就不会有第二次访问了。 进行一项改动时，要考虑对性能的影响。 没事就观察一下blog的速度并尽可能优化。注意用Ctrl+F5刷新缓存，能观察到真实的速度。 一方面是网络速度。很多人都是用github自带的域名或者买个廉价/免费的域名，网站加载效率不高，所以尽量不要使用/source文件夹引用，速度非常慢（大概10k/s），特别对于sakura，图片非常多。目前我在用jsdelivr，加速所有较大的图片、js、css。 另一方面是cpu和内存的占用。一般是花里胡哨的功能导致的，比如看板娘、背景特效。加入某项东西的时候，要考虑到对性能的影响。某人的blog，虽然是next主题，但是cpu占用达到50%，内存占用超过1G！机房里的电脑性能本来就一般，很多 人访问他的blog差点死机。u1s1，这种blog也不会有什么回头客了吧。 一些工具有很多动画特效且提供源码 测速网站 又一个测速网站（你需要一架梯子） 各种工具（js工具和css工具很实用） 压缩系列： 高效无损图片压缩 自定义压缩比例，损失清晰度换取压缩度 gif压缩 后记断断续续写完了。算是退役前留下的最后的痕迹吧。 我也不适合教人，语言混乱，还可能漏洞百出，所以欢迎大佬们指出错误。","categories":[{"name":"杂物","slug":"杂物","permalink":"https://ctz45562.github.io/categories/%E6%9D%82%E7%89%A9/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://ctz45562.github.io/tags/blog/"}]},{"title":"Vimの临时配置&Linux对拍","slug":"Vimの临时配置&linux对拍","date":"2020-01-20T08:37:56.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2020/01/20/Vimの临时配置&linux对拍/","link":"","permalink":"https://ctz45562.github.io/2020/01/20/Vim%E3%81%AE%E4%B8%B4%E6%97%B6%E9%85%8D%E7%BD%AE&linux%E5%AF%B9%E6%8B%8D/","excerpt":"快要WC了虽然可能去不了，研究一下noi-linux的基操。 玩的虚拟机，不过用的不是noi-linux，而是其基底ubuntu。要是我因为这俩的差异打铁了那就。。。好像打铁了也没啥","text":"快要WC了虽然可能去不了，研究一下noi-linux的基操。 玩的虚拟机，不过用的不是noi-linux，而是其基底ubuntu。要是我因为这俩的差异打铁了那就。。。好像打铁了也没啥 Vim作为windows下的Vimer当然是要用Vim了。 终端下打开Vim的配置文件： vim ~/.vimrc 我在windows下的Vim有一堆插件，配置文件加起来有三四百行。。。 精简了一下： set nu! &quot;行号 set cul &quot;高亮当前行 set tabstop=4 &quot;tab宽度 set shiftwidth=4 &quot;缩进 set smartindent &quot;智能缩进 set mouse=a &quot;允许鼠标操作 colorscheme ron &quot;主题 &quot;括号补全 inoremap { {}&lt;esc&gt;i&lt;cr&gt;&lt;esc&gt;x%a inoremap ( ()&lt;esc&gt;i inoremap [ []&lt;esc&gt;i inoremap ) &lt;c-r&gt;=ClosePair(&#39;)&#39;)&lt;cr&gt; inoremap ] &lt;c-r&gt;=ClosePair(&#39;]&#39;)&lt;cr&gt; func! ClosePair(char) if getline(&#39;.&#39;)[col(&#39;.&#39;)-1] == a:char return &quot;\\&lt;Right&gt;&quot; &quot;记住是双引号！ else return a:char endif endfunction &quot;光标移动优化 nnoremap j gj nnoremap k gk nnoremap gj j nnoremap gk k &quot;编译运行 map &lt;F9&gt; :call Compile()&lt;cr&gt; map &lt;F10&gt; :!./%&lt;&lt;cr&gt; func! Compile() exec &quot;w&quot; exec &quot;!g++ % -o %&lt; -std=c++11 -O2&quot; endfuntion 至于设置字体，不知道为啥set guifont用不了，到时候看看吧，不行就直接改终端的字体。 Linux对拍本来想学点Linux基础命令的，发现除了对拍没啥有用的。。。 和windows一样直接用system命令，比较文件用diff，运行程序要加上./。没有找到终端里的输入输出只能在程序里freopen。 有一个坑点，Ctrl+C会中止正在运行的程序，大概率会中止非对拍程序，所以停不下来，只能关掉终端。。。 while(1){ system(&quot;./file&quot;); int s=clock(); system(&quot;./my&quot;); s=clock()-s; system(&quot;./right&quot;); if(system(&quot;diff juruo.out dalao.out&quot;)){ system(&quot;gedit file.in&quot;); return 0; } else printf(&quot;%d ms\\n&quot;,s); }","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ctz45562.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ctz45562.github.io/tags/Linux/"},{"name":"Vim","slug":"Vim","permalink":"https://ctz45562.github.io/tags/Vim/"}]},{"title":"计算几何学习笔记","slug":"计算几何学习笔记","date":"2020-01-15T08:28:09.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2020/01/15/计算几何学习笔记/","link":"","permalink":"https://ctz45562.github.io/2020/01/15/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"退役前最后一个大坑，大概。 还有，关于七都的福袋活动，终于能达成我最后的心愿了（指朝奈）","text":"退役前最后一个大坑，大概。 还有，关于七都的福袋活动，终于能达成我最后的心愿了（指朝奈） 前言$\\LaTeX$的向量高度不统一好难看啊。。。（模仿慎老师） 基础部分的代码是写笔记的时候直接打上去的，不保证没有手滑打错甚至可能CE，有锅的话请告诉我。 抄袭来源 来自主席的夏令营课件 https://www.cnblogs.com/lstoi/p/9791654.html 在线几何画板 https://www.cnblogs.com/shzr/p/12014963.html https://blog.csdn.net/Mr_HCW/article/details/82857715 https://blog.csdn.net/qq_40861916/article/details/83541403 基础终于（算是）整理完了。。。 精度问题计算几何的运算中会出现很大大大大的精度误差，要重新定义实数的比较运算： const double eps = 1e-9; inline int cmp(double a,double b){return fabs(a-b)&lt;eps?0:a-b&lt;-eps?-1:1;}//0:a==b;-1:a&lt;b;1:a&gt;b 后来发现了一种绝妙的cmp写法： inline int cmp(double a,double b){return (a-b&gt;eps)-(a-b&lt;-eps);} 你品，你细品。 点/向量定义及四则运算必修二基础知识。。。 struct point{ double x,y; point(double X=0,double Y=0){x=X,y=Y;} point operator + (point a){return point(x+a.x,y+a.y);} point operator - (point a){return point(x-a.x,y-a.y);} point operator * (double a){return point(x*a,y*a);} point operator / (double a){return point(x/a,y/a);} }; 以下均以$\\vec{a},\\vec{b}$举例，坐标分别为$(x_a,y_a),(x_b,y_b)$ 点乘和叉乘点乘（$dot\\ product$）不说了，以下用$\\vec{a}\\cdot \\vec{b}$表示点乘。 $\\vec{a}\\cdot\\vec{b}=|a||b|\\cos\\langle\\vec{a},\\vec{b}\\rangle=x_ax_b+y_ay_b$ 叉乘（$cross\\ product$）用$\\vec{a}\\times\\vec{b}$表示。 $a\\times b=|a||b|\\sin\\langle\\vec{a},\\vec{b}\\rangle=x_ay_b-x_by_a$ 其含义简单地说，就是平行四边形定则中那个平行四边形（ABDC）的有向面积。$\\vec{a}$在$\\vec{b}$顺时针方向为正，否则为负。 叉乘不满足结合律和交换律（交换时要取反：$\\vec{a}\\times\\vec{b}=-\\vec{b}\\times\\vec{a}$），但满足分配律。 inline double dot(point a,point b){return a.x*b.x+a.y*b.y;} inline double cross(point a,poit b){return a.x*b.y-a.y*b.x;} 点乘可以判断向量夹角情况：钝角小于$0$，锐角大于$0$。 叉乘可以用于判断向量方向关系，大于$0$则$\\vec{a}$在$\\vec{b}$的顺时针方向，等于$0$共线，否则为逆时针。 夹角计算$\\vec{a}$和$\\vec{b}$的夹角。 $\\vec{a}\\cdot\\vec{b}=|a||b|\\cos\\langle\\vec{a},\\vec{b}\\rangle$ $\\vec{a}\\times\\vec{b}=|a||b|\\sin\\langle\\vec{a},\\vec{b}\\rangle$ $\\tan\\langle\\vec{a},\\vec{b}\\rangle=\\dfrac{\\sin\\langle\\vec{a},\\vec{b}\\rangle}{\\cos\\langle\\vec{a},\\vec{b}\\rangle}=\\dfrac{\\vec{a}\\times\\vec{b}}{\\vec{a}\\cdot\\vec{b}}$ inline double angle(point a,point b){return atan2(cross(a,b),dot(a,b));} 注：atan2传入两个参数$y$和$x$，返回弧度制，范围$(-\\pi,\\pi]$。 旋转将幅角为$\\alpha$的$\\vec{a}$旋转$\\beta$度。 $\\vec{a}$一定能表示成$k(\\cos\\alpha,\\sin\\alpha)$。把$(\\cos\\alpha,\\sin\\alpha)$转过去再乘上$k$。 即$k(\\cos(\\alpha+\\beta),\\sin(\\alpha+\\beta))=k(\\cos\\alpha\\cos\\beta-\\sin\\alpha\\sin\\beta,\\sin\\alpha\\cos\\beta+\\cos\\alpha\\sin\\beta)=(x_a\\cos\\beta-y_a\\sin\\beta,y_a\\cos\\beta+x_a\\sin\\beta)$ inline point rotate(point a,double b){return point(a.x*cos(b)-a.y*sin(b),a.y*cos(b)+a.x*sin(b));} 其他inline double abs2(point a){return a.x*a.x+a.y*a.y}//模长的平方 inline double abs(point a){return sqrt(abs2(a));}//模长 inline double unit(point a){return a/abs(a);}//单位向量 inline double dis(point a,point b){return abs(a-b);}//距离 inline double angle(point a){return atan2(a.y,a.x);}//幅角，也能用来求夹角 直线/线段定义两点确定一条直线。 struct line{ point a,b; line(point A=point(0,0),point B=point(0,0)){a=A,b=B;} } 点线位置关系点在直线上判断$\\overrightarrow{PA}$、$\\overrightarrow{PB}$与直线围成的三角形面积是否为$0$，即$\\overrightarrow{PA}\\times\\overrightarrow{PB}=0$ inline bool locate(point a,line b){return cmp(cross(b.a-a,b.b-a),0.0)==0;} 点在线段上和直线一样，但要判断坐标范围： inline bool in(double a,double b,double c){return cmp(a,b)==0||cmp(a,c)==0||cmp(a,b)!=cmp(a,c);} inline bool in(point a,line b){return in(a.x,b.a.x,b.b.x)&amp;&amp;in(a.y,b.a.y,b.b.y);} 线线位置关系平行叉乘等于$0$。 inline bool par(line a,line b){return cmp(cross(a.a-a.b,b.a-b.b),0.0)==0;} 垂直点乘等于$0$。 inline bool ver(line a,line b){return cmp(dot(a.a-a.b,b.a-b.b),0,0)==0;} 直线交点 直线$P_1P_2$与$Q_1Q_2$交点为$C$。作$P_1A\\perp Q_1Q_2,P_2B\\perp Q_1Q_2$，垂足分别为$A,B$。连接$Q_2P_1,Q_2,P_2$。 由三角形面积公式得$\\dfrac{|\\overrightarrow{P_1A}|}{|\\overrightarrow{P_2B}|}=\\dfrac{\\overrightarrow{Q_2P_1}\\times\\overrightarrow{Q_2Q_1}}{\\overrightarrow{Q_2P_2}\\times\\overrightarrow{Q_2Q_1}}$ 记$x=\\overrightarrow{Q_2P_1}\\times\\overrightarrow{Q_2Q_1}$，$y=\\overrightarrow{Q_2P_2}\\times\\overrightarrow{Q_2Q_1}$。 由相似得$\\dfrac{|\\overrightarrow{P_1C}|}{|\\overrightarrow{P_2C}|}=\\dfrac{|\\overrightarrow{P_1A}|}{|\\overrightarrow{P_2B}|}=\\dfrac{x}{y}$ 因为这几组模长的比例关系都是平行向量之间的比较，可以把绝对值去掉： $\\dfrac{\\overrightarrow{P_1C}}{\\overrightarrow{P_2C}}=\\dfrac{x}{y}$ $\\overrightarrow{P_2P_1}=\\overrightarrow{P_2C}-\\overrightarrow{P_1C}$ 解方程：$\\overrightarrow{P_1C}=\\dfrac{x}{y-x}\\overrightarrow{P_2P_1}$ $\\vec{c}=\\vec{p_1}+\\overrightarrow{P_1C}$ inline point inter(line a,line b){ double x=cross(a.a-b.b,b.b-b.a),y=cross(a.b-b.b,b.b-b.a); return a.a+(a.a-a.b)*x/(y-x); } 后来发现太丑了换了一种求法： 首先，除了用两个点，直线还有一种表示方式：一个端点和方向向量。实际上这个方向向量就是两端点相减。 假设直线$(P,\\vec{a}),(Q,\\vec{b})$交点为$C$。 显然，我们可以用$P+t\\vec{a}$来表示一个在直线上的点。 设$C=P+t_1\\vec{a}=Q+t_2\\vec{b}$。 大力列方程： $\\begin{cases}x_C=x_P+t_1x_a=x_Q+t_2x_b\\\\y_C=y_P+t_1y_a=y_Q+t_2t_b\\end{cases}$ 大力化式子： $t_1=\\dfrac{x_by_P-x_Py_b+x_Qy_b-x_by_Q}{x_ay_b-x_by_a}$ 大力叉乘： $t_1=\\dfrac{\\vec{b}\\times\\vec{p}+\\vec{q}\\times\\vec{b}}{\\vec{a}\\times\\vec{b}}=\\dfrac{\\vec{b}\\times(\\vec{p}-\\vec{q})}{\\vec{a}\\times\\vec{b}}$ inline point inter(line a,line b){ point A=a.b-a.a,B=b.b-b.a; return a.a+A*cross(B,a.a-b.a)/cross(A,B); } 线段交点和直线一样，但是也要判断一下求出来的点是否在线段上。 其他投影 点$C$在$\\overrightarrow{AB}$上的投影为$D$。 $\\overrightarrow{AC}\\cdot\\overrightarrow{AB}=|\\overrightarrow{AD}||\\overrightarrow{AB}|$ $|\\overrightarrow{AD}|=\\dfrac{\\overrightarrow{AC}\\cdot\\overrightarrow{AB}}{|\\overrightarrow{AB}|}$ 转化$\\overrightarrow{AD}$为其模长乘单位向量： $\\overrightarrow{AD}=|\\overrightarrow{AD}|\\dfrac{\\overrightarrow{AB}}{|\\overrightarrow{AB}|}=\\dfrac{(\\overrightarrow{AB}\\cdot\\overrightarrow{AC})\\overrightarrow{AB}}{|\\overrightarrow{AB}|^2}$ $\\vec{d}=\\vec{a}+\\overrightarrow{AD}$ inline point project(point a,line b){ point AB=b.b-b.a; return b.a+AB*dot(AB,a-b.a)/abs2(AB); } 点到直线距离投个影求两点距离即可。 inline double dis(point a,line b){ point p=project(a,b); return dis(a,p); } 点到线段距离同上，判断一下投影是否在线段上，不在的话取两端点距离最小值。 直线到直线距离先判断是否平行，不平行距离为$0$；否则任取一点计算到另一条直线的距离。 inline double dis(line a,line b){ if(!par(a,b))return 0; return dis(a.a,b); } 线段到线段距离判断平行，不平行的话要把不属于同一线段的端点距离都算一遍，取最小值。 多边形定义vector存储即可。 typedef vector&lt;point&gt; polygon; 为了方便下面计算，要求按逆时针方向存储各顶点。 面积先考虑原点在多边形内部的情况： 把多边形分成若干个三角形，容易看出每个三角形的面积就是相邻两点叉乘的一半。 如果原点不在多边形内部呢？ 在计算下面$\\overrightarrow{OA},\\overrightarrow{OB},\\overrightarrow{OC}$之间的叉乘时，因为和上面的方向相反，正好把多出来的白色部分减掉了，所以一样适用。 顺便发现了一种不用取模或特判的循环方法： inline double area(const polygon &amp;a){ double ans=0; for(register int i=0,j=a.size()-1;i&lt;a.size();j=i++)ans+=cross(a[j],a[i]); return ans/2; } 点在多边形内部网上基本都是水平向左引一条射线判断与多边形交点数的奇偶。但这样还要处理过顶点之类的特殊情况。在「算法竞赛·入门经典」上看到一种不用特判的方法。 水平向右引一条射线，正穿过一条边加1，反穿过一条边减1，最后如果和为$0$，说明不在多边形上。 判断正穿和反穿： 左边情况：$\\overrightarrow{OJ}\\times\\overrightarrow{JI}&lt;0,y_O\\in[y_I,y_J]$ 右边情况：$\\overrightarrow{OJ’}\\times\\overrightarrow{OI’}&gt;0,y_O\\in[y_{J’},y_{I’}]$。 inline int contain(point a,polygon &amp;b){ int cnt=0; for(register int i=0,j=b.size()-1;i&lt;b.size();j=i++){ if(locate(a,line(b[i],b[j])))return -1;//在多边形边界上 if(cmp(a.y,b[j].y)==cmp(a.y,b[i].y))continue; double k=cross(b[j]-a,b[i]-b[j]); if(k&lt;0&amp;&amp;cmp(a.y,b[i].y)&gt;=0)++cnt; else if(k&gt;0&amp;&amp;cmp(a.y,b[j].y)&gt;=0)--cnt; } return (bool)cnt; } 重心直接背过吧 分成若干三角形，记$S_i$为第$i$个三角形的有向面积，$(x_i,y_i)$为第$i$个三角形的重心。 $x=\\dfrac{\\sum S_ix_i}{\\sum S_i},y=\\dfrac{\\sum S_iy_i}{\\sum S_i}$ 三角形$(x_1,y_1)-(x_2,y_2)-(x_3,y_3)$的重心： $\\left(\\dfrac{x_1+x_2+x_3}{3},\\dfrac{y_1+y_2+y_3}{3}\\right)$ inline point center(const polygon &amp;a){ double S=0.0,x=0.0,y=0.0; for(register int i=0,j=a.size()-1;i&lt;a.size();j=i++){ double s=cross(a[i],a[j]); S+=s,x+=s*(a[i].x+a[j].x)/3,y+=s*(a[i].y+a[j].y)/3; } return point(x/S,y/S); } 圆定义圆心与半径。 struct circle{ point c; double r; circle(point C=point(0,0),double R=0){c=C,r=R;} }; 三点定圆众所周知，不共线的三个点确定一个圆。 用平面几何可以搞。做两条中垂线算交点即为圆心，算个距离就是半径。 但这样涉及到旋转、交点和距离，比较繁琐，常数和精度不够优秀。考虑用解析几何。 设三个点分别为$(x_1,y_1),(x_2,y_2),(x_3,y_3)$，圆的圆心为$(x_0,y_0)$，方程为$(x-x_0)^2+(y-y_0)^2=r^2$。 直接把三个点带进去，大力搞方程组。解方程的过程太复杂直接说结论了： 令 $a=x_1^2-x_2^2+y_1^2-y_2^2$ $b=x_2^2-x_3^2+y_2^2-y_3^2$ $c=x_1-x_2$ $d=y_1-y_2$ $e=x_2-x_3$ $f=y_2-y_3$ $x_0=\\dfrac{af-bd}{2(cf-de)}$ $y_0=\\dfrac{bc-ae}{2(cf-de)}$ 最后带回去算$r$即可。 circle(point A,point B,point C){ #define sqr(x) ((x)*(x)) double a=sqr(A.x)-sqr(B.x)+sqr(A.y)-sqr(B.y),b=sqr(B.x)-sqr(C.x)+sqr(B.y)-sqr(C.y),_c=A.x-B.x,d=A.y-B.y,e=B.x-C.x,f=B.y-C.y,m=2*(_c*f-d*e); c=point((a*f-b*d)/m,(b*_c-a*e)/m); r=sqrt(sqr(A.x-c.x)+sqr(A.y-c.y)); #undef sqr } 切线 根据点到圆心距离和半径用反三角函数能算出来$\\left\\langle\\overrightarrow{AC},\\overrightarrow{AB}\\right\\rangle$，把$\\overrightarrow{AC}$转一下即可。 inline line tangent(point a,circle b){ double d=dis(a,b.c); return line(rotate(b.c-a,asin(b.r/d))+a,a); //另一条切线就是-asin } 圆和直线的交点比较圆心到直线的距离和半径的关系判断有没有交。 一看就是有垂径定理了，作$A$在$CD$上的投影$H$。 根据勾股定理，$|HF|=\\sqrt{|AF|^2-|AH|^2}=\\sqrt{r^2-|AH|^2}$。 $\\overrightarrow{HF}=|HF|\\dfrac{\\overrightarrow{CD}}{|CD|}$ $\\vec{f}=\\vec{h}+\\overrightarrow{HF}$ inline point inter(line a,circle b){ point h=project(b.c,a); return h+(a.b-a.a)*sqrt((b.r*b.r-abs2(b.c-h))/abs2(a.b-a.a)); //另一个交点就是h-... } 圆和圆的交点比较圆心的距离和半径之和的关系判断有没有交。 根据余弦定理： $|BE|^2=|AE|^2+|AB|^2-2|AB||AE|\\cos\\left\\langle\\overrightarrow{AB},\\overrightarrow{AE}\\right\\rangle$ $\\left\\langle\\overrightarrow{AB},\\overrightarrow{AE}\\right\\rangle=\\arccos\\left(\\dfrac{|AE|^2+|AB|^2-|BE|^2}{2|AB||AE|}\\right)=\\arccos\\left(\\dfrac{r_1^2-r_2^2+|AB|^2}{2r_1|AB|}\\right)$ 旋转一下$\\overrightarrow{AB}$，乘上$\\dfrac{|AE|}{|AB|}$得到$\\overrightarrow{AE}$。 inline point inter(circle a,circle b){ double d=dis(a.c,b.c); return rotate(b.c-a.c,acos((a.r*a.r-b.r*b.r+d*d)/(2.0*a.r*d)))*a.r/d+a.c; //另一个交点就是-acos } 外公切线GeoGebra画不了公切线将就着看吧 作$BC\\perp AE$于$C$。 用反三角函数能得到$\\left\\langle\\overrightarrow{AB},\\overrightarrow{AE}\\right\\rangle$，旋转$\\overrightarrow{AB}$，乘上$\\dfrac{r_1}{|AB|}$就能得到$\\overrightarrow{AE}$，进而得到$\\vec{e}$。 同理能得出$\\vec{f}$。 const double pi = acos(-1); inline line ex_common_tangent(circle a,circle b){ point AB=b.c-a.c; double d=abs(AB),an=acos((a.r-b.r)/d); return line(point(a.c+rotate(AB,an)*a.r/d),point(b.c+rotate(a.c-b.c,an-pi)*b.r/d)); //把旋转角度都取反得到另一条外公切线 } 内公切线 和外公切线差不多。 作$AH\\perp BF$延长线于$H$。 用反三角函数得到$\\left\\langle\\overrightarrow{BA},\\overrightarrow{BH}\\right\\rangle=\\left\\langle\\overrightarrow{AB},\\overrightarrow{AE}\\right\\rangle$，把$\\overrightarrow{AB}$转到$\\overrightarrow{AE}$乘上$\\dfrac{r_1}{|AB|}$得到$\\overrightarrow{AE}$，进而得到$\\vec{e}$，同理得到$\\vec{f}$。 代码和外公切线的区别只有a.r-b.r改成a.r+b.r和an-pi改成an。 inline line in_common_tangent(circle a,circle b){ point AB=b.c-a.c; double d=abs(AB),an=acos((a.r+b.r)/d); return line(point(a.c+rotate(AB,an)*a.r/d),point(b.c+rotate(a.c-b.c,an)*b.r/d)); //旋转角度都取反得到另一条内公切线 } 二维凸包凸包就是平面上有一堆点，把最外围的点连成一个凸多边形，框起来这些点。 这里是一种不正经的方法求凸包说不定哪天就翻车了，想学正经的Andrew算法的另寻大佬吧。 如果学过斜率优化$DP$的话甚至可以自己$yy$出来。对这些点求一个上凸壳和一个下凸壳拼起来即可。 上凸壳就是维护一个相邻点构成的直线斜率递减的点集，下凸壳则是递增的。不过这里我们还有chuan新的判断方式：计算差积判断方向。 和斜率优化一样，以横坐标为第一关键字、纵坐标为第二关键字排序，用单调栈维护凸壳。 找上凸壳的时候可以倒着再求一遍下凸壳，避免重新排序。 之后我们会发现一个问题：上凸壳和下凸壳的点可能会有交集。 这样常数大了，有的时候还会导致求某些东西的时候出锅。需要再对凸包上的点去重。 struct point{ double x,y; point(double X=0.0,double Y=0.0){x=X,y=Y;} point operator + (const point &amp;a){return point(x+a.x,y+a.y);} point operator - (const point &amp;a){return point(x-a.x,y-a.y);} bool operator &lt; (const point &amp;a)const{return x==a.x?y&lt;a.y:x&lt;a.x;} bool operator != (const point &amp;a){return x!=a.x||y!=a.y;} }p[maxn],sta[maxn],u[maxn]; typedef vector&lt;point&gt; polygon; int top; polygon v; inline int cmp(double a,double b){return fabs(a-b)&lt;eps?0:a-b&gt;eps?1:-1;} inline double abs(const point &amp;a){return a.x*a.x+a.y*a.y;} inline double abs2(const point &amp;a){return sqrt(abs(a));} inline double dis(point a,point b){return abs2(a-b);} inline double cross(const point &amp;a,const point &amp;b){return a.x*b.y-a.y*b.x;} int main(){ int n=read(),cnt=0; double ans=0.0; for(register int i=1;i&lt;=n;++i)scanf(&quot;%lf%lf&quot;,&amp;p[i].x,&amp;p[i].y); sort(p+1,p+1+n); for(register int i=1;i&lt;=n;++i){ while(top&gt;1&amp;&amp;cmp(cross(p[i]-sta[top],sta[top]-sta[top-1]),0)&gt;=0)--top; sta[++top]=p[i]; } for(register int i=1;i&lt;=top;++i)u[i]=sta[i]; cnt=top,top=0; for(register int i=n;i;--i){ while(top&gt;1&amp;&amp;cmp(cross(p[i]-sta[top],sta[top]-sta[top-1]),0)&gt;=0)--top; sta[++top]=p[i]; } for(register int i=1;i&lt;=top;++i)u[++cnt]=sta[i]; for(register int i=1,j=cnt;i&lt;=cnt;j=i++)if(u[i]!=u[j])v.push_back(u[i]); for(register int i=0,j=v.size()-1;i&lt;v.size();j=i++)ans+=dis(v[i],v[j]); printf(&quot;%.2lf\\n&quot;,ans); } 旋转卡壳考虑怎么找到一个点的最远点。 过点$A$作一条直线（不能与凸包内有交），再过另一个点作一条平行线，使两条直线距离最大，这个点（$E$）就是最远点了。这两个点就叫对踵点。 不过随便作一条直线的话好像不太好找，让这条直线过凸包的一条边： 这时通过计算三角形的面积，即通过叉乘，就能判断平行线之间的距离了： 而且，观察一下会发现，这个面积是一个单峰函数。 于是依次遍历每条边，让最远点跟着动。剽张gif： 代码很简短： if(c.size()==2){printf(&quot;%d\\n&quot;,abs2(c[0]-c[1]));return 0;}//特判两个点 int k=1,ans=0; for(register int i=0,j=c.size()-1;i&lt;c.size();++i,j=i++){ while(cross(c[i]-c[j],c[k]-c[j])&lt;cross(c[i]-c[j],c[(k+1)%c.size()]-c[j]))k=(k+1)%c.size(); ans=max(max(ans,abs2(c[i]-c[j])),max(abs2(c[k]-c[i]),abs2(c[k]-c[j]))); } printf(&quot;%d\\n&quot;,ans); 半平面交什么是半平面交？ 一条有向直线左侧的平面称为半平面。顾名思义，半平面交就是若干条有向直线的半平面的交集。 朴素的求法是$O(n^2)$的，维护当前的半平面交，枚举直线切割半平面交，如果能缩小交集就加入，再删去无用直线。 定义一条有向直线的极角为其与$x$轴正半轴夹角。 优化朴素算法，要先按极角排序本来求凸包要用极角排序的，但是我求凸包的方法太鬼畜了结果拖到这里 用双端队列维护若干条直线表示当前半平面交。加入一条直线，分别在队尾和队首把无用的直线弹掉： 加入绿色直线后，蓝色直线就无用了。得到判断方式为：只要队尾和队尾前一条直线的交点在新直线右侧（判断左右用叉乘），队尾就无用。队首同理。 把新直线压到队尾。最后双端队列中相邻元素求交点得到的凸多边形就是半平面交。 再有两个细节： 一个是极角排序时，如果有几条直线极角相同，要仅保留最靠左的直线。不然求交点会炸。 另一个是求完半平面交之后，双端队列里可能会出现这种东西： 两条红色直线是最后加入双端队列的，但它们都没有用。而且如果模拟一下上面的过程，这种直线的出现是合情合理的。 如果再加一条直线呢？ 如果是绿/紫色位置（新直线无用），要么红色直线被判为无用弹出，要么只把新直线压进去；如果是棕色位置（新直线有用），红色直线必定被弹出。 所以这种直线一定都堆积在队尾。求完半平面交后，检查一下队尾两条直线交点和队首直线的关系即可。 复杂度瓶颈在排序，$O(n\\log n)$的。 inline bool mmp(line &amp;a,line &amp;b){ int k=cmp(angle(a),angle(b)); if(!k)return cmp(cross(b.b-a.a,b.a-a.a),0)==-1; return k==-1; } inline bool judge(point &amp;a,line &amp;b){return cmp(cross(b.b-a,b.a-a),0)==1;} point p[maxn]; line l[maxn],q[maxn]; polygon v; int main(){ int n=read(),h=1,t=0,cnt=0; while(n--){ v.clear(); int m=read(); point p; while(m--)p.x=read(),p.y=read(),v.push_back(p); for(register int i=0,j=v.size()-1;i&lt;v.size();j=i++)l[++cnt]=line(v[j],v[i]); } sort(l+1,l+1+cnt,mmp); for(register int i=1;i&lt;=cnt;++i){ if(i!=1&amp;&amp;!cmp(angle(l[i]),angle(l[i-1])))continue; while(t-h&gt;=1&amp;&amp;judge(p[t],l[i]))--t; while(t-h&gt;=1&amp;&amp;judge(p[h+1],l[i]))++h; q[++t]=l[i]; if(t-h&gt;=1)p[t]=inter(q[t],q[t-1]); } v.clear(); while(t-h&gt;=1&amp;&amp;judge(p[t],q[h]))--t; v.push_back(inter(q[h],q[t])); for(register int i=h+1;i&lt;=t;++i)v.push_back(p[i]); printf(&quot;%.3lf\\n&quot;,area(v)); } 板子的性质比较好，没有特殊情况。 如果半平面交不是个封闭图形呢？ 强行用一个极大的矩形规定坐标范围（超过题目给定坐标范围），加进半平面交里即可。 如果半平面交是空集呢？ 此时队列元素个数不超过2。因为前面用一个大矩形框了起来，所以只要存在半平面交，一定有至少三条直线。 还有一道双倍经验。实际上这样能无死角看到整个多边形的区域就是半平面交，被称为多边形的核。 最小圆覆盖板子 双倍经验 给出平面上的$n$个点，求一个最小的圆使其覆盖所有的点。 这个要用随机增量法。 不难发现一个结论：如果点集$S$的最小覆盖圆没有覆盖到$P$，则$P$一定在$S\\cup\\{P\\}$的最小覆盖圆上。 根据这个，我们可以得到一个复杂度不靠谱的解法： 遍历一遍点集，维护前$i-1$个点的最小覆盖圆作为当前答案（记为$ans$） 如果$P_i$没有被$ans$覆盖，则根据上面的结论，更新$ans$为以$P_i$为圆心、半径为$0$的圆，遍历前$i-1$个点（假设当前遍历到了$P_j$） 如果$P_j$没有被$ans$覆盖，更新$ans$为以$P_i,P_j$中点为圆心，半径为$\\frac{dis(P_i,P_j)}{2}$的圆，遍历前$j-1$个点（假设当前遍历到了$P_k$） 如果$P_k$没有被$ans$覆盖，此时我们就得到了$P_i,P_j,P_k$三个位于当前点集最小覆盖圆上的点，三点定圆更新$ans$ 乍一看是$O(n^3)$的，既然是随机增量法，先random_shuffle打乱点集。 第一层遍历：根据三点定圆，$P_i$有$\\frac{3}{i}$的概率在前$i$个点的最小覆盖圆上，进入第二层遍历。 第二层遍历：遍历到$P_j$时，实际上是在求$\\{P_i\\}\\cup\\{P_x|x\\le j\\}$的最小覆盖圆，点集大小为$j+1$，$P_j$有$\\frac{3}{j}$的概率被选中，进入第三层遍历。 第三层遍历的复杂度显然是点集大小的。 于是得到： $T_1(n)=O(n)+\\sum\\limits_{i=1}^n\\dfrac{3}{i}T_2(i)$ $T_2(n)=O(n)+\\sum\\limits_{i=1}^n\\dfrac{3}{i}T_3(i)$ $T_3(n)=O(n)$ 所以期望复杂度是$O(n)$的。 point p[maxn]; circle ans; inline bool contain(point &amp;a,circle &amp;b){return cmp(abs2(a-b.c),b.r*b.r)&lt;=0;} int main(){ int n=read(); for(register int i=1;i&lt;=n;++i)scanf(&quot;%Lf%Lf&quot;,&amp;p[i].x,&amp;p[i].y); random_shuffle(p+1,p+1+n); for(register int i=1;i&lt;=n;++i){ if(!contain(p[i],ans)){ ans=circle(p[i],0); for(register int j=1;j&lt;i;++j) if(!contain(p[j],ans)){ ans=circle((p[i]+p[j])/2,dis(p[i],p[j])/2); for(register int k=1;k&lt;j;++k) if(!contain(p[k],ans))ans=circle(p[i],p[j],p[k]); } } } printf(&quot;%.10Lf\\n%.10Lf %.10Lf\\n&quot;,ans.r,ans.c.x,ans.c.y); } 水题信用卡凸包显然凸包上的圆弧加起来是个整圆，对所有圆心求凸包即可。 最大土地面积显然答案一定是在凸包上的四个点。 枚举对角线，然后四边形的面积就被分成两个三角形。和旋转卡壳一样，这两个三角形的面积都是单峰函数，于是再维护两个指针跟着对角线走即可。$O(n^2)$可过。 最小矩形覆盖先求个凸包。 猜一下结论，矩形的一条边一定和凸包的一条边重合。 感觉挺对的，那我们枚举这条边就行了，其对边显然过对踵点。而邻边也一定过凸包上的点，维护一下这两个点，旋转卡壳的时候跟着动就行了。 计算面积和求矩形投影旋转啥的就行了。 射箭二分答案。 观察限制$ax^2+bx\\in [y_1,y_2]$，化简为$ax+b\\in [\\frac{y_1}{x},\\frac{y_2}{x}]$。 把$a$看作自变量，$b$看作因变量，那么形如$ax+b\\le c$或$ax+b\\ge c$实际上是一个半平面。判断一下半平面交是否为空即可。 我们需要用一个极大的矩形框起来坐标系，同时由于抛物线在第一象限，有一个潜在的条件$a\\lt0,b\\gt0$，所以选择第二象限的矩形。 提前排好序就能$O(n\\log n)$了。 最后，为丧心病狂卡精度卡常的出题人献上祝福： #define double long double const double eps = 1e-18; const double inf = 1e10; 数矩形可以证明，矩形个数上界为$O(n^{2.5})$。 根据矩形对角线等长同中点，对$C_n^2$条线段排序暴力枚举即可。 瞭望塔先求出来多边形的核。然后是一个结论：瞭望塔的位置一定在半平面交或地形的一个端点上。 证明很简单，把半平面交和地形的端点抠出来，横坐标相邻的放一块，截取中间的半平面交和地形，一定是上下两条线段。 分类讨论一下，无非是斜率一个大一个小。如果上面的斜率大，在线段上任意一点一定不如左端点；反之为右端点。 赛车很裸的半平面交。由于时间是正数，要用一个$y$轴负半轴方向的向量限制一下。 小凸想跑步题解 信号增幅仪把$x$轴逆时针旋转$a^\\circ$（也就是把所有点旋转$-a^\\circ$），再把所有点的横坐标缩小至$\\frac{1}{p}$倍，就是最小圆覆盖了。 最小覆盖双圆问题题解","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ctz45562.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"计算几何","slug":"计算几何","permalink":"https://ctz45562.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"}]},{"title":"洛谷 P5504 [JSOI2011]柠檬","slug":"洛谷-P5504-JSOI2011-柠檬","date":"2020-01-15T03:13:43.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2020/01/15/洛谷-P5504-JSOI2011-柠檬/","link":"","permalink":"https://ctz45562.github.io/2020/01/15/%E6%B4%9B%E8%B0%B7-P5504-JSOI2011-%E6%9F%A0%E6%AA%AC/","excerpt":"传送门 诶嘿嘿随便一交就是最优解","text":"传送门 诶嘿嘿随便一交就是最优解 首先指出一个阅读理解问题：去掉一段lemon后，两边的lemon是不会拼起来的。 所以这个操作实际上就是序列划分成若干区间使贡献最大。 设$f(i)$为前$i$个lemon的最大值。 容易得到$f(i)=\\max\\limits_{j&lt;i}\\{f(j)+w(j,i)\\}$，其中$w(j,i)$为区间$[j,i]$的最大的$a_0t^2$。 这个$w(j,i)$不太好算啊，而且也没有决策单调性 用三半规管想一想的话，会发现一个显然的性质：划分的子段两端点颜色一定相同且选择的$a_0$就是端点的颜色。再向两边扩展是没有贡献的，不如自成一段。 令$s_i$为$\\sum\\limits_{j\\le i}[a_j=a_i]$。 方程改为$f(i)=\\max\\limits_{j\\le i,a_j=a_i}\\{f(j-1)+a_i(s_i-s_j+1)^2\\}$。 这一看就是斜率优化了，化一化式子： $f(i)+2a_is_is_j\\sim f(j-1)+a_is_j(s_j-2)$ 看起来还不能斜率优化，不过有$a_i=a_j$嘛： $f(i)+2a_is_is_j\\sim f(j-1)+a_js_j(s_j-2)$ 在同种颜色里斜率递增，横坐标递增，求最大截距。每种颜色开一个单调队列维护上凸包即可。（不过因为是添加和删除都是在队尾进行，用单调栈就能维护） 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #define maxn 100005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } struct triple{ long long y;int x,p; triple(int X=0,long long Y=0,int P=0){x=X,y=Y,p=P;} friend double operator / (const triple &amp;a,const triple &amp;b){return double(a.y-b.y)/(a.x-b.x);} }; vector&lt;triple&gt;q[10005]; long long f[maxn],a[maxn],s[maxn],tax[10005]; inline void push(triple d,int c){ triple t; while(q[c].size()&gt;1&amp;&amp;(*(q[c].end()-1))/(*(q[c].end()-2))&lt;d/(*(q[c].end()-1)))q[c].pop_back(); q[c].push_back(d); } inline int get(double k,int c){ while(q[c].size()&gt;1&amp;&amp;(*(q[c].end()-1))/(*(q[c].end()-2))&lt;k)q[c].pop_back(); return (q[c].end()-1)-&gt;p; } int main(){ int n=read(); long long ans=0,ma=0; for(register int i=1;i&lt;=n;++i){ s[i]=++tax[a[i]=read()]; push(triple(s[i],1ll*a[i]*s[i]*(s[i]-2)+f[i-1],i),a[i]); int j=get(s[i]*a[i]&lt;&lt;1,a[i]); f[i]=f[j-1]+1ll*a[i]*(s[i]-s[j]+1)*(s[i]-s[j]+1); } printf(&quot;%lld\\n&quot;,f[n]); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"单调栈","slug":"单调栈","permalink":"https://ctz45562.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"斜率优化","slug":"斜率优化","permalink":"https://ctz45562.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"}]},{"title":"决策单调性学习笔记","slug":"决策单调性学习笔记","date":"2020-01-14T03:11:26.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2020/01/14/决策单调性学习笔记/","link":"","permalink":"https://ctz45562.github.io/2020/01/14/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"neb e denoe rsdi gWeiFielb?in 世界上最无聊的事之一——造一个连自己也不会破译的密码。","text":"neb e denoe rsdi gWeiFielb?in 世界上最无聊的事之一——造一个连自己也不会破译的密码。 前言真的，不要尝试破译上面那个密码，你会爆炸的 决策单调性是一类优化动态规划的算法。 我也没想到生成函数这么快就结束了，干脆垫上一些小算法后开计算几何吧。 抄袭来源 https://www.luogu.com.cn/blog/83547/zong-dong-tai-gui-hua-di-ben-zhi-kan-si-bian-xing-fou-deng-shi-you-hua https://www.luogu.com.cn/problemnew/solution/P1912 某网课 决策单调性定义如果我们有一个$DP$的式子：$f(i)=\\min\\limits_{j&lt;i}\\{f(j)+w(j,i)\\}$ 其中$w(j,i)$是一个与$i,j$有关的二元函数。而且这个$w(j,i)$搞不了单调队列或斜率优化。 但是，如果我们通过打表或证明发现决策点是单调不降的（$f$值不一定单调），这个$DP$就满足决策单调性。 形式化地说，记$p_i$为$f(i)$的决策点（即$p_i$是使$f(j)+w(j,i)$最小的那个$j$），则$\\forall i&gt;j,p_i\\ge p_j$。 这样我们就可以根据决策单调性优化$DP$。 如何证明怎么优化下面讲。先说一下如何证明。（以上面的$\\min$方程为例，$\\max$倒过来就好啦） 直接输出决策点打表是一个好办法，然后再写一个决策单调性优化$DP$和暴力拍。 而严谨的证明可以用四边形不等式。（以下只给出结论，结论和四边形不等式性质的证明我太菜了不会，还请自行搜索） 四边形不等式：如果$\\forall a&lt;b&lt;c&lt;d,w(a,c)+w(b,d)\\le w(a,d)+w(b,c)$（相交优于包含）且$w(a,d)\\ge w(b,c)$（大区间比其子区间权值大），称为四边形不等式，此时满足决策单调性。 这个式子看起来不太好用来证明，还有一个性质： 如果$\\forall a&lt;b,w(a,b)+w(a+1,b+1)\\le w(a,b+1)+w(a+1,b)$，则满足四边形不等式。 其实还是“相交优于包含”，只是把区间放缩了一下，更容易证明了。 还有一种更直观更好用的证明方法： 考虑决策单调性的实质：为什么会出现决策单调性？ 决策点单调不降，换句话说，如果$i$有两个决策点$j,k(k&lt;j)$，只要$j$优于$k$，那么在之后$i+1,i+2\\dots$的决策中，$k$就再也没有反超的机会了。 $k$怎么着就反超不了$j$了？随着$i$的增加，$w(k,i)$的增长速度比$w(j,i)$快。 所以只要证明自变量为$i$的函数$w(j,i)$满足任意$k&lt;j$，$w(k,i)$增长速度比$w(j,i)$快即可。 你会发现这实质上就是四边形不等式，但从决策单调性的角度上理解更直观了。 优化一般有两种优化方式——二分和分治。 二分解法例题-诗人小G 设$f(i)$为前$i$句话的最小代价，$sum_i$为$\\sum\\limits_{j\\le i}len(s_j)+1$。 $DP$方程显然：$f(i)=\\min\\limits_{j&lt;i}\\{f(j)+|sum_i-sum_j-L-1|^P\\}$。 打表可以发现决策单调性，尝试证明一下： $w(j,i)$就是$|sum_i-sum_j-L-1|^P$。 假设有$k&lt;j$，现在要证明$w(k,i)$增长速度比$w(j,i)$快，即$|sum_i-sum_k-L-1|^P$增长速度比$|sum_i-sum_j-L-1|^P$快。 令$p=-sum_k-L-1,q=-sum_j-L-1$，显然$p&gt;q$。 尝试画出$w(k,i)$和$w(j,i)$的图象： 这里只画了$P=2$的情况。但只要$P&gt;1$，$|x+c|^p$的图象就有这些性质： 关于$x=-c$对称 在对称轴左侧单调递减，右侧单调递增 离对称轴越远，下降/增长速率越快 分类讨论： 当$sum_i$在$A$左侧的时候，$w(k,i)$和$w(j,i)$都在下降，而$sum_i$离$x=-q$更远，$w(j,i)$下降更快（增长速度小） 当$sum_i$在$A,B$之间时，$w(k,i)$在上升，$w(j,i)$在下降 当$sum_i$在$B$右侧时，$w(k,i)$和$w(j,i)$都在上升，而$sum_i$离$x=-q$更近，$w(j,i)$增长更慢 综上，$w(k,i)$增长速度比$w(j,i)$快，满足决策单调性。 考虑如何优化。既然有决策单调性了，决策点与位置会有这样的关系： 每个决策点控制了一段连续的区间。 于是可以维护一个决策点的单调队列，其中存有若干三元组$(p_i,l_i,r_i)$表示决策点$p_i$当前控制区间$[l_i,r_i]$的转移，队尾三元组一定满足$r_{tail}=n$。 转移时，弹出队头直到$i\\in[l,r]$，然后直接转移。 之后我们得到了一个新的决策点$i$，分步进行： 判断$n$以$i$为决策点是否不如$p_{tail}$优，如果在位置$n$都干不过队尾的话就可以当场去世了。 否则，不断判断$l_{tail}$以$i$为决策点转移是否比$p_{tail}$更优。如果$i$在$l_{tail}$都比$p_{tail}$优的话，后面的位置就更不用说了，把队尾踢掉好了。 最后，显然控制区间是有单调性的。根据$[l_{tail},r_{tail}]$二分出左端点（右端点为$n$），更新队尾的$r_{tail}$并把$i$压入队尾。 复杂度$O(n\\log n)$。 要判断答案是否超过$10^{18}$，直接long long的话会爆炸，用long double存储。 代码long double f[maxn]; int sum[maxn],pos[maxn],ll[maxn],rr[maxn],w[maxn],l,p; char s[maxn][31]; inline long double quickpow(long double x,int y){ long double ans=1.0; while(y){ if(y&amp;1)ans*=x; x*=x,y&gt;&gt;=1; } return ans; } void print(int p){ if(!p)return; print(pos[p]); for(register int i=pos[p]+1;i&lt;p;++i)printf(&quot;%s &quot;,s[i]); printf(&quot;%s\\n&quot;,s[p]); } inline long double calc(int j,int i){return f[j]+quickpow(abs(sum[i]-sum[j]-l-1),p);} inline int getpos(int l,int r,int p,int q){ while(l&lt;r){ int mid=l+r&gt;&gt;1; if(calc(p,mid)&lt;calc(q,mid))r=mid; else l=mid+1; } return l; } int main(){ int t=read(); while(t--){ int n=read(),h=1,t=0; l=read(),p=read(); for(register int i=1;i&lt;=n;++i)scanf(&quot;%s&quot;,s[i]),sum[i]=sum[i-1]+strlen(s[i])+1; ll[++t]=1,rr[t]=n,w[t]=0; for(register int i=1;i&lt;=n;++i){ while(h&lt;=t&amp;&amp;rr[h]&lt;i)++h; f[i]=calc(pos[i]=w[h],i); if(calc(i,n)&gt;=calc(w[t],n))continue; while(h&lt;=t&amp;&amp;calc(i,ll[t])&lt;calc(w[t],ll[t]))--t; rr[t]=getpos(ll[t],rr[t]+1,i,w[t])-1,++t,ll[t]=rr[t-1]+1,rr[t]=n,w[t]=i; } if(f[n]&gt;1e18)puts(&quot;Too hard to arrange&quot;); else { printf(&quot;%lld\\n&quot;,(long long)(f[n]+0.5)); print(n); } puts(&quot;--------------------&quot;); } } 利弊二分的好处是能动态加入决策点，方程中未计算出的$f$不影响维护决策单调性（这一点在分治中能体现出来）。 而缺点是必须能快速计算$w(j,i)$。 分治普通分治例题 其实算不上DP，只是用决策单调性优化而已 移个项：$a_j+\\sqrt{|i-j|}-a_i\\le p$ 则$ans_i=\\max\\{a_j+\\sqrt{|i-j|}\\}-a_i$。 分类去掉绝对值：$ans_i=\\max\\{\\max\\limits_{j&lt; i}\\{a_j+\\sqrt{i-j}\\},\\max\\limits_{j&gt;i}\\{a_j+\\sqrt{j-i}\\}\\}-a_i$ 因为前一半翻转过来再求一遍就是后一半，所以只考虑$\\max\\limits_{j&lt;i}\\{a_j+\\sqrt{i-j}\\}$。 同样通过打表，可以发现满足决策单调性。 严格证明也好说，显然函数$f(x)=x^{\\frac{1}{2}}$的增长速度是越来越慢的，就能证出来，不再赘述。 分治的基础是根据决策单调性，如果已知$i$的决策点$p_i$，则$\\forall j&lt; i,p_j\\le p_i$；$\\forall j&gt;i,p_j\\ge p_i$。 维护一个位置区间$[l,r]$和决策点区间$[L,R]$，表示$\\forall i\\in[l,r],p_i\\in[L,R]$。初始都是$[1,n]$。 分治时，取$[l,r]$的中点$mid$，暴力遍历$[L,R]$得到$p_{mid}$，然后继续分治$([l,mid-1],[L,p_{mid}])$和$([mid+1,r],[p_{mid},R])$。 复杂度还是容易算的：一共递归$O(\\log n)$层，每层遍历的$[L,R]$之和是$O(n)$的，总复杂度为$O(n\\log n)$。 代码1double f[maxn],ans[maxn]; int a[maxn]; void solve(int l,int r,int L,int R){ if(l&gt;r)return; int mid=l+r&gt;&gt;1,p; for(register int i=min(mid,R);i&gt;=L;--i)if(f[mid]&lt;a[i]+sqrt(mid-i))f[mid]=a[i]+sqrt(mid-i),p=i; solve(l,mid-1,L,p); solve(mid+1,r,p,R); } int main(){ int n=read(); for(register int i=1;i&lt;=n;++i)a[i]=read(); solve(1,n,1,n); for(register int i=1;i&lt;=n;++i)ans[i]=f[i],f[i]=0.0; reverse(a+1,a+1+n); solve(1,n,1,n); for(register int i=1;i&lt;=n;++i)ans[i]=max(ans[i],f[n-i+1]); reverse(a+1,a+1+n); for(register int i=1;i&lt;=n;++i)printf(&quot;%d\\n&quot;,(int)ceil(ans[i])-a[i]); } 分治+莫队例题 本题中$w(j,i)$就是区间$[j,i]$的相同元素对数。 暴力很简单，设$f(i,j)$为前$j$个数分了$i$段的最小代价。 $f(i,j)=\\min\\limits_{k&lt;j}\\{f(i-1,k)+w(k+1,j)\\}$ 决策单调性的证明也很简单，把元素$a_{i+1}$分别添加到$[j,i]$和$[k,i]$（$k&lt;j$）中，一定有$\\sum\\limits_{x\\in[j,i]}[a_x=a_{i+1}]&lt;\\sum\\limits_{x\\in[k,i]}[a_x=a_{i+1}]$，$w(j,i)$的增长速度比$w(k,i)$慢，满足决策单调性。 而现在最大的问题在于无法快速计算$w(j,i)$。 如果仅仅是多次询问$w(l,r)$且可以离线，第一想法肯定是莫队。 是不是可以把莫队的思想用到分治里呢？ 维护两个指针，计算$w(j,i)$时就暴力把指针移动过去。但是分治就相当于强制在线了，不能对询问排序，只能按分治的顺序移动指针。 可以证明（懒），这样指针的移动次数是$O(n\\log n)$的。 最终复杂度$O(nk\\log n)$。 代码2long long f[2][maxn],ans; int tax[maxn],a[maxn],pl,pr; inline void add(int x){ans+=tax[x],++tax[x];} inline void del(int x){--tax[x],ans-=tax[x];} inline void move(int j,int i){ while(pl&lt;j)del(a[pl++]); while(pl&gt;j)add(a[--pl]); while(pr&gt;i)del(a[pr--]); while(pr&lt;i)add(a[++pr]); } void solve(int l,int r,int L,int R,bool o){ if(l&gt;r)return; int mid=l+r&gt;&gt;1,p; for(register int i=min(mid-1,R);i&gt;=L;--i){ move(i+1,mid); if(f[o^1][i]+ans&lt;f[o][mid])f[o][mid]=f[o^1][i]+ans,p=i; } solve(l,mid-1,L,p,o); solve(mid+1,r,p,R,o); } int main(){ int n=read(),k=read(); for(register int i=1;i&lt;=n;++i)a[i]=read(); memset(f[0],0x3f,sizeof f[0]),f[0][0]=0; for(register int i=1;i&lt;=k;++i){ memset(tax,0,sizeof tax),ans=0,pl=1,pr=0; memset(f[i&amp;1],0x3f,sizeof f[i&amp;1]); solve(i,n,0,n,i&amp;1); } printf(&quot;%lld\\n&quot;,f[k&amp;1][n]); } 利弊最大的优点就是通过莫队的思想可以解决一些$w(j,i)$无法快速计算的问题。再一个分治更好理解，代码好写。 所以请读者尝试写一下「诗人小G」的分治做法。 是不是发现问题了？ 在「诗人小G」中，$f$数组是由自身转移过来的。而在后两道题中，$f$是由无关的数组转移的。 而分治的过程中取了$[l,r]$中点计算，没有按顺序转移。其局限性就在于不能处理自身的转移。 水题注：毕竟这是篇决策单调性学习笔记，下面的题肯定都满足决策单调性。。。而实际应用中这玩意还是要想到并且打表证明出来的。所以所有题均不予证明决策单调性，留给读者自证。 邮局$w(j,i)$为在村儿$[j,i]$中建一个邮局最小的距离和。 显然建在中点是最优的。维护个坐标前缀和就可以$O(1)$算了。 设$f(i,j)$为在前$j$个村儿里造$i$个邮局的最小代价。 枚举第$i$个邮局的控制范围转移：$f(i,j)=\\min\\limits_{k&lt;j}\\{f(i-1,k)+w(k+1,j)\\}$ 看起来这个方程有点别扭，可能$[k+1,j]$里有的村儿最近的邮局不是$i$啊。但这样的话这个转移一定不优，会有一个更大的$k$让这些村儿往最近的邮局跑。 任务分配问题简单地说就是把序列分成$k$段，段内顺序对之和最小。 设$f(i,j)$为前$j$个数分了$i$段的最小顺序对，$w(j,i)$为区间$[j,i]$的顺序对数。 $f(i,j)=\\min\\limits_{k&lt;j}\\{f(i-1,k)+w(k+1,j)\\}$ 分治+莫队套个树状数组即可，$O(nk\\log^2n)$的。 柠檬决策单调性请右转题解区吧，因为我写的斜率优化。。。 斜率优化の题解","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ctz45562.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"决策单调性","slug":"决策单调性","permalink":"https://ctz45562.github.io/tags/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"}]},{"title":"洛谷 P5219 无聊的水题 I","slug":"洛谷-P5219-无聊的水题-I","date":"2020-01-13T01:59:43.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2020/01/13/洛谷-P5219-无聊的水题-I/","link":"","permalink":"https://ctz45562.github.io/2020/01/13/%E6%B4%9B%E8%B0%B7-P5219-%E6%97%A0%E8%81%8A%E7%9A%84%E6%B0%B4%E9%A2%98-I/","excerpt":"传送门 没想到我退役前还能做到$prufer$序列的题。。。","text":"传送门 没想到我退役前还能做到$prufer$序列的题。。。 转换一下，最大度数恰好为$m$的方案数即为最大度数不超过$m$的方案数减去不超过$m-1$的方案数。 无根树？有标号？度数？数数？$prufer$序列！ 最大度数不超过$m$的方案数就是值域为$[1,n]\\bigcap \\mathbb{Z}$、长度为$n-2$、任意元素出现次数不超过$m-1$的序列个数。 如果每个点度数是确定的，其方案数为：$\\dfrac{(n-2)!}{\\prod\\limits_{i=1}^n(d_i-1)!}$。 于是可以构造一个$EGF$：$F(x)=\\sum\\limits_{i=0}^{m-1}\\dfrac{x^i}{i!}$，$i$表示一个点的出现次数。 考虑$F\\times F$的意义：一个$\\dfrac{x^i}{i!}$和$\\dfrac{x^j}{j!}$相乘，对$x^{i+j}$有$\\dfrac{1}{i!j!}$的贡献。 这和前面确定度数的式子很吻合。于是答案为$(n-2)![x^{n-2}]F^n(x)$。 多项式快速幂即可。懒得写$\\ln$和$\\exp$，直接$O(n\\log^2n)$暴力好了。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 140005 #define inf 0x3f3f3f3f const int mod = 998244353; const int g = 3; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } inline int quickpow(int x,int y=mod-2){ int ans=1; while(y){ if(y&amp;1)ans=1ll*ans*x%mod; x=1ll*x*x%mod,y&gt;&gt;=1; } return ans; } const int ig = quickpow(g); int tr[maxn]; inline int qm(int x){return x&gt;=mod?x-mod:x;} void NTT(int *f,int n,bool t){ for(register int i=0;i&lt;n;++i)if(i&lt;tr[i])swap(f[i],f[tr[i]]); for(register int p=2;p&lt;=n;p&lt;&lt;=1){ int len=p&gt;&gt;1,o=quickpow(t?ig:g,(mod-1)/p); for(register int i=0;i&lt;n;i+=p){ int gen=1,cop; for(register int j=i;j&lt;i+len;++j){ cop=1ll*f[j+len]*gen%mod,gen=1ll*gen*o%mod; f[j+len]=qm(f[j]+mod-cop),f[j]=qm(f[j]+cop); } } } if(t){ int inv=quickpow(n); for(register int i=0;i&lt;n;++i)f[i]=1ll*f[i]*inv%mod; } } int F[maxn]; void Pow(int *g,int n,int y){ int lim=1; while(lim&lt;n&lt;&lt;1)lim&lt;&lt;=1; for(register int i=0;i&lt;lim;++i)tr[i]=(tr[i&gt;&gt;1]&gt;&gt;1)|(i&amp;1?lim&gt;&gt;1:0); NTT(g,lim,0),--y; for(register int i=0;i&lt;lim;++i)F[i]=g[i]; while(y){ if(y&amp;1){ for(register int i=0;i&lt;lim;++i)F[i]=1ll*F[i]*g[i]%mod; NTT(F,lim,1); for(register int i=n;i&lt;lim;++i)F[i]=0; NTT(F,lim,0); } for(register int i=0;i&lt;lim;++i)g[i]=1ll*g[i]*g[i]%mod; NTT(g,lim,1); for(register int i=n;i&lt;lim;++i)g[i]=0; NTT(g,lim,0); y&gt;&gt;=1; } NTT(F,lim,1); for(register int i=0;i&lt;n;++i)g[i]=F[i],F[i]=0; for(register int i=n;i&lt;lim;++i)g[i]=F[i]=0; } int fac[maxn]={1},inv[maxn],f[maxn]; inline int calc(int n,int m){ memset(f,0,sizeof f); for(register int i=0;i&lt;m;++i)f[i]=inv[i]; Pow(f,n-1,n); return 1ll*fac[n-2]*f[n-2]%mod; } int main(){ int n=read(),m=read(),t=max(n,m); for(register int i=1;i&lt;=t;++i)fac[i]=1ll*fac[i-1]*i%mod; inv[t]=quickpow(fac[t]); for(register int i=t-1;~i;--i)inv[i]=1ll*inv[i+1]*(i+1)%mod; printf(&quot;%d\\n&quot;,qm(calc(n,m)+mod-calc(n,m-1))); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"FFT/NTT","slug":"FFT-NTT","permalink":"https://ctz45562.github.io/tags/FFT-NTT/"},{"name":"多项式","slug":"多项式","permalink":"https://ctz45562.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"name":"prufer序列","slug":"prufer序列","permalink":"https://ctz45562.github.io/tags/prufer%E5%BA%8F%E5%88%97/"},{"name":"生成函数","slug":"生成函数","permalink":"https://ctz45562.github.io/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"}]},{"title":"洛谷 P2791 幼儿园篮球题","slug":"洛谷-P2791-幼儿园篮球题","date":"2020-01-12T09:19:54.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2020/01/12/洛谷-P2791-幼儿园篮球题/","link":"","permalink":"https://ctz45562.github.io/2020/01/12/%E6%B4%9B%E8%B0%B7-P2791-%E5%B9%BC%E5%84%BF%E5%9B%AD%E7%AF%AE%E7%90%83%E9%A2%98/","excerpt":"传送门 把有气和没气看反结果推了一下午，果然是我对cxk的爱还不够深沉吗","text":"传送门 把有气和没气看反结果推了一下午，果然是我对cxk的爱还不够深沉吗 枚举投中了球，易知答案为$\\dfrac{\\sum\\limits_{i=0}^kC_m^iC_{n-m}^{k-i}i^L}{C_n^k}$ 大力搞分子。考虑到$L$相对较小，用第二类斯特林数展开$L$次方： $\\sum\\limits_{j=0}^L\\begin{Bmatrix}L\\\\j\\end{Bmatrix}j!\\sum\\limits_{i=0}^kC_i^jC_m^iC_{n-m}^{k-i}$ 这里出现了一个经典的等式：$C_i^jC_m^i=C_m^jC_{m-j}^{i-j}$： $=\\sum\\limits_{j=0}^L\\begin{Bmatrix}L\\\\j\\end{Bmatrix}C_m^jj!\\sum\\limits_{i=0}^kC_{m-j}^{i-j}C_{n-m}^{k-i}$ 感觉后面长得很范德蒙，又由于$i\\in[0,j-1]$的时候$C_{m-j}^{i-j}$都没有意义，统一把$i$换成$i+j$： $=\\sum\\limits_{j=0}^L\\begin{Bmatrix}L\\\\j\\end{Bmatrix}C_m^jj!\\sum\\limits_{i=0}^{k-j}C_{m-j}^iC_{n-m}^{k-j-i}$ 大名鼎鼎的范德蒙恒等式就出来了：$\\sum\\limits_{i=0}^{k-j}C_{m-j}^iC_{n-m}^{k-j-i}=C_{n-j}^{k-j}$。 于是答案就是$\\dfrac{\\sum\\limits_{j=0}^L\\begin{Bmatrix}L\\\\j\\end{Bmatrix}C_m^jC_{n-j}^{k-j}j!}{C_n^k}$。 $NTT$预处理一行第二类斯特林数，每次询问暴力$O(L)$回答，复杂度$O(N+L\\log L+SL)$。 听说有点卡常，把组合数拆开约分一下就好了。不知道为啥吸氧比不吸氧慢了一倍。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 20000005 #define inf 0x3f3f3f3f const int mod = 998244353; const int g = 3; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } inline int quickpow(int x,int y=mod-2){ int ans=1; while(y){ if(y&amp;1)ans=1ll*ans*x%mod; x=1ll*x*x%mod,y&gt;&gt;=1; } return ans; } const int ig = quickpow(g); int tr[1000005]; inline int qm(int x){return x&gt;=mod?x-mod:x;} void NTT(int *f,int n,bool t){ for(register int i=0;i&lt;n;++i)if(i&lt;tr[i])swap(f[i],f[tr[i]]); for(register int p=2;p&lt;=n;p&lt;&lt;=1){ int len=p&gt;&gt;1,o=quickpow(t?ig:g,(mod-1)/p); for(register int i=0;i&lt;n;i+=p){ int gen=1,cop; for(register int j=i;j&lt;i+len;++j){ cop=1ll*f[j+len]*gen%mod,gen=1ll*gen*o%mod; f[j+len]=qm(f[j]+mod-cop),f[j]=qm(f[j]+cop); } } } if(t){ int inv=quickpow(n); for(register int i=0;i&lt;n;++i)f[i]=1ll*f[i]*inv%mod; } } int fac[maxn]={1},inv[maxn]={1},F[1000005],G[1000005]; int main(){ int n=read(),m=read(),s=read(),l=read(),k=max(max(n,m),l); for(register int i=1;i&lt;=k;++i)fac[i]=1ll*fac[i-1]*i%mod; inv[k]=quickpow(fac[k]); for(register int i=k-1;~i;--i)inv[i]=1ll*inv[i+1]*(i+1)%mod; for(register int i=0;i&lt;=l;++i)F[i]=i&amp;1?mod-inv[i]:inv[i],G[i]=1ll*quickpow(i,l)*inv[i]%mod; k=1; while(k&lt;=l&lt;&lt;1)k&lt;&lt;=1; for(register int i=0;i&lt;k;++i)tr[i]=(tr[i&gt;&gt;1]&gt;&gt;1)|(i&amp;1?k&gt;&gt;1:0); NTT(F,k,0),NTT(G,k,0); for(register int i=0;i&lt;k;++i)F[i]=1ll*F[i]*G[i]%mod; NTT(F,k,1); while(s--){ int ans=0; n=read(),m=read(),k=read(); for(register int i=min(min(m,k),l);~i;--i)ans=qm(ans+1ll*F[i]*fac[n-i]%mod*inv[m-i]%mod*inv[k-i]%mod); printf(&quot;%d\\n&quot;,1ll*ans*fac[k]%mod*fac[m]%mod*inv[n]%mod); } }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"组合数学","slug":"组合数学","permalink":"https://ctz45562.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"斯特林数","slug":"斯特林数","permalink":"https://ctz45562.github.io/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"},{"name":"FFT/NTT","slug":"FFT-NTT","permalink":"https://ctz45562.github.io/tags/FFT-NTT/"},{"name":"多项式","slug":"多项式","permalink":"https://ctz45562.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"name":"概率期望","slug":"概率期望","permalink":"https://ctz45562.github.io/tags/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/"}]},{"title":"洛谷 P3978 [TJOI2015]概率论","slug":"洛谷-P3978-TJOI2015-概率论","date":"2020-01-11T01:25:55.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2020/01/11/洛谷-P3978-TJOI2015-概率论/","link":"","permalink":"https://ctz45562.github.io/2020/01/11/%E6%B4%9B%E8%B0%B7-P3978-TJOI2015-%E6%A6%82%E7%8E%87%E8%AE%BA/","excerpt":"传送门 提前一个月退役啦，为什么快乐的时光总是那么短暂啊","text":"传送门 提前一个月退役啦，为什么快乐的时光总是那么短暂啊 众所周知$n$个点的二叉树数量是卡特兰数$c(n)$。 令$G(x)$为其生成函数，其封闭形式为$\\dfrac{1-\\sqrt{1-4x}}{2x}$。怎么得到的可以看我的生成函数笔记。 设$f(n)$为$n$个节点二叉树的叶子总数。枚举根的左子树大小转移：$f(0)=0,f(1)=1,f(n)=\\sum\\limits_{i=0}^{n-1}f(i)c(n-1-i)+f(n-1-i)c(i)$ 令$F(x)$为$\\{f(n)\\}$的生成函数。 $F=\\sum\\limits_{n=1}^\\infty f(n)x^n$ $=\\sum\\limits_{n=1}^\\infty x^n\\left([n=1]+\\sum\\limits_{i=0}^{n-1}f(i)c(n-1-i)+f(n-1-i)c(i)\\right)$ $=x+2xF\\times G$ 解出来$F=\\dfrac{x}{1-2xG}=\\dfrac{x}{\\sqrt{1-4x}}$。 之后的操作就有点仙了，不知道谁想到的对$xG(x)$求导： $(xG(x))’=\\dfrac{1}{\\sqrt{1-4x}}=\\dfrac{F(x)}{x}$ 另一方面： $(xG(x))’=\\left(\\sum\\limits_{n=1}^\\infty c(n-1)x^n\\right)’=\\sum\\limits_{n=0}^\\infty (n+1)c(n)x^n$ $\\dfrac{F(x)}{x}=\\sum\\limits_{n=0}^\\infty f(n+1)x^n$ 于是$f(n+1)=(n+1)c(n)$。 答案为$\\dfrac{f(n)}{c(n)}$，代入上式和卡特兰数通项公式，化简得到$\\dfrac{n(n+1)}{2(2n-1)}$。 代码： puts(&quot;这么简单的代码还有什么展示的必要吗&quot;);","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"卡特兰数","slug":"卡特兰数","permalink":"https://ctz45562.github.io/tags/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/"},{"name":"概率期望","slug":"概率期望","permalink":"https://ctz45562.github.io/tags/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/"},{"name":"生成函数","slug":"生成函数","permalink":"https://ctz45562.github.io/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"}]},{"title":"洛谷 P4233 射命丸文的笔记","slug":"洛谷-P4233-射命丸文的笔记","date":"2020-01-10T03:26:04.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2020/01/10/洛谷-P4233-射命丸文的笔记/","link":"","permalink":"https://ctz45562.github.io/2020/01/10/%E6%B4%9B%E8%B0%B7-P4233-%E5%B0%84%E5%91%BD%E4%B8%B8%E6%96%87%E7%9A%84%E7%AC%94%E8%AE%B0/","excerpt":"传送门 有生之年系列节目之「成爷主动找我说话」","text":"传送门 有生之年系列节目之「成爷主动找我说话」 给顶点标号，因为循环同构算同一条，强制起点都是$1$。则哈密顿回路的序列就是第一个点为$1$的排列。有$n$条边已经构成回路了，剩下的边随便连。所以$n$个点的哈密顿回路总数为$(n-1)!2^{\\frac{n(n-1)}{2}-n}$。 那么我们只要求出有多少个存在哈密顿回路的竞赛图，用总数除一下即可。 下面证明一个结论：「竞赛图是强联通的」与「竞赛图存在哈密顿回路」是等价的。 看着挺对的。不会证，告辞，自行百度吧。 于是问题转化为强联通竞赛图计数。 设$g(n)$为$n$个点的竞赛图数量，$f(n)$为$n$个点的强联通竞赛图数量。显然$g(n)=2^{\\frac{n(n-1)}{2}}$。 考虑把$g(n)$分类。按$1$号点所在强联通分量大小分不好使了，因为这个强连通分量和其他点之间也会有边，关系不好确定。 按拓扑序最小的强连通分量大小来分，$g(n)=\\sum\\limits_{i=1}^nC_n^if(i)g(n-i)$。 后面是个带组合数的卷积，拆开组合数就出来$EGF$了：$\\dfrac{g(n)}{n!}=\\sum\\limits_{i=1}^n\\dfrac{f(i)}{i!}\\dfrac{g(n-i)}{(n-i)!}$ 令$F(x)$为$\\{f(n)\\}$的$EGF$，$G(x)$为$\\{g(n)\\}$的$EGF$。 $G=\\sum\\limits_{n=0}^\\infty\\dfrac{g(n)}{n!}x^n$ $=\\sum\\limits_{n=0}^\\infty x^n\\left([n=0]+\\sum\\limits_{i=1}^n\\dfrac{f(i)}{i!}\\dfrac{g(n-i)}{(n-i)!}\\right)$ $=1+F\\times G$ $F=\\dfrac{G-1}{G}$ 多项式求逆即可。特判一下$n=2$。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 530005 #define inf 0x3f3f3f3f const int mod = 998244353; const int g = 3; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } inline int quickpow(int x,long long y=mod-2){ int ans=1; while(y){ if(y&amp;1)ans=1ll*ans*x%mod; x=1ll*x*x%mod,y&gt;&gt;=1; } return ans; } const int ig = quickpow(g); int tr[maxn]; inline int qm(int x){return x&gt;=mod?x-mod:x;} void NTT(int *f,int n,bool t){ for(register int i=0;i&lt;n;++i)if(i&lt;tr[i])swap(f[i],f[tr[i]]); for(register int p=2;p&lt;=n;p&lt;&lt;=1){ int len=p&gt;&gt;1,o=quickpow(t?ig:g,(mod-1)/p); for(register int i=0;i&lt;n;i+=p){ int gen=1,cop; for(register int j=i;j&lt;i+len;++j){ cop=1ll*f[j+len]*gen%mod,gen=1ll*gen*o%mod; f[j+len]=qm(f[j]+mod-cop),f[j]=qm(f[j]+cop); } } } if(t){ int inv=quickpow(n); for(register int i=0;i&lt;n;++i)f[i]=1ll*f[i]*inv%mod; } } int A[maxn],B[maxn]; void mul(int *a,int *b,int *c,int n,int lim){ for(register int i=0;i&lt;n;++i)A[i]=a[i],B[i]=b[i]; int m=n&lt;&lt;1; n=1; while(n&lt;m)n&lt;&lt;=1; for(register int i=0;i&lt;n;++i)tr[i]=(tr[i&gt;&gt;1]&gt;&gt;1)|(i&amp;1?n&gt;&gt;1:0); NTT(A,n,0),NTT(B,n,0); for(register int i=0;i&lt;n;++i)A[i]=1ll*A[i]*B[i]%mod; NTT(A,n,1); for(register int i=0;i&lt;lim;++i)c[i]=A[i]; for(register int i=0;i&lt;n;++i)A[i]=B[i]=0; } int invR[maxn],_invR[maxn]; void Inv(int *f,int *g,int n){ #define R invR #define _R _invR int lim=2; R[0]=quickpow(f[0]); while(lim&lt;n&lt;&lt;1){ for(register int i=0;i&lt;lim;++i)_R[i]=R[i],R[i]=f[i]; for(register int i=1;i&lt;lim&lt;&lt;1;++i)tr[i]=(tr[i&gt;&gt;1]&gt;&gt;1)|(i&amp;1?lim:0); NTT(_R,lim&lt;&lt;1,0),NTT(R,lim&lt;&lt;1,0); for(register int i=0;i&lt;lim&lt;&lt;1;++i)R[i]=1ll*qm(2+mod-1ll*R[i]*_R[i]%mod)*_R[i]%mod; NTT(R,lim&lt;&lt;1,1),lim&lt;&lt;=1; for(register int i=lim&gt;&gt;1;i&lt;lim;++i)R[i]=_R[i]=0; } for(register int i=0;i&lt;n;++i)g[i]=R[i]; for(register int i=0;i&lt;lim;++i)R[i]=_R[i]=0; #undef R #undef _R } int G[maxn],_G[maxn],fac[maxn]={1},inv[maxn]; int main(){ int n=read(); for(register int i=1;i&lt;=n;++i)fac[i]=1ll*fac[i-1]*i%mod; inv[n]=quickpow(fac[n]); for(register int i=n-1;~i;--i)inv[i]=1ll*inv[i+1]*(i+1)%mod; _G[0]=1; for(register int i=1;i&lt;=n;++i){ int c=quickpow(2,(1ll*i*(i-1)&gt;&gt;1)%(mod-1)); G[i]=_G[i]=1ll*c*inv[i]%mod; } Inv(_G,_G,n+1),mul(_G,G,G,n+1,n+1),puts(&quot;1\\n-1&quot;); for(register int i=3;i&lt;=n;++i)printf(&quot;%d\\n&quot;,1ll*fac[i-1]*quickpow(2,(1ll*i*(i-1)&gt;&gt;1)-i)%mod*quickpow(1ll*G[i]*fac[i]%mod)%mod); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://ctz45562.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"FFT/NTT","slug":"FFT-NTT","permalink":"https://ctz45562.github.io/tags/FFT-NTT/"},{"name":"多项式","slug":"多项式","permalink":"https://ctz45562.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"name":"概率期望","slug":"概率期望","permalink":"https://ctz45562.github.io/tags/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/"},{"name":"生成函数","slug":"生成函数","permalink":"https://ctz45562.github.io/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"}]},{"title":"洛谷 P4389 付公主的背包","slug":"洛谷-P4389-付公主的背包","date":"2020-01-08T08:58:42.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2020/01/08/洛谷-P4389-付公主的背包/","link":"","permalink":"https://ctz45562.github.io/2020/01/08/%E6%B4%9B%E8%B0%B7-P4389-%E4%BB%98%E5%85%AC%E4%B8%BB%E7%9A%84%E8%83%8C%E5%8C%85/","excerpt":"传送门 其实只要多背一些常见生成函数就好说了。","text":"传送门 其实只要多背一些常见生成函数就好说了。 生成函数暴力搞它，根据小学奥数生成函数基础知识，答案的生成函数就是$\\prod\\limits_{i}\\left(\\sum\\limits_{n=0}^\\infty x^{v_in}\\right)$ 我们还知道$\\sum\\limits_{n=0}^\\infty x^{v_in}=\\dfrac{1}{1-x^{v_i}}$。 于是问题成了求$\\prod\\limits_i\\dfrac{1}{1-x^{v_i}}$。 这个连乘看起来很别扭，考虑取个$\\ln$转加法： $\\sum\\limits_i\\ln\\dfrac{1}{1-x^{v_i}}$ 根据初中奥数泰勒公式或背式子，我们知道$\\ln\\dfrac{1}{1-x^d}=\\sum\\limits_{n=1}^\\infty \\dfrac{x^{dn}}{n}$： $\\sum\\limits_i\\sum\\limits_{n=1}^\\infty\\dfrac{x^{v_in}}{n}$ 多项式加法好做啊。不过直接枚举每个$v_i$的倍数不大行。看到枚举倍数想调和级数，考虑把$v_i$相同的物品一块处理，记$c_i$为$v_j=i$的数量，则$f_j=\\sum\\limits_{i|j}\\dfrac{c_i}{j/i}$。 最后$\\exp$回来，复杂度$O(n\\log n)$。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 530005 #define inf 0x3f3f3f3f const int mod = 998244353; const int g = 3; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } inline int quickpow(int x,int y=mod-2){ int ans=1; while(y){ if(y&amp;1)ans=1ll*x*ans%mod; x=1ll*x*x%mod,y&gt;&gt;=1; } return ans; } const int ig = quickpow(g); int tr[maxn],inv[maxn]; inline int qm(int x){return x&gt;=mod?x-mod:x;} void NTT(int *f,int n,bool t){ for(register int i=0;i&lt;n;++i)if(i&lt;tr[i])swap(f[i],f[tr[i]]); for(register int p=2;p&lt;=n;p&lt;&lt;=1){ int len=p&gt;&gt;1,o=quickpow(t?ig:g,(mod-1)/p); for(register int i=0;i&lt;n;i+=p){ int gen=1,cop; for(register int j=i;j&lt;i+len;++j){ cop=1ll*f[j+len]*gen%mod,gen=1ll*gen*o%mod; f[j+len]=qm(f[j]+mod-cop),f[j]=qm(f[j]+cop); } } } if(t)for(register int i=0;i&lt;n;++i)f[i]=1ll*f[i]*inv[n]%mod; } int A[maxn],B[maxn]; void mul(int *a,int *b,int *c,int n,int lim){ for(register int i=0;i&lt;n;++i)A[i]=a[i],B[i]=b[i]; int m=n&lt;&lt;1; n=1; while(n&lt;m)n&lt;&lt;=1; for(register int i=0;i&lt;n;++i)tr[i]=(tr[i&gt;&gt;1]&gt;&gt;1)|(i&amp;1?n&gt;&gt;1:0); NTT(A,n,0),NTT(B,n,0); for(register int i=0;i&lt;n;++i)A[i]=1ll*A[i]*B[i]%mod; NTT(A,n,1); for(register int i=0;i&lt;lim;++i)c[i]=A[i]; for(register int i=0;i&lt;n;++i)A[i]=B[i]=0; } int invR[maxn],_invR[maxn]; void Inv(int *f,int *g,int n){ #define R invR #define _R _invR int lim=2; R[0]=quickpow(f[0]); while(lim&lt;n&lt;&lt;1){ for(register int i=0;i&lt;lim;++i)_R[i]=R[i],R[i]=f[i]; for(register int i=0;i&lt;lim&lt;&lt;1;++i)tr[i]=(tr[i&gt;&gt;1]&gt;&gt;1)|(i&amp;1?lim:0); NTT(_R,lim&lt;&lt;1,0),NTT(R,lim&lt;&lt;1,0); for(register int i=0;i&lt;lim&lt;&lt;1;++i)R[i]=1ll*qm(2+mod-1ll*R[i]*_R[i]%mod)*_R[i]%mod; NTT(R,lim&lt;&lt;1,1),lim&lt;&lt;=1; for(register int i=lim&gt;&gt;1;i&lt;lim;++i)R[i]=0; } for(register int i=0;i&lt;n;++i)g[i]=R[i]; for(register int i=0;i&lt;lim;++i)R[i]=_R[i]=0; #undef R #undef _R } void derivate(int *f,int *g,int n){ for(register int i=1;i&lt;n;++i)g[i-1]=1ll*f[i]*i%mod; g[n-1]=0; } void intergrate(int *f,int *g,int n){ for(register int i=n;i;--i)g[i]=1ll*f[i-1]*inv[i]%mod; g[0]=0; } int lnR[maxn]; void ln(int *f,int *g,int n){ #define R lnR Inv(f,R,n),derivate(f,g,n),mul(R,g,g,n,n),intergrate(g,g,n); for(register int i=0;i&lt;n;++i)R[i]=0; #undef R } int expR[maxn],_expR[maxn]; void Exp(int *f,int *g,int n){ #define R expR #define _R _expR int lim=2; R[0]=1; while(lim&lt;n&lt;&lt;1){ for(register int i=0;i&lt;lim;++i)_R[i]=R[i]; ln(_R,_R,lim); for(register int i=1;i&lt;lim;++i)_R[i]=qm(f[i]+mod-_R[i]); _R[0]=1,mul(R,_R,R,lim,lim),lim&lt;&lt;=1; } for(register int i=0;i&lt;n;++i)g[i]=R[i]; for(register int i=0;i&lt;lim;++i)R[i]=_R[i]=0; #undef R #undef _R } int c[maxn],f[maxn]; int main(){ inv[1]=1; for(register int i=2;i&lt;maxn;++i)inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod; int n=read(),m=read(); for(register int i=1;i&lt;=n;++i)++c[read()]; for(register int i=1;i&lt;=m;++i){ if(!c[i])continue; for(register int j=i;j&lt;=m;j+=i) f[j]=qm(f[j]+1ll*c[i]*inv[j/i]%mod); } Exp(f,f,m+1); for(register int i=1;i&lt;=m;++i)printf(&quot;%d\\n&quot;,f[i]); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"FFT/NTT","slug":"FFT-NTT","permalink":"https://ctz45562.github.io/tags/FFT-NTT/"},{"name":"多项式","slug":"多项式","permalink":"https://ctz45562.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"name":"生成函数","slug":"生成函数","permalink":"https://ctz45562.github.io/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"}]},{"title":"洛谷 P4841 [集训队作业2013]城市规划","slug":"洛谷-P4841-集训队作业2013-城市规划","date":"2020-01-08T02:48:23.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2020/01/08/洛谷-P4841-集训队作业2013-城市规划/","link":"","permalink":"https://ctz45562.github.io/2020/01/08/%E6%B4%9B%E8%B0%B7-P4841-%E9%9B%86%E8%AE%AD%E9%98%9F%E4%BD%9C%E4%B8%9A2013-%E5%9F%8E%E5%B8%82%E8%A7%84%E5%88%92/","excerpt":"传送门 嘤嘤嘤看不透生成函数怎么办啊","text":"传送门 嘤嘤嘤看不透生成函数怎么办啊 设$f(n)$为$n$个点的有标号无向连通图个数，$g(n)$为$n$个点的无向图个数。 显然$g(n)=2^{\\frac{n(n-1)}{2}}$。 考虑容斥转移，用总的减去不合法的。 $f(0)=0,f(n)=g(n)-\\sum\\limits_{i=1}^{n-1}C_{n-1}^{i-1}f(i)g(n-i)$ 啥意思呢？$g(n)$是总数，然后枚举$1$号点所在联通块的大小。$C_{n-1}^{i-1}$选出和$1$一个联通块的点，$f(i)$让它们联通，剩下$n-i$个点随便连$g(n-i)$。后面那一坨不是在容斥，它只是把所有不同类型的不合法情况枚举了一遍，所以不用乘容斥系数。 带组合数可以考虑$EGF$了，把组合数拆开： $f(n)=g(n)-\\sum\\limits_{i=1}^{n-1}\\dfrac{(n-1)!}{(i-1)!(n-i)!}f(i)g(n-i)$ $(n-1)!$除过去： $\\dfrac{f(n)}{(n-1)!}=\\dfrac{g(n)}{(n-1)!}-\\sum\\limits_{i=1}^{n-1}\\dfrac{f(i)}{(i-1)!}\\dfrac{g(n-i)}{(n-i)!}$ 这个式子涉及到三种形式：$\\dfrac{f(n)}{(n-1)!},\\dfrac{g(n)}{(n-1)!},\\dfrac{g(n)}{n!}$ 令$\\{f(n-1)\\}$的$EGF$为$F(x)=\\sum\\limits_{n=1}^\\infty \\dfrac{f(n)}{(n-1)!}x^n$，$\\{g(n-1)\\}$的$EGF$为$G(x)=\\sum\\limits_{n=1}^\\infty \\dfrac{g(n)}{(n-1)!}x^n$，$\\{g(n)\\}$的$EGF$为$G’(x)=\\sum\\limits_{n=0}^\\infty \\dfrac{g(n)}{n!}x^n$。 $F=\\sum\\limits_{n=1}^\\infty x^n\\left(\\dfrac{g(n)}{(n-1)!}-\\sum\\limits_{i=1}^{n-1}\\dfrac{f(i)}{(i-1)!}\\dfrac{g(n-i)}{(n-i)!}\\right)$ 后面那一坨像卷积，但上界不对劲。单独处理一下$i=n$的情况，顺便把$G$提出来： $F=G-\\sum\\limits_{n=0}^\\infty x^n\\left(\\sum\\limits_{i=1}^{n}\\dfrac{f(i)}{(i-1)!}\\dfrac{g(n-i)}{(n-i)!}-\\dfrac{f(n)}{(n-1)!}\\right)$ $F=G-F\\times G’+F$ $F=G\\times G’^{-1}$ 多项式求逆+乘法，最后答案要乘个$(n-1)!$。 或者也可以不用容斥推，按$1$号点所在联通块大小把$g(n)$分类： $g(n)=\\sum\\limits_{i=1}^nC_{n-1}^{i-1}f(i)g(n-i)$ 结果是一样的。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 270005 #define inf 0x3f3f3f3f const int mod = 1004535809; const int g = 3; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } inline int quickpow(int x,int y=mod-2){ int ans=1; while(y){ if(y&amp;1)ans=1ll*ans*x%mod; x=1ll*x*x%mod,y&gt;&gt;=1; } return ans; } const int ig = quickpow(g); int tr[maxn]; inline int qm(int x){return x&gt;=mod?x-mod:x;} void NTT(int *f,int n,bool t){ for(register int i=0;i&lt;n;++i)if(i&lt;tr[i])swap(f[i],f[tr[i]]); for(register int p=2;p&lt;=n;p&lt;&lt;=1){ int len=p&gt;&gt;1,o=quickpow(t?ig:g,(mod-1)/p); for(register int i=0;i&lt;n;i+=p){ int gen=1,cop; for(register int j=i;j&lt;i+len;++j){ cop=1ll*f[j+len]*gen%mod,gen=1ll*gen*o%mod; f[j+len]=qm(f[j]+mod-cop),f[j]=qm(f[j]+cop); } } } if(t){ int inv=quickpow(n); for(register int i=0;i&lt;n;++i)f[i]=1ll*f[i]*inv%mod; } } int A[maxn],B[maxn]; void mul(int *a,int *b,int *c,int n,int lim){ for(register int i=0;i&lt;n;++i)A[i]=a[i],B[i]=b[i]; int m=n&lt;&lt;1; n=1; while(n&lt;m)n&lt;&lt;=1; for(register int i=0;i&lt;n;++i)tr[i]=(tr[i&gt;&gt;1]&gt;&gt;1)|(i&amp;1?n&gt;&gt;1:0); NTT(A,n,0),NTT(B,n,0); for(register int i=0;i&lt;n;++i)A[i]=1ll*A[i]*B[i]%mod; NTT(A,n,1); for(register int i=0;i&lt;lim;++i)c[i]=A[i]; for(register int i=0;i&lt;n;++i)A[i]=B[i]=0; } int invR[maxn],_invR[maxn]; void Inv(int *f,int *g,int n){ #define R invR #define _R _invR int lim=2; R[0]=quickpow(f[0]); while(lim&lt;n&lt;&lt;1){ for(register int i=0;i&lt;lim;++i)_R[i]=R[i],R[i]=f[i]; for(register int i=0;i&lt;lim&lt;&lt;1;++i)tr[i]=(tr[i&gt;&gt;1]&gt;&gt;1)|(i&amp;1?lim:0); NTT(_R,lim&lt;&lt;1,0),NTT(R,lim&lt;&lt;1,0); for(register int i=0;i&lt;lim&lt;&lt;1;++i)R[i]=1ll*qm(2+mod-1ll*R[i]*_R[i]%mod)*_R[i]%mod; NTT(R,lim&lt;&lt;1,1),lim&lt;&lt;=1; for(register int i=lim&gt;&gt;1;i&lt;lim;++i)R[i]=0; } for(register int i=0;i&lt;n;++i)g[i]=R[i]; for(register int i=0;i&lt;lim;++i)R[i]=_R[i]=0; } int fac[maxn]={1},inv[maxn],G[maxn],_G[maxn]; int main(){ int n=read(); for(register int i=1;i&lt;=n;++i)fac[i]=1ll*fac[i-1]*i%mod; inv[n]=quickpow(fac[n]); for(register int i=n-1;~i;--i)inv[i]=1ll*inv[i+1]*(i+1)%mod; for(register int i=1;i&lt;=n;++i){ int k=quickpow(2,(1ll*i*(i-1)&gt;&gt;1)%(mod-1)); G[i]=1ll*k*inv[i-1]%mod; _G[i]=1ll*k*inv[i]%mod; } _G[0]=1; Inv(_G,_G,n+1),mul(_G,G,G,n+1,n+1); printf(&quot;%d\\n&quot;,1ll*G[n]*fac[n-1]%mod); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"容斥","slug":"容斥","permalink":"https://ctz45562.github.io/tags/%E5%AE%B9%E6%96%A5/"},{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"FFT/NTT","slug":"FFT-NTT","permalink":"https://ctz45562.github.io/tags/FFT-NTT/"},{"name":"多项式","slug":"多项式","permalink":"https://ctz45562.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"name":"生成函数","slug":"生成函数","permalink":"https://ctz45562.github.io/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"}]},{"title":"多项式全家桶&生成函数学习笔记","slug":"多项式-生成函数学习笔记","date":"2020-01-06T06:36:19.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2020/01/06/多项式-生成函数学习笔记/","link":"","permalink":"https://ctz45562.github.io/2020/01/06/%E5%A4%9A%E9%A1%B9%E5%BC%8F-%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"重 拳 出 击","text":"重 拳 出 击 前言OI生涯中最大的坑。虽然我觉得填不上了 我的学习笔记真是越写越烂：缺少证明、漏洞百出。 难得要专攻算法了，（大概）会写的详细点。 抄袭来源 https://www.luogu.com.cn/blog/command-block/ntt-yu-duo-xiang-shi-quan-jia-tong sls的课件 https://www.luogu.com.cn/blog/lx-2003/generating-function https://www.luogu.com.cn/blog/lx-2003/generating-function-advanced #define以下，代码以mod表示模数，其他地方以$p$表示模数。 $g$为模$p$意义下的原根，$ig$为$g^{-1}$。 $tr$：$FFT/NTT$用的反转数组。 多项式全家桶再次复读又又的励志语录： “大声大声！熟练熟练！” 为了封装完整，保证多次调用函数不会有影响，我的写法常数不小，也很丑，将就着看吧。 找原根$g$为模$p$意义下的原根，需要满足$\\forall d|(p-1)\\land d\\neq p-1,g^d\\not\\equiv1\\pmod p$。 而且最小的原根一般都比较小，只检验$100$以内的数即可： const int mod = 998244353; inline int quickpow(int x,int y=mod-2){ int ans=1; while(y){ if(y&amp;1)ans=1ll*ans*x%mod; x=1ll*x*x%mod,y&gt;&gt;=1; } } bool check(int x){ for(register int i=2;i*i&lt;mod;++i) if((mod-1)%i==0&amp;&amp;(quickpow(x,i)==1||quickpow(x,(mod-1)/i)==1))return 0; return 1; } int getG(){ for(register int i=2;i&lt;=100;++i)if(check(i))return i; } FFT/NTT详见FFT/NTT学习笔记（虽然我只是粘了个板子啥都没讲） 一般用不着$FFT$就只放$NTT$辣。 int tr[maxn]; inline int qm(int x){return x&gt;=mod?x-mod:x;} void NTT(int *f,int n,bool t){//f为多项式；n为多项式项数；t=0为dft，否则为idft for(register int i=0;i&lt;n;++i)if(i&lt;tr[i])swap(f[i],f[tr[i]]); for(register int p=2;p&lt;=n;p&lt;&lt;=1){ int len=p&gt;&gt;1,o=quickpow(t?ig:g,(mod-1)/p); for(register int i=0;i&lt;n;i+=p){ int gen=1,cop; for(register int j=i;j&lt;i+len;++j){ cop=1ll*f[j+len]*gen%mod,gen=1ll*gen*o%mod; f[j+len]=qm(f[j]+mod-cop),f[j]=qm(f[j]+cop); } } } if(t){ int inv=quickpow(n); for(register int i=0;i&lt;n;++i)f[i]=1ll*f[i]*inv%mod; } } 乘法就是把$NTT$板子封装成函数。 int A[maxn],B[maxn]; void mul(int *a,int *b,int *c,int n,int lim){//长度为n的多项式a和b相乘，结果前lim位保存在c中 for(register int i=0;i&lt;n;++i)A[i]=a[i],B[i]=b[i]; int m=n&lt;&lt;1; n=1; while(n&lt;m)n&lt;&lt;=1; for(register int i=0;i&lt;n;++i)tr[i]=(tr[i&gt;&gt;1]&gt;&gt;1)|(i&amp;1?n&gt;&gt;1:0); NTT(A,n,0),NTT(B,n,0); for(register int i=0;i&lt;n;++i)A[i]=1ll*A[i]*B[i]%mod; NTT(A,n,1); for(register int i=0;i&lt;lim;++i)c[i]=A[i]; for(register int i=0;i&lt;n;++i)A[i]=B[i]=0; } 泰勒公式用多项式来拟合函数： 若$f(x)$在$x_0$处可$n$阶导，有： $f(x)=R_n(x)+\\sum\\limits_{i=0}^n\\dfrac{f^{(i)}(x_0)}{i!}(x-x_0)^i$ 其中$f^{(i)}(x)$表示$i$阶导数，$R_n(x)$是余项（毕竟拟合是有误差的） 若能无限求导，有： $f(x)=\\sum\\limits_{i=0}^\\infty \\dfrac{f^{(i)}(x_0)}{i!}(x-x_0)^i$ 一般取$x_0=0$计算方便，这时也叫麦克劳林公式。 牛顿迭代根据泰勒公式得出来的。 已知多项式$G(x)$，求多项式$F(x)$满足$G(F(x))\\equiv 0\\pmod {x^n}$（$\\bmod {x^n}$表示只考虑前$n$项） 倍增求解。假设已经求出$G(F^*(x))\\equiv 0\\pmod {x^{\\frac{n}{2}}}$，要求$G(F(x))\\equiv 0\\pmod{x^n}$。 有$F(x)\\equiv F^*(x)-\\dfrac{G(F^*(x))}{G’(F^*(x))}\\pmod{x^n}$ 泰勒公式和牛顿迭代的证明不写了，网上到处都是。 求逆已知多项式$F$，求出多项式$G$满足$F\\times G\\equiv 1\\pmod {x^n}$。 倍增求解。当多项式只有常数项时，直接求出常数项的逆元即可。 可以用牛顿迭代来推： $F(x)G(x)-1\\equiv 0$ 令$H(G(x))=F(x)G(x)-1$ $F(x)$已知，实际上是个系数，求完导后$G(x)$就没了，所以$H’(G(x))=F(x)$。 直接把牛顿迭代套上去： $G(x)\\equiv G^*(x)-\\dfrac{H(G^*(x))}{H’(G^*(x))}\\equiv G^*(x)-\\dfrac{F(x)G^*(x)-1}{F(x)}\\equiv G^*(x)-G(x)(F(x)G^*(x)-1)$ 由于$F(x)G^*(x)-1\\equiv 0\\pmod{x^{\\frac{n}{2}}}$即$F(x)G^*(x)-1$的前$\\frac{n}{2}$为$0$。 所以$G(x)$乘上去的时候，在$\\bmod{x^n}$时它的后$\\frac{n}{2}$项是没有用的，用$G^*(x)$代替它。 于是$G(x)\\equiv G^*(x)-G^*(x)(F(x)G^*(x)-1)\\equiv (2-F(x)G^*(x))G^*(x)$ 或者平方法推式子： 假设已知$F\\times R’\\equiv 1\\pmod {x^{\\frac{n}{2}}}$ 要求$R$满足$F\\times R\\equiv 1\\pmod{x^n}$ 显然$R\\equiv R’\\pmod {x^{\\frac{n}{2}}}$ $R-R’\\equiv 0\\pmod {x^{\\frac{n}{2}}}$ 两边平方，扩展到$x^n$： $(R-R’)^2\\equiv 0\\pmod {x^n}$ $R^2-2RR’+R’^2\\equiv 0\\pmod {x^n}$ 两边都乘一个$F$，由于是$\\bmod x^n$，$F\\times R$可以消掉，但$F\\times R’$不能。 $R\\equiv 2R’-FR’^2\\pmod {x^n}$ 于是可以愉快地扩展了。 此时我们发现要做$2$遍多项式乘法，$6$遍$NTT$。虽然可以把$R’^2$优化成$2$次效果也不大。 但其实可以先两遍$DFT$把$F$和$R’$转成点值，然后对点值做上面的运算，最后$IDFT$回去，只需要$3$遍$NTT$。 时间复杂度为$T(n)=T(\\frac{n}{2})+O(n\\log n)=O(n\\log n)$，不是很明白为啥有人觉得是$\\log^2$，是$T(\\frac{n}{2})$不是$2T(\\frac{n}{2})$啊。 肝了一上午终于把迭代+$3$次$NTT$版本搞出来了 int invR[maxn],_invR[maxn]; void inv(int *f,int *g,int n){//对项数为n的多项式f求逆，结果保存在g中 #define R invR #define _R _invR int lim=2; R[0]=quickpow(f[0]); while(lim&lt;n&lt;&lt;1){ for(register int i=0;i&lt;lim;++i)_R[i]=R[i],R[i]=f[i]; for(register int i=0;i&lt;lim&lt;&lt;1;++i)tr[i]=(tr[i&gt;&gt;1]&gt;&gt;1)|(i&amp;1?lim:0); NTT(_R,lim&lt;&lt;1,0),NTT(R,lim&lt;&lt;1,0); for(register int i=0;i&lt;lim&lt;&lt;1;++i)R[i]=1ll*qm(2+mod-1ll*_R[i]*R[i]%mod)*_R[i]%mod; NTT(R,lim&lt;&lt;1,1),lim&lt;&lt;=1; for(register int i=lim&gt;&gt;1;i&lt;lim;++i)R[i]=0; } for(register int i=0;i&lt;n;++i)g[i]=R[i]; for(register int i=0;i&lt;lim;++i)R[i]=_R[i]=0; #undef R #undef _R } 求导&amp;积分众所周知，$(x^\\mu)’=\\mu x^{\\mu-1}$。 众所周知，求导逆回去就是积分。 void derivate(int *f,int *g,int n){//对n项多项式f求导，结果存在g中 for(register int i=1;i&lt;n;++i)g[i-1]=1ll*f[i]*i%mod; g[n-1]=0; } void intergrate(int *f,int *g,int n){//积分，同上 for(register int i=n;i;--i)g[i]=1ll*f[i-1]*quickpow(i); g[0]=0; } ln给定多项式$A$，求出多项式$B=\\ln A$。 众所周知，$\\ln’(x)=\\dfrac{1}{x}$。于是考虑求导。 但$\\ln A$实际上是复合函数求导，要用链式法则$(f(g(x)))’=f’(g(x))g’(x)$。 $B=\\ln A$ $B’=\\ln’A\\times A’$ $B’=A^{-1}A’$ $B=\\int(A^{-1}A’)$ 求逆+求导+乘法+积分就好了。 int lnR[maxn]; void ln(int *f,int *g,int n){//对n项多项式f求ln，结果存在g中 #define R lnR inv(f,R,n),derivate(f,g,n),mul(R,g,g,n,n),intergrate(g,g,n); for(register int i=0;i&lt;n;++i)R[i]=0; #undef R } exp给出$F$，求$G$满足$e^F\\equiv G\\pmod{x^n}$ 倍增+牛顿迭代。 两边取个$\\ln$： $F\\equiv \\ln G$ $\\ln G-F\\equiv 0$ 令$H(G(x))\\equiv \\ln G-F$ $H’(G(x))\\equiv \\dfrac{1}{G}$ 套公式：$G\\equiv G^*(x)-G^*(\\ln G^*-F)\\pmod{x^n}$ $G\\equiv G^*(1-\\ln G^*+F)\\pmod{x^n}$ 复杂度$O(n\\log n)$ int expR[maxn],_expR[maxn]; void Exp(int *f,int *g,int n){//对n项多项式f做exp，结果存在g中 #define R expR #define _R _expR int lim=2; R[0]=1; while(lim&lt;n&lt;&lt;1){ for(register int i=0;i&lt;lim;++i)_R[i]=R[i]; ln(_R,_R,lim); for(register int i=1;i&lt;lim;++i)_R[i]=qm(f[i]+mod-_R[i]); _R[0]=1,mul(_R,R,R,lim,lim),lim&lt;&lt;=1; } for(register int i=0;i&lt;n;++i)g[i]=R[i]; for(register int i=0;i&lt;lim;++i)R[i]=_R[i]=0; #undef R #undef _R } 开根已知多项式$F$，求出$G$满足$G^2\\equiv F\\pmod {x^n}$。 最暴力的方法：根据小学数学$\\ln x^k=k\\ln x$，先把$F\\ln$过去，除个$2$再$exp$回来。这样常数较大，但可以开任意$k$次根。 而对于开平方根，同样可以倍增求解。 当多项式只有常数项时，解为常数项模$p$意义下的二次剩余。模板里保证常数项为$1$，解为$1$。 先用牛顿迭代试试： $G^2-F\\equiv 0\\pmod{x^n}$ 令$H(G(x))\\equiv G^2(x)-F(x)$ $H’(G(x))\\equiv 2G(x)$ 公式套一套：$G(x)\\equiv G^*(x)-\\dfrac{G^{*2}(x)-F(x)}{2G^*(x)}\\pmod{x^n}$ $G^*(x)\\equiv \\dfrac{F(x)+G^{*2}(x)}{2G^*(x)}\\pmod{x^n}$ 再试试平方法： 现在已知$R’^2\\equiv F\\pmod {x^{\\frac{n}{2}}}$，要求$R^2\\equiv F\\pmod {x^n}$ 还是根据$R\\equiv R’\\pmod {x^{\\frac{n}{2}}}$ 移项平方后得到： $R^2-2RR’+R’^2\\equiv 0\\pmod {x^n}$ $F-2RR’+R’^2\\equiv 0\\pmod{x^n}$ $R=\\dfrac{F+R’^2}{2R’}\\pmod{x^n}$ 套个多项式求逆即可，复杂度$O(n\\log n)$。 const int inv2 = quickpow(2); int sqrtR[maxn],_sqrtR[maxn],tem[maxn]; void Sqrt(int *f,int *g,int n){//对项数为n的多项式f开根，结果存在g里 #define R sqrtR #define _R _sqrtR int lim=2; R[0]=1; while(lim&lt;n&lt;&lt;1){ for(register int i=0;i&lt;lim;++i)tem[i]=f[i],_R[i]=R[i]; inv(R,R,lim); for(register int i=0;i&lt;lim&lt;&lt;1;++i)tr[i]=(tr[i&gt;&gt;1]&gt;&gt;1)|(i&amp;1?lim:0); NTT(R,lim&lt;&lt;1,0),NTT(tem,lim&lt;&lt;1,0); for(register int i=0;i&lt;lim&lt;&lt;1;++i)R[i]=1ll*R[i]*tem[i]%mod; NTT(R,lim&lt;&lt;1,1); for(register int i=0;i&lt;lim;++i)R[i]=1ll*qm(R[i]+_R[i])*inv2%mod; lim&lt;&lt;=1; for(register int i=lim&gt;&gt;1;i&lt;lim;++i)R[i]=0; } for(register int i=0;i&lt;n;++i)g[i]=R[i]; for(register int i=0;i&lt;lim;++i)R[i]=_R[i]=tem[i]=0; #undef R #undef _R } 快速幂快速幂好说，直接$A^k=\\exp(k\\ln A)=\\exp((k\\bmod p)\\ln A)$。 $\\ln+\\exp$即可，常数很大。 也可以直接倍增快速幂，看上面的式子发现$k$可以对$p$（不是$p-1$）取模，$O(n\\log^2 n)$暴力乘法。 void Pow(int *f,int *g,int n,int k){//f^k ln(f,g,n); for(register int i=0;i&lt;n;++i)g[i]=1ll*g[i]*k%mod; Exp(g,g,n); } 带余除法给定$n$项多项式$A(x)$和$m$项多项式$B(x)$，求出$n-m+1$项多项式$F(x)$和$m-1$次多项式$G(x)$，使得$A=B\\times F+G$。 把$x$都换成$x^{-1}$，显然还是相等的。 $A(x^{-1})=B(x^{-1})F(x^{-1})+G(x^{-1})$ 两边同乘$x^n$： $x^nA(x^{-1})=x^nB(x^{-1})F(x^{-1})+x^nG(x^{-1})$ 考虑一个$n$项多项式$A(x)$，$x^nA(x^{-1})$相当于是把$A$的系数翻转了一下，以下记为$A^R(x)$。 $A^R(x)=B^R(x)F^R(x)+x^{n-m+1}G^R(x)$ 看到后面那个$x^{n-m+1}$，直接强制$\\bmod {x^{n-m+1}}$消掉它。 $A^R(x)\\equiv B^R(x)F^R(x)\\pmod{x^{n-m+1}}$ 求逆再翻转回来就能得到$F(x)$，然后根据最原始的式子$A=B\\times F+G$就能得到$G$。 int divR[maxn],divF[maxn],divG[maxn]; void div(int *f,int *g,int n,int m,int *d,int *mo){//f=d*g+mo #define R divR #define F divF #define G divG for(register int i=0;i&lt;n;++i)F[i]=f[n-i-1]; for(register int i=0;i&lt;m;++i)G[i]=g[m-i-1]; inv(G,R,n-m+1),mul(R,F,R,n-m+1,n-m+1); reverse(F,F+n),reverse(G,G+n),reverse(R,R+n); for(register int i=0;i&lt;=n-m;++i)d[i]=R[i]; mul(R,G,R,n,n); for(register int i=0;i&lt;m;++i)mo[i]=qm(F[i]+mod-R[i]); for(register int i=0;i&lt;n;++i)F[i]=G[i]=R[i]=0; #undef R #undef F #undef G } 任意模数NTT咕咕咕 分治FFT咕咕咕 三角函数咕咕咕咕咕咕咕咕咕 生成函数初来乍到，多多包涵。 引入 假设你在看cxk的视频。同时你有一个愉♀悦度。已知： 看cxk唱歌可以增加1点愉♀悦度 看cxk跳舞可以增加2点愉♀悦度 看cxk说rap可以增加3点愉♀悦度 看cxk打篮球可以增加4点愉♀悦度 重复看每种视频只能增加一次愉♀悦度。对于$n\\in[1,10]$，有多少种看视频的方案能使愉♀悦度达到恰好$n$？ 显然，这个问题可以用背包轻松解决。 考虑另一种奇妙的做法。对每种方式，构造一个形如$\\sum\\limits_{i=0}^\\infty a_ix^i$多项式代表它。其中$x$的指数代表一个状态，这里表示愉♀悦度；$a_i$表示达到这种状态的方案数；而$x$本身没有意义，只是一个载体。 以唱歌为例构造多项式：有两种选择：看cxk唱歌或不看。这就分别代表了$1x^1$和$1x^0$。所以唱歌的多项式为$1+x$ 类似的，跳舞的多项式为$1+x^2$，rap为$1+x^3$，打篮球为$1+x^4$。 那么将两个多项式相乘会发生什么？ 考虑一个多项式的某一项$a_ix^i$和另一个多项式的某一项$a_jx^j$的贡献，指数$i,j$相加，表示了状态$i+j$；系数$a_i,a_j$相乘，是乘法原理，即达到状态$i+j$的方案数；而每一个$x^{i+j}$的系数$a_ia_j$加起来，又是加法原理。最终得到的新多项式就是用这两种方式的方案情况！ 所以，将$4$个多项式乘起来，取$n$次项就是答案。 定义对一个数列$\\{a_i\\}$，其普通生成函数（$OGF$）为$\\sum\\limits_{i=0}^\\infty a_ix^i$，指数生成函数（$EGF$）为$\\sum\\limits_{i=0}^\\infty \\dfrac{a_i}{i!}x^i$。 比如说数列$\\{1,1,1,1…\\}$的生成函数为$\\sum\\limits_{i=0}^\\infty x^i$。 我们发现这其实是一个等比数列求和，等于$\\dfrac{1-x^\\infty}{1-x}$。根据引入部分，这个$x$其实没啥意义。如果给$x$代一个$(-1,1)$的数，$x^\\infty$趋近于$0$，这个式子就为$\\dfrac{1}{1-x}$。 普通生成函数，一般用于无标号计数问题。而指数生成函数一般用于有标号计数问题。这个很好理解，因为有标号的除以$n!$就成为无标号问题了。 一些常见的生成函数： $\\sum\\limits_{n=0}^\\infty ax^n=\\dfrac{a}{1-x}$ $\\sum\\limits_{n=0}^\\infty x^{dn}=\\dfrac{1}{1-x^d}$ $\\sum\\limits_{n=0}^\\infty c^nx^n=\\dfrac{1}{1-cx}$ $\\sum\\limits_{n=0}^\\infty C_k^nx^n=(x+1)^k$ $\\sum\\limits_{n=0}^\\infty C_{n+k-1}^{k-1}x^n=\\dfrac{1}{(1-x)^k}$。（广义二项式定理） $\\sum\\limits_{n=0}^\\infty \\dfrac{c^nx^n}{n!}=e^{cx}$（泰勒公式） $\\sum\\limits_{n=1}^\\infty \\dfrac{c^nx^{dn}}{n}=\\ln\\left(\\dfrac{1}{1-cx^d}\\right)$ 应用推导通项公式序有$k$个非负变量$x_i$，求满足$\\sum\\limits_{i=1}^kx_i=n$的方案数。 考虑生成函数做法，因为$x_i\\in[0,n]$，所以它对应的数列就是$\\{1,1,1\\dots\\}$，构造生成函数$\\sum\\limits_{i=0}^nx^i=\\dfrac{1}{1-x}$，乘$k$次就是每个$n$的方案数的生成函数，即$\\dfrac{1}{(1-x)^k}$。 我们只要找出这个生成函数对应数列就能知道答案。 根据前文，$\\dfrac{1}{(1-x)^k}=\\sum\\limits_{i=0}^\\infty C_{i+k-1}^{k-1}x^i$。 于是得到答案为$C_{n+k-1}^{k-1}$。实际上这和插板法得到的是一样的。 简单的例题直接根据题意构造$10$个生成函数就好了： $6$的倍数：$\\sum\\limits_{n=0}^\\infty[6|n]x^n=\\dfrac{1}{1-x^6}$ 最多用$9$块：$\\sum\\limits_{n=0}^9 x^n=\\dfrac{1-x^{10}}{1-x}$ $\\dots$ 把这些乘起来，化简得到$\\dfrac{1}{(1-x)^5}$。再把这个生成函数还原成数列。 $\\dfrac{1}{(1-x)^5}=\\sum\\limits_{n=0}^\\infty C_{n+4}^4x^n$ 第$n$项就是答案，即$C_{n+4}^4=\\dfrac{(n+1)(n+2)(n+3)(n+4)}{24}$。 只要套个高精就行了事实上不久之前这个题缩短时限把python卡掉了，涉及到100000位的高精乘高精你还要写个FFT/NTT 斐波那契数列通项公式上面这些没啥意思，我们试试用生成函数推导斐波那契数列的通项公式。 定义斐波那契数列$fib_0=0,fib_1=1,fib_i=fib_{i-1}+fib_{i-2}$。 令$\\{fib_n\\}$的$OGF$为$F(x)=\\sum\\limits_{n=0}^\\infty fib_nx^n$. 根据斐波那契数列的递推式，可以考虑错位相减法。乘上$x$就能使数列平移一位。 $\\ \\ \\ F(x)=fib_1x^1+fib_2x^2+fib_3x^3\\dots$ $\\ xF(x)=0\\qquad\\ +fib_1x^2+fib_2x^3\\dots$ $x^2F(x)=0\\qquad\\ +0\\qquad\\ +fib_1x^3\\dots$ 我们发现$F(x)$和$xF(x)+x^2F(x)$只差了个$fib_1x=x$。 于是$F=x+xF+x^2F$，即$F=\\dfrac{x}{1-x-x^2}$。 这玩意看不透它的数列，考虑转化为常见的形式： 设$\\dfrac{x}{1-x-x^2}=\\dfrac{A}{1-ax}+\\dfrac{B}{1-bx}$ 相加肯定是要通分的，看分母，有$1-x-x^2=(1-ax)(1-bx)=abx^2-(a+b)x+1$ 系数分别相同，有$\\begin{cases}ab=-1\\\\a+b=1\\end{cases}$ 解得$a=\\dfrac{1+\\sqrt5}{2},b=\\dfrac{1-\\sqrt5}{2}$。 代回去看分子：$A(1-bx)+B(1-ax)=A+B-\\dfrac{(1-\\sqrt5)Ax}{2}-\\dfrac{(1+\\sqrt5)Bx}{2}=x$ 还是看相同的系数，得出$\\begin{cases}A+B=0\\\\ -\\dfrac{(1-\\sqrt5)A}{2}-\\dfrac{(1+\\sqrt5)B}{2}=1\\end{cases}$ 解得$A=\\dfrac{1}{\\sqrt5},B=-\\dfrac{1}{\\sqrt5}$ 回到最初的目的，$\\dfrac{x}{1-x-x^2}=\\dfrac{1}{\\sqrt5}\\left[\\dfrac{1}{1-(\\frac{1+\\sqrt5}{2})x}-\\dfrac{1}{1-(\\frac{1-\\sqrt5}{2})x}\\right]$ 我们知道，$\\dfrac{1}{1-ax}=\\sum\\limits_{n=0}^\\infty a^nx^n$ 于是斐波那契数列生成函数为$\\sum\\limits_{n=0}^\\infty\\frac{1}{\\sqrt5}\\left[(\\frac{1+\\sqrt5}{2})^n-(\\frac{1-\\sqrt5}{2})^n\\right]x^n$ 就能得到$fib_n=\\frac{1}{\\sqrt5}\\left[(\\frac{1+\\sqrt5}{2})^n-(\\frac{1-\\sqrt5}{2})^n\\right]$ 卡特兰数通项公式我不是鸽子！我来抄推卡特兰数通项辣！ 卡特兰数的定义式为$c_0=1,c_n=\\sum\\limits_{i=0}^{n-1}c_ic_{n-1-i}$。看起来很卷积。 令$F(x)$为$\\{c_n\\}$的生成函数。 $F=\\sum\\limits_{n=0}^\\infty c_nx^n$ $=\\sum\\limits_{n=0}^\\infty x^n\\left([n=0]+\\sum\\limits_{i=1}^{n-1}c_ic_{n-1-i}\\right)$ $=1+xF^2$ 解一元二次方程，$F=\\dfrac{1\\pm\\sqrt{1-4x}}{2x}$ 诶？这咋有个$\\pm$啊？ $F$当然不会有两个解，要舍掉一个。 虽然生成函数中$x$本身没有意义，但是给它代个值是可以的。比如$0$就很好，因为$F(0)$就是常数项。 而本题中$F(0)=1$，取加号时等式右边为$\\dfrac{2}{0}=+\\infty$，取减号时为$\\dfrac{0}{0}=1$，舍掉加号。 所以$F(x)=\\dfrac{1-\\sqrt{1-4x}}{2x}$ 然后开始抄rqy铃悬的博客： 根据广义二项式定理展开$\\sqrt{1-4x}$ $(1-4x)^{\\frac{1}{2}}$ $=\\sum\\limits_{n=0}^\\infty C_{\\frac{1}{2}}^n(-4x)^n$ $=1+\\sum\\limits_{n=1}^\\infty\\dfrac{\\frac{1}{2}(-\\frac{1}{2})(-\\frac{3}{2})\\dots(\\frac{3}{2}-n)}{n!}(-4x)^n$ $=1+\\sum\\limits_{n=1}^\\infty\\dfrac{(-1)(-3)\\dots(3-2n)}{n!}(-2x)^n$ $=1-\\sum\\limits_{n=1}^\\infty\\dfrac{1\\times3\\times\\dots(2n-3)}{n!}(2x)^n$ $=1-\\sum\\limits_{n=1}^\\infty\\dfrac{1\\times2\\times 3\\times4\\times\\dots(2n-3)\\times(2n-2)}{2\\times4\\times\\dots(2n-2)n!}(2x)^n$ $=1-\\sum\\limits_{n=1}^\\infty\\dfrac{(2n-2)!}{1\\times2\\times\\dots(n-1)n!}2x^n$ $=1-\\sum\\limits_{n=1}^\\infty\\dfrac{(2n-2)!}{(n-1)!n!}2x^n$ 把它代回去： $F(x)=\\dfrac{1-\\sqrt{1-4x}}{2x}$ $=\\dfrac{\\sum\\limits_{n=1}^\\infty\\dfrac{(2n-2)!}{(n-1)!n!}2x^n}{2x}$ $=\\sum\\limits_{n=1}^\\infty\\dfrac{(2n-2)!}{n!(n-1)!}x^{n-1}$ $=\\sum\\limits_{n=0}^\\infty\\dfrac{(2n)!}{(n+1)!n!}x^n$ $=\\sum\\limits_{n=0}^\\infty\\dfrac{C_{2n}^n}{n+1}x^n$ 于是得出卡特兰数通项公式为$c_n=\\dfrac{C_{2n}^n}{n+1}$ 结合多项式例题 设$f(n)$为权值为$n$的神犇二叉树数量。 枚举根、左右儿子的权值，$f(0)=1,f(n)=\\sum\\limits_{i=1}^n[i\\in C]\\sum\\limits_{j=0}^{n-i}f(j)f(n-i-j)$ 后面那个看起来很卷积很多项式。 令$\\{a_n=[n\\in C]\\}$的$OGF$为$G(x)=\\sum\\limits_{n=0}^\\infty[n\\in C]x^n$，$\\{f(n)\\}$的$OGF$为$F(x)\\sum\\limits_{n=0}^\\infty f(n)x^n$ $F(x)=\\sum\\limits_{n=0}^\\infty x^n\\left([n=0]+\\sum\\limits_{i=1}^n[i\\in C]\\sum\\limits_{j=0}^{n-i}f(i)f(n-i-j)\\right)$ 于是有$F=1+GF^2$。 解这个一元二次方程得$F=\\dfrac{1\\pm\\sqrt{1-4G}}{2G}$。 $G(0)=0,F(0)=1$，令$x=0$，计算可知取减号。 $F=\\dfrac{1-\\sqrt{1-4G}}{2G}$。这就是个多项式问题了。直接上板子。 但是当你兴冲冲地默写完多项式开根和求逆后会懵逼地发现：由于$G(0)=0$，$2G$求逆后全变成$0$了！ 这咋整啊？分母无理化呗！ 分式上下同乘$1+\\sqrt{1-4G}$得：$F=\\dfrac{1-(1-4G)}{2G(1+\\sqrt{1-4G})}=\\dfrac{2}{1+\\sqrt{1-4G}}$ 这样就可以做了。 水题整数的lqp拆分设$f(n)$为答案。 根据打表可知f(n)=2f(n-1)+f(n-2)，高精矩乘应该能过 显然有$f(0)=1,f(n)=\\sum\\limits_{i=1}^nfib(i)f(n-i)$ 设$\\{fib(i)\\}$的$OGF$为$G(x)=\\sum\\limits_{n=0}^\\infty fib(n)x^n$（不要在意为什么是$G$），$\\{f(i)\\}$的$OGF$为$F(x)=\\sum\\limits_{n=0}^\\infty f(n)x^n$ $F(x)=\\sum\\limits_{n=0}^\\infty x^n\\left([n=0]+\\sum\\limits_{i=1}^nfib(i)f(n-i)\\right)$ $F=1+F\\times G$ $F=\\dfrac{1}{1-G}$ 根据前文，$G(x)=\\dfrac{x}{1-x-x^2}$ $F=\\dfrac{1}{1-\\frac{x}{1-x-x^2}}=\\dfrac{1-x-x^2}{1-2x-x^2}=1+\\dfrac{x}{1-2x-x^2}$ 和斐波那契数列通项的推导类似，设$\\dfrac{1}{1-2x-x^2}=\\dfrac{A}{1-ax}+\\dfrac{B}{1-bx}$ 解方程就不说了，最终解得$a=1+\\sqrt2,b=1-\\sqrt2,A=\\dfrac{1}{2\\sqrt2},B=-\\dfrac{1}{2\\sqrt2}$ 得出通项为$f(n)=\\dfrac{\\sqrt2}{4}[(1+\\sqrt2)^n-(1-\\sqrt2)^n]$ 不会二次剩余？$O(p)$枚举得出$59713600^2\\equiv2\\pmod{10^9+7}$ 城市规划$EGF$结合多项式。 题解 付公主的背包生成函数与多项式$\\ln$和$\\exp$的应用。 题解 ZJL的妹子序列一句话题意：求恰好有$k$对逆序对的$1\\sim n$排列数。$n,k\\le 10^5$。 和「付公主的背包」挺像的。设$f(i,j)$为恰有$j$对逆序对的$1\\sim i$排列数。 $f(i,0)=1,f(i,j)=\\sum\\limits_{k=0}^{i-1}f(i-1,j-k)$ 令$\\{f(i)\\}$的普通生成函数为$F_i(x)$。 $F_i=\\sum\\limits_{n=0}^\\infty f(i,n)x^n$ $=\\sum\\limits_{n=0}^\\infty x^n\\sum\\limits_{j=0}^{i-1}f(i-1,n-j)$ $=\\sum\\limits_{j=0}^{i-1}x^jF_{i-1}$ $\\dfrac{F_i}{F_{i-1}}=\\dfrac{1-x^i}{1-x}$ 累乘得到$F_n=F_0\\prod\\limits_{i=1}^n\\dfrac{1-x^i}{1-x}$ $F_0=1$就不要了。还是通过取对数转乘为加： $F_n=\\exp\\sum\\limits_{i=1}^n\\ln\\dfrac{1-x^i}{1-x}$ $=\\exp\\sum\\limits_{i=1}^n\\left(\\ln\\dfrac{1}{1-x}-\\ln\\dfrac{1}{1-x^i}\\right)$ $=\\exp\\sum\\limits_{i=1}^n\\left(\\sum\\limits_{k=1}^\\infty\\dfrac{x^k}{k}-\\sum\\limits_{k=1}^\\infty\\dfrac{x^{ik}}{k}\\right)$ $=\\exp\\left(\\sum\\limits_{k=1}^\\infty\\dfrac{n}{k}x^k-\\sum\\limits_{i=1}^n\\sum\\limits_{k=1}^\\infty\\dfrac{x^{ik}}{k}\\right)$ 枚举倍数构造多项式再$\\exp$回来即可，$O(n\\log k)$的。 射命丸文的笔记和「城市规划」差不多。 题解 玩游戏答案为$\\dfrac{\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m(a_i+b_j)^k}{nm}$，只考虑分子。 用二项式定理展开： $\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m(a_i+b_j)^k$ $=\\sum\\limits_{x=0}^k\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^mC_k^xa_i^xb_i^{k-x}$ $=k!\\sum\\limits_{x=0}^k\\dfrac{\\sum\\limits_{i=1}^na_i^x}{x!}\\dfrac{\\sum\\limits_{j=1}^mb_j^{k-x}}{(k-x)!}$ 搞出来$3$个$EGF$卷一下就好了，问题是怎么求$\\sum\\limits_{i=1}^na_i^k$。 先把$\\{a_i^k\\}$写成生成函数：$\\sum\\limits_{k=1}^\\infty a_i^kx^k=\\dfrac{1}{1-a_ix}$。 那么$\\left\\{\\sum\\limits_{i=1}^na_i^k\\right\\}$的生成函数$F(x)$就是这$n$个生成函数的和，即$F(x)=\\sum\\limits_{i=1}^n\\dfrac{1}{1-a_ix}$。 令$G(x)=\\sum\\limits_{i=1}^n\\dfrac{-a_i}{1-a_ix}$。 接下来变魔术： $F(x)=n+\\sum\\limits_{i=1}^n\\dfrac{1-1+a_ix}{1-a_ix}=-xG(x)+n$ 现在要求$G(x)$。发现$\\ln’(1-a_ix)=\\dfrac{-a_i}{1-a_ix}$。 于是$G(x)=\\sum\\limits_{i=1}^n\\ln’(1-a_ix)=\\ln’\\left(\\prod\\limits_{i=1}^n(1-a_ix)\\right)=\\dfrac{\\left(\\prod\\limits_{i=1}^n(1-a_ix)\\right)’}{\\prod\\limits_{i=1}^n(1-a_ix)}$ 这个连乘用分治求。将两边区间的结果$NTT$乘起来。复杂度为$T(n)=2T(\\frac{n}{2})+O(n\\log n)=O(n\\log^2n)$。 最后还原上面的推导。 终于做完了。。。 然后发现我是真的真的真的写不动，那就光嘴巴好了 概率论题解","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ctz45562.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"FFT/NTT","slug":"FFT-NTT","permalink":"https://ctz45562.github.io/tags/FFT-NTT/"},{"name":"多项式","slug":"多项式","permalink":"https://ctz45562.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"name":"生成函数","slug":"生成函数","permalink":"https://ctz45562.github.io/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"}]},{"title":"bzoj 3252 攻略","slug":"bzoj-3252-攻略","date":"2020-01-04T11:07:20.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2020/01/04/bzoj-3252-攻略/","link":"","permalink":"https://ctz45562.github.io/2020/01/04/bzoj-3252-%E6%94%BB%E7%95%A5/","excerpt":"传送门 不知道扯啥了，就想构造个密码，然而搜狗打不出来“横折弯”，百度上也没搜出来。。。 所以这不就有的扯了吗","text":"传送门 不知道扯啥了，就想构造个密码，然而搜狗打不出来“横折弯”，百度上也没搜出来。。。 所以这不就有的扯了吗 考虑一个贪心：每次取权值最大的路径，然后把这条路径上的点权清空。 不会理性证明，那就感性理解一下，看起来挺对的。 用不大一样的长剖优化。不以深度划分长短儿子，而是以权值和划分，然后把所有长链扔到堆里取前$k$大。 正确性的话，根据上面的贪心，某个点一定是被它下面最大的一条路径取走。这若干条不相交的链就可以代表取走每个叶子时的权值。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define maxn 200005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } priority_queue&lt;long long&gt;q; long long md[maxn]; int son[maxn],a[maxn],top[maxn],h[maxn],num; struct edge{int pre,to;}e[maxn]; inline void add(int from,int to){e[++num]=(edge){h[from],to},h[from]=num;} void dfs1(int node=1){ md[node]=a[node]; for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to,dfs1(x); if(md[x]&gt;md[son[node]])son[node]=x,md[node]=md[x]+a[node]; } } void dfs2(int node=1){ if(top[node]==node)q.push(md[node]); if(!son[node])return; top[son[node]]=top[node],dfs2(son[node]); for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(x!=son[node])top[x]=x,dfs2(x); } } int main(){ top[1]=1; int n=read(),k=read(); long long ans=0; for(register int i=1;i&lt;=n;++i)a[i]=read(); for(register int i=1,x;i&lt;n;++i)x=read(),add(x,read()); dfs1(),dfs2(); while(k--)ans+=q.top(),q.pop(); printf(&quot;%lld\\n&quot;,ans); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://ctz45562.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"长链剖分","slug":"长链剖分","permalink":"https://ctz45562.github.io/tags/%E9%95%BF%E9%93%BE%E5%89%96%E5%88%86/"}]},{"title":"长链剖分学习笔记","slug":"长链剖分学习笔记","date":"2020-01-03T23:42:38.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2020/01/04/长链剖分学习笔记/","link":"","permalink":"https://ctz45562.github.io/2020/01/04/%E9%95%BF%E9%93%BE%E5%89%96%E5%88%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"感jo长链剖分要写的东西不是很多（其实也不少），但感觉很$dio$干脆新开一篇了（","text":"感jo长链剖分要写的东西不是很多（其实也不少），但感觉很$dio$干脆新开一篇了（ 前言和重链剖分一样，长链剖分也是把树划分成若干条链的方式。 重链剖分是以子树大小划分的，而长链剖分是以点的深度划分的。 抄袭来源 https://www.cnblogs.com/cjyyb/p/9479258.html https://blog.csdn.net/litble/article/details/87965999 #define$son(x)$：$x$的长儿子。 $md(x)$：$x$与其子树内最远点的距离。 $top(x)$：长链链顶。 $seg(x)$：$x$的$dfs$序。 长链剖分实现以$md$最大的儿子为自己的长儿子，剩下的和重链剖分完全一样。 代码int md[maxn],son[maxn],top[maxn],h[maxn]; bool vis[maxn]; struct edge{int h[from],to;}e[maxn&lt;&lt;1]; void dfs1(int node){ md[node]=1; for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(md[x])continue; dfs1(x); if(md[x]&gt;md[son[node]])son[node]=x,md[node]=md[x]+1; } } void dfs2(int node){ vis[node]=1; if(!son[node])return; top[son[node]]=top[node],dfs2(son[node]); for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(!vis[x])top[x]=x,dfs2(x); } } 性质1.所有长链链顶的$md$之和是$O(n)$的。 长链一定是延伸到叶节点的，也就是说长链的长度等于链顶的$md$。 而长链互不相交，且每个点只属于一条长链。所以长链长度之和是$O(n)$的。 2.从一个点向上跳top，长链的长度单调递增。 考虑反证法。 若长链的长度变短了： 非常直观了吧，此时一个更深的儿子反而不是长儿子，不符合定义。 3.从一个点向上跳top，最多跳$\\sqrt n$次到达根节点。 根据性质$2$，最坏情况下到达的长链长度为$1,2,3\\dots\\sqrt n$，使它们和为$n$。 不过毕竟是$\\sqrt n$，长剖求$lca$并不优秀。 4.任意一个点的$k$级祖先所在的长链长度不低于$k$。 都已经是$k$级祖先了，所以至少存在一条链长度为$k$。 应用dsu on tree·改一般所说的$dsu\\ on\\ tree$是基于重链剖分的： 访问轻儿子，回溯时清空信息 访问重儿子，保留信息 暴力把轻儿子的信息统计上，得到当前节点子树信息 当然这里不是用长剖来$dsu$，复杂度成$O(n\\sqrt n)$了。 注意保留重儿子信息这一点，用到长剖上会怎么样？ 实现例题 设$f(i,j)$为以点$i$为根的子树中，与$i$距离为$j$的点的数量。这个题实际上就是求最大的$f(i,j)$中的$j$。 转移很简单：$f(i,0)=1,f(i,j)=\\sum\\limits_{fa(x)=i}f(x,j-1)$ 这样是$O(n^2)$的。 考虑保留长儿子的信息，我们发现$f(i)$其实就是$f(son(i))$平移了一位，通过指针可以$O(1)$继承长儿子的信息（具体实现见代码）。 而短儿子（听起来好像很别扭）直接暴力转移即可。 代码int h[maxn],md[maxn],son[maxn],tax[maxn&lt;&lt;1],ans[maxn],*f[maxn],*p=tax,num; struct edge{int pre,to;}e[maxn&lt;&lt;1]; inline void add(int from,int to){e[++num]=(edge){h[from],to},h[from]=num;} void dfs(int node=1){ md[node]=1; for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(md[x])continue; dfs(x); if(md[x]&gt;md[son[node]])son[node]=x,md[node]=md[x]+1; } } void dp(int node=1,int fa=0){ if(son[fa]!=node)f[node]=p,p+=md[node]&lt;&lt;1;//轻儿子申请数组空间 if(son[node]){ f[son[node]]=f[node]+1,dp(son[node],node);//直接使用重儿子的数组，继承重儿子的f if(ans[son[node]])ans[node]=ans[son[node]]+1; } f[node][0]=1; for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(x==fa||x==son[node])continue; dp(x,node); for(register int j=1;j&lt;=md[x];++j){ f[node][j]+=f[x][j-1]; if(f[node][j]&gt;f[node][ans[node]]||(f[node][j]==f[node][ans[node]]&amp;&amp;ans[node]&gt;j))ans[node]=j; } } } 也可以通过给节点编号继承，在用线段树维护$DP$的时候更方便。 复杂度时间复杂度是$O(\\sum\\limits_{son(fa(i))\\neq i}md(i))$的。 显然一个短儿子是它所在长链的链顶，那么根据性质$1$，$md$之和是$O(n)$的。所以时间复杂度是$O(n)$的。 而空间复杂度不高于时间复杂度，从代码也能看出来和时间复杂度同级。 对于这种和复杂度和深度有关的，可以考虑长剖优化。 求k级祖先实现在此之前，求$k$级祖先可以倍增$O(n\\log n)-O(\\log n)$、树剖$O(n)-O(\\log n)$和离线$dfs$+栈$O(n)$。 而用长剖可以做到在线$O(n\\log n)-O(1)$。 板子 首先在每条长链的链顶存下链中所有点和链顶的前$md$级祖先，根据性质$1$这是$O(n)$的。 查询$x$的$k$级祖先，要选择一个$r$，跳到$x$的$r$级祖先$y$，满足$r\\le k\\le 2r$。 根据性质$4$，此时的链顶一定存有$y$的$k-r$级祖先，要么在链顶的祖先里，要么在长链里。而前面已经存过了，$O(1)$获取即可。 选择$k$二进制下最高位的$1$作为$r$，然后倍增预处理出$x$的$2^r$祖先就行了。 代码vector&lt;int&gt;u[maxn],d[maxn]; int md[maxn],son[maxn],top[maxn],fa[maxn][22],lg[maxn],h[maxn],deep[maxn],num; struct edge{int pre,to;}e[maxn]; inline void add(int from,int to){e[++num]=(edge){h[from],to},h[from]=num;} void dfs1(int node){ md[node]=1; for(register int i=1;i&lt;=lg[deep[node]];++i) fa[node][i]=fa[fa[node][i-1]][i-1]; for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to,fa[x][0]=node,deep[x]=deep[node]+1,dfs1(x); if(md[x]&gt;md[son[node]])son[node]=x,md[node]=md[x]+1; } } void dfs2(int node){ d[top[node]].push_back(node); if(top[node]==node)for(register int i=1,x=fa[node][0];i&lt;=md[node]&amp;&amp;x;x=fa[x][0],++i)u[node].push_back(x); if(!son[node])return; top[son[node]]=top[node],dfs2(son[node]); for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(x!=son[node])top[x]=x,dfs2(x); } } int query(int x,int k){ if(!k)return x; x=fa[x][lg[k]],k^=1&lt;&lt;lg[k]; if(k&lt;=deep[x]-deep[top[x]])return d[top[x]][deep[x]-deep[top[x]]-k]; return u[top[x]][k-deep[x]+deep[top[x]]-1]; } #define ui unsigned int ui s; inline ui get(ui x) { x ^= x &lt;&lt; 13; x ^= x &gt;&gt; 17; x ^= x &lt;&lt; 5; return s = x; } int main(){ int n=read(),m=read(),root,ans=0; long long res=0; s=read&lt;unsigned int&gt;(); for(register int i=2;i&lt;=n;++i)lg[i]=lg[i&gt;&gt;1]+1; for(register int i=1,x;i&lt;=n;++i){ x=read(); if(!x)root=i; else add(x,i); } deep[root]=1,top[root]=root,dfs1(root),dfs2(root); for(register int i=1;i&lt;=m;++i){ int x=(get(s)^ans)%n+1,k=(get(s)^ans)%deep[x]; ans=query(x,k),res^=1ll*ans*i; } printf(&quot;%lld\\n&quot;,res); } 水题HOT-Hotels洛谷上也有，不过是弱化版。 难点其实是DP。 距离两两相等的三个点会长成这样： 设$f(i,j)$为以点$i$为根的子树中，与$i$距离为$j$的点的数量；$g(i,j)$为以点$i$为根的子树中，点对$(x,y)$的数量，满足$dis(lca(x,y),x)=dis(lca(x,y),y)=dis(lca(x,y),i)+j$。 转移和统计答案显然： $f(i,0)=1,f(i,j)=\\sum\\limits_{fa(x)=i}f(x,j-1)$ $g(i,0)=\\sum\\limits_{fa(x)=i}g(x,1),g(i,j)=\\sum\\limits_{fa(x)=i}g(x,j+1)+f(i,j)\\times f(x,j-1)$ $ans+=g(i,0)+\\sum\\limits_{fa(x)=i}g(i,j)\\times f(x,j-1)+g(x,j+1)\\times f(i,j)$ 长剖优化即可。 重建计划以前用点分治写过，以下都是口胡。 见平均值想$01$分数规划，二分走起。 然后就是找一条长度在$[L,R]$之间、权值和最大的路径。 点分治+单调队列啊 设$f(i,j)$为以点$i$为根的子树中，点$i$为一端长度为$j$的路径最大值。 $f(i,j)=\\max\\limits_{fa(x)=i}\\{f(x,j-1)\\}$ $ans=\\max\\limits_{k\\in[L,R]}\\{f(i,k)\\}$ 区间求$\\max$需要套个线段树，指针就不管用了，要用编号来处理。 长剖的时候求一下$dfs$序。和树剖一样先遍历长儿子。 维护一颗蛇皮的全局线段树，位置$seg(i)+j$表示$f(i,j)$。这样就可以直接继承了。 攻略题解 希望告辞.jpg","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ctz45562.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"长链剖分","slug":"长链剖分","permalink":"https://ctz45562.github.io/tags/%E9%95%BF%E9%93%BE%E5%89%96%E5%88%86/"}]},{"title":"USACO-07JAN Cow School","slug":"USACO-07JAN-Cow-School","date":"2019-12-30T09:16:45.000Z","updated":"2020-06-21T10:17:54.000Z","comments":true,"path":"2019/12/30/USACO-07JAN-Cow-School/","link":"","permalink":"https://ctz45562.github.io/2019/12/30/USACO-07JAN-Cow-School/","excerpt":"传送门 试图用$kdt$强上凸包の翻车现场。","text":"传送门 试图用$kdt$强上凸包の翻车现场。 以下记$a_i$为$t[i]$，$b_i$为$p[i]$，$S$为去掉得分比前$d$小后的$\\sum a_i$，$T$为去掉前$d$小后的$\\sum b_i$。 如果存在一种更优的方案，一定可以在前$d$小里选$1$场替换掉已有的$1$场，使得分更大。 即$\\dfrac{S-a_i+a_j}{T-b_i+b_j}&gt;\\dfrac{S}{T}(j\\le d &lt;i)$ update：关于这个结论的证明我出胡策的时候发现不是很显然，所以还是简单证一下。 最大的问题在于：如果存在某种方案用集合$A$替换集合$B$是较优的，而对于$i\\in A,j\\in B$，仅用$i$替换$j$并不优，这个结论是否就不成立了呢。 感性理解，如果对于所有$i\\in A,j\\in B$满足仅用$i$替换$j$并不优，好像这个$A$换$B$也不太可能成为较优解了。 啰嗦化形式化证明的话，这个条件可以这么表达： $\\exists i,j\\begin{cases}\\dfrac{S-a_i+a_j}{T-b_i+b_j}&lt;\\dfrac{S}{T}\\\\\\dfrac{S-a_i-C+a_j+C’}{T-b_i-D+b_j+D’}&gt;\\dfrac{S}{T}\\end{cases}$ 其中，$C=\\left(\\sum\\limits_{k\\in B}a_k\\right)-a_i,C’=\\left(\\sum\\limits_{k\\in A}a_k\\right)-a_j,D=\\left(\\sum\\limits_{k\\in B}b_k\\right)-b_i,D’=\\left(\\sum\\limits_{k\\in A}b_k\\right)-b_j$ 化一下式子就能得到$\\dfrac{S-C+C’}{T-D+D’}&gt;\\dfrac{S}{T}$ 也就是说从$A,B$去掉$i,j$这对不优解，剩下的元素依然可以成为一个较优解。那么如果$A,B$中所有$i,j$都不优的话，就去掉一组得到新集合。直到存在$i,j$较优或者都只剩$1$个元素，结论就成立了。 化简一波这个式子就成了$Ta_j-Sb_j&gt;Ta_i-Sb_i$ 于是选出最大的$Ta_j-Sb_j$和最小的$Ta_i-Sb_i$判断一下即可。 怎么搞呢？ 第一想法：我们发现这个式子长得很$kdt$（参见巧克力王国）。 直接上$kdt$瞎搞一搞就行了，计算矩形端点的取值剪枝。复杂度没有保证，反正$kdt$是暴力。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;time.h&gt; #define maxn 50005 const long long inf = 1e18; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } #define son(x,y) son[x][y] #define ls(x) son(x,0) #define rs(x) son(x,1) #define up(f,a,b) a[node][c[node]]=f(f(a[ls(node)][c[node]],a[rs(node)][c[node]]),p[node][b]) #define dup(f,a) a[node][c[node]^1]=f(a[ls(node)][c[node]^1],a[rs(node)][c[node]^1]) long long s,t,res; int ans[maxn],id[maxn],fa[maxn],son[maxn][2],xl[maxn][2],xr[maxn][2],yl[maxn][2],yr[maxn][2],p[maxn][2],root,cnt,D; bool c[maxn]; struct grade{ int a,b; bool operator &lt; (const grade &amp;x)const{return a*x.b&lt;b*x.a;} }g[maxn]; struct point{ int pos[2],id; bool operator &lt; (const point &amp;x)const{return pos[D]&lt;x.pos[D];} }po[maxn]; inline void update(int node){ up(min,xl,0),up(max,xr,0),up(min,yl,1),up(max,yr,1); dup(min,xl),dup(max,xr),dup(min,yl),dup(max,yr); } void build(int l,int r,int &amp;node){ if(l&gt;r)return; int mid=l+r&gt;&gt;1; node=++cnt,D=rand()&amp;1; nth_element(po+l,po+mid,po+r+1); memcpy(p[node],po[mid].pos,sizeof p[node]),id[po[mid].id]=node; build(l,mid-1,ls(node)),build(mid+1,r,rs(node)); fa[ls(node)]=fa[rs(node)]=node; update(node); } inline void toggle(int node){ c[node]=1; while(node)update(node),node=fa[node]; } inline long long calc_max(int node){return node?t*xr[node][1]-s*yl[node][1]:-inf;} inline long long calc_min(int node){return node?t*xl[node][0]-s*yr[node][0]:inf;} void Max(int node){ if(c[node])res=max(res,t*p[node][0]-s*p[node][1]); long long d[2]={calc_max(ls(node)),calc_max(rs(node))}; int t=d[1]&gt;d[0]; if(d[t]&gt;res)Max(son(node,t)); if(d[t^1]&gt;res)Max(son(node,t^1)); } void Min(int node){ if(!c[node])res=min(res,t*p[node][0]-s*p[node][1]); long long d[2]={calc_min(ls(node)),calc_min(rs(node))}; int t=d[1]&lt;d[0]; if(d[t]&lt;res)Min(son(node,t)); if(d[t^1]&lt;res)Min(son(node,t^1)); } inline long long ma(){res=-inf,Max(root);return res;} inline long long mi(){res=inf,Min(root);return res;} int main(){ srand(time(0)); int n=read(),cnt=0; for(register int i=1;i&lt;=n;++i)s+=(g[i].a=read()),t+=(g[i].b=read()); sort(g+1,g+1+n); for(register int i=1;i&lt;=n;++i)po[i].id=i,po[i].pos[0]=g[i].a,po[i].pos[1]=g[i].b; build(1,n,root); for(register int i=1;i&lt;n;++i){ s-=g[i].a,t-=g[i].b,toggle(id[i]); if(ma()&gt;mi())ans[++cnt]=i; } printf(&quot;%d\\n&quot;,cnt); for(register int i=1;i&lt;=cnt;++i)printf(&quot;%d\\n&quot;,ans[i]); } $kdt$丰硕的战果： 复杂度没有保证：最后一个点跑了$29s$ 反正$kdt$是暴力：喜提和暴力一个分 重新考察这个式子$Ta_j-Sb_j&gt;Ta_i-Sb_i$： 令$Ta_i-Sb_i=C$，变形一波又成了$\\frac{T}{S}a_i-\\frac{C}{S}=b_i$。 把$\\frac{T}{S}$看作斜率，$\\frac{C}{S}$为截距。目的是最小/最大化$C$。 问题就很斜率优化了。维护若干个点，支持： 插入一个点 给定一条直线的斜率，使它过一个点，最大/小化截距 显然斜率是单调的。没什么高论，两遍$cdq$分治+单调队列维护凸包解决。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 50005 const long long inf = 1e18; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } inline double calc(int x1,int y1,int x2,int y2){if(x1==x2)return 1e18;return double(y2-y1)/(x2-x1);} int ans[maxn]; long long mi[maxn],ma[maxn]; struct grade{ int a,b; bool operator &lt; (const grade &amp;x)const{return a*x.b&lt;b*x.a;} }g[maxn]; struct operation{ bool t;//0 insert 1 ask int id; long long x,y;//x:T y:S }A[maxn&lt;&lt;1],B[maxn&lt;&lt;1]; struct Monoqueue{ int xx[maxn],yy[maxn],pos[maxn],head,tail; void clear(){head=1,tail=0;} void push1(int x,int y,int p){ while(head&lt;tail&amp;&amp;calc(xx[tail],yy[tail],xx[tail-1],yy[tail-1])&gt;calc(xx[tail],yy[tail],x,y))--tail; xx[++tail]=x,yy[tail]=y,pos[tail]=p; } int front1(double k){ while(head&lt;tail&amp;&amp;calc(xx[head],yy[head],xx[head+1],yy[head+1])&lt;k)++head; if(head&lt;=tail)return pos[head]; return -1; } void push2(int x,int y,int p){ while(head&lt;tail&amp;&amp;calc(xx[tail],yy[tail],xx[tail-1],yy[tail-1])&lt;calc(xx[tail],yy[tail],x,y))--tail; xx[++tail]=x,yy[tail]=y,pos[tail]=p; } int front2(double k){ while(head&lt;tail&amp;&amp;calc(xx[head],yy[head],xx[head+1],yy[head+1])&gt;k)++head; return pos[head]; } Monoqueue(){clear();} }q; void cdq1(int l,int r){ if(l==r)return; int mid=l+r&gt;&gt;1,pl=l,pr=mid+1,p=l; cdq1(l,mid),q.clear(); for(register int i=l;i&lt;=mid;++i)if(!A[i].t)q.push1(A[i].x,A[i].y,A[i].id); for(register int i=mid+1;i&lt;=r;++i){ if(!A[i].t)continue; int j=q.front1((double)A[i].x/A[i].y); if(~j)mi[A[i].id]=min(mi[A[i].id],A[i].x*g[j].a-A[i].y*g[j].b); } cdq1(mid+1,r),q.clear(); while(pl&lt;=mid&amp;&amp;pr&lt;=r){ if(A[pl].x&gt;A[pr].x||(A[pl].x==A[pr].y&amp;&amp;A[pl].y&lt;A[pr].y))B[p++]=A[pl++]; else B[p++]=A[pr++]; } while(pl&lt;=mid)B[p++]=A[pl++]; while(pr&lt;=r)B[p++]=A[pr++]; for(register int i=l;i&lt;=r;++i)A[i]=B[i]; } void cdq2(int l,int r){ if(l==r)return; int mid=l+r&gt;&gt;1,pl=l,pr=mid+1,p=l; cdq2(l,mid),q.clear(); for(register int i=l;i&lt;=mid;++i)if(!A[i].t)q.push2(A[i].x,A[i].y,A[i].id); for(register int i=mid+1;i&lt;=r;++i){ if(!A[i].t)continue; int j=q.front2((double)A[i].x/A[i].y); if(~j)ma[A[i].id]=max(ma[A[i].id],A[i].x*g[j].a-A[i].y*g[j].b); } cdq2(mid+1,r),q.clear(); while(pl&lt;=mid&amp;&amp;pr&lt;=r){ if(A[pl].x&gt;A[pr].x||(A[pl].x==A[pr].x&amp;&amp;A[pl].y&gt;A[pr].y))B[p++]=A[pl++]; else B[p++]=A[pr++]; } while(pl&lt;=mid)B[p++]=A[pl++]; while(pr&lt;=r)B[p++]=A[pr++]; for(register int i=l;i&lt;=r;++i)A[i]=B[i]; } int main(){ memset(mi,0x3f,sizeof mi),memset(ma,~0x3f,sizeof ma); long long s=0,t=0; int n=read(),cnt=0,len=0; for(register int i=1;i&lt;=n;++i)g[i].a=read(),g[i].b=read(); sort(g+1,g+1+n); for(register int i=n;i;--i){ A[++len]=(operation){1,i,t,s}; A[++len]=(operation){0,i,g[i].a,g[i].b}; s+=g[i].a,t+=g[i].b; } cdq1(1,len); len=0; for(register int i=1;i&lt;=n;++i){ s-=g[i].a,t-=g[i].b; A[++len]=(operation){0,i,g[i].a,g[i].b}; A[++len]=(operation){1,i,t,s}; } cdq2(1,len); for(register int i=1;i&lt;n;++i)if(ma[i]&gt;mi[i])ans[++cnt]=i; printf(&quot;%d\\n&quot;,cnt); for(register int i=1;i&lt;=cnt;++i)printf(&quot;%d\\n&quot;,ans[i]); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"K-D Tree","slug":"K-D-Tree","permalink":"https://ctz45562.github.io/tags/K-D-Tree/"},{"name":"cdq分治","slug":"cdq分治","permalink":"https://ctz45562.github.io/tags/cdq%E5%88%86%E6%B2%BB/"},{"name":"单调队列","slug":"单调队列","permalink":"https://ctz45562.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"}]},{"title":"SPOJ22343 NORMA2 - Norma","slug":"SPOJ22343-NORMA2-Norma","date":"2019-12-29T09:58:23.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/12/29/SPOJ22343-NORMA2-Norma/","link":"","permalink":"https://ctz45562.github.io/2019/12/29/SPOJ22343-NORMA2-Norma/","excerpt":"传送门 ——别撕时政材料啊，我明年补考还要用的。 ——明年就有新材料了。","text":"传送门 ——别撕时政材料啊，我明年补考还要用的。 ——明年就有新材料了。 突然发现自己还不会这种分治算出所有子区间权值的套路，随机钦定了一道来练练。 对于一段中点为$mid$的区间$[l,r]$，它的贡献是经过$mid$的子区间权值加上$[l,mid]$和$[mid+1,r]$的贡献，然后就能分治下去了。 这样只需要考虑怎么算出经过某个点的区间的权值和就可以了。 我的脑回路不太正常，搞了一个无脑暴力的做法： 记$mi_i$为$i$到$mid$所有数的最小值，$ma_i$为最大值，$len_i$为$i$到$mid$的长度。 枚举右端点，考虑左端点的影响。对于$j\\in[l,mid],i\\in[mid+1,r]$，大力分类讨论$[j,i]$的贡献： $case1:mi_j&lt; mi_i\\land ma_i&gt;ma_i:mi_jma_j(len_j+len_i)$ $case2:mi_j&lt;mi_i\\land ma_j\\le ma_i:mi_jma_i(len_j+len_i)$ $case3:mi_j\\ge mi_i\\land ma_j&gt;ma_i:mi_ima_j(len_j+len_i)$ $case4:mi_j\\ge mi_i\\land ma_j\\le ma_i:mi_ima_i(len_j+len_i)$ 显然$ma$和$mi$是单调的，而且一个左端点的变化情况只有可能是$case1\\rightarrow case2 \\rightarrow case4$或$case1\\rightarrow case3\\rightarrow case4$。所以可以用一个指针维护左端点情况，在随着右端点移动向左跑；再对$case2,3$开两个队列判断是否可以进入$case4$，对每种$case$开两个变量随便搞一搞就行了。复杂度还是$O(n\\log n)$。 最棒的是这个方法无论是代码难度、美观度还是常数都被正解踩爆了呢 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define maxn 500005 #define inf 0x3f3f3f3f const int mod = 1e9; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int a[maxn],mi[maxn],ma[maxn],mul[maxn],ans; queue&lt;int&gt;min_q,max_q; #define clear(q) while(!q.empty())q.pop() inline int mix(int x,int y){return x+y&gt;=mod?x+y-mod:x+y;} void solve(int l,int r){ if(l==r){ans=mix(ans,1ll*a[l]*a[l]%mod);return;} clear(min_q); clear(max_q); int mid=l+r&gt;&gt;1,j=mid,min_max_sum,min_max_cnt,min_sum=0,min_cnt=0,max_sum=0,max_cnt=0,sum=0,cnt=0,Mi=inf,Ma=0; mi[mid]=ma[mid]=a[mid],min_max_sum=min_max_cnt=mul[mid]=1ll*a[mid]*a[mid]%mod; for(register int i=mid-1;i&gt;=l;--i)mi[i]=min(mi[i+1],a[i]),ma[i]=max(ma[i+1],a[i]),mul[i]=1ll*mi[i]*ma[i]%mod,min_max_sum=mix(min_max_sum,1ll*mul[i]*(mid-i+1)%mod),min_max_cnt=mix(min_max_cnt,mul[i]); for(register int i=mid+1;i&lt;=r;++i){ Mi=min(Mi,a[i]),Ma=max(Ma,a[i]); while(j&gt;=l){ if(mi[j]&lt;Mi&amp;&amp;ma[j]&gt;Ma)break; min_max_sum=mix(min_max_sum,mod-1ll*mul[j]*(mid-j+1)%mod); min_max_cnt=mix(min_max_cnt,mod-mul[j]); if(mi[j]&gt;=Mi&amp;&amp;ma[j]&lt;=Ma)sum=mix(sum,mid-j+1),++cnt; else if(mi[j]&gt;=Mi)max_sum=mix(max_sum,1ll*ma[j]*(mid-j+1)%mod),max_cnt=mix(max_cnt,ma[j]),max_q.push(j); else min_sum=mix(min_sum,1ll*mi[j]*(mid-j+1)%mod),min_cnt=mix(min_cnt,mi[j]),min_q.push(j); --j; } while(!min_q.empty()){ int k=min_q.front(); if(mi[k]&lt;Mi)break; min_sum=mix(min_sum,mod-1ll*mi[k]*(mid-k+1)%mod),min_cnt=mix(min_cnt,mod-mi[k]); sum=mix(sum,mid-k+1),++cnt; min_q.pop(); } while(!max_q.empty()){ int k=max_q.front(); if(ma[k]&gt;Ma)break; max_sum=mix(max_sum,mod-1ll*ma[k]*(mid-k+1)%mod),max_cnt=mix(max_cnt,mod-ma[k]); sum=mix(sum,mid-k+1),++cnt; max_q.pop(); } ans=mix(ans,mix(mix(mix(min_max_sum,1ll*min_max_cnt*(i-mid)%mod),mix(1ll*max_sum*Mi%mod,1ll*max_cnt*Mi%mod*(i-mid)%mod)),mix(mix(1ll*min_sum*Ma%mod,1ll*min_cnt*Ma%mod*(i-mid)%mod),mix(1ll*sum*Mi%mod*Ma%mod,1ll*cnt*Mi%mod*Ma%mod*(i-mid)%mod)))); } solve(l,mid),solve(mid+1,r); } int main(){ int n=read(); for(register int i=1;i&lt;=n;++i)a[i]=read(); solve(1,n); printf(&quot;%d\\n&quot;,ans); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"cdq分治","slug":"cdq分治","permalink":"https://ctz45562.github.io/tags/cdq%E5%88%86%E6%B2%BB/"}]},{"title":"『请问您今天要来点兔子吗？？sing for you』简评","slug":"sing-for-you","date":"2019-12-27T12:40:34.000Z","updated":"2021-07-01T04:57:23.266Z","comments":true,"path":"2019/12/27/sing-for-you/","link":"","permalink":"https://ctz45562.github.io/2019/12/27/sing-for-you/","excerpt":"对点兔OVA2的简单评价，以及对2020年点兔3的合（hu）理（shuo）推（ba）测（dao）。","text":"对点兔OVA2的简单评价，以及对2020年点兔3的合（hu）理（shuo）推（ba）测（dao）。 作画画风还是熟悉的配方，与第二季和「Dear My Sister」一样。 大部分日常番（尤其是芳文社的）包括点兔都有一个共同的问题：动画要用漫画中一格画面表达其中所有的语言，导致一个人说话时周围人往往会完全静止几秒（砸瓦鲁多！）。一开始看注意力都集中在说话的人身上没啥感觉，刷多了就会感觉很变扭。 个人认为，如果制作想进一步改善作画质量，不妨给静止的人物添加动作弥补连贯性。这一点良心京都做得就很出色（咱不懂就可以随便瞎扯） 虽然我认为动画的画风绝对超越不了漫画，还是希望制作方能进一步改善作画和细节。大胆妄想京阿尼做点兔，细节完全放心，就怕画成京都脸违背了koi老师的画风 剧情整个「sing for you」是基于漫画61话的。 同时增添了不少剧情：开头加了幼年智乃和父母玩耍的剧情，中间加了心爱、千夜和纱路制作应援服的剧情，结尾加了香风隆宏对智乃母亲的回忆和智乃与爷爷的对话。其他还有些细节就不说了。 这些剧情加得很出彩。本身TV版都是24分钟对应漫画2话；同样的时间只写1话必然是要加戏的。依照漫画后面的走向，第三季少不了智乃母亲的戏份，相当于是做铺垫了。 而且这开头，这结尾，这首尾呼应，无论是对母亲形象的塑造，还是体现智乃成长这一主线都是非常符合的。 我看到贴吧评论说剧情太赶了，个人感觉挺合适的，毕竟就1话的内容也长不到哪去。 唯一不满意的是中间那一段众人在甘兔庵开演唱会唱歌。音乐和画面切得太快了，没有衔接观感不好。 音乐看之前就有评论说OVA是来卖歌的。 然而智乃开口的瞬间彻底惊艳到我了，awsl都难以表达我的兴奋。 说我在沙发上和蛆一样扭来扭去的，不赶紧把摄像头拆了我就报警了 然而想听完整版的得买BD，我没钱也没购买渠道，最后从网上剽来的资源。 木もれび青春譜（提取码dqte） （本来是想内联html弄个播放器的，但是&lt;embed&gt;在chrome上炸了，只好挂网盘上。。。） 有日本民歌的感觉，配上小豆队的声线。。。老夫的萌豚心啊 除此之外其他的音乐也是很优秀的，尤其推荐智乃和母亲合唱的「銀のスプーン ～Blend of Memory～」（听说祈妹达成了与她偶像合唱的梦想？）。 銀のスプーン ～Blend of Memory～（提取码xpfk） 顺带一提智乃母亲的声优是水树奈奈。 瞎猜据说2020年1月点兔3就开播了，而且这可能是我高中生涯最后一部追的番了。希望点兔3能带给我亮眼的表现。 按照前两季60话的进度，第三季大概能做到90话。最后小豆队和理世毕业了，之后就是旅行篇了。 旅行篇故事很连贯，不适合放到TV版里。来个剧场版，而且旅行篇能有十多话，做个两小时没问题，岂不美哉？蟠桃大会盛况","categories":[{"name":"点兔","slug":"点兔","permalink":"https://ctz45562.github.io/categories/%E7%82%B9%E5%85%94/"}],"tags":[{"name":"二次元","slug":"二次元","permalink":"https://ctz45562.github.io/tags/%E4%BA%8C%E6%AC%A1%E5%85%83/"},{"name":"请问您今天要来点兔子吗","slug":"请问您今天要来点兔子吗","permalink":"https://ctz45562.github.io/tags/%E8%AF%B7%E9%97%AE%E6%82%A8%E4%BB%8A%E5%A4%A9%E8%A6%81%E6%9D%A5%E7%82%B9%E5%85%94%E5%AD%90%E5%90%97/"},{"name":"番剧","slug":"番剧","permalink":"https://ctz45562.github.io/tags/%E7%95%AA%E5%89%A7/"}]},{"title":"Codeforces1215F Radio Stations","slug":"Codeforces1215F-Radio-Stations","date":"2019-12-27T06:32:45.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/12/27/Codeforces1215F-Radio-Stations/","link":"","permalink":"https://ctz45562.github.io/2019/12/27/Codeforces1215F-Radio-Stations/","excerpt":"传送门 合 格 考 前 一 天 刚 把 政 治 书 上 的 光 盘 撕 下 来 的 屑","text":"传送门 合 格 考 前 一 天 刚 把 政 治 书 上 的 光 盘 撕 下 来 的 屑 题意： 有$n$个电台，每个电台有一个频段$[l_i,r_i]$。有主频$f$，可以在取$[1,v]$中任意整数。现在要大清洗保留一些电台。如果$f\\in [l_i,r_i]$，则可以保留电台$i$，否则不能。有$m_1$个限制形如$x_i$和$y_i$，表示$x_i$和$y_i$至少保留一个；有$m_2$个限制形如$u_i$和$v_i$，表示$u_i$和$v_i$最多保留一个。要求你钦定$f$和保留的电台，满足这些限制。不存在合法方案输出-1，否则输出方案。 这$m_1+m_2$个限制一脸$2-SAT$了，按题意连上就好了。 关键是$f$的限制。一个很$NAIVE$的想法是把$f$拆成$v$个点，表示$f$的取值，大概还要套个线段树优化建图。发现这样不大行。 还是把$f$拆成$v$个点，记为$le(i)$，表示$f\\le i$。 这样就可以连边$i\\rightarrow le(r_i),le(l_i-1)\\rightarrow i’$。 这限制还不太够，再来$v$个点，记为$ge(i)$，表示$f&gt;i$。 于是又可以连边$i\\rightarrow ge(l_i-1),ge(r_i)\\rightarrow i’$。 $le$和$ge$内部也有些关系：$le(i)\\rightarrow le(i+1),ge(i)\\rightarrow ge(i-1)$。 跑一遍缩点，判断$i$和$i’$是否在同一个$SCC$里即可。为什么不用判$le(i)$和$ge(i)$？手玩可以发现，当$le(i)$和$ge(i)$在同一$SCC$时，必有一对$i$和$i’$在同一$SCC$里，也就不用管了。 输出方案按$2-SAT$板子一样，$f$为选取的电台中$l_i$的最大值。不用考虑$r_i$，因为如果不合法了，判$SCC$就过不去。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 400005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } #define le(x) ((n&lt;&lt;1)+x) #define ge(x) ((n&lt;&lt;1)+v+1+x) int h[maxn&lt;&lt;2],seg[maxn&lt;&lt;2],low[maxn&lt;&lt;2],sta[maxn&lt;&lt;2],id[maxn&lt;&lt;2],ans[maxn],l[maxn],r[maxn],top,cnt,num,all; bool vis[maxn&lt;&lt;2]; struct edge{int pre,to;}e[maxn*10]; inline void add(int from,int to){e[++num]=(edge){h[from],to},h[from]=num;} void TJ(int node){ vis[sta[++top]=node]=1; seg[node]=low[node]=++cnt; for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(!seg[x])TJ(x),low[node]=min(low[node],low[x]); else if(vis[x])low[node]=min(low[node],seg[x]); } if(seg[node]==low[node]){ id[node]=++all,vis[node]=0; while(sta[top]!=node)id[sta[top]]=all,vis[sta[top--]]=0; --top; } } int main(){ int m=read(),n=read(),v=read(),M=read(),f=0; while(m--){ int x=read(),y=read(); add(x+n,y),add(y+n,x); } for(register int i=v;i&gt;1;--i)add(le(i-1),le(i)); for(register int i=0;i&lt;v-1;++i)add(ge(i+1),ge(i)); for(register int i=1;i&lt;=n;++i){ l[i]=read(),r[i]=read(); add(i,le(r[i])); add(i,ge(l[i]-1)); if(r[i]&lt;v)add(ge(r[i]),i+n); if(l[i]&gt;1)add(le(l[i]-1),i+n); } while(M--){ int x=read(),y=read(); add(x,y+n),add(y,x+n); } for(register int i=1;i&lt;=(n&lt;&lt;1)+(v&lt;&lt;1);++i)if(!seg[i])TJ(i); cnt=0; for(register int i=1;i&lt;=n;++i){ if(id[i]==id[i+n]){puts(&quot;-1&quot;);return 0;} if(id[i]&lt;id[i+n])f=max(f,l[i]),ans[++cnt]=i; } printf(&quot;%d %d\\n&quot;,cnt,f); for(register int i=1;i&lt;=cnt;++i)printf(&quot;%d &quot;,ans[i]); pn; }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://ctz45562.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"tarjan","slug":"tarjan","permalink":"https://ctz45562.github.io/tags/tarjan/"},{"name":"2-SAT","slug":"2-SAT","permalink":"https://ctz45562.github.io/tags/2-SAT/"}]},{"title":"猛男必刷——「みずしろごちうさクイズ」14题题解","slug":"14questions","date":"2019-12-19T13:52:38.000Z","updated":"2021-07-01T04:39:15.689Z","comments":true,"path":"2019/12/19/14questions/","link":"","permalink":"https://ctz45562.github.io/2019/12/19/14questions/","excerpt":"刷这个比做OI题自闭多了。感觉，我可能没看过「点兔」吧。","text":"刷这个比做OI题自闭多了。感觉，我可能没看过「点兔」吧。 契机是在搜点兔图片的时候，康到了这个。 大概意思是，在这个推特（科学上网）上，每周六会有一道点兔冷门知识题。其中精选了14道正答率低于30%的题。于是就有了这篇题解。 自闭x1 アニメ「ご注文はうさぎですか？？ ～Dear My Sister～」より（在点兔剧场版「Dear My Sister」中） 青山ブルーマウンテン著「ベーカリークイーン」の出版社は？（青山所著的「面包女王」的出版社是哪一家？） 1，跳兎舎 2，跳兎社 3，走兎舎 4，走兎社 正答率23%。 看不透“走兔”和“跳兔”的含义，也分不清“社”和“舎”的区别。 直接放图吧： 自闭x2 アニメ「ご注文はうさぎですか？？」より（在点兔2动画中） 「手洗いの底力、見せてあげるよ！」（让你见识一下手洗的功力！） 大量のカーテンを手洗いしようとしたココアに対するシャロのツッコミで、正しいのは？（面对很多要手洗的窗帘，纱路对心爱这句话的吐槽是哪句？） 1，出来るわけないでしょ！（不可能做到的吧） 2，何言ってるの！（你在说什么） 3，どこからその自信が湧いてくるのよ！（你是从哪涌出的自信说这种话） 4，どこからその自信が出てくるのよ！（你是哪来的信心说出这种话） 正答率28%。 出自第二季第七集（我非常喜欢的一集）： emm。。。好像仅通过翻译不能确定选3还是4。。。 反复听了几遍后才确定是4。 自闭x3 「ご注文はうさぎですか？」コミックス第3巻より（出自漫画第3卷） カレーパーティーで皆が作ったカレーの銘柄で、正しいのは？（咖喱派对上大家用的咖喱品牌是哪个？） 1，とろけてしまうカレー（会融化的咖喱） 2，カレー大王（咖喱大王） 3，ラビットカレー（兔子咖喱） 4，ジョワカレー（看不透） 正答率15%。 仅凭直觉的话肯定是选3。点兔的兔子元素很多，无论是物品外形还是品牌名字一般都是以兔子为根据。 然而这套题让我发现有很多特例。 在漫画里能看到： 这个翻译应该能对上选项1，不太确定的话直接看日语版的： 实际上在动漫第二季第七集里，心爱一行人在商店里提出开咖喱派对的计划时，给过这么一个特写： 但是并没有明确指出她们买的哪种咖喱，而且题目指出是漫画了，实属迷惑行为。 自闭x4 アニメ「ご注文はうさぎですか？」より（动漫中） 次のメニューと値段の組み合わせで、間違っているのはどれ？（以下哪组点心和价钱对不上？） 1，煌めく三宝珠 650円 2，海に映る月と星々 600円 3，黄金の鯱スペシャル 900円 4，姫君の宝石箱 850円 正答率18%。 出自第一季第二集： 于是答案是1。 顺便一提，对比一下漫画的话会发现甘兔庵的价位在动漫里翻了三倍。。。 自闭x5 「ご注文はうさぎですか？」原作コミックスより（在点兔漫画中） モカが中学生の頃、ココアを起こすために歌っていた目覚ましソングの歌詞は？（摩卡是中学生的时候，叫醒心爱起床唱的歌词是什么？） 1，おっはよー 朝だよ ヘイヘヘーイ♪（翻） 2，おきなきゃ マズイゾ グッモーニン♪（译） 3，おっはよー 朝だよ グッモーニン♪（挂） 4，おきなきゃ ダメだゾ グッモーニン♪（了） 正答率29%。 摩卡在漫画中正式出场，只有43-44话摩卡攻略木结构街道；60话心爱回老家；80话智乃升学考试，心爱和摩卡打电话。 然而都没有看到摩卡给心爱唱歌。。。 又翻了一遍漫画，还是没找着。 不应该啊，我印象里是有这个场面的。 最后没办法了去推特抄答案： 这是每一话最后额外的一张简笔画，但它在大妈之家上没有。我有印象是因为在纸质单行本上看到过。。。 自闭x6 「ご注文はうさぎですか？」コミックス第6巻より（漫画第6卷中） ラビットハウスを取材した凛の記事が、喫茶店特集として掲載された雑誌の名前は？（凛采访Rabbit House的报道所刊登的杂志名字是哪个？） 1，KIGUMI WATCHING 2，KIGUMI WALKING 3，RABBIT CAFE 4，RABBIT SWEETS 正答率22%。 科普一下，这里指的是漫画77~79话，动漫没做到那儿。在圣诞节前凛采访Rabbit House，使Rabbit House人气大增，导致工作量增加。恰好心爱和理世都有事请假。于是千夜和纱路穿着心爱补好的制服（智乃母亲没完成的绿色和黄色制服）、惠和麻耶穿着理世新做的制服来帮助智乃，最后平安夜时心爱理世回到Rabbit House，7色制服大团聚。就是这张图的来源： 扯多了毕竟这一段我非常喜欢 所以这个不是第二季第一集的采访报道： 答案在漫画77话： 自闭x7 アニメ「ご注文はうさぎですか？」より（动漫中） 映画「うさぎになったバリスタ」をココア、チノ、リゼ、千夜、シャロの5人が観に行った映画館の名称は？（5人一起去看电影「变成兔子的咖啡师」，电影院叫什么？） 1，シネマ パラダイス（电影天堂） 2，ラビット シネマ（兔子电影院） 3，シネマ ユートピア（电影乌托邦） 4，MOVIX 石畳の街（MOVIX石板路街道） 正答率2%！ 正答率很低，因为很大一部分人被兔子电影院诱导了。 实际上，在第一季第八集： 在电影院左侧能看到写着“CINEMA PARADISE”，这是啥意思我就不用说了吧。 自闭x8 「ご注文はうさぎですか？」コミックス第7巻より（漫画第7卷中） ココアとマヤがゲーセンで遊んだゲームの順番で、正しいのは？（心爱和麻耶在游戏中心里游玩的顺序是？） 1，クレーンゲーム→馬→ボール投げ（抓娃娃→旋转木马→投球） 2，馬→ボール投げ→クレーンゲーム（旋转木马→投球→抓娃娃） 3，ボール投げ→クレーンゲーム→馬（抓娃娃→投球→旋转木马） 4，馬→クレーンゲーム→ボール投げ（旋转木马→抓娃娃→投球） 正答率18%。 出自漫画82话。 容我再扯两句： 这一话主要内容是被智乃抛弃的心爱和被理世抛弃的麻耶组成新cp愉快玩耍最终迷路走向终结迎来Bad End被其他人捡回了家。 所以说koi老师就是nb啊，目前的cp关系快要构成完全图了。 自闭x9 アニメ「ご注文はうさぎですか？？」より（动漫中） リゼとシャロの2人が助っ人にまわった6つの部活を正しい順番に並べると、4番目は？（理世和纱路给其他社团当帮手时，第4个社团是哪个？） 1，演劇部 2，庶民研究部 3，乗馬部 4，ソフトボール部（垒球部） 正答率28%。 出自第二季第十集： 漫画第48话顺序也是一样的： 组合技！自闭x11 「ご注文はうさぎですか？」コミックス第3巻より（漫画第3卷中） ワイルドギースが隠れていた雑誌の名前は？（Wild Geese躲藏的杂志名称是？） 1，Walker 2，Tea times 3，PYON！ 4，PYON PYON！ アニメ「ご注文はうさぎですか？？」より（动漫中） ワイルドギースが隠れていた雑誌の名前は？（Wild Geese躲藏的杂志名称是？） 1，Walker 2，Tea times 3，PYON！ 4，PYON PYON！ 正答率分别为21%和29%。 第一问出自漫画第3卷第5话： 第二问出自动漫第二季第二集： 没想到吧，动漫魔改了！我也没想到。。。 自闭x12 アニメ「ご注文はうさぎですか？」より（动漫中） チノが毎日少しずつ進めていたうさぎのパズルは何ピース？（智乃以每天拼一点为乐趣的拼图有多少块？） 1，260ピース 2，280ピース 3，300ピース 4，320ピース 正答率16%。 出自第一季第七集。 动漫里并没有提到具体是多少块，只能自己数： 答案是14x20=280。 自闭x13 「ご注文はうさぎですか？」コミックス第6巻より（漫画第6卷中） ハロウィンでメグとマヤが仮装した動物はどれ？（麻耶和惠在万圣节扮成了什么动物？） 1，猫 2，犬 3，狼 4，特に決まっていない（不确定） 正答率26%。 来自漫画71话的配图： 你猜这是什么动物？第一感觉应该是狼，事实上选“狼”的人最多。 答案： 所以是“不确定”。。。 插句题外话，说到71话，我就想起来我特别喜欢70话和72话，分别为智乃恶意卖萌和万圣节智乃母亲出现，安利一波。 自闭x14 「ご注文はうさぎですか？」コミックス第6巻より（漫画第6卷中） 青山ブルーマウンテン先生の編集者、真手凛が勤めている出版社の名前は？（青山蓝山的cp编辑真手凛工作的出版社是哪一个？） 1，生論社 2，方文社 3，走兎舎 4，跳兎舎 正答率9%。 很容易受第一题的影响选3。 出自漫画第69话。 可以看到真手凛名片左上角写着“生論社”，应该选1。 小说和编辑的出版社不一样是什么鬼","categories":[{"name":"点兔","slug":"点兔","permalink":"https://ctz45562.github.io/categories/%E7%82%B9%E5%85%94/"}],"tags":[{"name":"二次元","slug":"二次元","permalink":"https://ctz45562.github.io/tags/%E4%BA%8C%E6%AC%A1%E5%85%83/"},{"name":"请问您今天要来点兔子吗","slug":"请问您今天要来点兔子吗","permalink":"https://ctz45562.github.io/tags/%E8%AF%B7%E9%97%AE%E6%82%A8%E4%BB%8A%E5%A4%A9%E8%A6%81%E6%9D%A5%E7%82%B9%E5%85%94%E5%AD%90%E5%90%97/"},{"name":"番剧","slug":"番剧","permalink":"https://ctz45562.github.io/tags/%E7%95%AA%E5%89%A7/"}]},{"title":"K-D Tree学习笔记","slug":"K-D-Tree学习笔记","date":"2019-12-17T12:20:52.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/12/17/K-D-Tree学习笔记/","link":"","permalink":"https://ctz45562.github.io/2019/12/17/K-D-Tree%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"感jo $kdt$ 要写的东西比较多，干脆新开一篇了。","text":"感jo $kdt$ 要写的东西比较多，干脆新开一篇了。 前言学$kdt$前：$kdt$是一种用于维护多维点集的高级数据结构。 学$kdt$后：$kdt$就是加了些剪枝的暴力，看起来复杂度没保证，用于骗分。 抄袭来源 翻出来的pdf课件 https://oi-wiki.org/ds/kdt/ #defineson[x][0/1]/son(x,0/1)/ls(x),rs(x)：$x$的左右儿子。 xl[x],xr[x],yl[x],yr[x]：二维$kdt$点$x$维护的矩形范围。 d[x]：点$x$的比较维度。 pool：内存池。pool[0]存储数量。 sqr(x)：x*x 修改操作$kdt$是一棵$BST$。每个节点代表坐标系上的一个点，并维护一个$k$维立方体，其子树的点都被包含在该$k$维立方体内，且左右儿子的$k$维立方体的并等于该$k$维立方体。 代码都以$2$维$kdt$为例。 建树选择一个维度（即d[x]），取点集中该维度的中位数作为自己的点，左边的点扔到ls里，右边的点扔到rs里，递归左右儿子，最后更新$k$维立方体范围。 这样造出来的$BST$树高是$\\log$的。取中位数时用nth_element，复杂度是$O(n\\log n)$的。 维度可以$1,2,…$循环选取，也可以rand()一个不易被卡。 int son[maxn][2],xl[maxn]={inf},xr[maxn]={-inf},yl[maxn]={inf},yr[maxn]={-inf},d[maxn],pool[maxn],siz[maxn],D; struct point{ int pos[2]; bool operator &lt; (const point &amp;x)const{return pos[D]&lt;x.pos[D];} }poi[maxn],p[maxn]; inline void update(int node){ xl[node]=min(min(xl[ls(node)],xl[rs(node)]),p[node].pos[0]),xr[node]=max(max(xr[ls(node)],xr[rs(node)]),p[node].pos[0]); yl[node]=min(min(yl[ls(node)],yl[rs(node)]),p[node].pos[1]),yr[node]=max(max(yr[ls(node)],yr[rs(node)]),p[node].pos[1]); siz[node]=siz[ls(node)]+siz[rs(node)]+1; } void build(int l,int r,int &amp;node){ if(l&gt;r)return; int mid=l+r&gt;&gt;1; node=pool[pool[0]--],d[i]=D=rand()&amp;1; nth_element(poi+l,poi+mid,poi+1+r); p[node]=poi[mid]; build(l,mid-1,ls(node)); build(mid+1,r,rs(node)); update(node); } 插入以每个节点的$d[x]$比较和$BST$一样插入。 面临一个同样的问题是树会不平衡。 一种解决方法是把操作离线下来提前建树，未被插入的节点打上标记。执行插入时就找到它并激活。 但如果强制在线的话，就要考虑$BST$维护平衡的方式。旋转是不可能的了，每一个点的比较方式不一样怎么转？于是要用替罪羊树的方式重构$kdt$。 const double alpha = 0.7; int cnt,root; void insert(int &amp;node,point P){ if(!node){ node=pool[pool[0]--]; xl[node]=xr[node]=P.pos[0]; yl[node]=yr[node]=P.pos[1]; p[node]=P,siz[node]=1,d[node]=rand()&amp;1; return; } insert(son(node,P.pos[d[node]]&gt;p[node][d[node]]),P),++siz[node]; } void clear(int &amp;node){ if(!node)return; clear(ls(node)),clear(rs(node)); pool[++pool[0]]=node,poi[++cnt]=(point){p[node][0],p[node][1]},node=0; } void check(int &amp;node,point P){ if(!node)return; if(1.0*max(siz[ls(node)],siz[rs(node)])&gt;=alpha*siz[node]){ cnt=0,clear(node),build(1,cnt,node); return; } check(son(node,P.pos[d[node]]&gt;p[node][d[node]]),P); update(node); } void ins(point P){ insert(root,P),check(root,P); } 删除和替罪羊一样删，打上删除标记，重构的时候丢掉。 代码就不放了。 应用前面看起来都很正常（都是基于平衡树的操作嘛），真正的暴力在下面。 $kdt$的查询方法是——在遍历整棵树为前提下，通过计算极端值剪枝来少遍历一些点。 平面最近/远点对计算查询点到矩形域的最小/大距离，若最小/大值都大于/小于当前答案则返回。 好像会被构造数据卡。 欧几里得距离$dis_{\\min}=sqr(\\max\\{\\max\\{xl[node]-x,x-xr[node]\\},0\\})+sqr(\\max\\{\\max\\{yl[node]-y,y-yr[node]\\},0\\})$ $dis_{\\max}=sqr(\\max\\{x-xl[node],xr[node]-x\\})+sqr(\\max\\{y-yl[node],yr[node]-y\\})$ 曼哈顿距离$dis_{\\min}=\\max\\{\\min\\{xl[node]-x,x-xr[node]\\},0\\}+\\max\\{\\min\\{yl[node]-y,y-yr[node]\\},0\\}$ $dis_{\\max}=\\max\\{xr[node]-x,x-xl[node]\\}+\\max\\{yr[node]-y,y-yl[node]\\}$ 切比雪夫距离转成曼哈顿距离就好了。 什么？不会转？5分钟前我也不会 切比雪夫转曼哈顿：$(x,y)\\rightarrow(\\frac{x+y}{2},\\frac{x-y}{2})$ 曼哈顿转切比雪夫：$(x,y)\\rightarrow(x+y,x-y)$ 代码以欧几里得距离$\\min$为例。还有一个小剪枝是先访问极端距离更小的儿子。 long long ans=inf; int x,y; inline long long sqr(int x){return 1ll*x*x;} inline long long calc(int node){ return node?sqr(max(max(xl[node]-x,x-xr[node]),0))+sqr(max(max(yl[node]-y,y-yr[node]),0)):inf; } void ask(int node){ ans=min(ans,sqr(p[node].pos[0]-x)+sqr(p[node].pos[1]-y)); int d[2]={calc(ls(node)),calc(rs(node))},t=d[1]&lt;d[0]; if(d[t]&lt;ans)ask(son(node,t)); if(d[t^1]&lt;ans)ask(son(node,t^1)); } 矩形求和单点加，矩形求和。 如果当前矩形与查询矩形完全不相交直接返回 如果当前矩形完全被包含在查询矩形内，返回矩形和 否则判断该节点代表的点是否在矩形内部，再递归左右儿子。 int x1,y1,x2,y2; int ask(int node){ if(xl[node]&gt;x2||xr[node]&lt;x1||yl[node]&gt;y2||yr[node]&lt;y1)return 0; if(xl[node]&gt;=x1&amp;&amp;xr[node]&lt;=x2&amp;&amp;yl[node]&gt;=y1&amp;&amp;yr[node]&lt;=y2)return sum[node]; return ask(ls(node))+ask(rs(node))+(p[node].pos[0]&gt;=x1&amp;&amp;p[node].pos[0]&lt;=x2&amp;&amp;p[node].pos[1]&gt;=y1&amp;&amp;p[node].pos[1]&lt;=y2)?a[node]:0; } 随机数据下单次查询$O(\\log n)$，构造数据下为$O(\\sqrt{n})$。 解决偏序问题$kdt$维护$k$维偏序复杂度是$O(n^{\\frac{k-1}{k}})$的。 强制在线用不了cdq分治，$kdt$可以用$O(kn)$的空间代替树套树，而且在非构造数据下效率很高。 水题板子们平面最近欧几里得距离点对 平面最近/远曼哈顿距离点对 带修最近曼哈顿距离 只能kdt做的单点加矩形和 可以树套树和cdq做的单点加矩形和 K远点对维护一个小根堆。如果当前点对的距离比堆顶大就替换掉堆顶。通过判断极端值和堆顶的关系选择是否递归。 但如果堆中元素不满$k$个就没得选择。 求的是无序点对，所以$k$要乘$2$。 双倍经验 巧克力王国这道题进一步加深了我对$kdt$暴力的理解。 直接暴力查，把$a,b$带进去计算极端值。最大值小于$c$返回矩形和，最小值大于等于$c$不递归。 要注意的是$a,b,x,y$都可能是负数，不一定是左上角和右下角取到极端值，四个端点都可能取到。 复杂度？kdt的题算什么复杂度 TATT$DP$方程显然：$f(i)=\\max\\limits_{a_j\\le a_i,b_j\\le b_i,c_j\\le c_i,d_j\\le d_i}\\{f(j)\\}+1$ 第一维排序，$3$维$kdt$优化$DP$即可。 不想写带插入$kdt$，提前建好树，记录下原序列中每个点在$kdt$中的节点编号以及父节点，更新时直接跳父节点就好。 有个细节，第一维相同时要按其他维为第二关键字比较大小。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ctz45562.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"K-D Tree","slug":"K-D-Tree","permalink":"https://ctz45562.github.io/tags/K-D-Tree/"}]},{"title":"洛谷 P4208 [JSOI2008]最小生成树计数","slug":"洛谷-P4208-JSOI2008-最小生成树计数","date":"2019-12-17T07:15:33.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/12/17/洛谷-P4208-JSOI2008-最小生成树计数/","link":"","permalink":"https://ctz45562.github.io/2019/12/17/%E6%B4%9B%E8%B0%B7-P4208-JSOI2008-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E8%AE%A1%E6%95%B0/","excerpt":"传送门 Bientôt исчезать の happiness.","text":"传送门 Bientôt исчезать の happiness. 显然，不同的$MST$，每种边权的出现次数是相同的。而把某个边权从不同的$MST$中删去，得到的联通块形态一样的。 对后者的简单证明：任求一棵$MST$，删去某个边权$x$。对剩下的联通块，假设存在一条长为$y$的边能连接两个联通块。若$y&lt; x$，存在更优的$MST$，不符合当前树是$MST$；若$y&gt;x$，连起来得到的比当前树劣，不可能连这条边。 于是就可以随便搞个$MST$，枚举边权，把$MST$中不是该边权的边连起来，对得到的联通块们和原图中所有等于该边权的边跑矩阵树定理，根据乘法原理乘起来就是答案。 分析一波复杂度是$O(n^3\\log n)$的。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 105 #define inf 0x3f3f3f3f const int mod = 31011; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int a[maxn][maxn],fa[maxn],id[maxn],cnt,n,m; struct edge{ int x,y,l; bool operator &lt; (const edge &amp;a)const{return l&lt;a.l;} }e[maxn*10],u[maxn]; int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);} inline void add(int x,int y){++a[x][x],++a[y][y],--a[x][y],--a[y][x];} void kru(){ sort(e+1,e+1+m); for(register int i=1;i&lt;=n;++i)fa[i]=i; for(register int i=1;i&lt;=m;++i){ int x=find(e[i].x),y=find(e[i].y); if(x==y)continue; u[++cnt]=e[i],fa[x]=y; } } int Gauss(){ int ans=1; for(register int i=2;i&lt;=cnt;++i){ for(register int j=i+1;j&lt;=cnt;++j) while(a[j][i]){ int t=a[i][i]/a[j][i]; for(register int k=i;k&lt;=cnt;++k)(a[i][k]-=a[j][k]*t)%=mod,swap(a[i][k],a[j][k]); ans=-ans; } ans=1ll*ans*a[i][i]%mod; } return ans; } int calc(int l){ cnt=0,memset(a,0,sizeof a); for(register int i=1;i&lt;=n;++i)fa[i]=i,id[i]=0; for(register int i=1;i&lt;n;++i)if(u[i].l!=l)fa[find(u[i].x)]=find(u[i].y); for(register int i=1;i&lt;=n;++i){ int x=find(i); if(!id[x])id[x]=++cnt; id[i]=id[x]; } for(register int i=1;i&lt;=m;++i)if(e[i].l==l&amp;&amp;id[e[i].x]!=id[e[i].y])add(id[e[i].x],id[e[i].y]); return Gauss(); } int main(){ n=read(),m=read(); int ans=1; for(register int i=1;i&lt;=m;++i)e[i].x=read(),e[i].y=read(),e[i].l=read(); kru(); for(register int i=1;i&lt;n;++i)if(u[i].l!=u[i-1].l)ans=1ll*ans*calc(u[i].l)%mod; printf(&quot;%d\\n&quot;,ans); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://ctz45562.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"组合数学","slug":"组合数学","permalink":"https://ctz45562.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"高斯消元","slug":"高斯消元","permalink":"https://ctz45562.github.io/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"},{"name":"矩阵树定理","slug":"矩阵树定理","permalink":"https://ctz45562.github.io/tags/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/"}]},{"title":"洛谷 P3317 [SDOI2014]重建","slug":"洛谷-P3317-SDOI2014-重建","date":"2019-12-17T02:29:23.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/12/17/洛谷-P3317-SDOI2014-重建/","link":"","permalink":"https://ctz45562.github.io/2019/12/17/%E6%B4%9B%E8%B0%B7-P3317-SDOI2014-%E9%87%8D%E5%BB%BA/","excerpt":"传送门 只有我是暴力缩点搞的吗。。。","text":"传送门 只有我是暴力缩点搞的吗。。。 令$E$为生成树边集，显然我们要求的就是$\\sum\\limits_E\\left(\\prod\\limits_{e\\in E}p_e\\prod\\limits_{e\\notin E}(1-p_e)\\right)$ 令$P=\\prod(1-p_e)$，即原图所有边的$1-p_e$之积。上面的式子就成了$P\\sum\\limits_E\\left(\\prod\\limits_{e\\in E}\\dfrac{p_e}{1-p_e}\\right)$ 直接变元矩阵树定理搞它就完事了。。。吗？ 若$p_e=1$，会出现分母为$0$的情况。其他题解里都是改为$1-eps$，精度误差可以接受。 没想到于是暴力缩点。$p_e=1$说明生成树中一定有这条边，用并查集缩成一个点。 对于两端点在同一并查集的$e$，若$p_e\\neq 1$，当成自环不用管它；若$p_e=1$，说明一定会出来一个环，输出0。然而我一开始没判过了，大概是数据水了。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 55 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } double a[maxn][maxn],e[maxn][maxn]; int cnt,fa[maxn],id[maxn]; inline void add(int x,int y,double l){a[x][x]+=l,a[y][y]+=l,a[x][y]-=l,a[y][x]-=l;} int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);} double Gauss(){ double ans=1.0; for(register int i=2;i&lt;=cnt;++i){ int t=i; for(register int j=i+1;j&lt;=cnt;++j)if(fabs(a[j][i])&gt;fabs(a[t][i]))t=j; if(t!=i)swap(a[t],a[i]),ans=-ans; for(register int j=i+1;j&lt;=cnt;++j) for(register int k=cnt;k&gt;=i;--k) a[j][k]-=a[i][k]*a[j][i]/a[i][i]; ans*=a[i][i]; } return ans; } int main(){ int n=read(); double P=1.0; for(register int i=1;i&lt;=n;++i)fa[i]=i; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j){ scanf(&quot;%lf&quot;,&amp;e[i][j]); if(i&lt;j&amp;&amp;e[i][j]==1.0){ int u=find(i),v=find(j); if(u==v){puts(&quot;0.000000&quot;);return 0;} fa[u]=v; } } for(register int i=1;i&lt;=n;++i){ if(!id[find(i)])id[find(i)]=++cnt; id[i]=id[find(i)]; } for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=n;++j) if(i&lt;j&amp;&amp;e[i][j]!=1.0)add(id[i],id[j],e[i][j]/(1.0-e[i][j])),P*=1.0-e[i][j]; printf(&quot;%.8lf\\n&quot;,Gauss()*P); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://ctz45562.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"概率期望","slug":"概率期望","permalink":"https://ctz45562.github.io/tags/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/"},{"name":"高斯消元","slug":"高斯消元","permalink":"https://ctz45562.github.io/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"},{"name":"矩阵树定理","slug":"矩阵树定理","permalink":"https://ctz45562.github.io/tags/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/"},{"name":"并查集","slug":"并查集","permalink":"https://ctz45562.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"洛谷 P3648 [APIO2014]序列分割","slug":"洛谷-P3648-APIO2014-序列分割","date":"2019-12-15T10:41:43.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/12/15/洛谷-P3648-APIO2014-序列分割/","link":"","permalink":"https://ctz45562.github.io/2019/12/15/%E6%B4%9B%E8%B0%B7-P3648-APIO2014-%E5%BA%8F%E5%88%97%E5%88%86%E5%89%B2/","excerpt":"传送门 听亲妈聊耽美和魔道祖师是种什么体验","text":"传送门 听亲妈聊耽美和魔道祖师是种什么体验 令$S_i$为分成$k+1$段后第$i$段的和。 考虑任意的第$i$段和第$j$段（$i\\neq j$）之间的贡献，一定会存在某次分割使它们分开，产生$S_iS_j$的贡献，之后两者再无关联。 所以答案为$\\sum\\limits_{i=1}^{k+1}\\sum\\limits_{j=i+1}^{k+1}S_iS_j$，与分割顺序无关。 把这个式子变一变：$\\dfrac{\\left(\\sum\\limits_{i=1}^{k+1}S_i\\right)^2-\\sum\\limits_{i=1}^{k+1}S_i^2}{2}$ $\\left(\\sum\\limits_{i=1}^{k+1}S_i\\right)^2$就是整个序列的和的平方，我们的任务就成了最小化$\\sum\\limits_{i=1}^{k+1}S_i^2$。 设$s_i$为数列前缀和，$f(i,j)$为前$i$个数分成$j$段的最小代价。 显然，$f(i,k)=\\min\\limits_{j&lt;i}\\{f(j,k-1)+(s_i-s_j)^2\\}$ 变个形：$f(j,k-1)+s_j^2=f(i,k)+2s_is_j-s_i^2$ 然后就能斜率优化了。有一个坑点是序列可能有$0$，所以斜率可能不存在。 复杂度$O(nk)$。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 100005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } long long f[maxn][2],y[maxn]; int x[maxn],g[maxn][205],p[maxn],s[maxn],head,tail; inline void clear(){head=1,tail=0;} inline void push(int xx,long long yy,int pos){ while(head&lt;tail&amp;&amp;xx!=x[tail]&amp;&amp;(x[tail]==x[tail-1]||(double)(y[tail]-y[tail-1])/(x[tail]-x[tail-1])&gt;(double)(yy-y[tail])/(xx-x[tail])))--tail; x[++tail]=xx,y[tail]=yy,p[tail]=pos; } inline int front(int k){ while(head&lt;tail&amp;&amp;(double)(y[head+1]-y[head])&lt;=1ll*k*(x[head+1]-x[head]))++head; return p[head]; } inline long long sqr(int x){return 1ll*x*x;} int main(){ int n=read(),k=read()+1; for(register int i=1;i&lt;=n;++i)f[i][1]=sqr(s[i]=s[i-1]+read()); for(register int j=2;j&lt;=k;++j){ clear(),push(s[j-1],f[j-1][j&amp;1^1]+sqr(s[j-1]),j-1); for(register int i=j;i&lt;=n;++i){ int J=g[i][j]=front(s[i]&lt;&lt;1); f[i][j&amp;1]=f[J][j&amp;1^1]+sqr(s[i]-s[J]); push(s[i],f[i][j&amp;1^1]+sqr(s[i]),i); } } printf(&quot;%lld\\n&quot;,1ll*s[n]*s[n]-f[n][k&amp;1]&gt;&gt;1); for(register int j=k,i=n;j&gt;1;--j)printf(&quot;%d &quot;,i=g[i][j]); pn; }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"单调队列","slug":"单调队列","permalink":"https://ctz45562.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"斜率优化","slug":"斜率优化","permalink":"https://ctz45562.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"}]},{"title":"没意思的算法の学习笔记","slug":"没意思的算法の学习笔记","date":"2019-12-11T06:35:34.000Z","updated":"2021-08-21T03:37:04.223Z","comments":true,"path":"2019/12/11/没意思的算法の学习笔记/","link":"","permalink":"https://ctz45562.github.io/2019/12/11/%E6%B2%A1%E6%84%8F%E6%80%9D%E7%9A%84%E7%AE%97%E6%B3%95%E3%81%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"学一个算法，就要把它学精了，理解透彻了。——某金牌教练","text":"学一个算法，就要把它学精了，理解透彻了。——某金牌教练 所以我要多快好省、不求甚解地大量学习算法。 前言本来想挺进多项式，因为要耗费太多精力先放放。 感觉我会的东西好少啊，学弟们会的算法都比我多。 于是来清一波任务清单。很多算法都太小了就把学习笔记合到一块了。 抄袭来源 https://www.luogu.com.cn/blog/user9012/ke-lu-si-ka-er-zhong-gou-shu-lve-xie https://www.luogu.com.cn/problemnew/solution/P3805 https://www.luogu.com.cn/problemnew/solution/P2365 https://www.cnblogs.com/twilight-sx/p/9064208.html https://blog.csdn.net/Adolphrocs/article/details/88756533 https://blog.csdn.net/a_forever_dream/article/details/83654397 https://ouuan.github.io/%E7%BA%BF%E6%80%A7%E5%9F%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ https://www.cnblogs.com/cjjsb/p/9771868.html https://oi-wiki.org/graph/diff-constraints/ https://www.cnblogs.com/Parsnip/p/10969989.html kruskal重构树构造在kruskal的过程中合并两个联通块时，新建一个节点作为重构树上这两个联通块的根的父亲，把该节点的点权设为当前边边权就行了。 也就是把fa[u]=v改成a[++cnt]=e[i].l,fa[u]=cnt,fa[v]=cnt。 性质以最小生成树为例。 1.kruskal重构树是一棵二叉树 2.原图中的点在重构树上都是叶子节点 3.点权随深度增加而递减 4.定义一条路径的权值是其最大边权。原图上两点之间所有路径的最小权值，等于重构树上两点$lca$的点权 应用 一个无向连通图，多次询问，给定一个点，只走边权不超过$k$的边，求出所有能到达的点中#@%^&amp;。 在重构树上倍增到第一个权值小于等于$k$的点，它的子树就是能到达的点。 因为根据性质2,3，如果再往上走的话，经过的边权就大于$k$了。 选取合适的数据结构维护子树信息即可。 水题Peaks求子树第$k$大直接$dfs$序+主席树就好了。 归程跑一遍点$1$的最短路，以最短路距离作为点权，答案就是子树$\\min$。 werewolf狼人题意就是一张无向连通图上，给定两个点$s,e$，询问是否存在一个点$x$，使得$s$到$x$的路径上点的编号都大于等于$L$，且$x$到$e$的路径上点的编号都小于等于$R$。 分别对最小生成树和最大生成树造kruskal重构树。走一条边一定是两端点都经过了，所以边权分别为$\\max(x,y)$和$\\min(x,y)$。 让$s$和$e$分别在最小重构树和最大重构树上倍增到合适节点，判断两个子树是否有交，主席树或离线树状数组皆可。 manacher莫名其妙两点睡的困死了大脑已停止工作看不懂矩阵树嘤嘤嘤先学马拉车了 #define$ma(i)$：以字符$i$为对称轴，向两边扩展的最长回文半径。也就是说开区间$(i-ma(i),i+ma(i))$为回文串。 $R$：当前所有回文子串能扩展到的最靠右的端点。 $mid$：$R$对应的对称轴。 实现回文子串的对称轴可能是一个字符，也可能是字符间隙。 在$S$的开头、结尾和字符之间插入特殊字符#，两种情况就可以一块处理了。为了便于处理越界情况，在最开头再插一个#。 举个栗子：manacher $\\rightarrow$ ##m#a#n#a#c#h#e#r# 扫一遍串，对于当前位置$i$： 若$i\\le r$，取$i$关于$mid$的对称点$j$（易知$j=mid\\times 2 -i$）。$i,j$在同一回文子串中对称，所以有$ma(i)=ma(j)$。但因为该回文串右端点是$R$，$i+ma(j)$不能超过$R$，所以要对$R-i+1$取$\\min$。 若$i&gt;r$，直接从$1$开始暴力向两边拓展得到$ma(i)$。 最后更新$R$和$mid$。 答案为$\\max\\{ma(i)\\}-1$。 板子int ma[maxn&lt;&lt;1]; char a[maxn],s[maxn&lt;&lt;1],n,len;//a为给定串，n为其长度。s为插入特殊字符后的串，len为其长度 void manacher(){ s[0]=&#39;$&#39;; for(register int i=1;i&lt;=n;++i)s[++len]=&#39;$&#39;,s[++len]=a[i]; s[++len]=&#39;$&#39;; int ans=0,R=0,mid; for(register int i=1;i&lt;=len;++i){ if(i&lt;=r)ma[i]=min(ma[(mid&lt;&lt;1)-i],r-i+1); while(s[i-ma[i]]==s[i+ma[i]])++ma[i]; if(i+ma[i]-1&gt;R)R=i+ma[i]-1,mid=i; ans=max(ans,ma[i]); } printf(&quot;%d\\n&quot;,ans-1); } 终于不会出现用$hash$求回文串被卡只能默写后缀数组的情况了。 复杂度时间复杂度为$O(|S|)$。 对于上面第一种情况，因为$ma$的定义是最大回文半径了，所以$i$继承的$ma$要么已经是最大的了，不需要拓展，复杂度为$O(1)$；要么右端点在$R$上，需要暴力拓展。 对于第二种情况，因为$i&gt;R$，所以拓展出的右端点一定大于$R$。 因此只要暴力拓展，$R$一定会被更新。而$R$是单调不降的，故暴力拓展复杂度为$O(|S|)$。 斜率优化DP实现例题1首先可以得到一个朴素的$DP$： 设$f(i)$为完成前$i$项任务最小代价，$t_i$为时间前缀和，$sum_i$为费用前缀和。因为启动时间$s$会对后面的人物都产生影响，$DP$时要算上对后面的贡献。 有转移$f(i)=\\min\\limits_{j&lt;i}\\{f(j)+t_i(sum_i-sum_j)+s(sum_n-sum_j)\\}$ 把这个式子变个形： $f(j)=(t_i+s)sum_j+f(i)-t_isum_i-sum_ns$ 后面那一坨$-t_isum_i-sum_ns$是个常数，先不要管它。 如果把这个式子看作直线方程的话，那它就表示斜率为$t_i+s$，截距为$f(i)$，过点$(sum_j,f(j))$的直线，而我们的目的是最小化截距$f(i)$。 有一条已知斜率的直线和若干点，找一个点使该直线与$y$轴交点尽量靠下。就是把直线往上面移动，碰到的第一个点就是转移点。 考虑什么样的点会使转移点： 先把点按横坐标排序，相邻点连线。首先能排除掉像这样的上凸包顶点： 那么剩下的点连出来的直线斜率是递增的，大概可以$yy$出来转移点是长这样的： 也就是给定直线的斜率大于该点前一条直线的斜率、小于该点后一条直线的斜率。 于是我们要做的是： 维护相邻点连线斜率递增的若干个点 查询给定斜率的后继 就本题而言，横坐标$sum$是递增的，可以用单调队列维护第一条，不断弹出队尾直到队尾和前一个点的斜率小于给定点和队尾的斜率。 而$sum+t$也是递增的，查询时直接弹出队首直到队首和第二个点的斜率大于给定斜率，这时队首就是转移点。 代码1用乘法代替直接计算斜率，避免浮点数误差，还能优化常数。 int sum[maxn],t[maxn],f[maxn]; struct Monoqueue{ int x[maxn],y[maxn],p[maxn],head,tail; void push(int xx,int yy,int pos){ while(head&lt;tail&amp;&amp;1ll*(xx-x[tail])*(y[tail]-y[tail-1])&gt;=1ll*(x[tail]-x[tail-1])*(yy-y[tail]))--tail; x[++tail]=xx,y[tail]=yy,p[tail]=pos; } void check(int k){while(head&lt;tail&amp;&amp;y[head+1]-y[head]&lt;k*(x[head+1]-x[head]))++head;} int front(){return p[head];} Monoqueue(){head=1,tail=0;} }q; int main(){ int n=read(),s=read(); for(register int i=1;i&lt;=n;++i)t[i]=t[i-1]+read(),sum[i]=sum[i-1]+read(); q.push(0,0,0); for(register int i=1;i&lt;=n;++i){ q.check(t[i]+s); int j=q.front(); f[i]=f[j]+t[i]*(sum[i]-sum[j])+s*(sum[n]-sum[j]); q.push(sum[i],f[i],i); } printf(&quot;%d\\n&quot;,f[n]); } 例题2和例题1不同的是时间有负数。 也就是说斜率不单调了，不能通过弹出队首找后继了。但因为队里的元素都是递增的，直接二分即可。 同理，如果横坐标不递增，就要用平衡树或cdq分治维护了。 代码2其他地方都差不多就只放二分的代码了： inline int find(long long k){ int l=1,r=tail,mid; while(l&lt;r){ mid=l+r+1&gt;&gt;1; if(y[mid]-y[mid-1]&lt;=k*(x[mid]-x[mid-1]))l=mid; else r=mid-1; } return p[l]; } 水题剽的一本通的题。。。然而都是套路。。。 玩具装箱TOY设$f(i)$为前$i$件物品的最小费用，$sum_i$为$C_i$的前缀和。容易得到$f(i)=\\min\\{f(j)+(i-j-1+sum_i-sum_j-L)^2\\}$。 令$s_i=i+sum_i,t_i=i+sum_i-L-1$，方程经过变形可以得到： $f(j)+s_j^2=f(i)+2t_is_j-t_i^2$ $2t_i$为斜率，$s_j$为横坐标，且这两者递增。$f(j)+s_j^2$为纵坐标，单调队列维护即可。 Cats Transport对$d$做个前缀和，令$s_i=t_i-d_{h_i}$，即从$s_i$时刻出发恰好能接上猫$i$。 对$s_i$排个序，令$sum_i$为其前缀和。 设$f(i,j)$为接了按$s$排好序的前$i$只猫，已经用了$j$个铲屎官的最小等待时间。 枚举先接哪只猫，转移：$f(i,j)=\\min\\limits_{k\\le i}\\{f(k,j-1)+s_i(i-k)-sum_i+sum_k\\}$ 变形得$f(k,j-1)+sum_k=f(i,j)+s_ik-is_i+sum_i$ 以$s_i$为斜率，$k$为横坐标，$f(k,j-1)+sum_k$为纵坐标，用单调队列维护斜率优化。 仓库建设令$t_i=\\sum\\limits_{j=1}^ip_j,s_i=\\sum\\limits_{j=1}^ip_jx_j$。 设$f(i)$为前$i$个工厂都$OK$的最小费用。 $f(i)=\\min\\limits_{j&lt;i}\\{f(j)+(t_i-t_j)x_i-s_i+s_j\\}+c_i$ 剩下的套路不用说了吧。 特别行动队本来期待$APIO$的题能有什么东西的，结果还是没意思。。。 令$s_i=\\sum\\limits_{j=1}^ix_j$ $f(i)=\\max\\limits_{j&lt;i}\\{f(j)+a(s_i-s_j)^2+b(s_i-s_j)+c\\}$ 唯一不同的是取$\\max$正好反过来，要维护一个斜率递减的点集。 锯木厂选址令$D_i=\\sum\\limits_{j&lt;i}d_i,t_i=\\sum\\limits_{j\\le i}w_j,s_i=\\sum\\limits_{j\\le i}w_jD_j$ 设$g(i)$为前$i$棵树，只有$i$有一个锯木厂的花费，$f(i)$为前$i$棵树已经有两个锯木厂，且$i$有一个锯木厂的最小花费。 $g(i)=D_it_i-s_i$ $f(i)=\\min\\limits_{j&lt;i}\\{g(j)+D_i(t_i-t_j)-s_i+s_j\\}$ 最后答案在$f(i)+D_{n+1}(t_n-t_i)-s_n+s_i$里取$\\min$。 序列分割题解 矩阵树定理内容详情请咨询组合数学食用笔记 水题小Z的房间板子题。唯一要注意的是柱子不能放进Kirchhoff矩阵中。 黑暗前的幻想乡枚举集合$S$表示哪些公司没有修路容斥。对剩下的公司矩阵树定理求方案数。 即$ans=\\sum\\limits_{S}(-1)^{|S|}calc(S)$ 复杂度$O((n-1)^32^{n-1})$ 重建题解 最小生成树计数题解 线性基定义对一个数的集合$S$，其线性基就是由最少的数（最小性）构成的集合$B$，满足从$S$中任取一些数异或起来（不包括$0$）得到的值域，与$B$中任取一些数异或起来得到的值域相同。 性质1.对于任意的$i$，$B$中最多只有一个元素二进制下最高位的$1$为第$i$位（下记该元素为$B_i$） 2.取$B$中任意元素异或起来结果不为$0$ 3.对于任意$B$的元素$x$，不存在取$B$中若干其他元素异或起来等于$x$ 4.若$S$的值域上界为$2^n-1$，则$B$最多有$n$个数 构造插入考虑插入元素$x$的影响：根据性质$3$，如果当前线性基能异或出$x$，就不管$x$；否则添加某个数使线性基能异或出$x$。 怎么得到$x$呢？根据性质$1$，异或$B_i$（如果$B_i$有值）对$i$以上的位没有影响。从高到低考虑，如果$x$第$i$位上为$1$，就让$x$异或上$B_i$。如果$B_i$不存在就$gg$了，这时我们需要把$x$放到$B_i$上。 插入复杂度$O(\\log V)$，$V$为值域。 插入代码： long long b[61]; void insert(long long x){ for(register int i=60;~i;--i){ if(x&gt;&gt;i&amp;1){ if(!b[i]){b[i]=x;return;} x^=b[i]; } } } 合并把$S_1$和$S_2$的线性基合并，得到的新线性基对应的集合$S=S_1\\cup S_2$。 显然直接把$S_1$插到$S_2$里就行，复杂度$O(\\log^2V)$。 应用判断是否能从S中取若干数异或得到x把$x$插入线性基看看是否插入成功就行了。 子集异或最大值从高到低贪心，若当前答案第$i$位本来就有$1$，不用管；否则判断与$B_i$是否能异或出第$i$位的$1$（其实就是看看$B_i$是否存在），能就异或上$B_i$。 当然不用写这么麻烦，直接if((ans^b[i])&gt;ans)ans^=b[i];就行。 子集异或最小值就是$B$的最小值。 子集异或第k小说实话还没有完全明白。。。 首先要魔改（其实是正规化）构造方式： 重新定义$B_i$为满足原来条件的最小值。 还是考虑插入$x$的影响，若$x$在第$i$位上$gg$了： 对于低位，$x$可以通过异或它们变得更小，从而使$B_i$最小 对于高位，它们异或$x$可能会变得更小 因此扫一遍更新即可。 代码： void insert(long long x){ for(register int i=60;~i;--i){ if(x&gt;&gt;i&amp;1){ if(!b[i]){ for(register int j=i-1;~j;--j)if(x&gt;&gt;j&amp;1)x^=b[j]; for(register int j=i+1;j&lt;=60;++j)if((b[j]^x)&lt;b[j])b[j]^=x; b[i]=x; return; } x^=b[i]; } } } 然后把有值的$B_i$提出来排好，得到的数组记为$A$。把$k$二进制拆分，答案就是为$1$的位的$A$的异或和。 由于不能选空集，会有一些细节自己研究去吧我就懒得说了 水题元素按魔法值从大到小排序，依次插入线性基，如果成功插入就选。 彩灯翻译一下，若干个$n$位二进制数，取任意个异或起来有多少种不同的结果？ 因为这和在线性基取若干数是等价的，若线性基有$cnt$个数，还可以取空集，答案就是$2^{cnt}$。 幸运数字基于线性基的合并用数据结构维护线性基。 可以倍增，也可以点分治，题解区五花八门的。 记$M(A,B)$为$A,B$合并得到的新线性基，显然有性质$M(M(A,B),C)=M(M(A,B),M(B,C))$。 也就是说合并有重叠性，可以$ST$表维护。于是我选择了树剖+$ST$表，$3$个$\\log$。不过合并一般跑不满所以能过。 最大XOR和路径题解第一篇讲的很清楚了。 装备购买第一道水题的实数版。 OI中的线性基一般都是指上面的异或线性基，这道题就是实数的线性基了。 考虑把异或拓展到实数运算上： 构造异或线性基的时候，其实是把每个数看作$n$维向量，对每一维考虑，若为$1$就异或上$B_i$来消掉这一位的$1$，不存在$B_i$就赋值为该数。 同理，对于实数线性基，把一组数也看作$n$维向量，对有值的位，若$B_i$存在，就消掉该位；否则赋值$B_i$为该实数集。 怎么消啊？类似于高斯消元搞一搞就行了。 2-SAT都9102年了我还在学图论基础算法 定义有一堆变量$a$，现在要给它们赋值为$0$或$1$。 $k-SAT$问题就是有若干条限制$b$，每条形如$(a_{b_1}=0/1)\\lor (a_{b_2}=0/1)\\lor \\dots \\lor (a_{b_k}=0/1)$，问是否存在一种赋值方案满足这些限制。 $k-SAT$是$NP$完全问题，但当$k=2$时可做。 复读一遍$2-SAT$的定义：$2-SAT$即有若干条限制$b$，每条形如$(a_{b_1}=0/1)\\lor (a_{b_2}=0/1)$，问是否存在一种赋值方案满足这些限制。 判定把$a_i$拆成两个点$a_{i,0}$和$a_{i,1}$，分别表示$a_i=0/1$。 用有向边$a_{i,x}\\rightarrow a_{j,y}$表示$a_i=x\\Rightarrow a_j=y$。 对于一条限制，比如是$a_3=0\\lor a_4=0$，就要将$a_{3,1}$向$a_{4,0}$连边，$a_{4,1}$向$a_{3,0}$连边。 当从$a_{i,0}$沿着边走能走到$a_{i,1}$，且$a_{i,1}$能走到$a_{i,0}$，即$a_i=0\\Leftrightarrow a_i=1$，矛盾，就不存在合法方案。 于是大力缩点判断$a_{i,0}$与$a_{i,1}$是否在同一强连通分量里即可解决。 输出方案枚举每个变量赋值为几。 为了造成尽可能少的影响，直接选$a_{i,0}$和$a_{i,1}$中拓扑序较大的；或者说我们的目的是选拓扑序较大的一些点，就能保证构造出合法方案。 而$Tarjan$缩完点给强连通分量的编号就是逆序拓扑序，所以不用再拓扑排序了。 如果要求按字典序输出，没啥好方法，枚举每个变量选哪个判定是否可行，复杂度$O(nm)$。 代码板子 板子改一改就A了 #define px(x) putchar(x) #define ps px(&#39; &#39;) #define pn px(&#39;\\n&#39;) struct edge{int pre,to;}e[maxn&lt;&lt;1]; int h[maxn],seg[maxn],low[maxn],sta[maxn],id[maxn],cnt,num,all,top; bool vis[maxn]; inline void add(int from,int to){e[++num]=(edge){h[from],to},h[from]=num;} void TJ(int node){ vis[sta[++top]=node]=1; seg[node]=low[node]=++cnt; for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(!seg[x])TJ(x),low[node]=min(low[node],low[x]); else if(vis[x])low[node]=min(low[node],seg[x]); } if(seg[node]==low[node]){ id[node]=++all,vis[node]=0; while(sta[top]!=node)id[sta[top]]=all,vis[sta[top--]]=0; --top; } } int main(){ int n=read(),m=read(); while(m--){ int a=read(),x=read(),b=read(),y=read(); add(a+(x^1)*n,b+y*n),add(b+(y^1)*n,a+x*n); } for(register int i=1;i&lt;=n&lt;&lt;1;++i)if(!seg[i])TJ(i); for(register int i=1;i&lt;=n;++i)if(id[i]==id[i+n]){puts(&quot;IMPOSSIBLE&quot;);return 0;} puts(&quot;POSSIBLE&quot;); for(register int i=1;i&lt;=n;++i)px(48+(id[i+n]&lt;id[i])),ps; pn; } 水题Flags最小距离最大显然要二分。 二分判定显然是$2-SAT$。记$a_{i,0/1}$分别为$x_i$和$y_i$。如果存在$a_{i,x}-a_{j,y}&lt;mid$且$a_{i,x}\\ge a_{j,y}$，则两者不能同时选，连边$a_{i,x}\\rightarrow a_{j,y\\ xor\\ 1},a_{j,y}\\rightarrow a_{i,x\\ xor 1}$。 复杂度爆炸显然要线段树优化建图。 有个坑点是直接连区间会把$a_{i,0}$和$a_{i,1}$连出来环，要把区间里的$a_{i,0}$抠出来。显然不好写。 游戏如果没有x就是裸的$2-SAT$。对于限制$(i,x,j,y)$，连边$a_{i,x}\\rightarrow a_{j,y},a_{j,y\\ xor\\ 1}\\rightarrow a_{i,x\\ xor\\ 1}$。 $3^d$爆搜每个x的状态时间爆炸。发现x为a,b的时候已经把c的情况包含进去了，$2^d$爆搜即可。 Radio Stations题解 差分约束都9102年了我还在学图论基础算法（复读） 而且后天就0202年了 板子有$n$个变量$a_{1\\dots n}$，$m$个限制形如$a_i-a_j\\le c$。 这个长得很像最短路里的三角形不等式：$a_i-a_j\\le c\\rightarrow a_j+c\\ge a_i\\rightarrow dis_j+c\\ge dis_i$。 把$j$向$i$连一条权值为$c$的边，建一个超级源向每个点连一条$0$边。跑一遍最短路，存在负环就无解。 方案就是$a_i=dis_i$。 板子代码只判断可行性，直接广搜$spfa$会$T$，需要$dfs$版$spfa$。 struct edge{int pre,to,l;}e[maxn&lt;&lt;1]; int dis[maxn],cnt[maxn],h[maxn],num; bool vis[maxn]; queue&lt;int&gt;q; inline void add(int from,int to,int l){e[++num]=(edge){h[from],to,l},h[from]=num;} void dfs(int node){ vis[node]=1; for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(dis[x]&gt;dis[node]+e[i].l){ if(vis[x]){puts(&quot;No&quot;);exit(0);} dis[x]=dis[node]+e[i].l,dfs(x); } } vis[node]=0; } int main(){ int n=read(),m=read(); for(register int i=1;i&lt;=n;++i)add(0,i,0); while(m--){ int s=read(),a=read(),b=read(); if(s==1)add(b,a,read()); else if(s==2)add(a,b,-read()); else add(b,a,0); } memset(dis,0x3f,sizeof dis),dis[0]=0; dfs(0); puts(&quot;Yes&quot;); } 水题糖果本来是并查集+拓扑排序水题的，不过差分约束也能骗分搞。 连边关系显然，不过为了计算糖果数要按最长路的连。因为每个人都要有糖果，源点向每个点连的边权为$1$。 答案就是$dis$之和。 然后这个题卡$spfa$，第$5$个点要双端队列优化，第$6$个测试点源点向$1\\sim n$要逆序连边。 倍杀测量者任意情况都有人女装$\\rightarrow$所有人都不女装不合法。 显然可以二分答案。 对两种条件，分别用$a_i\\ge (k-T)a_j$和$a_i\\ge \\frac{1}{k+T}a_j$表示。 对已经确定的人，用$a_i\\ge 1\\times x$且$1\\times x\\ge a_i$表示。 取对数跑最长路，有正环就可以。 布局很容易转成最短路来做，先判一下负环。 如果合法，假设答案为$ans$，显然$ans$为满足$dis_n-dis_1\\ge ans$的最大值。实际上这就是从$n$到$1$连了一条长为$-ans$的边，且不会产生负环。 以$1$为起点跑一遍最短路，$dis_n$即为答案。 莫队其实我是会莫队的，不过还没有系统地学过莫队全家桶，在这写一写。 树上莫队搞出来树的括号序：$dfs$整棵树。对于点$i$，进入时加入$i$记为$st_i$，回溯时再加进去记为$en_i$。 然后把询问$(x,y)$分两种情况扔到括号序上： $lca(x,y)=x$：$[st_x,st_y]$（$lca(x,y)=y$一样） $\\operatorname{otherwise}$：$[en_x,st_y]$（假设$en_x&lt;st_y$）此时$lca$没有算上，要额外计算。 在括号序上跑莫队。出现过奇数次的点算上贡献，偶数次不算。 带修莫队按左端点的块为第一关键字、右端点的块为第二关键字、时间为第三关键字排序，块大小设置为$n^{\\frac{2}{3}}$，维护左右端点和时间三个指针即可，复杂度$O(n^{\\frac{5}{3}})$。 回滚莫队如果莫队的添加容易，删除麻烦（或者反过来），可以考虑回滚莫队。 排序还是一样的。把左端点都在同一个块（假设块的区间为$[L,R]$）里的一块处理，维护一个右指针$pr$，初始值为$R$。对于询问$[l,r]$： 若$l$与$r$在同一个块里，暴力。 否则，移动$pr$到$r$，加上$[pr+1,r]$的贡献（因为同一个块里的$r$是单增的，所以只需要添加操作）。然后暴力加上$[l,R]$的贡献，统计答案。再把$[l,R]$的贡献清掉，还原成$[R+1,pr]$的样子。 处理完一个块后，要把残余的信息清空。 取块大小为$\\frac{n}{\\sqrt{m}}$，复杂度还是$O(n\\sqrt{m})$的，而且只需要考虑添加操作，在维护最大值的时候有奇效。 只考虑删除的同理。 二次离线莫队&amp;在线莫队不可能学的，这辈子都不可能学的。 板子+水题糖果公园树上+带修莫队板子。 long long ans[maxn],sum[maxn],all; int be[maxn&lt;&lt;1],st[maxn],en[maxn],f[maxn&lt;&lt;1],tax[maxn],a[maxn],v[maxn],c[maxn],h[maxn],siz[maxn],son[maxn],top[maxn],deep[maxn],fa[maxn],num,cnt; bool vis[maxn]; struct query{ int l,r,id,t,lc; bool operator &lt; (const query &amp;x)const{ if(be[l]!=be[x.l])return l&lt;x.l; else if(be[r]!=be[x.r])return r&lt;x.r; return t&lt;x.t; } }q[maxn]; struct modify{int x,y;}ch[maxn]; struct edge{int pre,to;}e[maxn&lt;&lt;1]; inline void add(int from,int to){e[++num]=(edge){h[from],to},h[from]=num;} void dfs1(int node=1){ f[st[node]=++cnt]=node,siz[node]=1; for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(siz[x])continue; fa[x]=node,deep[x]=deep[node]+1; dfs1(x),siz[node]+=siz[x]; if(siz[x]&gt;siz[son[node]])son[node]=x; } f[en[node]=++cnt]=node; } void dfs2(int node=1){ siz[node]=0; if(!son[node])return; top[son[node]]=top[node],dfs2(son[node]); for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(siz[x])top[x]=x,dfs2(x); } } inline int lca(int x,int y){ while(top[x]!=top[y])deep[top[x]]&lt;deep[top[y]]?y=fa[top[y]]:x=fa[top[x]]; return deep[x]&lt;deep[y]?x:y; } inline void add(int x){all+=1ll*v[x]*c[++tax[x]];} inline void del(int x){all-=1ll*v[x]*c[tax[x]--];} inline void modify(int x){ if(vis[x])del(a[x]); else add(a[x]); vis[x]^=1; } int main(){ int n=read(),m=read(),t=read(),x,y,last=0,ql=0; for(register int i=1;i&lt;=m;++i)v[i]=read(); for(register int i=1;i&lt;=n;++i)sum[i]=sum[i-1]+(c[i]=read()); for(register int i=1;i&lt;n;++i)x=read(),y=read(),add(x,y),add(y,x); dfs1(),dfs2(); for(register int i=1;i&lt;=n;++i)a[i]=read(); for(register int i=1;i&lt;=t;++i){ bool type=read(); if(!type)ch[++last].x=read(),ch[last].y=read(); else { x=read(),y=read(),q[++ql].id=ql,q[ql].t=last; int l=lca(x,y); if(st[x]&gt;st[y])swap(x,y); if(l==x)q[ql].l=st[x],q[ql].r=st[y]; else q[ql].l=en[x],q[ql].r=st[y],q[ql].lc=l; } } int sq=pow(cnt,2.0/3),len=cnt/sq+(bool)(cnt%sq),l=1,r=0,w=0; for(register int i=1;i&lt;=len;++i) for(register int j=(i-1)*sq+1,r=min(j+sq-1,cnt);j&lt;=r;++j) be[j]=i; sort(q+1,q+1+ql); for(register int i=1;i&lt;=ql;++i){ while(l&lt;q[i].l)modify(f[l++]); while(l&gt;q[i].l)modify(f[--l]); while(r&gt;q[i].r)modify(f[r--]); while(r&lt;q[i].r)modify(f[++r]); while(w&lt;q[i].t){ x=ch[++w].x,y=ch[w].y; if(vis[x])del(a[x]),add(y); swap(a[x],ch[w].y); } while(w&gt;q[i].t){ x=ch[w].x,y=ch[w].y; if(vis[x])del(a[x]),add(y); swap(a[x],ch[w--].y); } if(q[i].lc)add(a[q[i].lc]); ans[q[i].id]=all; if(q[i].lc)del(a[q[i].lc]); } for(register int i=1;i&lt;=ql;++i)printf(&quot;%lld\\n&quot;,ans[i]); } 歴史の研究回滚莫队板子。 long long ans[maxn],all; int be[maxn],dis[maxn],a[maxn],tax[maxn]; struct query{ int l,r,id; bool operator &lt; (const query &amp;x)const{ if(be[l]!=be[x.l])return l&lt;x.l; return r&lt;x.r; } }q[maxn]; inline void add(int x){++tax[x],all=max(all,1ll*tax[x]*dis[x]);} int main(){ int n=read(),m=read(),sq=n/sqrt(m),num=n/sq+(bool)(n%sq); for(register int i=1;i&lt;=num;++i) for(register int j=(i-1)*sq+1,r=min(n,j+sq-1);j&lt;=r;++j) be[j]=i,dis[j]=a[j]=read(); sort(dis+1,dis+1+n); int len=unique(dis+1,dis+1+n)-dis-1,b=0,r; for(register int i=1;i&lt;=n;++i)a[i]=lower_bound(dis+1,dis+1+len,a[i])-dis; for(register int i=1;i&lt;=m;++i)q[i].id=i,q[i].l=read(),q[i].r=read(); sort(q+1,q+1+m); for(register int i=1;i&lt;=m;++i){ if(be[q[i].l]!=b)b=be[q[i].l],all=0,memset(tax,0,sizeof tax),r=b*sq; if(be[q[i].l]==be[q[i].r]){ for(register int j=q[i].l;j&lt;=q[i].r;++j)add(a[j]); ans[q[i].id]=all,all=0; for(register int j=q[i].l;j&lt;=q[i].r;++j)tax[a[j]]=0; continue; } while(r&lt;q[i].r)add(a[++r]); long long rec=all; for(register int j=b*sq;j&gt;=q[i].l;--j)add(a[j]); ans[q[i].id]=all,all=rec; for(register int j=b*sq;j&gt;=q[i].l;--j)--tax[a[j]]; } for(register int i=1;i&lt;=m;++i)printf(&quot;%lld\\n&quot;,ans[i]); } 【模板】回滚莫队洛谷有回滚莫队板子辣！ 维护两个桶$tl[i],tr[i]$，分别表示权值$i$出现的最靠左/右的位置。 左端点移动的时候记录被修改的桶原来的权值，没了。 ants只加不删的回滚莫队。 暴力的做法是可撤销并查集，不过带个$\\log$。 优美的做法是链表。对链表每一块元素维护左/右端点。如果新加的点两边有元素就合并起来，删除直接断开更新端点。这样就没有$\\log$了。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ctz45562.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"字符串","slug":"字符串","permalink":"https://ctz45562.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"图论","slug":"图论","permalink":"https://ctz45562.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"2-SAT","slug":"2-SAT","permalink":"https://ctz45562.github.io/tags/2-SAT/"},{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"莫队","slug":"莫队","permalink":"https://ctz45562.github.io/tags/%E8%8E%AB%E9%98%9F/"},{"name":"矩阵树定理","slug":"矩阵树定理","permalink":"https://ctz45562.github.io/tags/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/"},{"name":"斜率优化","slug":"斜率优化","permalink":"https://ctz45562.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"},{"name":"kruskal重构树","slug":"kruskal重构树","permalink":"https://ctz45562.github.io/tags/kruskal%E9%87%8D%E6%9E%84%E6%A0%91/"},{"name":"manacher","slug":"manacher","permalink":"https://ctz45562.github.io/tags/manacher/"},{"name":"线性基","slug":"线性基","permalink":"https://ctz45562.github.io/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"},{"name":"差分约束","slug":"差分约束","permalink":"https://ctz45562.github.io/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"}]},{"title":"Codeforces961G Partitions","slug":"Codeforces961G-Partitions","date":"2019-12-11T02:02:48.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/12/11/Codeforces961G-Partitions/","link":"","permalink":"https://ctz45562.github.io/2019/12/11/Codeforces961G-Partitions/","excerpt":"传送门 「有生之年」系列节目之——跟活的成爷一起上数学课","text":"传送门 「有生之年」系列节目之——跟活的成爷一起上数学课 考虑每个物品的贡献。枚举该物品在所在的集合大小，易得答案为： $\\sum\\limits_{s=1}^nw_s\\sum\\limits_{i=1}^niC_{n-1}^{i-1}\\begin{Bmatrix}n-i\\\\k-1\\end{Bmatrix}$ 求出单列第二类斯特林数就行了。再考察一下模数。 $10^9+7$，好的不是$NTT$模数呢而且我也不会求单列第二类斯特林数 于是开始抄题解推式子，暴力用第二类斯特林数通项公式展开： $\\sum\\limits_{i=1}^niC_{n-1}^{i-1}\\begin{Bmatrix}n-i\\\\k-1\\end{Bmatrix}$ $=\\sum\\limits_{j=0}^{k-1}\\sum\\limits_{i=1}^niC_{n-1}^{i-1}\\dfrac{(-1)^j(k-1-j)^{n-i}}{j!(k-1-j)!}$ $=\\sum\\limits_{j=0}^{k-1}\\dfrac{(-1)^j}{j!(k-1-j)!}\\sum\\limits_{i=1}^n(i-1+1)C_{n-1}^{i-1}(k-1-j)^{n-i}$ $=\\sum\\limits_{j=0}^{k-1}\\dfrac{(-1)^j}{j!(k-1-j)!}\\left(\\sum\\limits_{i=1}^n(i-1)C_{n-1}^{i-1}(k-1-j)^{n-i}+\\sum\\limits_{i=1}^nC_{n-1}^{i-1}(k-1-j)^{n-i}\\right)$ 根据$mC_n^m=nC_{n-1}^{m-1}$和二项式定理，有： $=\\sum\\limits_{j=0}^{k-1}\\dfrac{(-1)^j}{j!(k-1-j)!}\\left((n-1)\\sum\\limits_{i=1}^nC_{n-2}^{i-2}(k-1-j)^{n-i}+(k-j)^{n-1}\\right)$ $=\\sum\\limits_{j=0}^{k-1}\\dfrac{(-1)^j}{j!(k-1-j)!}((n-1)(k-j)^{n-2}+(k-j)^{n-1})$ $=\\sum\\limits_{j=0}^{k-1}\\dfrac{(-1)^j}{j!(k-1-j)!}(n-1+k-j)(k-j)^{n-2}$ 就能$O(k\\log n)$做了。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 200005 #define inf 0x3f3f3f3f const int mod = 1e9 + 7; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int inv[maxn]; inline int quickpow(int x,int y=mod-2){ if(y&lt;0)return quickpow(quickpow(x,-y)); int ans=1; while(y){ if(y&amp;1)ans=1ll*ans*x%mod; x=1ll*x*x%mod,y&gt;&gt;=1; } return ans; } int main(){ int n=read(),k=read(),sum=0,ans=0,fac=1; for(register int i=1;i&lt;=n;++i)(sum+=read())%=mod,fac=1ll*fac*i%mod; inv[n]=quickpow(fac); for(register int i=n-1;~i;--i)inv[i]=1ll*inv[i+1]*(i+1)%mod; for(register int i=0;i&lt;k;++i)(ans+=(i&amp;1?-1ll:1ll)*inv[i]*inv[k-i-1]%mod*(n-1+k-i)%mod*quickpow(k-i,n-2)%mod)%=mod; printf(&quot;%d\\n&quot;,(1ll*sum*ans%mod+mod)%mod); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"组合数学","slug":"组合数学","permalink":"https://ctz45562.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"斯特林数","slug":"斯特林数","permalink":"https://ctz45562.github.io/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"}]},{"title":"洛谷 P4491 [HAOI2018]染色","slug":"洛谷-P4491-HAOI2018-染色","date":"2019-12-10T01:54:51.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/12/10/洛谷-P4491-HAOI2018-染色/","link":"","permalink":"https://ctz45562.github.io/2019/12/10/%E6%B4%9B%E8%B0%B7-P4491-HAOI2018-%E6%9F%93%E8%89%B2/","excerpt":"传送门 二项式反演套路题啊。。。","text":"传送门 二项式反演套路题啊。。。 看到“恰好”想“至少”。设$f(i)$为恰好$i$种颜色出现次数为$S$，$g(i)$为至少$i$种颜色出现次数为$S$。 $g(i)$很好算。$C_m^i$钦定$i$种颜色，$\\dfrac{A_n^{iS}}{(S!)^i}$钦定位置和顺序，剩下$n-iS$个位置和$m-i$种颜色随便填，为$(m-i)^{n-iS}$。 即$g(i)=\\dfrac{C_m^iA_n^{iS}(m-i)^{n-iS}}{(S!)^i}$ 对于一种恰好$i$种颜色出现次数为$S$的方案，它会在$g(j)$中被计算$C_j^i$次。 即$g(i)=\\sum\\limits_{j=i}^mC_j^if(j)$ 二项式反演，$f(i)=\\sum\\limits_{j=i}^m(-1)^{j-i}C_j^ig(j)$ 把$g(j)$带进去，组合数展开，化简一下，得到： $f(i)=\\dfrac{n!m!}{i!}\\sum\\limits_{j=i}^m\\dfrac{(-1)^{j-i}(m-j)^{n-jS}}{(j-i)!(n-jS)!(m-j)!(S!)^j}$ 这个式子的$j$从$i$开始，不太好看。统一把$j$换成$m-j$，再分个类： $f(i)=\\dfrac{n!m!}{i!}\\sum\\limits_{j=0}^{m-i}\\dfrac{(-1)^{m-i-j}}{(m-i-j)!}\\times \\dfrac{j^{n-(m-j)S}}{[n-(m-j)S]!j!(S!)^{m-j}}$ 这显然是个卷积的形式。令多项式$F_i=\\dfrac{(-1)^i}{i!},G_i=\\dfrac{i^{n-(m-i)S}}{[n-(m-i)S]!i!(S!)^{m-i}}$，$NTT$卷起来。 答案就是$n!m!\\sum\\limits_{i=0}^m\\dfrac{W_i\\times (F*G)_{m-i}}{i!}$ 复杂度$O(n+m\\log m)$。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 500005 #define inf 0x3f3f3f3f const int mod = 1004535809; const int g = 3; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } inline int quickpow(int x,int y=mod-2){ int ans=1; while(y){ if(y&amp;1)ans=1ll*ans*x%mod; x=1ll*x*x%mod,y&gt;&gt;=1; } return ans; } const int ig = quickpow(g); int fac[10000005]={1},inv[10000005],rev[maxn],F[maxn],G[maxn]; inline int mix(int x,int y){return x+y&gt;=mod?x+y-mod:x+y;} void NTT(int *f,int n,bool type){ static int invn = quickpow(n); for(register int i=0;i&lt;n;++i)if(i&lt;rev[i])swap(f[i],f[rev[i]]); for(register int p=2;p&lt;=n;p&lt;&lt;=1){ int len=p&gt;&gt;1,o=quickpow(type?ig:g,(mod-1)/p); for(register int i=0;i&lt;n;i+=p){ int gen=1,cop; for(register int j=i;j&lt;i+len;++j){ cop=1ll*f[j+len]*gen%mod; f[j+len]=mix(f[j],mod-cop),f[j]=mix(f[j],cop),gen=1ll*gen*o%mod; } } } if(type)for(register int i=0;i&lt;n;++i)f[i]=1ll*f[i]*invn%mod; } void init(int n){ for(register int i=1;i&lt;=n;++i)fac[i]=1ll*fac[i-1]*i%mod; inv[n]=quickpow(fac[n]); for(register int i=n-1;~i;--i)inv[i]=1ll*inv[i+1]*(i+1)%mod; } int main(){ int n=read(),m=read(),s=read(),lim=1,ans=0; init(max(n,max(m,s))); while(lim&lt;=m&lt;&lt;1)lim&lt;&lt;=1; for(register int i=1;i&lt;lim;++i)rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|(i&amp;1?lim&gt;&gt;1:0); for(register int i=0;i&lt;=m;++i){ F[i]=i&amp;1?mod-inv[i]:inv[i]; if(n&gt;=(m-i)*s)G[i]=1ll*quickpow(i,n-(m-i)*s)*inv[n-(m-i)*s]%mod*inv[i]%mod*quickpow(inv[s],m-i)%mod; } NTT(F,lim,0),NTT(G,lim,0); for(register int i=0;i&lt;lim;++i)F[i]=1ll*F[i]*G[i]%mod; NTT(F,lim,1); for(register int i=0;i&lt;=m;++i){ int w=read(); ans=mix(ans,1ll*w*F[m-i]%mod*inv[i]%mod); } printf(&quot;%d\\n&quot;,1ll*ans*fac[m]%mod*fac[n]%mod); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"容斥","slug":"容斥","permalink":"https://ctz45562.github.io/tags/%E5%AE%B9%E6%96%A5/"},{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"组合数学","slug":"组合数学","permalink":"https://ctz45562.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"FFT/NTT","slug":"FFT-NTT","permalink":"https://ctz45562.github.io/tags/FFT-NTT/"},{"name":"多项式","slug":"多项式","permalink":"https://ctz45562.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"name":"二项式反演","slug":"二项式反演","permalink":"https://ctz45562.github.io/tags/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/"}]},{"title":"洛谷 P3723 [AH2017/HNOI2017]礼物","slug":"洛谷-P3723-AH2017-HNOI2017-礼物","date":"2019-12-09T00:30:55.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/12/09/洛谷-P3723-AH2017-HNOI2017-礼物/","link":"","permalink":"https://ctz45562.github.io/2019/12/09/%E6%B4%9B%E8%B0%B7-P3723-AH2017-HNOI2017-%E7%A4%BC%E7%89%A9/","excerpt":"传送门 （摸肚皮）真的真的真的真的扯不动了。","text":"传送门 （摸肚皮）真的真的真的真的扯不动了。 答案长这样：$\\sum\\limits(x-y+c)^2$ 拆一下式子：$\\sum\\limits x^2-2xy+y^2+c^2+2cx-2cy$ 把带$c$的提出来：$nc^2+2c(\\sum x-\\sum y)$ 这不一二次函数吗？由于两个手环都可以加$c$，所以$c$实际上可以取任意整数。 考虑到精度问题，$c$为整数，而且$m\\le 100$，直接$O(m)$枚举求最小值都行。 然后带$c$的成了常数项，$x^2+y^2$也是常数项，就剩了个$-\\sum 2xy$ 把$y$序列翻转后面补$0$，$x$序列拷贝一份接到后面，这个式子就成了$-2\\sum\\limits_{j=0}^i x_jy_{i-j}$ $NTT$卷起来就完了。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 135005 #define inf 0x3f3f3f3f const int mod = 998244353; const int g = 3; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } inline int quickpow(int x,int y=mod-2){ int ans=1; while(y){ if(y&amp;1)ans=1ll*ans*x%mod; x=1ll*x*x%mod,y&gt;&gt;=1; } return ans; } const int ig = quickpow(g); int a[maxn],b[maxn],rev[maxn]; inline int mix(int x,int y){return x+y&gt;=mod?x+y-mod:x+y;} void NTT(int *f,int n,bool type){ for(register int i=0;i&lt;n;++i)if(i&lt;rev[i])swap(f[i],f[rev[i]]); for(register int p=2;p&lt;=n;p&lt;&lt;=1){ int len=p&gt;&gt;1,o=quickpow(type?ig:g,(mod-1)/p); for(register int i=0;i&lt;n;i+=p){ int gen=1,cop; for(register int j=i;j&lt;i+len;++j){ cop=1ll*f[j+len]*gen%mod; f[j+len]=mix(f[j],mod-cop),f[j]=mix(f[j],cop),gen=1ll*gen*o%mod; } } } if(type){ int inv=quickpow(n); for(register int i=0;i&lt;n;++i)a[i]=1ll*a[i]*inv%mod; } } int main(){ int n=read(),m=read(),sum=0,base=0,mi=inf,lim=1,ans=0; for(register int i=0;i&lt;n;++i)a[i]=a[i+n]=read(); for(register int i=0;i&lt;n;++i)b[i]=read(),sum+=a[i]-b[i],base+=a[i]*a[i]+b[i]*b[i]; sum&lt;&lt;=1,reverse(b,b+n); for(register int i=-m;i&lt;=m;++i)mi=min(mi,n*i*i+sum*i); base+=mi; while(lim&lt;=n&lt;&lt;1)lim&lt;&lt;=1; for(register int i=0;i&lt;lim;++i)rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|(i&amp;1?lim&gt;&gt;1:0); NTT(a,lim,0),NTT(b,lim,0); for(register int i=0;i&lt;lim;++i)a[i]=1ll*a[i]*b[i]%mod; NTT(a,lim,1); for(register int i=n-1;i&lt;(n&lt;&lt;1)-1;++i)ans=max(ans,a[i]&lt;&lt;1); printf(&quot;%d\\n&quot;,base-ans); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"FFT/NTT","slug":"FFT-NTT","permalink":"https://ctz45562.github.io/tags/FFT-NTT/"},{"name":"多项式","slug":"多项式","permalink":"https://ctz45562.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"name":"枚举","slug":"枚举","permalink":"https://ctz45562.github.io/tags/%E6%9E%9A%E4%B8%BE/"}]},{"title":"FFT/NTT学习笔记","slug":"FFT-NTT学习笔记","date":"2019-12-07T02:12:52.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/12/07/FFT-NTT学习笔记/","link":"","permalink":"https://ctz45562.github.io/2019/12/07/FFT-NTT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"大声大声！熟练熟练！ 又又不要打我","text":"大声大声！熟练熟练！ 又又不要打我 前言历经四个月终于开新算法了。 最近越来越懒了，而且抄袭来源讲的炒鸡详细就只放模板和水题了。 抄袭来源 https://www.luogu.com.cn/blog/command-block/fft-xue-xi-bi-jihttps://www.luogu.com.cn/blog/command-block/ntt-yu-duo-xiang-shi-quan-jia-tong# 板子FFT#define maxn 2100005 const double pi = acos(-1)*2; struct cp{ double x,y; cp(double a=0,double b=0){x=a,y=b;} cp operator + (const cp &amp;a){return cp(x+a.x,y+a.y);} cp operator - (const cp &amp;a){return cp(x-a.x,y-a.y);} cp operator * (const cp &amp;a){return cp(x*a.x-y*a.y,x*a.y+y*a.x);} }A[maxn],B[maxn]; int rev[maxn]; void FFT(cp *f,int n,bool type){ for(register int i=0;i&lt;n;++i)if(i&lt;rev[i])swap(f[i],f[rev[i]]); for(register int p=2;p&lt;=n;p&lt;&lt;=1){ int len=p&gt;&gt;1; cp o(cos(pi/p),type?-sin(pi/p):sin(pi/p)); for(register int i=0;i&lt;n;i+=p){ cp gen(1,0); for(register int j=i;j&lt;i+len;++j){ cp cop=f[j+len]*gen; f[j+len]=f[j]-cop,f[j]=f[j]+cop,gen=gen*o; } } } } int main(){ int n=read(),m=read(); for(register int i=0;i&lt;=n;++i)scanf(&quot;%lf&quot;,&amp;A[i].x); for(register int i=0;i&lt;=m;++i)scanf(&quot;%lf&quot;,&amp;B[i].x); m+=n,n=1; while(n&lt;=m)n&lt;&lt;=1; for(register int i=1;i&lt;n;++i)rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|(i&amp;1?n&gt;&gt;1:0); FFT(A,n,0),FFT(B,n,0);//dft for(register int i=0;i&lt;n;++i)A[i]=A[i]*B[i]; FFT(A,n,1);//idft for(register int i=0;i&lt;=m;++i)printf(&quot;%.4lf &quot;,A[i].x); } NTT#define maxn 2100005 const int mod = 998244353; const int g = 3; const int ig = 332748118; int rev[maxn],A[maxn],B[maxn]; inline int quickpow(int x,int y=mod-2){ int ans=1; while(y){ if(y&amp;1)ans=1ll*ans*x%mod; x=1ll*x*x%mod,y&gt;&gt;=1; } return ans; } inline int mix(int x,int y){return x+y&gt;=mod?x+y-mod:x+y;} void NTT(int *f,int n,bool type){ for(register int i=0;i&lt;n;++i)if(i&lt;rev[i])swap(f[i],f[rev[i]]); for(register int p=2;p&lt;=n;p&lt;&lt;=1){ int len=p&gt;&gt;1,o=quickpow(type?ig:g,(mod-1)/p); for(register int i=0;i&lt;n;i+=p){ int gen=1,cop; for(register int j=i;j&lt;i+len;++j){ cop=1ll*f[j+len]*gen%mod; f[j+len]=mix(f[j],mod-cop),f[j]=mix(f[j],cop),gen=1ll*gen*o%mod; } } } } int main(){ int n=read(),m=read(); for(register int i=0;i&lt;=n;++i)A[i]=read(); for(register int i=0;i&lt;=m;++i)B[i]=read(); m+=n,n=1; while(n&lt;=m)n&lt;&lt;=1; for(register int i=1;i&lt;n;++i)rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|(i&amp;1?n&gt;&gt;1:0); NTT(A,n,0),NTT(B,n,0);//dft for(register int i=0;i&lt;n;++i)A[i]=1ll*A[i]*B[i]%mod; NTT(A,n,1);//idft int inv=quickpow(n); for(register int i=0;i&lt;=m;++i)printf(&quot;%d &quot;,1ll*A[i]*inv%mod); } 水题力令$q_0=0$，前半部分就是$\\sum\\limits_{i=0}^{n-1}\\dfrac{q_i}{(n-i)^2}$ 设$f(i)=q_i,g(i)=\\dfrac{1}{(i+1)^2}$，求的成了$\\sum\\limits_{i=0}^{n-1}f(i)g(n-i-1)$，$FFT$就没了。 后半部分就是翻过来卷。 差分与前缀和通过手玩会发现$k$阶前缀和答案为$\\sum\\limits_{j=1}^iC_{i-j+k-1}^{i-j}a_j$，$k$阶差分答案为$\\sum\\limits_{j=1}^i(-1)^{i-j}C_k^{i-j}a_j$ 显然是个卷积的形式。而这个组合数可以递推： 对于$C_{i+k-1}^i$，$C_{i+k-1}^0=1,C_{i+k+1}^{i}=C_{i+k}^{i-1}\\times \\dfrac{k+i-1}{i}$ 对于$C_k^i$，$C_k^0=1,C_k^i=C_k^{i-1}\\times\\dfrac{k-i+1}{i}$ 这样$k$就能取模了。然后就是$NTT$板子。 序列统计涨姿势了。其实这是一道多项式快速幂 考虑一个朴素的$DP$：设$f(i,j)$为生成了$i$个数乘积为$j$的方案数。任意钦定两个集合的大小拼出来$i$，有$f(i,j)=\\sum\\limits_{ab\\equiv j\\pmod m}f(k,a)\\times f(i-k,b)(k&lt;i)$。注意只能选一个$k$转移否则就重复了。 用原根转乘法为加法。令$g$为模$m$意义下的原根，$g^A\\equiv a,g^B\\equiv b\\pmod m$。 方程就成了$f(i,j)=\\sum\\limits_{a+b\\equiv j\\pmod {\\phi(m)}}f(k,a)\\times f(i-k,b)(k&lt;i)$ 我们发现这其实就是$f$自乘了$n$次，多项式快速幂即可。 没学过多项式快速幂咋办？有另一种理解的方法： 把$n$二进制拆分，最终乘出来的多项式就是$\\prod\\limits_{i}f(2^i)$。 根据上文能得到$f(i\\times 2)=\\sum\\limits_{ab\\equiv j\\pmod m}f(i,a)\\times f(i,b)$。 和快速幂一样（其实这就是快速幂）从$f(1)$往上自乘就能得到所有的$f(2^i)$。 要注意的是$f$自乘后会得到一个$2(m-1)$项的多项式，因为是在模$m-1$意义下转移的，要把后$m-1$项加到前$m-1$项上。 复杂度$O(m\\log^2 n)$。 残缺的字符串$FFT/NTT$经典应用。 先将模式串翻转，后面补通配符。 把通配符看作$0$。考虑两个字符$a,b$相等的条件： 两者相等，$a-b=0$ 其中一个是通配符，$ab=0$ 那么以$i$为结尾的子串能匹配的条件就是$\\sum\\limits_{j=0}^i(a_j-b_{i-j})^2a_jb_{i-j}=0$。带平方是为了防止正负抵消。 拆一下式子就是$\\sum\\limits_{j=0}^ia_j^3b_{i-j}-2\\sum\\limits_{j=0}^ia_j^2b_{i-j}^2+\\sum\\limits_{j=0}^ia_jb_{i-j}^3$ $FFT/NTT$卷三遍即可。 礼物题解 万径人踪灭枚举对称轴，算出有多少对字符关于该轴对称。 因为字符集只有$a,b$，可以用$\\sum\\limits_{i=0}^j(a_j-a_{i-j})^2$表示不对称的字符对，用总的减去不对称的就是对称的了。 式子拆开，两个平方一个卷积，上$NTT$。 假设算出的字符对有$cnt$个，若该轴为字符，这个字符也可以算进子序列里，有$2^{cnt+1}-1$个子序列关于该轴对称；否则为$2^{cnt}$。 最后第二个条件就减去回文子串数就行。 顺便一提，我又双叒叕$hash$被卡被迫默写$SA$了。 DNA当年用$SAM$写的，但不得不说$FFT/NTT$在字符串匹配上有奇效。 $A,G,C,T$分开算。以$A$为例，$A$看作$1$，不是$A$的看作$0$，贡献为$\\sum\\limits_{j=0}^i(s_j-s_{i-j})^2$。 四个贡献加起来不超过$3$的就是合法的。 染色题解 求和大力推式子： $\\sum\\limits_{i=0}^n\\sum\\limits_{j=0}^i\\begin{Bmatrix}i\\\\j\\end{Bmatrix}2^jj!$ $=\\sum\\limits_{j=0}^n2^jj!\\sum\\limits_{i=0}^n\\begin{Bmatrix}i\\\\j\\end{Bmatrix}$ $=\\sum\\limits_{j=0}^n2^jj!\\sum\\limits_{i=0}^n\\sum\\limits_{k=0}^j\\dfrac{(-1)^k}{k!}\\dfrac{(j-k)^i}{(j-k)!}$ $=\\sum\\limits_{j=0}^n2^jj!\\sum\\limits_{k=0}^j\\dfrac{(-1)^k}{k!}\\dfrac{\\sum\\limits_{i=0}^n(j-k)^i}{(j-k)!}$ 观察一下$\\sum\\limits_{i=0}^n(j-k)^i$，这不就一等比数列求和吗。到这里卷积已经很明显了吧。 还有种不用卷积$O(n)$的做法，看不透。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ctz45562.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"FFT/NTT","slug":"FFT-NTT","permalink":"https://ctz45562.github.io/tags/FFT-NTT/"},{"name":"多项式","slug":"多项式","permalink":"https://ctz45562.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"}]},{"title":"洛谷 P5339 [TJOI2019]唱、跳、rap和篮球","slug":"洛谷-P5339-TJOI2019-唱、跳、rap和篮球","date":"2019-12-06T08:42:12.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/12/06/洛谷-P5339-TJOI2019-唱、跳、rap和篮球/","link":"","permalink":"https://ctz45562.github.io/2019/12/06/%E6%B4%9B%E8%B0%B7-P5339-TJOI2019-%E5%94%B1%E3%80%81%E8%B7%B3%E3%80%81rap%E5%92%8C%E7%AF%AE%E7%90%83/","excerpt":"传送门 那啥，其实。。。cxk是我（b站上的）最喜欢的偶像。","text":"传送门 那啥，其实。。。cxk是我（b站上的）最喜欢的偶像。 话说没有朴素的$O(n^3)$容斥+$DP$的题解诶。。。 一脸套路容斥。枚举有$i$个不合法组，容斥系数$(-1)^i$，$C_{n-3i}^i$选位置，剩下了$a-i$、$b-i$、$c-i$、$d-i$个人和$n-4i$个位置，要给他们任意安排位置。 直接组合数学不太会做的样子，咱也不会$NTT$和生成函数，考虑$DP$。 设$f(i,j)$为前$i$种爱好放了$j$个人的方案数。 枚举每种爱好有多少人，插进当前的队伍里：$f(i,j)=\\sum\\limits_{k=0}^{a/b/c/d}f(i-1,j-k)\\times C_j^{j-k}$ 套路容斥：$ans=\\sum\\limits_{i=0}^{\\min\\{\\frac{n}{4},a,b,c,d\\}}(-1)^iC_{n-3i}^if(4,n-4i)$。注意每个$i$的$a,b,c,d$都不一样，需要重新$DP$。 复杂度$O(n^3)$，然而实际上常数极小甚至（应该）到不了$\\dfrac{1}{10}$。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 1005 #define inf 0x3f3f3f3f const int mod = 998244353; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int f[maxn],c[maxn][maxn],a[5]; inline int calc(int n){ memset(f,0,sizeof f); f[0]=1; for(register int i=1,sum=0;i&lt;=4;++i){ sum=min(sum+a[i],n); for(register int j=sum;j;--j) for(register int k=min(j,a[i]);k;--k) (f[j]+=1ll*f[j-k]*c[j][j-k]%mod)%=mod; --a[i]; } return f[n]; } inline long long pow1(int x){return x&amp;1?-1ll:1ll;} int main(){ int n=read(),mi=n&gt;&gt;2,ans=0; for(register int i=1;i&lt;=4;++i)mi=min(a[i]=read(),mi); c[0][0]=1; for(register int i=1;i&lt;=n;++i){ c[i][0]=1; for(register int j=1;j&lt;=i;++j)c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod; } for(register int i=0;i&lt;=mi;++i)(ans+=pow1(i)*c[n-i*3][i]*calc(n-(i&lt;&lt;2))%mod)%=mod; printf(&quot;%d\\n&quot;,(ans+mod)%mod); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"容斥","slug":"容斥","permalink":"https://ctz45562.github.io/tags/%E5%AE%B9%E6%96%A5/"},{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"组合数学","slug":"组合数学","permalink":"https://ctz45562.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}]},{"title":"洛谷 P5376 [THUPC2019]过河卒二","slug":"洛谷-P5376-THUPC2019-过河卒二","date":"2019-12-05T09:35:24.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/12/05/洛谷-P5376-THUPC2019-过河卒二/","link":"","permalink":"https://ctz45562.github.io/2019/12/05/%E6%B4%9B%E8%B0%B7-P5376-THUPC2019-%E8%BF%87%E6%B2%B3%E5%8D%92%E4%BA%8C/","excerpt":"传送门 CSP后的第一篇题解。 不知道为啥突然很想刷容斥，于是用容斥题进行康复训练。","text":"传送门 CSP后的第一篇题解。 不知道为啥突然很想刷容斥，于是用容斥题进行康复训练。 定义$f(n,m)$为从$(1,1)$走到$(n,m)$（没有障碍）的方案数，强制$n&lt;m$，反正$f(n,m)=f(m,n)$。 如果只有$\\rightarrow$和$\\uparrow$就是$C_{n+m}^n$。 有了$\\nearrow$就枚举有多少步走$\\nearrow$，得出$f(n,m)=\\sum\\limits_{i=0}^nC_{n+m-i}^iC_{n+m-2i}^{n-i}$ 根据$C_m^rC_{m-r}^{n-r}=C_m^nC_n^r$还可以把这个式子变得更漂亮些：$f(n,m)=\\sum\\limits_{i=0}^nC_{n+m-i}^nC_n^i$。 很妙的一个结论是走出边界的方案数实际上就是走到$(n+1,m+1)$的方案数，因为一旦走出边界，到$(n+1,m+1)$的方案就是唯一的了。 把障碍点以$x$为第一关键字、$y$为第二关键字排序。枚举障碍点集合$S$，记$g(S)$为从$(1,1)$经过$S$中所有点到达$(n+1,m+1)$的方案数。 显然$g(S)$就是按顺序的相邻两点、$(1,1)$到第一个点和最后一个点到$(n+1,m+1)$围成的矩形的$f$乘积。如果存在一个点在上一个点的右下方，方案数就为$0$。 $O(mk^2\\log_{mod}n)$预处理出障碍点两两之间矩形的$f$值，$\\log_{mod}$是卢卡斯带的。 最后容斥，答案为$\\sum\\limits(-1)^{|S|}g(S)$。 复杂度$O(mk^2\\log_{mod}n+k2^k)$。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 100005 #define inf 0x3f3f3f3f const int mod = 59393; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int fac[mod]={1},inv[mod],f[21][21],g[21]; int INV(int x){return x==1?1:1ll*(mod-mod/x)*INV(mod%x)%mod;} struct fpos{ int x,y; bool operator &lt; (const fpos &amp;X)const{ if(x!=X.x)return x&lt;X.x; return y&lt;X.y; } }p[21]; inline int C(int n,int m){ if(m&gt;n)return 0; if(n&gt;=mod)return 1ll*C(n/mod,m/mod)*C(n%mod,m%mod)%mod; return 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod; } inline int calc(int n,int m){ if(n&gt;m)swap(n,m); int ans=0; for(register int i=0;i&lt;=n;++i)(ans+=1ll*C(n+m-i,n)*C(n,i)%mod)%=mod; return ans; } inline int pow1(int x){return x&amp;1?-1:1;} inline int pop_count(int x){ int ans=0; while(x)++ans,x-=x&amp;-x; return ans; } int main(){ for(register int i=1;i&lt;mod;++i)fac[i]=1ll*fac[i-1]*i%mod; inv[mod-1]=INV(fac[mod-1]); for(register int i=mod-2;~i;--i)inv[i]=1ll*inv[i+1]*(i+1)%mod; int n=read(),m=read(),k=read(),ans=0; for(register int i=1;i&lt;=k;++i)p[i].x=read(),p[i].y=read(); sort(p+1,p+1+k),p[0].x=1,p[0].y=1; for(register int i=0;i&lt;=k;++i){ f[i][i]=1,g[i]=calc(n+1-p[i].x,m+1-p[i].y); for(register int j=i+1;j&lt;=k;++j){ if(p[j].y&lt;p[i].y)continue; f[i][j]=calc(p[j].x-p[i].x,p[j].y-p[i].y); } } for(register int i=0;i&lt;1&lt;&lt;k;++i){ int last=0,res=1; for(register int j=1;j&lt;=k;++j) if(i&gt;&gt;j-1&amp;1)res=1ll*res*f[last][j]%mod,last=j; res=1ll*res*g[last]%mod; ans=(ans+pow1(pop_count(i))*res)%mod; } printf(&quot;%d\\n&quot;,(ans+mod)%mod); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"容斥","slug":"容斥","permalink":"https://ctz45562.github.io/tags/%E5%AE%B9%E6%96%A5/"},{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"组合数学","slug":"组合数学","permalink":"https://ctz45562.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"卢卡斯定理","slug":"卢卡斯定理","permalink":"https://ctz45562.github.io/tags/%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86/"}]},{"title":"CSP-S2019续命游记","slug":"CSP-S2019续命游记","date":"2019-12-04T08:57:23.000Z","updated":"2021-07-19T09:15:11.583Z","comments":true,"path":"2019/12/04/CSP-S2019续命游记/","link":"","permalink":"https://ctz45562.github.io/2019/12/04/CSP-S2019%E7%BB%AD%E5%91%BD%E6%B8%B8%E8%AE%B0/","excerpt":"ただいま。 时隔半个月终于来写游记了。 感觉咕了好多东西啊，慢慢补吧。","text":"ただいま。 时隔半个月终于来写游记了。 感觉咕了好多东西啊，慢慢补吧。 题外话今天是香风智乃的生日。 CSP之前我还在想，12月4号，我还有没有机会在机房里给智乃庆祝生日呢。当时还特意留了一张智乃图片作为本文头图。 现在看来答案很清晰了。 香風チノ，お誕生日おめでとうございます！ （可惜我没有一张合适的智乃生日图片） Day -??临近CSP，陷入了刷题的死角。 大概就是不能一眼秒的难题不想做，怕打击信心；简单但实现很麻烦的题不愿写，懒。平时只能上午打比赛，下午水题，晚上颓废这样子维持生活。 感觉周围人也是这种状态。 然而我不想就这么退役啊，还是强迫自己去多写点有思维量的水题。 Day -1上午和asuldb和杜爷尝试跟loli请假中午回去休息，被反奶了，最后成了下午走。 zhuoer昨天就跑了，稳稳中午也跑了，机房显得十分冷清。 ZR最后一场附加赛史无前例地怒切2题，rp--。 下午迎来了机房的传统，高二（以及大一的杜爷）的给学弟介绍经验。结果我也不会说话了。因为上午请假未遂怀恨在心故意说要休息好之类的话。 csq向我请教STL的用法，反正也没事干给他说了说。 期间把我所有的文件都备份到了u盘里，退役已准备就绪。（后来u盘出锅，压缩文件全炸了） 晚上开始打板子。点分治板子一直WA调了半个小时发现桶开小了。 和前几天一样因为紧张失眠了，12点才睡着。 Day 0本来想打板子的，结果还是颓了一上午。 下午和稳稳、asuldb第一个上车，抢占了车上仅有的带桌子的两个座位。 稳稳颓three kingdoms 10，我打板子。exBSGS忘干净了，题解也看不懂，我想也不可能考，于是打了更不能考的杜教筛。结果记忆化写挂了，还是回归老本手写哈希。线段树调了半小时发现1、2操作看反了。 我智商已经退化到如此地步了，这回是真的告别自行车了。 本来还想再睡一会的，闭上眼就感受到四面八方涌来的说话声，眯了半小时没睡着起来颓七都。 之前和一个学弟换了宿舍，跟zhuoer和四个gryz高一的住一块，我下铺zhuoer上铺。志愿者是一个彪形大汉（雾） 宿舍环境还可以吧，然而六个人只有四个凳子，来晚了没抢着。 不知道为啥宿舍里网很差，速度一般，还经常断掉。lol是打不了了，只好玩了把红警。 去试机。然而有种管理监狱的感觉，（或者说流放囚犯）。彪形大汉把我们吼出来，排队行进。遇到了asuldb等人于是掉队了。 大概走了十来分钟吧，一个多月没锻炼，累死了。 win7的机子，内存8G。写了快读和cin的a+b拍了一下，又写了个SAM和SA本质不同子串拍了起来（话说都能一遍写对真是奇迹，也可能是都写挂了），最后拍了树剖lca和O(1)lca，试了试开巨大数组。除了显示屏离得有点远其他都没啥问题。 回去快9点了，打了打板子10点了，睡觉。 再次因紧张失眠。躺了一会没那么紧张了，传来了美妙的呼噜声，而且是三种呼噜声交织在一起，一个尤为响亮而突出的带领两个很小的。。。 小声的还算能接受，是正常人睡觉的声音。然而大呼噜无法忍受。我姑且称源头为呼噜老哥。 一开始以为是zhuoer，听了一会发现zhuoer在上面翻来覆去，讲道理打呼噜的人不会乱动啊。 过了一会zhuoer下床去了趟厕所，同是受害者啊。突然有点后悔换宿舍了 又享受了一段时间呼噜声后，我上了个厕所，大概是发出的声音比较大把呼噜老哥吵醒了，趁他再 放 送前睡着了。 Day 1因为没睡好，直接和zhuoer去超市买了2罐咖啡。 早饭送了一盒优酸乳，怕吃坏肚子没喝。喝着咖啡逐渐有了精神。 D1的策略决定切掉T1T2再打全T3部分分（flag）。 进考场，发现没有清dev的设置，早知道把缺省源打了。 还有20分钟开考，突然焦虑了起来。 我其实不想退役啊。然而没智商还天天颓废，这么菜的我是注定要没了。 深呼吸几口放平了心态。 今年的密码画风奇特：Ren2Zhen0Si1Kao9，奶量十足。监考老师漏掉了9造成全考场陷入恐慌。 乍一看T1的时候很懵逼，开头以为是字符串大模拟。这不自闭了吗（ 读完构造方法，发现前面那些和题毫无关系。。。 看了看数据范围，5分钟想出来$O(n)$的——我也不知道该怎么称呼，姑且叫做暴力枚举构造吧。 码+调了5分钟过了大样例，然而不太放心还是用10分钟拍了一会。 突发奇想想造几组$n=64$的数据，发现爆long long造不出来。 发现自己的程序也只是开了long long赶紧改成unsigned long long。 顺手试了一下$64\\ 2^{64}-1$，全输出$0$？ 我的做法读入$k$的时候要加一，爆unsigned long long了，加工了一下终于过了。 虽然用了半小时，好得保证不会丢分了。 开始肝T2。看起来很可做的样子，搞了个前缀和+桶的做法，过不了第二个样例。 $50$的数据还是没法调，写了个$O(n^3)$暴力拍了起来。很快出锅了，改好了还是过不了第二个样例。 接下来一个多小时陷入了过不了样例$\\rightarrow$对拍$\\rightarrow$修锅/换做法$\\rightarrow$过不了样例的死循环。 我心态崩了。扫了一眼T3，题面很复杂的样子，而且暴力只有10分。 还有1小时我决定冒险继续肝T2。A不掉T2的话就真的退役了啊。 先打了T2的$O(n^2)$暴力和链，70分有了。然后就后悔了，我可以尝试优化$O(n^2)$暴力啊。 一小时没够我优化成正解。 期望得分100+70+0=170。 最后5分钟我心态炸没了。 D1T2都切不掉，退役了退役了退役了。。。 D1 170分，D2肯定要更低，别说上400了，说不定300都上不了。。。 是不是人均切T2啊，我要高二垫底了啊。。。 翻盘是不可能的，这辈子是不可能的。作为D1型选手D1爆炸不就没了吗。 这大概是我第一次在（对我而言的）重要比赛上爆炸。虽然我也没经历过什么重要比赛 出考场很快就想出了正解。去食堂的路上没遇到熟人，也渐渐看开了，退役就退役吧，文化课生活也挺好的。。。大概。 我果然还是不甘心，打算放平心态搏一搏D2。尽管我清楚自己是D1型选手。 在食堂遇到了Juan_feng和zhuoer。Juan_fengT2一开始就想出了一个很复杂的做法，最后没调出来，但是把T3 10分打了。zhuoer切了前两题但T3暴力没调出来。 遇到了杜爷和csq，得知我还被众学弟踩了。 我果然是垫底。 俗话说“一颓解千愁”，下午先放松一波心情，听着歌打了2小时红警。想睡一会，gryz的在旁边一边做题一遍聊天，躺了半小时没睡着又起来继续颓红警。 Tommy_clas和asuldb来玩，asuldb没开unsigned long long还用的1ll&lt;&lt;n的写法导致$n=63$也会挂。（然而他还是比我高） 厚颜无耻地用光棱坦克推掉了7个中等的敌人后去吃饭，一遍看皇室tv一遍自己吃饭。 （话说小号把矿工人海套升满后很迷茫要养什么卡组，搞了一半的熔炉皇家驹坐冷板凳了真的自闭） 吃完饭去稳稳的宿舍玩。那边网稍微好点了，起码不会经常断掉。 本来想打lol的，用劫和卡莎试了两把训练延迟100+还是放弃了。 zhuoer和R打怪猎，主席D1表现良好，心情舒畅，配上音乐，身着 紧 身 衣 跳了一段舞，被我及时录了下来。 稳稳妄图在宿舍里玩剧本杀，扮演罪犯大将军，深受噪音干扰蹲厕所里了。 下午和晚上的心态比起中午好多了。 既然退役的末路已经摆在眼前了，那就纵情享受最后的欢乐时光吧。 颓七都到9点，以防万一背了背图论的板子。 因为没啥压力了，在呼噜老哥表演之前就睡着了。 Day 2起来感觉还是没精神。一罐咖啡下肚，又是一条好汉。 密码是熟悉的配方，@zhuajin1SHIJIAN7，又是一股奶味。 D2决定求稳，先把T2T3暴力打出来再肝T1。 三道题都很清新，一脸$DP$的样子。 T2半小时码了个$O(n^2)DP$，又用二十分钟把T3$O(n^2)$和链写了。 开始肝T1。很快想到了要容斥，更妙的是一种不合法的方案只会有一种食材不合法。 想了个$O(n^2m)$的$DP$求总方案数，然而容斥这一块我又傻了，只搞了个$O(n^3m)$，有84分了。 后来大部分时间都在尝试优化，以失败告终。 我好菜啊，其实只要$DP$状态设为不合法食材和其他食材之和的差就能$O(n^2m)$了啊。 期间想了想T3的完全二叉树，没想出来。但在剩一小时的时候有了一个鬼畜的做法： 完全二叉树的$n$是固定的，也就是说这棵树的形态是固定的。 这样打个表表示每个点会被算作多少次重心，和编号一乘就好了！ 粗略算一下，我大概需要100分钟就能打这个表。而且确定树的形态还要费点事，告辞。 测了一下T3暴力的常数，2.6s好慌啊，不会卡我常吧。。。 最终得分84+64+55=203。总分373，没上400有点难看，但这个分起码能保我不会退役。。。应该吧。 又遇到了zhuoer、Juan_feng、杜爷和csq，除了杜爷D2都跪在DP上了。 只能说运气好，CSP前爆刷DP让我至少能保住暴力分。 说我D2正常发挥，确实勉强扳回一程；说发挥失常，然而我明明还有该拿的分没拿。就这样吧。 回去的路上终于能打lol了。 后记回归文化课后突然忙了起来，补课，补体育测试，担心能不能去WC，loli要重装系统去重新备份，又恰逢七都周年庆肝了起来。 出了成绩，一分没高，一份不挂，373分，rank29。 但还是不甘心啊，我所有丢掉的分，我觉得自己应该有能力拿上的。我只能是说没休息好来自我安慰了。 大概是缺乏比赛经验，也可能是急功近利，最大的失策在于肝题。D1T2成了我OI生涯中最大的耻辱。 至少又能苟半年了。而未来怎样，谁知道呢。 花絮下了车在校外等着，稳稳莫名其妙开始捡石头往学校里扔，有一块石头经过弹射成功击中了「忘了是ZUTTER还是shzr了反正很强就是了」。 一个宿舍有俩厕所，我们的宿舍还标了男厕所和女厕所。然后Day0晚上女厕所就坏了。 和稳稳开黑打皇室的吹箭2v2选卡，因为网不好刚选完卡网就断了。 QQ聊天记录： 稳稳：你啥意思 稳稳：我要揍你 后来稳稳以0胜3负的好战绩结束了比赛。 试机时： 我左边的老哥，字号调的巨大，大概5行字塞满整个屏幕的感觉。 我右边的老哥，全程没动过电脑，一直在阅读指导手册，在上面写东西。 试机结束后： 老师：那个，有件事要拜托一下你们。你们看看地上和桌子里面有没有垃圾，有的话扔到前面的垃圾桶里（我懒得打扫）。谢谢大家！ 众人：？？？ Day1早上与zhuoer交流受害经历，得知我是大概快12点后睡着的。 至于zhuoer。。。尝试了起来颓废、听安眠曲、上网查询“失眠怎么办”等等方法后终于在2点睡着了。 Day1比赛中： 我左边的老哥，依然是巨大字号。 我右边的老哥，开考半小时就玩起了各种windows游戏。 热烈祝贺稳稳再次一统三国！ Day1晚上睡觉时，zhuoer对呼噜老哥的心理阴影挥之不去。小型呼噜开始时，zhuoer找我商量把打呼噜的吵醒。 乃摇床、敲床板、大声咳嗽，乐声未尝息也，遂弃之。 Day2和李氏夫妇一同奔赴考场，我就如电灯泡一般被无情地灌了一路狗粮。 路上偶遇loli，幸亏perhan发动技能「打招呼」嘲讽loli吸引火力，要不然我得会被奶死。 别着er急，慢er慢er来。 Day2比赛中： 我左边的老哥，熟悉的配方，熟悉的大字号。 我右边的老哥，甚至没动过pdf和dev，玩了一上午游戏。 忍不住吐槽了，这俩老哥真nm奇葩。 asuldbD1T2奇妙的历程： Day1晚上：wocT2好像假了 Day2中午：（面对zhuoer和ctz）“我下午告诉你们一个好消息” Day2下午：（面对ctz）“我D1T2假了” 补课期间：诶我T2好像没假 出成绩：asuldb，brackets，score:100 asuldbD2T2奇妙的历程： 比赛中asuldb发现了T2的单调性，然而没时间了，写了个玄学的优化，复杂度是跑不满的$O(n^2)$，如果出题人不卡的话有88分。 出考场发现快写写挂了，if(x&gt;9)写成了if(x&gt;10)，答案前两位为10会挂。 出题人扬言要卡乱搞的$O(n^2)$优化 出题人说验题的时候也写挂过快写。 出成绩：asuldb，partition，score:60（玄学优化被卡没+快写挂一个点） 关于回去路上的lol，我都躺赢了。 尤其是第一把，中期我在中路被迫卖了一波，舍身让剑圣拿了个四杀，上路提莫又卖了一波，JS千里奔袭成功五杀。 之后他一挑五再获五杀，对面就投了。","categories":[{"name":"日常","slug":"日常","permalink":"https://ctz45562.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"二次元","slug":"二次元","permalink":"https://ctz45562.github.io/tags/%E4%BA%8C%E6%AC%A1%E5%85%83/"},{"name":"请问您今天要来点兔子吗","slug":"请问您今天要来点兔子吗","permalink":"https://ctz45562.github.io/tags/%E8%AF%B7%E9%97%AE%E6%82%A8%E4%BB%8A%E5%A4%A9%E8%A6%81%E6%9D%A5%E7%82%B9%E5%85%94%E5%AD%90%E5%90%97/"},{"name":"OI","slug":"OI","permalink":"https://ctz45562.github.io/tags/OI/"},{"name":"游记","slug":"游记","permalink":"https://ctz45562.github.io/tags/%E6%B8%B8%E8%AE%B0/"}]},{"title":"我对「点兔」の看法","slug":"thoughts-itoar","date":"2019-11-12T12:54:55.000Z","updated":"2021-07-01T04:38:38.530Z","comments":true,"path":"2019/11/12/thoughts-itoar/","link":"","permalink":"https://ctz45562.github.io/2019/11/12/thoughts-itoar/","excerpt":"昨天和学弟聊天时谈到了本子相关话题。我也不清楚为啥会聊到这个，昨天整晚的话风都挺h的","text":"昨天和学弟聊天时谈到了本子相关话题。我也不清楚为啥会聊到这个，昨天整晚的话风都挺h的 坚决不看点兔的本子，这是信仰。 这句话上我们有了分歧。大概他不是认真的，但对「点兔」的话题我是很严肃的。于是想把自己对「点兔」的看法一吐为快。 我不敢说自己阅番无数，但几百部总是有的。我对番剧的评价都是喜欢或不喜欢。（不过我门槛挺低的，补过的番一般没有说不喜欢的） 举点例子？ 轻音少女，经典之作，妹子萌，日常和主线兼得，我喜欢。 Fate/zero，剧情宏伟，特效精良，震撼人心，我喜欢。 京紫，顶尖作画，故事唯美感人，我喜欢。 然而从没有一部能像点兔一样能让我敬仰的。（比起上文的信仰，我觉得敬仰会更合适） 前年寒假补的点兔，第一感觉是“智乃好可爱”。 后来二刷，感觉每个妹子都很萌（当然最喜欢的还是智乃）。 日常番一大特点是补完了记不住剧情。于是一段时间后三刷，着重看剧情，大概对点兔的世界观有了点理解。 以欧洲小镇为依据的幻想世界，友善纯真的人，温馨安详的日常，没有猜忌与心机的纯洁友谊。 这就是我所向往的世界。可能是日常番入宅的原因，我不幻想着拥有穿越到异世界冒险的经历，或者成为后宫王受到众多妹子追捧。我只愿到一个世外桃源度过平静的一生。而且与弹幕里天天刷“智乃我老婆”的人相比，我更愿意有一个像智乃一样的女儿或妹妹。 之后断断续续刷了十几遍（可惜高中缺时间，不然都能刷三、四十遍了）。在二轮省选前每天中午的吃饭时间是那段停课时期我唯一颓废的时间，放弃补别的番重温点兔。我能逐渐体会到让点兔在众多日常番脱颖而出的魅力。那种与现实强大对比的落差感让我百看不腻。（这也是日常番另一大特点吧） 期间我补完了漫画，中了koi画风的毒。与动画不同的是，漫画带给我更多的是感动。智乃的变化（70话），智乃的母亲（72话），小豆队毕业（90话左右）。我能见证每个人的成长与变化。尤其是主角智乃，失去了母亲和爷爷（不过爷爷怕智乃寂寞附身于提比），在朋友的陪伴下敞开心扉，这是让我感触最深的暗线了。 扯了一堆有的没的，我只是想表达，我对点兔的追求，不止停留在人设、剧情这些肤浅的东西，更是它构造的世界和氛围。这种追求已经不是仅仅是二次元的层面，而是我人生层面的精神寄托。 毫不夸张地说，点兔是我的神，就如基督教里耶稣的地位。更实际点的比喻，就是航海员的指南针。 我一个初中同学曾问我：“如果给你机会让你穿越到一部番里，你会选择哪一部？” 我至今仍不能能决定，但能肯定的是，尽管我向往日常番的世界，我也绝对不会选点兔，或者任何一部日常番。 他对这个回答还挺诧异的。理由很简单，我不是像她们一样纯洁的人。我害怕破坏她们的日常，给美好的世界抹上污点。大概我对点兔的敬仰之心就是这样吧。 回到最初的话题，我不愿让任何东西玷污了点兔。 诚然，我对好看的妹子没有抵抗力，拥有极强的占有欲，看的本子数量也不少。但我从不看「真正意义上的神作」的本子，点兔就是我心中的最高神作。 以上。 原谅我只能以拙劣的文笔表达自己的真实想法。","categories":[{"name":"点兔","slug":"点兔","permalink":"https://ctz45562.github.io/categories/%E7%82%B9%E5%85%94/"}],"tags":[{"name":"二次元","slug":"二次元","permalink":"https://ctz45562.github.io/tags/%E4%BA%8C%E6%AC%A1%E5%85%83/"},{"name":"请问您今天要来点兔子吗","slug":"请问您今天要来点兔子吗","permalink":"https://ctz45562.github.io/tags/%E8%AF%B7%E9%97%AE%E6%82%A8%E4%BB%8A%E5%A4%A9%E8%A6%81%E6%9D%A5%E7%82%B9%E5%85%94%E5%AD%90%E5%90%97/"},{"name":"番剧","slug":"番剧","permalink":"https://ctz45562.github.io/tags/%E7%95%AA%E5%89%A7/"}]},{"title":"Codeforcesの三棵树","slug":"Codeforcesの三棵树","date":"2019-11-12T12:07:29.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/11/12/Codeforcesの三棵树/","link":"","permalink":"https://ctz45562.github.io/2019/11/12/Codeforces%E3%81%AE%E4%B8%89%E6%A3%B5%E6%A0%91/","excerpt":"在洛谷某讨论上薅了三道挺有意思的树题过来，都是$CF$的题。 话说我最近做的题和写的题解基本都是$CF$的。。。","text":"在洛谷某讨论上薅了三道挺有意思的树题过来，都是$CF$的题。 话说我最近做的题和写的题解基本都是$CF$的。。。 Codeforces1041E Tree Reconstruction第一次做这种构造题。。。应该是吧。 显然给出的点对其中一个必定是$n$，否则就假了。 按另一个点排序，钦定$n$为根节点（构造完再加进去），尝试在一条链上构造答案。以下记$a_i$为点对中不是$n$的那个点。 若$a_i\\neq a_{i-1}$，直接把链顶父亲设为$a_i$，这样对所有存在的点都没有影响。 若$a_i=a_{i-1}$，需要再来一条边割掉后一边最大值为$a_i$。钦定一个不在链里的点$x$，链顶父亲设为$x$。如果找不到就$gg$了。 最后把链顶的父亲设为$n$。 数据范围还挺友善的，$O(n^2)$暴力枚举就能过。写个链表的话就$O(n)$了。 关于正确性，构造成一条链是最优的。简单证一下： 假设我们已经得到了一棵合法的树（不一定是链），把$n$当做根节点，$a_i$实际上就是子树最大值。 考虑合并挂在某个点下面的两条链。把里面的边按$a_i$排序，小的$a_i$挂在大的$a_i$下面，就能得到一条新的链。不断地合并，最后这棵树就会变成一条合法的链。 所以只要存在合法的树，一定存在合法的链。那么构造成链是最优的。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 1005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int a[maxn],fa[maxn]; bool vis[maxn]; int main(){ int n=read(),tp=0; for(register int i=1,x,y;i&lt;n;++i){ x=read(),y=read(); if(max(x,y)!=n){puts(&quot;NO&quot;);return 0;} a[i]=min(x,y); } sort(a+1,a+n); for(register int i=1;i&lt;n;++i){ if(!vis[a[i]])fa[tp]=a[i],tp=a[i],vis[a[i]]=1; else { bool flag=0; for(register int j=1;j&lt;a[i];++j) if(!vis[j]){ flag=vis[j]=1,fa[tp]=j,tp=j; break; } if(!flag){puts(&quot;NO&quot;);return 0;} } } fa[tp]=n,puts(&quot;YES&quot;); for(register int i=1;i&lt;n;++i)printf(&quot;%d %d\\n&quot;,i,fa[i]); } Codeforces911F Tree Destruction真的，没有人体会过瞎猜一波结论、写了代码、一发$AC$的感觉。 大力猜测先把直径上的侧链删干净，最后把直径删掉。 证明胡一波： 考虑每个点被删除时的贡献，一定要找一个最远的点作为同伙，然后把自己干掉。 最远的点就是直径两端点之一了。为了让每个不在直径上的点被删掉时的贡献尽可能大，直径给其他点当梯子，最后再删掉。 胡毕。 比较懒复杂度是由于$LCA$的$O(n\\log n)$。把$LCA$换成两遍$dfs$就能$O(n)$做。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 200005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int son[maxn],siz[maxn],top[maxn],deep[maxn],fa[maxn],h[maxn],vis[maxn],line[maxn],deg[maxn],num,ma,root; pair&lt;int,int&gt;ans[maxn]; struct edge{int pre,to;}e[maxn&lt;&lt;1]; inline void add(int from,int to){++deg[from],e[++num]=(edge){h[from],to},h[from]=num;} void dfs1(int node=1){ siz[node]=1; for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(siz[x])continue; deep[x]=deep[node]+1,fa[x]=node; dfs1(x),siz[node]+=siz[x]; if(siz[x]&gt;siz[son[node]])son[node]=x; } } void dfs2(int node=1){ siz[node]=0; if(!son[node])return; top[son[node]]=top[node],dfs2(son[node]); for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(siz[x])top[x]=x,dfs2(x); } } inline int lca(int x,int y){ while(top[x]!=top[y])deep[top[x]]&lt;deep[top[y]]?y=fa[top[y]]:x=fa[top[x]]; return deep[x]&lt;deep[y]?x:y; } inline int dis(int x,int y){return deep[x]+deep[y]-(deep[lca(x,y)]&lt;&lt;1);} void dfs(int node,int f=0,int len=0){ if(len&gt;ma)ma=len,root=node; for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(x==f)continue; dfs(x,node,len+1); } } void _dfs(int node=1){ for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(x==fa[node])continue; _dfs(x),vis[node]+=vis[x]; } } int main(){ int n=read(),head=0,tail=0,len=0; for(register int i=1,x,y;i&lt;n;++i)x=read(),y=read(),add(x,y),add(y,x); dfs1(),dfs2(),dfs(1); int node=root; ma=0,dfs(root); ++vis[node],++vis[root],--vis[lca(node,root)],--vis[fa[lca(node,root)]],_dfs(); long long res=1ll*ma*(ma+1)&gt;&gt;1; for(register int i=1;i&lt;=n;++i)if(!vis[i]&amp;&amp;deg[i]==1)line[++tail]=i; while(head&lt;tail){ int x=line[++head],u=dis(x,node),v=dis(x,root); ans[++len]=(pair&lt;int,int&gt;){x,u&gt;v?node:root},res+=max(u,v); for(register int i=h[x];i;i=e[i].pre) if(!vis[e[i].to]&amp;&amp;--deg[e[i].to]==1)line[++tail]=e[i].to; } head=lca(node,root); while(node!=head||root!=head){ if(deep[node]&lt;deep[root])swap(node,root); ans[++len]=(pair&lt;int,int&gt;){node,root},node=fa[node]; } printf(&quot;%I64d\\n&quot;,res); for(register int i=1;i&lt;=len;++i)printf(&quot;%d %d %d\\n&quot;,ans[i].first,ans[i].second,ans[i].first); } Codeforces708C Centroids下记$siz$为子树大小。 如果一个点本来就是中心，就不要管它。 否则以这个点为根，有且仅有它的一个儿子的$siz$大于$\\left\\lfloor\\dfrac{n}{2}\\right\\rfloor$，记这个点为$x$。 以下是我从上午到下午的$zz$的做题历程： 断一条边，加一条边，实质上就是把一个子树接到另一个点上。 我们需要从$x$子树中选一棵子树接到一个另一个点上。选的子树需要满足既能使$x$子树变合法，又能不让被接上去的点$siz$依然小于$\\left\\lfloor\\dfrac{n}{2}\\right\\rfloor$。 最优方案就是从$x$子树所有点的$siz$中，找到$siz_x-\\left\\lfloor\\dfrac{n}{2}\\right\\rfloor$的后继，接到根节点$siz$最小的儿子上。（从这开始全乱了） 由于要判断所有点为根时的情况，考虑换根思想。 从$x$转移到儿子$y$，去掉一个$siz_y$，加上一个$n-siz_y$，bulabulabula 。。。 这咋搞啊，树剖套主席树时间爆炸，线段树合并空间爆炸。关键是不想写 。。。 噫，好！我会了！可以按$dfs$序建主席树，再开一棵线段树，$dfs$一遍树进入时去掉该点的$siz$加上$n-siz$，出去时再改回来bulabulabula 真的难写。码完了过不去样例，发现我压根不用接到最小的儿子上，直接接到根节点就好了。 于是这个问题转化为不合法的子树中是否存在一个点$siz\\le \\left\\lfloor\\dfrac{n}{2}\\right\\rfloor$ 刚才的线段树+主席树也是可以做的，但是调不动影响我的颓废时间。考虑$DP$。 正迟但到： 设$f(i)$为点$i$的子树所有点的$siz$中，$\\left\\lfloor\\dfrac{n}{2}\\right\\rfloor+1$的前驱。 转移：$f(i)=\\begin{cases}siz_i&amp;siz_i\\le \\left\\lfloor\\dfrac{n}{2}\\right\\rfloor\\\\\\max\\limits_{j\\in son(i)}\\{f(j)\\}&amp;otherwise\\end{cases}$ 考虑换根$DP$。 假设我们已经得到了$x$为根时的$f(fa_x)$记为$F$，把根从$x$移动到儿子$y$，需要知道以$y$为根时的$f(x)$： 对$x$的影响：少了一个儿子$y$，$siz$更新为$n-siz_y$。 对$y$的影响：多了一个儿子$x$，$siz$更新为$n$。 维护每个点儿子中$f$的最大值$m1$和次大值$m2$。 如果$n-siz_y\\le \\left\\lfloor\\dfrac{n}{2}\\right\\rfloor$，$f(x)=n-siz_y$ 否则，$\\begin{cases}f(x)=\\max\\{F,m2\\}&amp;f(y)=m1\\\\f(x)=\\max\\{F,m1\\}&amp;otherwise\\end{cases}$ 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 400005 #define inf 0x3f3f3f3f #define px putchar #define pn px(&#39;\\n&#39;) using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int siz[maxn],f[maxn],m1[maxn],m2[maxn],h[maxn],ms[maxn],num,n,lim; bool ans[maxn]; struct edge{int pre,to;}e[maxn&lt;&lt;1]; inline void add(int from,int to){e[++num]=(edge){h[from],to},h[from]=num;} inline void check(int &amp;f1,int &amp;f2,int d){ if(d&gt;f1)f2=f1,f1=d; else if(d&gt;f2)f2=d; } void dp(int node=1,int fa=0){ siz[node]=1; for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(x==fa)continue; dp(x,node); check(m1[node],m2[node],f[x]); f[node]=max(f[node],f[x]),siz[node]+=siz[x]; if(siz[x]&gt;siz[ms[node]])ms[node]=x; } if(siz[ms[node]]&lt;n-siz[node])ms[node]=-1; if(siz[node]&lt;=lim)f[node]=siz[node]; } inline int Max(int node){return ms[node]==-1?n-siz[node]:siz[ms[node]];} void _dp(int node=1,int fa=0,int F=0){ if(Max(node)&gt;lim){ if(ms[node]==-1){if(F&gt;=Max(node)-lim)ans[node]=1;} else if(f[ms[node]]&gt;=Max(node)-lim)ans[node]=1; } else ans[node]=1; for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(x==fa)continue; if(n-siz[x]&lt;=lim)_dp(x,node,n-siz[x]); else _dp(x,node,max(m1[node]==f[x]?m2[node]:m1[node],F)); } } int main(){ n=read(),lim=n&gt;&gt;1; for(register int i=1,x,y;i&lt;n;++i)x=read(),y=read(),add(x,y),add(y,x); dp(),_dp(); for(register int i=1;i&lt;=n;++i)printf(&quot;%d &quot;,ans[i]); pn; }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"贪心","slug":"贪心","permalink":"https://ctz45562.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"枚举","slug":"枚举","permalink":"https://ctz45562.github.io/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"换根DP","slug":"换根DP","permalink":"https://ctz45562.github.io/tags/%E6%8D%A2%E6%A0%B9DP/"},{"name":"构造","slug":"构造","permalink":"https://ctz45562.github.io/tags/%E6%9E%84%E9%80%A0/"}]},{"title":"Codeforces822E Liar","slug":"Codeforces822E-Liar","date":"2019-11-11T12:43:46.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/11/11/Codeforces822E-Liar/","link":"","permalink":"https://ctz45562.github.io/2019/11/11/Codeforces822E-Liar/","excerpt":"传送门 来啊，卡我啊，我换$SA$了有本事你再卡我？","text":"传送门 来啊，卡我啊，我换$SA$了有本事你再卡我？ 容易想到设$f(i,j)$为$s$的前$i$位中选$j$个子串匹配$t$的最大长度。 枚举分段长度转移：$f(i,j)=\\max\\{f(i-1,j),f(i-k,j-1)+k\\}(s[i-k+1,i]=t[f(i-k,j-1)+1,f(i-k,j-1)+k])$ 为了方便优化改成刷表的形式： $\\begin{cases}f(i,j)+k\\rightarrow f(i+k,j+1)(s[i+1,i+k]=t[f(i,j)+1,f(i,j)+k])\\\\f(i,j)\\rightarrow f(i+1,j)\\end{cases}$ 假设有两个可行的转移$i+k_1,i+k_2(k_1&lt;k_2)$。在$i+k_1$会存在一个的转移到$i+k_2$（即分为两段$[i+1,k_1],[i+k_1+1,k_2]$），这样多分了一段，一定不优。 所以直接转移到$i+1$开始最大匹配长度即可，哈希+二分。 然而。。。这个。。。这个丧心病狂的CF它卡哈希： 逼我强行改成后缀数组。居然还能默写对真是神奇 哈希+二分复杂度是$O(nx\\log n)$的，后缀数组是$O(n\\log n+nx)$的。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 100005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int f[maxn][31],tax[maxn&lt;&lt;1],sa[maxn&lt;&lt;1],rk[maxn&lt;&lt;1],tp[maxn&lt;&lt;1],hei[maxn&lt;&lt;1],g[maxn&lt;&lt;1][21],lg[maxn&lt;&lt;1],m,n; char a[maxn],s[maxn&lt;&lt;1]; void Rsort(){ for(register int i=0;i&lt;=m;++i)tax[i]=0; for(register int i=1;i&lt;=n;++i)++tax[rk[i]]; for(register int i=1;i&lt;=m;++i)tax[i]+=tax[i-1]; for(register int i=n;i;--i)sa[tax[rk[tp[i]]]--]=tp[i]; } void Ssort(){ for(register int i=1;i&lt;=n;++i)rk[i]=s[i],tp[i]=i; m=225,Rsort(); for(register int k=1,p=0;p&lt;n;k&lt;&lt;=1,m=p){ p=0; for(register int i=1;i&lt;=k;++i)tp[++p]=n-k+i; for(register int i=1;i&lt;=n;++i)if(sa[i]&gt;k)tp[++p]=sa[i]-k; Rsort(); for(register int i=1;i&lt;=n;++i)tp[i]=rk[i]; rk[sa[1]]=p=1; for(register int i=2;i&lt;=n;++i) rk[sa[i]]=tp[sa[i]]==tp[sa[i-1]]&amp;&amp;tp[sa[i]+k]==tp[sa[i-1]+k]?p:++p; } } void get_height(){ int k=0,x; for(register int i=1;i&lt;=n;++i){ if(rk[i]==1)continue; if(k)--k; x=sa[rk[i]-1]; while(x+k&lt;=n&amp;&amp;i+k&lt;=n&amp;&amp;s[x+k]==s[i+k])++k; g[rk[i]][0]=hei[rk[i]]=k; } } void ST(){ for(register int i=2;i&lt;=n;++i)lg[i]=lg[i&gt;&gt;1]+1; for(register int j=1;j&lt;=lg[n];++j) for(register int i=1;i+(1&lt;&lt;j-1)&lt;=n;++i) g[i][j]=min(g[i][j-1],g[i+(1&lt;&lt;j-1)][j-1]); } inline int query(int l,int r){ int len=lg[r-l+1]; return min(g[l][len],g[r-(1&lt;&lt;len)+1][len]); } inline int lcp(int i,int j){ if(rk[i]&gt;rk[j])swap(i,j); return query(rk[i]+1,rk[j]); } int main(){ int k,N=read(),M; scanf(&quot;%s&quot;,a+1); for(register int i=1;i&lt;=N;++i)s[i]=a[i]; s[n=N+1]=&#39;$&#39;,M=read(),scanf(&quot;%s&quot;,a+1); if(N&lt;M){puts(&quot;NO&quot;);return 0;} for(register int i=1;i&lt;=M;++i)s[n+i]=a[i]; n+=M,Ssort(),get_height(),ST(),k=read(); for(register int i=0;i&lt;N;++i) for(register int j=0;j&lt;=k;++j){ f[i+1][j]=max(f[i+1][j],f[i][j]); if(j==k)continue; int len=lcp(i+1,f[i][j]+N+2); if(len)f[i+len][j+1]=max(f[i+len][j+1],f[i][j]+len); } for(register int i=1;i&lt;=k;++i)if(f[N][i]==M){puts(&quot;YES&quot;);return 0;} puts(&quot;NO&quot;); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"字符串","slug":"字符串","permalink":"https://ctz45562.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"哈希","slug":"哈希","permalink":"https://ctz45562.github.io/tags/%E5%93%88%E5%B8%8C/"},{"name":"二分","slug":"二分","permalink":"https://ctz45562.github.io/tags/%E4%BA%8C%E5%88%86/"},{"name":"后缀数组","slug":"后缀数组","permalink":"https://ctz45562.github.io/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"},{"name":"ST表","slug":"ST表","permalink":"https://ctz45562.github.io/tags/ST%E8%A1%A8/"}]},{"title":"Codeforces875E Delivery Club","slug":"Codeforces875E-Delivery-Club","date":"2019-11-09T07:48:37.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/11/09/Codeforces875E-Delivery-Club/","link":"","permalink":"https://ctz45562.github.io/2019/11/09/Codeforces875E-Delivery-Club/","excerpt":"传送门 第一眼二分，第二眼就告辞了。 其实不算是动态规划，应该是递推的。只是我懒得再开新标签了。","text":"传送门 第一眼二分，第二眼就告辞了。 其实不算是动态规划，应该是递推的。只是我懒得再开新标签了。 正着推好像只能$O(n^2)$的$DP$。考虑倒着做。 假设当前二分值为$mid$。 维护一个限制区间$L$，表示要满足后面已考虑的点都不超出$mid$的限制，当前点能选取的区间。 一开始有一个快递员在$x_n$上，$L=[x_n-mid,x_n+mid]$，考虑钦定谁去点$x_{n-1}$。 若$x_{n-1}\\in L$，可以钦定其中一个快递员到$x_{n-1}$，另一个快递员到$x_n$（不用考虑在$x_{n-1}$前是否可行，这是之后要考虑的）。此时$x_n$也不受$mid$的限制了，$L=[x_{n-1}-mid,x_{n-1}+mid]$。 否则，必须钦定位于$x_n$的快递员去送$x_{n-1}$（若另一个快递员送的话$x_{n-1}$与$x_n$的距离会超过限制）。此时$x_n$和$x_{n-1}$的限制都需要考虑，$L=L\\bigcap[x_{n-1}-mid,x_{n-1}+mid]$。 这样的关系同样满足于前面所有$x_i$。递推到$x_1$时，只要判断$s_1,s_2$是否有一个属于$L$即可。递推过程中出现空集也不可行。不过若出现过空集，推到最后$L$也一定是空集，所以不用特判了。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 100005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int x[maxn],n,s1,s2; #define in(x,l,r) (x&gt;=l&amp;&amp;x&lt;=r) inline bool check(int len){ int l=x[n]-len,r=x[n]+len; for(register int i=n-1;i;--i){ if(in(x[i],l,r))l=x[i]-len,r=x[i]+len; else l=max(l,x[i]-len),r=min(r,x[i]+len); } return in(s1,l,r)||in(s2,l,r); } int main(){ n=read(),s1=read(),s2=read(); int l=max(s1,s2)-min(s1,s2),r=l,mid; for(register int i=1;i&lt;=n;++i)r=max(r,x[i]=read()); while(l&lt;r){ mid=l+r&gt;&gt;1; if(check(mid))r=mid; else l=mid+1; } printf(&quot;%d\\n&quot;,l); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"贪心","slug":"贪心","permalink":"https://ctz45562.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"二分","slug":"二分","permalink":"https://ctz45562.github.io/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"Codeforces178F3 Representative Sampling","slug":"Codeforces178F3-Representative-Sampling","date":"2019-11-06T09:08:35.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/11/06/Codeforces178F3-Representative-Sampling/","link":"","permalink":"https://ctz45562.github.io/2019/11/06/Codeforces178F3-Representative-Sampling/","excerpt":"传送门 翻译+一血+首篇题解+三倍经验美滋滋。","text":"传送门 翻译+一血+首篇题解+三倍经验美滋滋。 造个$trie$树，考虑一个朴素的$trie$树$DP$： 设$f(i,j)$为点$i$的子树内选了$j$个结束节点的最大答案，$s(i)$为点$i$子树内结束节点的个数。 为了不让贡献重复计算只考虑$i$到其父亲的边的贡献。 转移是个树形背包： $f(i,j)=\\max\\limits_{x\\in son(i),k\\le \\min\\{j,s(x)\\}}\\{f(x,k)+f(i,j-k)\\}+\\dfrac{j\\times(j-1)}{2}(j\\le s(i))$ 复杂度最高有$O(n|a_i|k)$。 我们发现有些没有分支和结束节点的链是多余的。 具体地说，只有结束节点和它们两两之间的$lca$有用，直接造虚树。 但是这里不用真的写虚树板子，我们只需$dfs$一遍把根节点、拥有至少$2$个儿子的节点和结束节点保留下来就行了。 记$dep(i)$为点$i$在原$trie$树上的深度。虚树上的方程要稍加改动： $f(i,j)=\\max\\limits_{x\\in son(i),k\\le \\min\\{j,s(x)\\}}\\{f(x,k)+f(i,j-k)\\}+\\dfrac{j\\times(j-1)}{2}\\times(dep(i)-dep(fa_i))(j\\le s(i))$ 复杂度是$O(nk)$的。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 1000005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } #define son(x,y) son[x][y] int en[maxn],son[maxn][26],siz[maxn],deep[maxn],s[4005],f[4005][2005],h[4005],c[2005],num,k,cnt=1,all; char a[505]; struct edge{int pre,to;}e[maxn]; inline void add(int from,int to){e[++num]=(edge){h[from],to},h[from]=num;} void insert(){ int len=strlen(a+1),node=1; for(register int i=1;i&lt;=len;++i){ if(!son(node,a[i]-&#39;a&#39;))son(node,a[i]-&#39;a&#39;)=++cnt,++siz[node]; node=son(node,a[i]-&#39;a&#39;); } ++en[node]; } void dfs(int node=1,int dep=0,int last=0){ if(node==1||siz[node]&gt;1||en[node])deep[++all]=dep,add(last,all),last=all,s[all]=en[node]; for(register int i=0;i&lt;26;++i)if(son(node,i))dfs(son(node,i),dep+1,last); } void dp(int node=1,int fa=0){ f[node][0]=0; for(register int i=h[node],x;i;i=e[i].pre){ dp(x=e[i].to,node),s[node]+=s[x]; for(register int j=min(s[node],k);j;--j) for(register int k=min(s[x],j);k;--k) f[node][j]=max(f[node][j],f[x][k]+f[node][j-k]); } for(register int i=1;i&lt;=s[node];++i)f[node][i]+=c[i]*(deep[node]-deep[fa]); } int main(){ int n=read(); k=read(); for(register int i=1;i&lt;=n;++i)scanf(&quot;%s&quot;,a+1),insert(); for(register int i=1;i&lt;=k;++i)c[i]=i*(i-1)&gt;&gt;1; dfs(),dp(); printf(&quot;%d\\n&quot;,f[1][k]); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"字符串","slug":"字符串","permalink":"https://ctz45562.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"trie树","slug":"trie树","permalink":"https://ctz45562.github.io/tags/trie%E6%A0%91/"},{"name":"虚树","slug":"虚树","permalink":"https://ctz45562.github.io/tags/%E8%99%9A%E6%A0%91/"}]},{"title":"洛谷 P2476 [SCOI2008]着色方案","slug":"洛谷-P2476-SCOI2008-着色方案","date":"2019-11-04T12:02:31.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/11/04/洛谷-P2476-SCOI2008-着色方案/","link":"","permalink":"https://ctz45562.github.io/2019/11/04/%E6%B4%9B%E8%B0%B7-P2476-SCOI2008-%E7%9D%80%E8%89%B2%E6%96%B9%E6%A1%88/","excerpt":"传送门 这不是水题吗，你怎么还写题解啊？ 。。。我也不知道颓啥了，随便水篇题解吧。","text":"传送门 这不是水题吗，你怎么还写题解啊？ 。。。我也不知道颓啥了，随便水篇题解吧。 主要是我的图片存货急需倾泻要不然退役前放不完了 第一想法是存下所有颜色剩余次数，然而$O(5^{15})$时空两开花。 $O(5^{15})$不行但是$O(15^5)=O(7\\times 10^5)$是$OK$的。 记录每种剩余次数有多少种颜色和上一格涂的颜色是那种次数。 枚举这一格涂哪种次数，如果是上一格颜色的次数要减$1$，剩下的随便选乘一乘就好了。 状态数$5\\times15^5$就可以愉快地记搜了。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 20 #define inf 0x3f3f3f3f const int mod = 1e9 + 7; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int f[16][16][16][16][16][6]; int dfs(int tax[],int last=0){ if(tax[1]+tax[2]+tax[3]+tax[4]+tax[5]==0)return 1; int *g=f[tax[1]][tax[2]][tax[3]][tax[4]][tax[5]]+last; if(~(*g))return *g; *g=0; for(register int i=1;i&lt;=5;++i) if(tax[i]-(i+1==last)&gt;0){ --tax[i],++tax[i-1]; (*g+=1ll*(tax[i]-(i+1==last)+1)*dfs(tax,i)%mod)%=mod; ++tax[i],--tax[i-1]; } return *g; } int main(){ int n=read(),tax[6]={0},sum=0; for(register int i=1;i&lt;=n;++i)++tax[read()]; memset(f,-1,sizeof f); printf(&quot;%d\\n&quot;,dfs(tax)); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"https://ctz45562.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"}]},{"title":"递归求逆元效率の胡乱分析","slug":"invTest","date":"2019-11-03T01:59:22.000Z","updated":"2021-07-01T04:33:02.316Z","comments":true,"path":"2019/11/03/invTest/","link":"","permalink":"https://ctz45562.github.io/2019/11/03/invTest/","excerpt":"其实一直想做这个测试了，但是没时间（懒）。 某个下午没干劲做题，不想荒废于是搞了出来。","text":"其实一直想做这个测试了，但是没时间（懒）。 某个下午没干劲做题，不想荒废于是搞了出来。 引子这种求逆元的方法其实是半年前指挥安利给我的。 众所周知，逆元可以$O(n)$递推： const int mod = 998244353; int inv[maxn],n; int main(){ for(register int i=1;i&lt;=n;++i)inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod; } 这只适用于模数较小或用的逆元个数有限的情况。 但我们可以把递推改成递归： const int mod = 998244353; int inv(int x){return x==1?1:1ll*(mod-mod/x)*inv(mod%x)%mod;} 这样可以求出任意数的逆元。如果会出现$0$要特判。 这种方法好像也没有什么专业的名称，我姑且称其为「递归式逆元」 优势非常明显，特别短，只有一行。 但它依然不适用于模数非质数的情况，而且复杂度未知。 接下来就是关于其复杂度的胡搞。 尝试证明这个复杂度不好证明。 每次$x$会变为$mod\\%x$，这并不能保证$x$会缩小为原来的多少。（$exgcd$每次$a$至少缩小一半所以保证其复杂度是$\\log$的） 在洛谷上得到了一篇知乎的证明：戳这儿。 大概意思是上界大约为$O(n^{\\frac{1}{3}})$，下界为$O(\\dfrac{\\ln n}{\\ln\\ln n})$，期望为$O(\\log mod)$。 这个复杂度听起来很爆炸。 好证明不如烂测试。直接挑选几个模数测试$1\\sim mod-1$里最大递归次数： const int mod = 998244353; int cnt[maxn]; int inv(int x){if(x&lt;maxn)return cnt[x];return inv(mod%x)+1;} int main(){ int ans=0; for(register int i=2;i&lt;maxn;++i)ans=max(ans,cnt[i]=cnt[mod%i]+1); for(register int i=maxn;i&lt;mod;++i)ans=max(ans,inv(i)); printf(&quot;%d\\n&quot;,ans); } 结果： 模数 最大递归次数 $998244353$ $44$ $10^9+7$ $48$ $10^9+9$ $46$ $10^6+7$ $25$ $104857601$ $38$ 某$8$位大质数 $36$ 这至少说明了在一些常用模数下，复杂度还是可以接受的。 可以看出最大递归次数与模数是近似的正相关，但是也有$10^9+7$和$10^9+9$的反例。 比较其他求逆元的方法无非就是基于费马小定理的快速幂和$exgcd$了。 论适用性的话还是$exgcd$，能处理模数非质数的情况。 以下只比较效率。 由于取模和除法效率远低于其他运算，只考虑这两种。同时还考虑了递归开栈和传入变量。 快速幂inline int quickpow(int x,int y){ int ans=1; while(y){ if(y&amp;1)ans=1ll*ans*x%mod; x=1ll*x*x%mod,y&gt;&gt;=1; } } 运行$\\log mod$次，一般跑不满。每次涉及$2$次取模，没有递归。 exgcdvoid exgcd(int a,int b,int &amp;x,int &amp;y){ if(!b)x=1,y=0; else exgcd(b,a%b,y,x),y-=x*(a/b); } inline int inv(int a){ int x,y; exgcd(a, mod, x, y); return (x+mod)%mod; } 运行$\\log mod$次，一般跑不满。每次涉及$1$次取模、$1$次除法。 需要递归实现，每层递归传入$2$个$int$和$2$个$int\\&amp;$。 递归式int inv(int x){return x==1?1:1ll*(mod-mod/x)*inv(mod%x)%mod;} 运行$?$次（参考上面数据）。每次涉及$2$次取模、$1$次除法。 需要递归实现，每层传入$1$个$int$。 小结理论上快速幂的性能是最高的，$exgcd$常数不小，递归式复杂度和常数都很大。 但是前两种递归式都不好优化，递归式有一个非常棒的优化：预处理。 int inv[maxn]={0,1}; int INV(int x){ if(x&lt;maxn)return inv[x]; return 1ll*(mod-mod/x)*INV(mod%x)%mod; } int main(){ for(register int i=2;i&lt;maxn;++i)inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod; } 也可以记忆化，但估计是负优化而且难写。 然而以上都是纸上谈兵，只是理论瞎分析了一波常数。实测才是硬道理。 实测以下测试都只用最常见的$998244353$和$10^9+7$，因为clock()是厌氧生物所以都没开$O2$。 当初指挥给我安利递归式的时候，进行了随机数据下的测试，结果是递归式跑的飞起。 那么把$1\\sim mod-1$全跑一遍呢？ 对快速幂、$exgcd$、递归式、预处理递归式（预处理至$10^7$，占用空间$38MB$，测试时算上预处理时间）进行测试。 测试代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;time.h&gt; #define maxn 10000005 const int mod = 998244353; using namespace std; namespace inv1{ inline int quickpow(int x,int y){ int ans=1; while(y){ if(y&amp;1)ans=1ll*ans*x%mod; x=1ll*x*x%mod,y&gt;&gt;=1; } return ans; } } namespace inv2{ void exgcd(int a,int b,int &amp;x,int &amp;y){ if(!b)x=1,y=0; else exgcd(b,a%b,y,x),y-=x*(a/b); } inline int inv(int a){ int x,y; exgcd(a,mod,x,y); return (x+mod)%mod; } } namespace inv3{ int inv(int x){return x==1?1:1ll*(mod-mod/x)*inv(mod%x)%mod;} } namespace inv4{ int inv[maxn]; void sieve(){ inv[1]=1; for(register int i=2;i&lt;maxn;++i)inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod; } int INV(int x){ if(x&lt;maxn)return inv[x]; return x==1?1:1ll*(mod-mod/x)*INV(mod%x)%mod; } } int main(){ printf(&quot;Speed test under mod %d.\\n&quot;,mod); int s=clock(); for(register int i=1;i&lt;mod;++i)inv1::quickpow(i,mod-2); s=clock()-s; printf(&quot;quickpow : %d ms\\n&quot;,s); s=clock(); for(register int i=1;i&lt;mod;++i)inv2::inv(i); s=clock()-s; printf(&quot;exgcd : %d ms\\n&quot;,s); s=clock(); for(register int i=1;i&lt;mod;++i)inv3::inv(i); s=clock()-s; printf(&quot;recursive : %d ms\\n&quot;,s); s=clock(); for(register int i=1;i&lt;mod;++i)inv4::INV(i); s=clock()-s; printf(&quot;recursive with preprocess: %d ms\\n&quot;,s); } 不要在意我胡写的英语 结果： $998244353$： 方法 时间（ms） 快速幂 162268 $exgcd$ 260005 递归式 270803 预处理递归式 99148 $10^9+7$也没啥区别： 方法 时间（ms） 快速幂 175463 $exgcd$ 270038 递归式 328440 预处理递归式 103875 预处理竟恐怖如斯，甚至一度突破$100s$。 缺点在于占用空间。可以少预处理一些以时间换空间。 再一个预处理递归式适用范围可能不是很广，并没有什么题会让你把$1\\sim mod-1$的逆元全求一遍。拿来卡常的话预处理自身已经需要$200+ms$了。 其他方法里快速幂是最优秀的了，而$exgcd$和递归式常数确实大。 总结逆元用什么方法还是看习惯吧。 通过这些测试，我收获了： 一篇水文 颓废的快乐 少量的干劲 “没有荒废”的自我安慰 以上。","categories":[{"name":"杂物","slug":"杂物","permalink":"https://ctz45562.github.io/categories/%E6%9D%82%E7%89%A9/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"逆元","slug":"逆元","permalink":"https://ctz45562.github.io/tags/%E9%80%86%E5%85%83/"}]},{"title":"ATcoder3913 XOR Tree","slug":"ATcoder3913-XOR-Tree","date":"2019-10-28T03:47:49.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/10/28/ATcoder3913-XOR-Tree/","link":"","permalink":"https://ctz45562.github.io/2019/10/28/ATcoder3913-XOR-Tree/","excerpt":"传送门 青岛集训是你，$DP$题单是你，今天比赛还是你。 大概这就是缘分吧。你不要过来啊！","text":"传送门 青岛集训是你，$DP$题单是你，今天比赛还是你。 大概这就是缘分吧。你不要过来啊！ 定义一个点的点权为与它相连的边的异或和。 结论是点权全为$0$等价于边权全为$0$。证明的话，使用逆反证法，因为举不出反例所以是对的。 对一条路径异或$x$，路径端点其中一条边被异或，点权异或$x$，而中间的点因为有两条边被异或，抵消了。这个操作就转成了任取两个点使它们异或上同一个值。 首先有一个显然的贪心：每次取两个相同的点权异或它们自己，一次操作能消掉两个数。 之后每种点权最多剩下$1$个。而且点权最大不超过$15$，这玩意可以状压。 设$f(S)$为状态为$S$（$0/1$表示每种点权的数量）全部消成$0$的最小次数。 每次操作我们可以枚举两个数量为$1$的数$x,y$异或上$x$，$x,y$就没了，产生了一个$x\\ xor\\ y$（记为$z$）。 讨论一下： $z\\notin S$，直接把$z$加进去，$f(S)=f(S\\ xor\\ (1&lt;&lt;x)\\ xor\\ (1&lt;&lt;y)\\ xor\\ (1&lt;&lt;z))+1$ $z\\in S$，这时会出现两个$z$，根据刚才的贪心再来一步消掉两个$z$是最优的，$f(S)=f(S\\ xor\\ (1&lt;&lt;x)\\ xor\\ (1&lt;&lt;y)\\ xor\\ (1&lt;&lt;z))+2$ 这个$DP$转移方向很鬼畜，不是很好递推，直接记搜就行。 复杂度$O(n+w^22^w)$ 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 100005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int a[maxn],tax[16],f[1&lt;&lt;16]; int dfs(int s){ if(~f[s])return f[s]; int x; f[s]=inf; for(register int i=1;i&lt;=15;++i) for(register int j=1;j&lt;=15;++j){ if(i==j||!(s&gt;&gt;i-1&amp;1)||!(s&gt;&gt;j-1&amp;1))continue; x=i^j; if(s&gt;&gt;x-1&amp;1)f[s]=min(f[s],dfs(s^(1&lt;&lt;i-1)^(1&lt;&lt;j-1)^(1&lt;&lt;x-1))+2); else f[s]=min(f[s],dfs(s^(1&lt;&lt;i-1)^(1&lt;&lt;j-1)^(1&lt;&lt;x-1))+1); } return f[s]; } int main(){ int n=read(),x,y,z,state=0,ans=0; for(register int i=1;i&lt;n;++i)x=read()+1,y=read()+1,z=read(),a[x]^=z,a[y]^=z; for(register int i=1;i&lt;=n;++i)++tax[a[i]]; for(register int i=1;i&lt;=15;++i){ ans+=tax[i]&gt;&gt;1; if(tax[i]&amp;1)state|=1&lt;&lt;i-1; } memset(f,-1,sizeof f),f[0]=0; printf(&quot;%d\\n&quot;,ans+dfs(state)); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"贪心","slug":"贪心","permalink":"https://ctz45562.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"https://ctz45562.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"状态压缩","slug":"状态压缩","permalink":"https://ctz45562.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"}]},{"title":"「某点兔主题比赛」水题笔记","slug":"计蒜客某点兔比赛水题笔记","date":"2019-10-26T08:25:53.000Z","updated":"2021-07-01T04:27:53.078Z","comments":true,"path":"2019/10/26/计蒜客某点兔比赛水题笔记/","link":"","permalink":"https://ctz45562.github.io/2019/10/26/%E8%AE%A1%E8%92%9C%E5%AE%A2%E6%9F%90%E7%82%B9%E5%85%94%E6%AF%94%E8%B5%9B%E6%B0%B4%E9%A2%98%E7%AC%94%E8%AE%B0/","excerpt":"莫名其妙被Tian-Xing拉过来打计蒜客的tg模拟赛。","text":"莫名其妙被Tian-Xing拉过来打计蒜客的tg模拟赛。 一般我都懒得打比赛。但这个题目背景都是点兔的，必打。 然而题目是真的水，水到我这种菜鸡都能2小时AK。。。 至于为啥要写水题笔记，是为了以后便于欣赏点兔的题面复习。 我非常认可所有题面的第一句话。 吐槽：没有千夜！一家人要整整齐齐才好！ 炮击题目描述 $rize$是一个可爱的女孩子。 一天，$rize$进行了炮击的练习。炮击用的靶子为一个圆，其中有$n−1$个与靶子同心的圆，将靶子划分成了$n$个区域。这些区域里到外从$1$到$n$编号，第$i$个区域的外径为$R_i$。每个区域有一个分数，第$i$个区域的分数为$s_i$。$rize$发射了$m$枚炮弹。在靶平面上的以靶心为原点的直角坐标系下，第$i$枚炮弹击中的区域为一个半径为$r_i$的圆，其圆心的坐标为$(x_i, y_i)$。若一枚炮弹击中的区域与靶子中的某个区域存在交集，则发射这枚炮弹会得到这个区域的分数。这里的区域不包含边界。 $rize$想知道发射每一枚炮弹的得分。 输入输出格式输入格式第一行两个数$n, m$； 之后$n$行，每行两个整数$R_i,s_i$； 之后$m$行，每行三个整数$x_i, y_i, r_i$。 输出格式 $m$行，每行一个数表示答案。 样例输入样例3 31 22 23 13 -1 1-2 -1 12 -4 2 输出样例131 数据范围有$30\\%$的数据$n, m \\le 1000$； 另有$20\\%$的数据$r_i = 1$； 另有$20\\%$的数据$s_i = 1$； 对于$100\\%$的数据，$1 \\le n, m \\le 2 \\times 10^5$，$1 \\le s_i \\le 10^4$，$-10^7 \\le x_i, y_i \\le 10^7$，$1 \\le r_i \\le 10^7$，$1 \\le R_1 &lt; R_2 &lt; \\cdots &lt; R_n \\le 10^7$。 题解对分数做个前缀和。求出$(x_i,y_i)$到原点的距离$dis$，$dis-d$的后继记为$l$，$dis+d$的后继记为$r$，答案就是$R_l\\sim R_r$的分数和。 一开始手写二分挂了，换成了lower_bound。 很坑的是本机上lower_bound返回了long long，而计蒜客的返回的是int，$\\min$函数出锅导致$CE$。。。 代码#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 200005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int sum[maxn]; double R[maxn]; inline int minn(int x,int y){return x&lt;y?x:y;} int main(){ int n=read(),m=read(); for(register int i=1;i&lt;=n;++i)R[i]=(double)read(),sum[i]=sum[i-1]+read(); while(m--){ int x=read(),y=read(),ans=0; double d=(double)read(),dis=sqrt(1ll*x*x+1ll*y*y); if(dis&gt;d)ans-=sum[lower_bound(R+1,R+1+n,dis-d)-R-1]; ans+=sum[minn(lower_bound(R+1,R+1+n,dis+d)-R,n)]; printf(&quot;%d\\n&quot;,ans); } } 出行题目描述 $syaro$是一个可爱的女孩子。 $syaro$所在的城市有$n$个街区，街区之间共有$m$条双向通行的道路，且任意两个街区可以通过这些道路互相到达。 一天，$syaro$要带着无数只兔子从$1$号街区走到$n$号街区。由于$syaro$无法管理太多的兔子，于是她决定，如果她经过的道路中存在长度为$w$的道路，那么她出发时只会带不大于$w$只兔子。为了节省时间，她只会在总长度最短的若干条路径中选择一条走。 另外，有$k$个街区由于开了很多咖啡店，整个街区都弥漫着咖啡的气味。由于$syaro$闻到咖啡的气味就会迷失方向，因此她只会从不经过任何一个这样的街区的最短路径中选择一条走。如果所有最短路径都会经过这样的街区，她就会放弃出行。 $syaro$告诉了$cocoa$自己的出行计划。$cocoa$作为一个擅长算术的女孩子，想知道$syaro$最多能带多少只兔子。当然，放弃出行意味着最多能带$0$只兔子。 输入输出格式输入格式第一行三个数$n, m, k$； 第二行$k$个数，表示开了很多咖啡店的街区编号； 之后$m$行，每行三个数$u, v, w$，表示有一条从$u$到$v$的长度为$w$的道路。 输出格式 输出一行一个数表示答案。 样例输入样例5 8 141 2 13 2 13 5 21 4 14 2 12 3 42 4 03 4 3 输出样例1 数据范围对于$10\\%$的数据$n, m \\le 50$，$m-n \\le 10$； 对于$30\\%$的数据$n, m \\le 10^3$； 对于$60\\%$的数据$n, m \\le 10^5$； 另有$20\\%$的数据$k = 0$； 对于$100\\%$的数据$1 \\le n, m \\le 10^6$，$0 \\le k \\le n$，$0 \\le w \\cdot n \\le 10^9$。不保证没有重边，保证没有自环。 题解第一眼：最短路图+最大生成树。 写出来挂了，而且我也并不确定正确性。。。 后来发现自己傻了，最短路的时候每个点记录到该点的最短路的边权最小值的最大值。 感觉题目有歧义： 因此她只会从不经过任何一个这样的街区的最短路径中选择一条走。如果所有最短路径都会经过这样的街区，她就会放弃出行。 我的理解是在原图的最短路中选一条不经过咖啡店的，若都经过则输出$0$。 但也可以理解为在删掉咖啡店后的图上找一条最短路，若此时$1$与$n$不联通输出$0$。 然而两种写法都能过，应该是数据水了。 代码#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define maxn 1000005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } priority_queue&lt;pair&lt;long long,int&gt; &gt;q; long long dis[maxn]; int ma[maxn],h[maxn],fa[maxn],n,num,cnt; bool co[maxn],vis[maxn]; struct EDGE{ int x,y,l; bool operator &lt; (const EDGE &amp;X)const{return l&gt;X.l;} }E[maxn]; struct edge{int pre,to,l;}e[maxn&lt;&lt;1]; inline void add(int from,int to,int l){e[++num]=(edge){h[from],to,l},h[from]=num;} void DJ1(){ memset(dis,0x3f,sizeof dis); q.push(make_pair(dis[1]=0,1)); while(!q.empty()){ int x=q.top().second,y; q.pop(); if(vis[x])continue; vis[x]=1; for(register int i=h[x];i;i=e[i].pre){ y=e[i].to; if(dis[y]&gt;dis[x]+e[i].l)q.push(make_pair(-(dis[y]=dis[x]+e[i].l),y)); } } } void DJ2(){ memset(ma,0x3f,sizeof ma); memset(dis,0x3f,sizeof dis); memset(vis,0,sizeof vis); q.push(make_pair(dis[1]=0,1)); while(!q.empty()){ int x=q.top().second,y; q.pop(); if(vis[x])continue; vis[x]=1; for(register int i=h[x];i;i=e[i].pre){ y=e[i].to; if(co[y])continue; if(dis[y]&gt;dis[x]+e[i].l)q.push(make_pair(-(dis[y]=dis[x]+e[i].l),y)),ma[y]=min(e[i].l,ma[x]); else if(dis[y]==dis[x]+e[i].l)ma[y]=max(ma[y],min(e[i].l,ma[x])); } } } int main(){ n=read(); int m=read(),k=read(); while(k--)co[read()]=1; while(m--){ int x=read(),y=read(),z=read(); add(x,y,z),add(y,x,z); } DJ1(); long long d=dis[n]; DJ2(); if(d!=dis[n]){puts(&quot;0&quot;);return 0;} else printf(&quot;%d\\n&quot;,ma[n]); } 会和题目描述 $cocoa$和$chino$是两个可爱的女孩子。 一天，她们要一起去参观花展。花展有$n$个花田，从$1$到$n$编号，其中花展的出入口在$1$号花田处。任意两个花田之间有且仅有一条路径。每个花田都有一个牌子，牌子上有一个数字，表示从这里回到出入口需要经过的道路数量。每个花田中仅有一种花，参展的花共有$m$种，从$1$到$m$编号。 为了更有趣一些，她们决定先分头行动，各自寻找漂亮的花。到了某个时间，$cocoa$走到了编号为$u$的花田，$chino$走到了编号为$v$的花田。她们决定在返回出入口的路上会合。她们会联系后确认双方所在地的牌子上的数字，数字更大的人会先往出入口方向走，另一个人待在原地。如果数字一样，那么$cocoa$ 走。如果走到了另一个人的所在地，两人就会合了。否则，当走到种着编号为$k$的花的花田或者出入口时，就会停下来，然后重新和另一个人联系，重复之前的过程。 现在她们很好奇，对于不同的$u, v, k$，两人会在哪个花田会合。 输入输出格式输入格式第一行三个数$n, m, q$； 第二行$n$个数，第$i$个数表示编号为$i$的花田中种的花的种类的编号； 之后$n-1$行，每行两个数$a, b$，表示编号分别为$a$和$b$的花田之间有一条道路； 之后$q$行，每行三个数$u, v, k$，意义如题目所述。 输出格式 输出$q$行，每行一个数表示会合的花田的编号。 样例输入样例8 3 83 2 2 2 1 1 1 11 22 33 42 54 62 77 87 2 18 6 38 7 17 3 18 2 36 4 17 7 15 5 1 输出样例21712475 数据范围有$30\\%$的数据$n, m, q \\le 1000$； 另有$20\\%$的数据$m = 1$，$n, q \\le 2 \\times 10^5$； 另有$30\\%$的数据$n, q \\le 5 \\times 10^4$； 对于$100\\%$的数据$1 \\le n, m, q \\le 3 \\times 10^5$。 题解记$x$为$lca(u,v)$。分两种情况： $x=u$或$x=v$，答案就是$x$。 $otherwise$，答案是$x$到根节点第一个颜色为$k$的点。若不存在这样的点答案为根。 没想到什么高论直接强上主席树。 题解给了个离线的线性做法： 虚树也可以搞。 别的题做的都很坎坷，但$T3$我最先切的而且一遍$A$。 代码#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 300005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } #define ls(x) ls[x] #define rs(x) rs[x] int ls[maxn&lt;&lt;5],rs[maxn&lt;&lt;5],dat[maxn&lt;&lt;5],root[maxn],m,cnt; int a[maxn],h[maxn],fa[maxn],top[maxn],son[maxn],siz[maxn],deep[maxn],num; struct edge{int pre,to;}e[maxn&lt;&lt;1]; inline void add(int from,int to){e[++num]=(edge){h[from],to},h[from]=num;} void build(int poi,int l,int r,int &amp;node,int ol,int d){ node=++cnt; if(l==r){dat[node]=d;return;} int mid=l+r&gt;&gt;1; if(poi&lt;=mid)rs(node)=rs(ol),build(poi,l,mid,ls(node),ls(ol),d); else ls(node)=ls(ol),build(poi,mid+1,r,rs(node),rs(ol),d); } int ask(int poi,int l,int r,int node){ if(!node)return 0; if(l==r)return dat[node]; int mid=l+r&gt;&gt;1; if(poi&lt;=mid)return ask(poi,l,mid,ls(node)); else return ask(poi,mid+1,r,rs(node)); } void dfs1(int node=1){ siz[node]=1; build(a[node],1,m,root[node],root[fa[node]],node); int x; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(siz[x])continue; deep[x]=deep[node]+1,fa[x]=node,dfs1(x); siz[node]+=siz[x]; if(siz[x]&gt;siz[son[node]])son[node]=x; } } void dfs2(int node=1){ siz[node]=0; if(!son[node])return; top[son[node]]=top[node],dfs2(son[node]); for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(siz[x])top[x]=x,dfs2(x); } } inline int lca(int x,int y){ while(top[x]!=top[y])deep[top[x]]&lt;deep[top[y]]?y=fa[top[y]]:x=fa[top[x]]; return deep[x]&lt;deep[y]?x:y; } int main(){ int n=read(); m=read(); int t=read(),x,y,k,z; for(register int i=1;i&lt;=n;++i)a[i]=read(); for(register int i=1;i&lt;n;++i)x=read(),y=read(),add(x,y),add(y,x); dfs1(),dfs2(); while(t--){ x=read(),y=read(),z=lca(x,y),k=read(); if(x==z||y==z)printf(&quot;%d\\n&quot;,z); else { x=ask(k,1,m,root[z]); printf(&quot;%d\\n&quot;,max(1,x)); } } }","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ctz45562.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"请问您今天要来点兔子吗","slug":"请问您今天要来点兔子吗","permalink":"https://ctz45562.github.io/tags/%E8%AF%B7%E9%97%AE%E6%82%A8%E4%BB%8A%E5%A4%A9%E8%A6%81%E6%9D%A5%E7%82%B9%E5%85%94%E5%AD%90%E5%90%97/"},{"name":"图论","slug":"图论","permalink":"https://ctz45562.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"二分","slug":"二分","permalink":"https://ctz45562.github.io/tags/%E4%BA%8C%E5%88%86/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"主席树","slug":"主席树","permalink":"https://ctz45562.github.io/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"name":"最短路","slug":"最短路","permalink":"https://ctz45562.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"洛谷 P3226 [HNOI2012]集合选数","slug":"洛谷-P3226-HNOI2012-集合选数","date":"2019-10-25T12:27:29.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/10/25/洛谷-P3226-HNOI2012-集合选数/","link":"","permalink":"https://ctz45562.github.io/2019/10/25/%E6%B4%9B%E8%B0%B7-P3226-HNOI2012-%E9%9B%86%E5%90%88%E9%80%89%E6%95%B0/","excerpt":"传送门 这个转化好仙啊。","text":"传送门 这个转化好仙啊。 看到约束就想到把$x$和$2x,3x$连边，然后会形成一个图： 看起来非常熟悉（图都是从那搬来的，所以不要在意编号问题），一副不可做的样子。 换种转化方式： 搞一个矩阵，左上角定一个初始值，其他元素都是其左边元素乘$2$或者上面元素乘$3$（这俩是相等的）。 大概这样： 1 2 4 8 ... 3 6 12 24 ... 9 18 36 72 ... ... 这个约束条件就成了在矩阵中选取若干个互不相邻的元素。 矩阵列数是$\\log_2 n$的，行数是$\\log_3 n$的，直接状压$DP$。 一个问题在于有的元素在矩阵中未出现过。需要从$1$枚举到$n$，每次$DP$时标记矩阵中的元素，访问到未被标记的元素就以它为初始值做$DP$。根据乘法原理全乘起来就是答案。 复杂度看起来挺玄学的，不过感性分析一波应该很小。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 100005 #define inf 0x3f3f3f3f const int mod = 1e9 + 1; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int f[2][1&lt;&lt;11],cnt[20],n; bool bad[1&lt;&lt;11],vis[maxn]; int solve(int base){ memset(cnt,0,sizeof cnt); memset(f,0,sizeof f); int len,ans=0; for(len=1;base&lt;=n;++len,base&lt;&lt;=1){ int x=base; while(x&lt;=n)vis[x]=1,++cnt[len],x*=3; } --len,f[0][0]=1; for(register int i=1;i&lt;=len;++i) for(register int j=0;j&lt;1&lt;&lt;cnt[i];++j){ if(bad[j])continue; f[i&amp;1][j]=0; for(register int k=0;k&lt;1&lt;&lt;cnt[i-1];++k){ if(bad[k]||j&amp;k)continue; (f[i&amp;1][j]+=f[i&amp;1^1][k])%=mod; } } for(register int i=0;i&lt;1&lt;&lt;cnt[len];++i)if(!bad[i])(ans+=f[len&amp;1][i])%=mod; return ans; } int main(){ n=read(); int ans=1; for(register int i=0;i&lt;1&lt;&lt;11;++i){ for(register int j=1;j&lt;11;++j) if(i&gt;&gt;j&amp;1&amp;&amp;i&gt;&gt;j-1&amp;1)bad[i]=1; } for(register int i=1;i&lt;=n;++i)if(!vis[i])ans=1ll*ans*solve(i)%mod; printf(&quot;%d\\n&quot;,ans); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"状态压缩","slug":"状态压缩","permalink":"https://ctz45562.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"}]},{"title":"ATCoder2062 ~K Perm Counting","slug":"ATCoder2062-K-Perm-Counting","date":"2019-10-24T11:58:28.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/10/24/ATCoder2062-K-Perm-Counting/","link":"","permalink":"https://ctz45562.github.io/2019/10/24/ATCoder2062-K-Perm-Counting/","excerpt":"传送门 难得能独立推出容斥题好激动啊。","text":"传送门 难得能独立推出容斥题好激动啊。 这么鬼畜的条件显然不能直接$DP$，考虑容斥。 设$f(i)$为至少$i$个位置不满足条件的方案数。 这玩意还是不好直接求。 $|P_i-i|\\neq k\\leftrightarrow P_i\\neq i+k \\lor P_i\\neq i-k$ 一个位置有两种取值是不合法的。 当两个位置$i,j$同时不合法且$P_i=P_j$时，必然满足$i+k=j-k$。 也就是说$i$与$i+2k$存在一个共同的不合法值$i+k$。 把这些不合法值连起来（假设$k=2$）： 这时我们可以对每条这样的链$DP$。 设$g(i,j,0/1/2)$为考虑到$i$，$i$所在的链选了$j$个不合法值，$i$选择了$i-k/i+k$或不选。 普及转移： $g(i,j,0)=g(i-2k,j-1,0)+g(i-2k,j-1,2)$ $g(i,j,1)=g(i-2k,j-1,0)+g(i-2k,j-1,1)+g(i-2k,j-1,2)$ $g(i,j,2)=g(i-2k,j,0)+g(i-2k,j,1)+g(i-2k,j,2)$ 考虑合并所有链，做个背包就行了： $f(i)=\\sum\\limits_{j=1}^i f(i-j)\\times (g(k,j,0)+g(k,j,1)+g(k,j,2))(k\\in [\\max\\{n-2k+1,1\\},n])$ 最后容斥一波，由于求的$f(i)$是仅考虑选不合法位置的方案数，还要给剩下位置随机钦定。 $ans=\\sum\\limits_{i=0}^n(-1)^if(i)(n-i)!$ 我的写法不能处理$k=0$的情况要特判，这时其实就是错排。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 2005 #define inf 0x3f3f3f3f const int mod = 924844033; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int f[maxn],c[maxn][maxn],g[maxn][maxn][3],fac[maxn]={1},n,m,ans; inline long long pow1(int x){return x&amp;1?-1ll:1ll;} int main(){ n=read(),m=read(); for(register int i=1;i&lt;=n;++i)fac[i]=1ll*fac[i-1]*i%mod; if(!m){ c[0][0]=1; for(register int i=1;i&lt;=n;++i){ c[i][0]=1; for(register int j=1;j&lt;=i;++j) c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod; } for(register int i=0;i&lt;=n;++i) (ans+=pow1(i)*c[n][i]*fac[n-i]%mod)%=mod; printf(&quot;%d\\n&quot;,(ans+mod)%mod); return 0; } for(register int i=1;i&lt;=min(m&lt;&lt;1,n);++i){ g[i][0][2]=1; if(i-m&gt;0)g[i][1][0]=1; if(i+m&lt;=n)g[i][1][1]=1; } for(register int i=(m&lt;&lt;1)+1;i&lt;=n;++i){ int x=i-(m&lt;&lt;1); for(register int j=0;j&lt;=n;++j){ if(j&amp;&amp;i-m&gt;0)g[i][j][0]=(g[x][j-1][0]+g[x][j-1][2])%mod; if(j&amp;&amp;i+m&lt;=n)g[i][j][1]=((g[x][j-1][0]+g[x][j-1][1])%mod+g[x][j-1][2])%mod; g[i][j][2]=((g[x][j][0]+g[x][j][1])%mod+g[x][j][2])%mod; } } f[0]=1; int sum=0,cnt; for(register int i=max(n-(m&lt;&lt;1)+1,1);i&lt;=n;++i){ cnt=(i-1)/(m&lt;&lt;1)+1,sum+=cnt; for(register int k=1;k&lt;=cnt;++k) for(register int j=sum;j;--j) for(register int k=min(j,cnt);k;--k) (f[j]+=1ll*f[j-k]*((g[i][k][0]+g[i][k][1])%mod+g[i][k][2])%mod)%=mod; } for(register int i=0;i&lt;=n;++i) (ans+=pow1(i)*f[i]*fac[n-i]%mod)%=mod; printf(&quot;%d\\n&quot;,(ans+mod)%mod); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"容斥","slug":"容斥","permalink":"https://ctz45562.github.io/tags/%E5%AE%B9%E6%96%A5/"}]},{"title":"欧与非","slug":"E-A","date":"2019-10-23T13:30:33.000Z","updated":"2021-07-01T04:36:10.741Z","comments":true,"path":"2019/10/23/E-A/","link":"","permalink":"https://ctz45562.github.io/2019/10/23/E-A/","excerpt":"10.22晚惊心动魄的经历。","text":"10.22晚惊心动魄的经历。 目前想要的神器使只有朝奈了，攒了三个月的石头和月卡，终于等来了朝奈池。 在朝奈池的前7天里，我累计抽了104发。 战利品： 染色之子、韦迪和重渊。 海量的影装 若干只酒妹 一堆A结晶和B结晶（然而还差一个觉醒羽弥ss3） 至于朝奈，2个1碎片+3个2碎片？？？ 仅存的理智让我没有卸游。 10.22，11点。 万圣活动送的都市券还没抽，来了发10连。 出了极道狂花和夜幕之华。（单抽概率为3%）毕竟也是用赛姐的，那叫个激动啊。 去羁绊池10连，出了两件稀有影装。 朝奈池还剩8小时。这两发欧气十足的10连一定暗示着什么。 刷了会殿堂，东拼西凑搞了7个石头。 白夜馆。 我从来不相信奇迹。 隙间。 我也从未经历过单抽出奇迹。 精选专场。 抽卡时不要想着“一定要抽出来”，放平心态才能抽到。 开启。 深呼吸。 在时钟上具体画了什么我也记不清楚了，3橙1紫2蓝。 钦定了最中间的五边形碎片，只见一道金光—— 我叫虎彻，继承了建御雷神的就是本大爷我啦！ ——某戴着黄色头巾的健♂壮男子 刚抽出来极道狂花怎么可能卸游呢2333","categories":[{"name":"日常","slug":"日常","permalink":"https://ctz45562.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"永远的七日之都","slug":"永远的七日之都","permalink":"https://ctz45562.github.io/tags/%E6%B0%B8%E8%BF%9C%E7%9A%84%E4%B8%83%E6%97%A5%E4%B9%8B%E9%83%BD/"},{"name":"游戏","slug":"游戏","permalink":"https://ctz45562.github.io/tags/%E6%B8%B8%E6%88%8F/"}]},{"title":"Codeforces1153D Serval and Rooted Tree","slug":"Codeforces1153D-Serval-and-Rooted-Tree","date":"2019-10-22T12:09:28.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/10/22/Codeforces1153D-Serval-and-Rooted-Tree/","link":"","permalink":"https://ctz45562.github.io/2019/10/22/Codeforces1153D-Serval-and-Rooted-Tree/","excerpt":"传送门 朝奈池最后一个晚上，抽了100多发的我已经看淡了一切","text":"传送门 朝奈池最后一个晚上，抽了100多发的我已经看淡了一切 这$DP$有点神仙啊。 设$f(i)$为点$i$的权值在其子树内的叶子中，能取到的最靠前的排名。 若$i$为叶子，$f(i)=1$ 若$i$操作为$\\max$，取所有儿子中排名最靠前的，$f(i)=\\min\\limits_{j\\in son(i)}\\{f(j)\\}$ 若$i$操作为$\\min$，$i$需要给所有儿子的$f$分配名额，$f(i)=\\sum\\limits_{j\\in son(i)}f(j)$ 答案就是叶子数$-f(1)+1$ 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 300005 #define inf 0x3f3f3f3f #define px putchar #define pn px(&#39;\\n&#39;) #define ps px(&#39; &#39;) #define pd puts(&quot;======================&quot;) #define pj puts(&quot;++++++++++++++++++++++&quot;) using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int f[maxn],h[maxn],num; bool leaf[maxn],type[maxn]; struct edge{int pre,to;}e[maxn]; inline void add(int from,int to){leaf[from]=1,e[++num]=(edge){h[from],to},h[from]=num;} void dp(int node=1){ if(!leaf[node]){f[node]=1;return;} f[node]=type[node]?inf:0; for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to,dp(x); f[node]=type[node]?min(f[node],f[x]):f[node]+f[x]; } } int main(){ int n=read(),ans=0; for(register int i=1;i&lt;=n;++i)type[i]=read(); for(register int i=2;i&lt;=n;++i)add(read(),i); dp(); for(register int i=1;i&lt;=n;++i)ans+=leaf[i]^1; printf(&quot;%d\\n&quot;,ans-f[1]+1); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Codeforces449D Jzzhu and Numbers","slug":"Codeforces449D-Jzzhu-and-Numbers","date":"2019-10-22T08:39:35.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/10/22/Codeforces449D-Jzzhu-and-Numbers/","link":"","permalink":"https://ctz45562.github.io/2019/10/22/Codeforces449D-Jzzhu-and-Numbers/","excerpt":"传送门 高维前缀和真是挺有意思的呵。","text":"传送门 高维前缀和真是挺有意思的呵。 直接$DP$只能$O(na_i)$，咱也不会$FWT$，考虑容斥。 设$f(S)$为选若干个数按位与结果为$S$的超集的方案数。 容斥一下，答案就是$\\sum\\limits_{S}(-1)^{|S|}f(S)$。 接下来求$f(S)$。 设$g(S)$为二进制为$S$的超集的$a_i$的个数。 显然从$g(S)$中任取几个数按位与，结果也一定是$S$的超集。 去掉空集，$f(S)=2^{g(S)}-1$。 接下来求$g(S)$。 初始化$++g(a_i)$。然后做个前缀和，$g(S)=\\sum\\limits_{S\\subseteq T}g(T)$。 高维前缀和优化，不过和我刚学的有点区别，因为$S,T$位置倒过来了，所以实际上是个后缀和，魔改一下就行了。 复杂度$O(a_i\\log a_i)$。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 1000005 #define inf 0x3f3f3f3f const int mod = 1e9 + 7; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int tax[1&lt;&lt;20]; inline int pow1(int x){return x&amp;1?-1:1;} inline int pop_count(int x){ int ans=0; while(x)++ans,x-=(x&amp;-x); return ans; } inline int quickpow(int y){ int ans=1,x=2; while(y){ if(y&amp;1)ans=1ll*ans*x%mod; x=1ll*x*x%mod,y&gt;&gt;=1; } return ans; } int main(){ int n=read(),ans=0; for(register int i=1;i&lt;=n;++i)++tax[read()]; for(register int i=0;i&lt;20;++i) for(register int j=0;j&lt;1&lt;&lt;20;++j) if(!(j&gt;&gt;i&amp;1))tax[j]+=tax[j|(1&lt;&lt;i)]; for(register int i=0;i&lt;1&lt;&lt;20;++i) (ans+=pow1(pop_count(i))*(quickpow(tax[i])-1))%=mod; printf(&quot;%d\\n&quot;,(ans+mod)%mod); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"容斥","slug":"容斥","permalink":"https://ctz45562.github.io/tags/%E5%AE%B9%E6%96%A5/"},{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"高维前缀和","slug":"高维前缀和","permalink":"https://ctz45562.github.io/tags/%E9%AB%98%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/"}]},{"title":"洛谷 P1587 [NOI2016]循环之美","slug":"洛谷-P1587-NOI2016-循环之美","date":"2019-10-20T10:32:10.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/10/20/洛谷-P1587-NOI2016-循环之美/","link":"","permalink":"https://ctz45562.github.io/2019/10/20/%E6%B4%9B%E8%B0%B7-P1587-NOI2016-%E5%BE%AA%E7%8E%AF%E4%B9%8B%E7%BE%8E/","excerpt":"传送门 众所周知，反演题只有套路题和神仙题","text":"传送门 众所周知，反演题只有套路题和神仙题 概括题意： 求$\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m[gcd(i,j)=1][gcd(j,k)=1]$ 蛤？你问我为啥是这个式子？ 道可道，非常道。只可意会，不可言传。请出门右转题解区。（一言以蔽之，我不会推） 大跃进反演： $\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m[gcd(i,j)=1][gcd(j,k)=1]$ $=\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m\\sum\\limits_{a=1}^n\\mu(a)[a|i][a|j]\\sum\\limits_{b=1}^m\\mu(b)[b|j][b|k]$ $=\\sum\\limits_{a=1}^n\\mu(a)\\left\\lfloor\\dfrac{n}{a}\\right\\rfloor\\sum\\limits_{b|k}\\mu(b)\\left\\lfloor\\dfrac{m}{lcm(a,b)}\\right\\rfloor$ 这什么沙雕？！ 事实证明，大跃进不可取 五五开反演： 设$f(n,m,k)=\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m[gcd(i,j)=1][gcd(j,k)=1]$ $f(n,m,k)=\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m[gcd(i,j)=1]\\sum\\limits_{d|k}\\mu(d)[d|j]$ $=\\sum\\limits_{d|k}\\mu(d)\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^{\\lfloor\\frac{m}{d}\\rfloor}[gcd(i,jd)=1]$ $=\\sum\\limits_{d|k}\\mu(d)\\sum\\limits_{j=1}^{\\lfloor\\frac{m}{d}\\rfloor}\\sum\\limits_{i=1}^n[gcd(i,j)=1][gcd(i,d)=1]$ $=\\sum\\limits_{d|k}\\mu(d)f(\\left\\lfloor\\dfrac{m}{d}\\right\\rfloor,n,d)$ 暴力递归算就好了。 边界：$f(n,0,k)=f(0,m,k)=0$，$f(n,m,1)=\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m[gcd(i,j)=1]=\\sum\\limits_{d=1}^n\\mu(d)\\left\\lfloor\\dfrac{n}{d}\\right\\rfloor\\left\\lfloor\\dfrac{m}{d}\\right\\rfloor$，还要套个杜教筛。 蛤？你问我复杂度？ 当然是O(能过)查阅一下题解是$O(\\log n\\log m\\sqrt{n}+n^{\\frac{2}{3}})$的。（我TM真不会推啊） 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #define maxn 10000005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int mu[maxn],prime[maxn&gt;&gt;2],cnt,sq; bool is[maxn]; vector&lt;int&gt;fac[2005]; const int mod =3e6 + 7; struct hash{ int cmp[mod],dat[mod],h[mod],nex[mod],cnt; void insert(int x,int d){nex[++cnt]=h[x%mod],h[x%mod]=cnt,cmp[cnt]=x,dat[cnt]=d;} int find(int x){ for(register int i=h[x%mod];i;i=nex[i]) if(cmp[i]==x)return dat[i]; return -inf; } }mmu; int smu(int n){ if(n&lt;maxn)return mu[n]; int ans=mmu.find(n); if(ans!=-inf)return ans; ans=1; for(register int l=2,r;l&lt;=n;l=r+1){ r=n/(n/l); ans-=(r-l+1)*smu(n/l); } mmu.insert(n,ans); return ans; } long long g(int n,int m){ if(n&gt;m)swap(n,m); long long ans=0; for(register int l=1,r;l&lt;=n;l=r+1){ r=min(n/(n/l),m/(m/l)); ans+=1ll*(smu(r)-smu(l-1))*(n/l)*(m/l); } return ans; } long long f(int n,int m,int k){ if(!n||!m)return 0; if(k==1)return g(n,m); long long ans=0; for(register int i=0,x;i&lt;fac[k].size();++i){ x=fac[k][i]; ans+=f(m/x,n,x)*(mu[x]-mu[x-1]); } return ans; } int main(){ mu[1]=1; for(register int i=2;i&lt;maxn;++i){ if(!is[i])prime[++cnt]=i,mu[i]=-1; for(register int j=1;j&lt;=cnt&amp;&amp;i*prime[j]&lt;maxn;++j){ is[i*prime[j]]=1; if(i%prime[j]==0){mu[i*prime[j]]=0;break;} mu[i*prime[j]]=-mu[i]; } } for(register int i=1;i&lt;=2000;++i){ if(!mu[i])continue; for(register int j=i;j&lt;=2000;j+=i) fac[j].push_back(i); } for(register int i=2;i&lt;maxn;++i)mu[i]+=mu[i-1]; int n=read(),m=read(),k=read(),ans=0; printf(&quot;%lld\\n&quot;,f(n,m,k)); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"https://ctz45562.github.io/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"name":"杜教筛","slug":"杜教筛","permalink":"https://ctz45562.github.io/tags/%E6%9D%9C%E6%95%99%E7%AD%9B/"}]},{"title":"洛谷 P2151 [SDOI2009]HH去散步","slug":"洛谷-P2151-SDOI2009-HH去散步","date":"2019-10-17T01:35:10.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/10/17/洛谷-P2151-SDOI2009-HH去散步/","link":"","permalink":"https://ctz45562.github.io/2019/10/17/%E6%B4%9B%E8%B0%B7-P2151-SDOI2009-HH%E5%8E%BB%E6%95%A3%E6%AD%A5/","excerpt":"传送门 朝奈池扔了$400$多个石头没出货啊啊啊啊啊","text":"传送门 朝奈池扔了$400$多个石头没出货啊啊啊啊啊 一个非常显然的$DP$： 设$f(i,j,k)$表示时间$i$到达$j$点，上一条经过的边为$k$。 一个非常显然的转移： $f(i,j,k)\\rightarrow f(i+1,edge(l).to,l)(l\\neq k)$ 用矩乘优化一波，但这样我们发现矩阵大小是$2nm$的，跑不动。 每个点的入边条数是有限的，所以很多状态是无用的，对每个点的所有入边在矩阵上开元素就行了。矩阵大小缩小到$2m$。 总复杂度$O((2m)^3\\log t)$。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #define maxn 100005 #define inf 0x3f3f3f3f const int mod = 45989; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int f[105][55][55],ma[55][65],id[55][65]; vector&lt;int&gt;e[55]; struct Matrix{ int a[130][130],l,c; Matrix operator * (const Matrix &amp;x){ Matrix ans; ans.l=l,ans.c=x.c; for(register int k=0;k&lt;c;++k) for(register int i=0;i&lt;=l;++i) for(register int j=0;j&lt;x.c;++j) ans.a[i][j]=(ans.a[i][j]+a[i][k]*x.a[k][j]%mod)%mod; return ans; } Matrix operator ^ (int y){ Matrix ans=*this,x=ans; --y; while(y){ if(y&amp;1)ans=ans*x; x=x*x,y&gt;&gt;=1; } return ans; } Matrix(){memset(a,0,sizeof a);} }tr,start; int main(){ int n=read(),m=read(),L=read(),s=read()+1,t=read()+1,cnt=0; while(m--){ int x=read()+1,y=read()+1; e[x].push_back(y),e[y].push_back(x); ma[x][e[x].size()-1]=e[y].size()-1; ma[y][e[y].size()-1]=e[x].size()-1; } for(register int i=1;i&lt;=n;++i) for(register int j=0;j&lt;e[i].size();++j) id[i][j]=cnt++; start.l=1,start.c=tr.l=tr.c=cnt; for(register int i=1;i&lt;=n;++i) for(register int j=0;j&lt;e[i].size();++j) for(register int k=0;k&lt;e[i].size();++k) if(j!=k)++tr.a[id[i][j]][id[e[i][k]][ma[i][k]]]; for(register int i=0;i&lt;e[s].size();++i) ++start.a[0][id[e[s][i]][ma[s][i]]]; start=start*(tr^(L-1)); int ans=0; for(register int i=0;i&lt;e[t].size();++i)(ans+=start.a[0][id[t][i]])%=mod; printf(&quot;%d\\n&quot;,ans); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"矩阵乘法","slug":"矩阵乘法","permalink":"https://ctz45562.github.io/tags/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"}]},{"title":"Codeforces433E Tachibana Kanade's Tofu","slug":"Codeforces433E-Tachibana-Kanade-s-Tofu","date":"2019-10-15T12:26:27.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/10/15/Codeforces433E-Tachibana-Kanade-s-Tofu/","link":"","permalink":"https://ctz45562.github.io/2019/10/15/Codeforces433E-Tachibana-Kanade-s-Tofu/","excerpt":"传送门 快 乐 水 题","text":"传送门 快 乐 水 题 这翻译跟那啥一样。。。复述一遍题意： 给定$n$个$m$进制数（可能包含前导$0$），每个数有一个价值$v_i$。定义一个$m$进制数的权值为$\\sum\\limits_{i=1}^ncnt_i\\times v_i$，其中$cnt_i$为第$i$个数在该数中作为子串出现的次数。求$[L,R]$中（$L,R$均为$m$进制数），权值不超过$K$且不含前导零的$m$进制数的个数。 很套路的$AC$自动机上数位$DP$。 设$f(i,0/1,0/1,j,k)$为填到第$i$位、是否顶上界、是否有前导零、位于$AC$自动机的$j$节点、权值为$k$的方案数。 枚举数字刷表转移即可。 转移时要特别注意前导零。如果转移后的状态依然有前导零，权值$k$不会改变，$AC$自动机也不会往下走，因为这点调了一个小时。 复杂度$O(4lenK\\sum|S|m)$，算出来是$O(1.6\\times 10^9)$，刷表时跳过不合法状态再加上滚动数组就能过了。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 205 #define inf 0x3f3f3f3f const int mod = 1e9 + 7; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } #define son(x,y) son[x][y] int en[maxn],line[maxn],son[maxn][20],pre[maxn],L[maxn],R[maxn],s[maxn],f[2][2][2][maxn][505],cnt=1,m,K; void insert(int len,int v){ int node=1; for(register int i=1;i&lt;=len;++i){ if(!son(node,s[i]))son(node,s[i])=++cnt; node=son(node,s[i]); } en[node]+=v; } void build(){ int head=0,tail=1; line[1]=1; for(register int i=0;i&lt;m;++i)son(0,i)=1; while(head&lt;tail){ int node=line[++head],x; en[node]+=en[pre[node]]; for(register int i=0;i&lt;m;++i){ x=son(node,i); if(x)pre[x]=son(pre[node],i),line[++tail]=x; else son(node,i)=son(pre[node],i); } } } inline void add(int &amp;x,int y){x+=y;if(x&gt;=mod)x-=mod;} int solve(int *tp){ int len=tp[0],ans=0; memset(f,0,sizeof f); f[len&amp;1][1][1][1][0]=1; for(register int i=len;i;--i) for(register int j=0;j&lt;2;++j) for(register int k=0;k&lt;2;++k) for(register int l=1;l&lt;=cnt;++l) for(register int p=0;p&lt;=K;++p){ if(!f[i&amp;1][j][k][l][p])continue; for(register int q=j?tp[i]:m-1;~q;--q) if((k&amp;&amp;!q)||p+en[son(l,q)]&lt;=K) add(f[i&amp;1^1][j&amp;&amp;q==tp[i]][k&amp;&amp;!q][(k&amp;&amp;!q)?l:son(l,q)][(k&amp;&amp;!q)?p:p+en[son(l,q)]],f[i&amp;1][j][k][l][p]); f[i&amp;1][j][k][l][p]=0; } for(register int i=1;i&lt;=cnt;++i) for(register int j=0;j&lt;=K;++j) add(ans,(f[0][0][0][i][j]+f[0][1][0][i][j])%mod); return ans; } int main(){ int n=read(); m=read(),K=read(),L[0]=read(); for(register int i=1;i&lt;=L[0];++i)L[L[0]-i+1]=read(); R[0]=read(); for(register int i=1;i&lt;=R[0];++i)R[R[0]-i+1]=read(); while(n--){ int len=read(); for(register int i=1;i&lt;=len;++i)s[i]=read(); insert(len,read()); } build(); int node=1,ans,sum=0; for(register int i=L[0];i;--i)node=son(node,L[i]),sum+=en[node]; ans=sum&lt;=K; printf(&quot;%d\\n&quot;,(solve(R)-solve(L)+ans+mod)%mod); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"字符串","slug":"字符串","permalink":"https://ctz45562.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"AC自动机","slug":"AC自动机","permalink":"https://ctz45562.github.io/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"数位DP","slug":"数位DP","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E4%BD%8DDP/"}]},{"title":"洛谷 P4620 [SDOI2018]荣誉称号","slug":"洛谷-P4620-SDOI2018-荣誉称号","date":"2019-10-12T02:48:01.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/10/12/洛谷-P4620-SDOI2018-荣誉称号/","link":"","permalink":"https://ctz45562.github.io/2019/10/12/%E6%B4%9B%E8%B0%B7-P4620-SDOI2018-%E8%8D%A3%E8%AA%89%E7%A7%B0%E5%8F%B7/","excerpt":"传送门 妈妈我能独立切「SDOI2018R2」的题啦！ 虽然这个题不难","text":"传送门 妈妈我能独立切「SDOI2018R2」的题啦！ 虽然这个题不难 向下取整满足结合律（并不知道为啥，asuldb说这很显然）。然后把那个鬼畜的条件拆开（懒得打向下取整了）： $a_{x/2}+a_{x/2/2}+a_{x/2/2/2}+…\\equiv 0 \\pmod m$ 如果连上边数列就会变成这个样子： 很明显构成了一棵完全二叉树。这个条件就能转化为从任意点出发，向下延伸包含$k+1$个点的路径权值和模$m$等于$0$。 再看上面那张图，令$k=2$，列两个式子： $a_1+a_2+a_4\\equiv 0\\pmod m$ $a_2+a_4+a_8\\equiv 0\\pmod m$ $\\therefore a_1\\equiv a_8\\pmod m$ 同理，$a_1\\equiv a_9\\equiv a_{10}\\equiv…a_{15}$，$a_2\\equiv a_{16}\\equiv a_{17}\\equiv … a_{23}\\pmod m$ 也就是说每个点与其子树内向下第$k+1$层的点最终的权值相等。 这样只要前$k+1$层的路径满足模$m$等于$0$，下面的所有路径就都满足。$DP$的时候要考虑的点数直接降到$2^{k+1}$个。 设$f(i,j)$为点$i$向下延伸至$k+1$层路径权值和模$m$为$j$的最小花费。 $O(n+m^22^{k+1})$预处理一个$v(i,j)$表示将点$i$以及与它相等的点权值全部改为$j$的花费。 直接枚举左右儿子的路径权值转移： $f(i,j)=\\min\\{f(i&lt;&lt;1,k)+f(i&lt;&lt;1|1,k)+v(i,(j-k+m)\\%m)\\}$ 从$2^{k+1}$开始倒着$DP$，答案就是$f(1,0)$。复杂度$O(Tn+Tm^22^{k+1})$。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 10000005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int n,m,k,a[maxn],b[maxn],id[maxn]; long long f[1&lt;&lt;11][200],v[1&lt;&lt;11][200],tax[1&lt;&lt;11][200]; namespace file{ unsigned int SA, SB, SC; int p, A, B; unsigned int rng61(){ SA ^= SA &lt;&lt; 16; SA ^= SA &gt;&gt; 5; SA ^= SA &lt;&lt; 1; unsigned int t = SA; SA = SB; SB = SC; SC ^= t ^ SA; return SC; } void gen(){ n=read(),k=read()+1,m=read(),p=read(),SA=read&lt;unsigned&gt;(),SB=read&lt;unsigned&gt;(),SC=read&lt;unsigned&gt;(),A=read(),B=read(); for(int i = 1; i &lt;= p; i++)a[i]=read()%m,b[i]=read(); for(int i = p + 1; i &lt;= n; i++){ a[i] = (rng61() % A + 1)%m; b[i] = rng61() % B + 1; } } } int main(){ int t=read(); while(t--){ file::gen(); memset(v,0,sizeof v); memset(tax,0,sizeof tax); memset(f,0x3f,sizeof f); for(register int i=1;i&lt;1&lt;&lt;k;++i)tax[id[i]=i][a[i]]=b[i]; for(register int i=1&lt;&lt;k;i&lt;=n;++i)tax[id[i]=id[i/(1&lt;&lt;k)]][a[i]]+=b[i]; for(register int i=1;i&lt;1&lt;&lt;k;++i){ for(register int j=0;j&lt;m;++j){ for(register int k=0;k&lt;j;++k) v[i][j]+=tax[i][k]*(j-k); for(register int k=j+1;k&lt;m;++k) v[i][j]+=tax[i][k]*(j+m-k); } } for(register int i=1&lt;&lt;k-1;i&lt;1&lt;&lt;k;++i) for(register int j=0;j&lt;m;++j) f[i][j]=v[i][j]; for(register int i=(1&lt;&lt;k-1)-1;i;--i) for(register int j=0;j&lt;m;++j) for(register int k=0;k&lt;m;++k) f[i][j]=min(f[i][j],f[i&lt;&lt;1][k]+f[i&lt;&lt;1|1][k]+v[i][(j-k+m)%m]); printf(&quot;%lld\\n&quot;,f[1][0]); for(register int i=1;i&lt;=n;++i)a[i]=b[i]=0; } }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"洛谷 P4516 [JSOI2018]潜入行动","slug":"洛谷-P4516-JSOI2018-潜入行动","date":"2019-10-11T09:25:56.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/10/11/洛谷-P4516-JSOI2018-潜入行动/","link":"","permalink":"https://ctz45562.github.io/2019/10/11/%E6%B4%9B%E8%B0%B7-P4516-JSOI2018-%E6%BD%9C%E5%85%A5%E8%A1%8C%E5%8A%A8/","excerpt":"传送门 又是荒废在搭$blog$的一天，不过成功把稳稳嫖了。","text":"传送门 又是荒废在搭$blog$的一天，不过成功把稳稳嫖了。 设$f(i,j,0/1,0/1)$为在$i$子树中安$j$个装置、$i$是否有儿子安、$i$是否安、满足$i$子树除$i$以外所有点均被覆盖的方案数。 搞个树形背包大力转移： $f(i,j,0,0)=\\sum\\limits_{x\\in son(i),k}f(x,k,1,0)\\times f(i,j-k,0,0)$ $f(i,j,0,1)=\\sum\\limits_{x\\in son(i),k}(f(x,k,0,0)+f(x,k,1,0))\\times f(i,j-k,0,1)$ $f(i,j,1,0)=\\sum\\limits_{x\\in son(i),k}f(x,k,1,0)\\times f(i,j-k,1,0)+(f(i,j-k,0,0)+f(i,j-k,1,0))\\times f(x,k,1,1)$ $f(i,j,1,1)=\\sum\\limits_{x\\in son(i),k}(f(x,k,0,0)+f(x,k,1,0))\\times f(i,j-k,1,1)+(f(x,k,0,1)+f(x,k,1,1))\\times(f(i,j-k,0,1)+f(i,j-k,1,1))$ （转移就是个普及$DP$我也懒得解释了） 这还没完，有一个坑点是不能直接跟树形背包一样直接更新$f$，需要先开个数组把存新的$f$，最后直接覆盖上去。 一开始以为和普通背包一样是防止状态更新顺序混乱，然而倒序循环$j$还是不对。通过输出$f$数组会发现某些状态在加入儿子后会变得不合法，而直接更新$f$是在原有基础上累加方案，不能过滤掉不合法的状态。 复杂度$O(nk)$。然而不知道为啥和树形背包一样枚举$j,k$会被链卡到$5s$，改成刷表转移才过。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 100003 #define inf 0x3f3f3f3f const int mod = 1e9 + 7; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int f[maxn][102][2][2],g[102][2][2],siz[maxn],h[maxn],num,m; struct edge{ int pre,to; }e[maxn&lt;&lt;1]; inline void add(int from,int to){ e[++num]=(edge){h[from],to}; h[from]=num; } inline void up(int &amp;x,long long y){if(y&gt;=mod)y%=mod;x=(x+y)%mod;} void dp(int node=1){ siz[node]=f[node][1][0][1]=f[node][0][0][0]=1; for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(siz[x])continue; dp(x); for(register int j=min(siz[node],m);~j;--j) for(register int k=min(siz[x],m-j);~k;--k){ up(g[j+k][0][0],1ll*f[x][k][1][0]*f[node][j][0][0]); up(g[j+k][0][1],1ll*(f[x][k][0][0]+f[x][k][1][0])*f[node][j][0][1]); up(g[j+k][1][0],1ll*f[x][k][1][0]*f[node][j][1][0]+1ll*f[x][k][1][1]*(f[node][j][0][0]+f[node][j][1][0])); up(g[j+k][1][1],1ll*(f[x][k][0][0]+f[x][k][1][0])*f[node][j][1][1]+1ll*(f[x][k][0][1]+f[x][k][1][1])*(f[node][j][0][1]+f[node][j][1][1])); } siz[node]+=siz[x]; for(register int j=min(siz[node],m);~j;--j){ f[node][j][0][0]=g[j][0][0],g[j][0][0]=0; f[node][j][0][1]=g[j][0][1],g[j][0][1]=0; f[node][j][1][0]=g[j][1][0],g[j][1][0]=0; f[node][j][1][1]=g[j][1][1],g[j][1][1]=0; } } } int main(){ int n=read(); m=read(); for(register int i=1,x,y;i&lt;n;++i)x=read(),y=read(),add(x,y),add(y,x); dp(); printf(&quot;%d\\n&quot;,(f[1][m][1][0]+f[1][m][1][1])%mod); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"洛谷 P3773 [CTSC2017]吉夫特","slug":"洛谷-P3773-CTSC2017-吉夫特","date":"2019-10-10T06:46:27.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/10/10/洛谷-P3773-CTSC2017-吉夫特/","link":"","permalink":"https://ctz45562.github.io/2019/10/10/%E6%B4%9B%E8%B0%B7-P3773-CTSC2017-%E5%90%89%E5%A4%AB%E7%89%B9/","excerpt":"传送门 我好菜啊连卢卡斯都不会了","text":"传送门 我好菜啊连卢卡斯都不会了 卢卡斯搞那一坨组合数： $C_{a_i}^{a_j}\\equiv C_{a_i/2}^{a_j/2}\\times C_{a_i\\%2}^{a_j\\%2}\\pmod 2$ 后面那个$C_{a_i\\%2}^{a_j\\%2}$有四种情况$C_0^0,C_0^1,C_1^0,C_1^1$，其中只有$C_0^1=0$。 然后继续处理$C_{a_i/2}^{a_j/2}$。 我们发现，这就是把$a_i$和$a_j$按二进制拆位了。其中只要出现过$C_0^1$，$C_{a_i}^{a_j}$就等于$0$。 也就是说二进制下不存在某一位$a_i$为$0$而$a_j$为$1$，即$a_j$二进制下是$a_i$的子集。 问题就变成了求子序列的个数，满足每一项在二进制下是前一项的子集。 $a_i\\le 233333$还互不相同，直接设$f(i)$为以$i$为结尾的子序列个数，枚举子集刷表转移就没了。 而且都是它的子集了，就不用考虑序列的单调性了。 复杂度是枚举子集的$O(3^{\\log_2\\max\\{a_i\\}})$。 非常简短的代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 250005 #define inf 0x3f3f3f3f const int mod = 1e9 + 7; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int f[maxn]; int main(){ int n=read(),a,ans=0; for(register int i=1;i&lt;=n;++i){ a=read(); for(register int S=a-1&amp;a;S;S=S-1&amp;a)(f[S]+=f[a]+1)%=mod; (ans+=f[a])%=mod; } printf(&quot;%d\\n&quot;,ans); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"组合数学","slug":"组合数学","permalink":"https://ctz45562.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"卢卡斯定理","slug":"卢卡斯定理","permalink":"https://ctz45562.github.io/tags/%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86/"}]},{"title":"洛谷 P4067 [SDOI2016]储能表","slug":"洛谷-P4067-SDOI2016-储能表","date":"2019-10-10T02:32:08.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/10/10/洛谷-P4067-SDOI2016-储能表/","link":"","permalink":"https://ctz45562.github.io/2019/10/10/%E6%B4%9B%E8%B0%B7-P4067-SDOI2016-%E5%82%A8%E8%83%BD%E8%A1%A8/","excerpt":"传送门 神仙数位$DP$。","text":"传送门 神仙数位$DP$。 仅考虑$i\\ xor\\ j\\ge k$的数对，答案就是所有$\\sum\\sum[i\\ xor\\ j\\ge K] i\\ xor\\ j-K\\times\\sum\\sum[i\\ xor\\ j\\ge K]$ 二进制下数位$DP$。设$f(i,0/1,0/1,0/1)$为填到第$i$位、第一个数是否顶着$n$上界、第二个数是否顶着$m$上界、异或结果是否顶着$K$下界的所有异或结果大于等于$K$的数对的异或的算术和，$g(i,0/1,0/1,0/1)$为方案数。 套路数位$DP$，枚举第$i$位上的数字刷表转移就行了。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 704 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } long long f[62][2][2][2],g[62][2][2][2]; int N[62],M[62],K[62],pw[62]={1}; inline void work(long long x,int *a){ for(register int i=61;i;--i)a[i]=x&gt;&gt;(i-1)&amp;1; } int main(){ int t=read(); while(t--){ long long n=read&lt;long long&gt;()-1,m=read&lt;long long&gt;()-1,p=read&lt;long long&gt;(),rec=p; int mod=read(); work(n,N),work(m,M),work(p,K); memset(f,0,sizeof f),memset(g,0,sizeof g); for(register int i=1;i&lt;=60;++i)pw[i]=(pw[i-1]&lt;&lt;1)%mod; g[61][1][1][1]=1; for(register int i=61;i;--i) for(register int j=0;j&lt;2;++j) for(register int k=0;k&lt;2;++k) for(register int l=0;l&lt;2;++l) for(register int a=0;a&lt;=(j?N[i]:1);++a) for(register int b=0;b&lt;=(k?M[i]:1);++b){ int c=a^b; if(l&amp;&amp;c&lt;K[i])continue; (g[i-1][j&amp;&amp;a==N[i]][k&amp;&amp;b==M[i]][l&amp;&amp;c==K[i]]+=g[i][j][k][l])%=mod; (f[i-1][j&amp;&amp;a==N[i]][k&amp;&amp;b==M[i]][l&amp;&amp;c==K[i]]+=f[i][j][k][l]+(c?g[i][j][k][l]*pw[i-1]:0))%=mod; } long long ans=0; rec%=mod; for(register int i=0;i&lt;2;++i) for(register int j=0;j&lt;2;++j) for(register int k=0;k&lt;2;++k) (ans+=f[0][i][j][k]-rec*g[0][i][j][k])%=mod; printf(&quot;%lld\\n&quot;,(ans+mod)%mod); } }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数位DP","slug":"数位DP","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E4%BD%8DDP/"}]},{"title":"洛谷 P3761 [TJOI2017]城市","slug":"洛谷-P3761-TJOI2017-城市","date":"2019-10-09T06:49:09.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/10/09/洛谷-P3761-TJOI2017-城市/","link":"","permalink":"https://ctz45562.github.io/2019/10/09/%E6%B4%9B%E8%B0%B7-P3761-TJOI2017-%E5%9F%8E%E5%B8%82/","excerpt":"传送门 绝不严谨推理，只管大胆胡猜。","text":"传送门 绝不严谨推理，只管大胆胡猜。 题意就是任意删掉一条边，再添加一条等长的边，保证仍然是一棵树的前提下最小化新树的直径。 显然要从原树的直径上删。如果不是的话新树的直径没变，不优。 $n\\le 5000$直接暴力枚举直径上的边。删掉后直径要么是分裂出的两棵树的直径，要么是连边后产生的新直径。 两棵树合并后，新树的直径两端点一定是在这两棵树四个直径端点里取到。 再对这两棵树求直径，在这两条直径上挑两个点连起来一定最优。 至于挑哪两个点，当然是中点了。 于是$O(n^2)$就能水过去了。 还有个$O(n)$的做法， 过于神仙，告辞。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 5005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } struct edge{ int pre,fr,to,l; bool vis; }e[maxn&lt;&lt;1]; int h[maxn],a[maxn],deep[maxn],edg[maxn],fa[maxn],num=1,root,ma; inline void add(int from,int to,int l){ e[++num]=(edge){h[from],from,to,l,0}; h[from]=num; } void dfs(int node,int len=0){ if(len&gt;ma)ma=len,root=node; for(register int i=h[node],x;i;i=e[i].pre){ if(e[i].vis)continue; x=e[i].to; if(x==fa[node])continue; fa[x]=node,a[x]=i; dfs(x,len+e[i].l); } } pair&lt;int,int&gt; get_diameter(int rt){ int node; fa[rt]=0,ma=-1,dfs(rt),fa[node=root]=0,ma=-1,dfs(node); return make_pair(node,root); } int main(){ int n=read(),cnt=0,ans=inf; for(register int i=1,x,y,z;i&lt;n;++i)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z); pair&lt;int,int&gt;o=get_diameter(1); while(o.second!=o.first)edg[++cnt]=a[o.second],o.second=fa[o.second]; for(register int i=1;i&lt;=cnt;++i){ e[edg[i]].vis=e[edg[i]^1].vis=1; int all=0,mi=inf,_mi=inf,ma1,ma2; o=get_diameter(e[edg[i]].fr),ma1=ma; if(o.first==o.second)mi=0; while(o.first!=o.second)all+=e[a[o.second]].l,mi=min(mi,max(ma-all,all)),o.second=fa[o.second]; all=0,o=get_diameter(e[edg[i]].to),ma2=ma; if(o.first==o.second)_mi=0; while(o.first!=o.second)all+=e[a[o.second]].l,_mi=min(_mi,max(ma-all,all)),o.second=fa[o.second]; ans=min(ans,max(mi+_mi+e[edg[i]].l,max(ma1,ma2))); e[edg[i]].vis=e[edg[i]^1].vis=0; } printf(&quot;%d\\n&quot;,ans); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"枚举","slug":"枚举","permalink":"https://ctz45562.github.io/tags/%E6%9E%9A%E4%B8%BE/"}]},{"title":"Codeforces521D Shop","slug":"Codeforces521D-Shop","date":"2019-10-07T23:19:49.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/10/08/Codeforces521D-Shop/","link":"","permalink":"https://ctz45562.github.io/2019/10/08/Codeforces521D-Shop/","excerpt":"传送门 快乐是怎么消失的呢，海楠绵宝宝。。。","text":"传送门 快乐是怎么消失的呢，海楠绵宝宝。。。 青岛国庆六日游做的唯一一道题。 显然按$1\\rightarrow 2\\rightarrow 3$的顺序操作是最优的。 答案是乘积最大值，如果只有$3$操作排序一波就好了。 考虑把$1,2$操作转成$3$操作。 赋值同一个位置只取最大的，转成加法。 加法一定是优先取较大的，这样每一个加法操作前的值都是固定的，用操作后的值比上操作前的作为价值转为乘法。 用浮点数大概是精度问题会$WA$，直接存分子分母排序时会爆$long\\ long$，需要分子统一减去分母，对答案没有影响。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 200005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } struct operation{ int type,num; long long s,m; bool operator &lt; (const operation &amp;x)const{ if(s*x.m!=m*x.s)return s*x.m&gt;m*x.s; return type&lt;x.type; } }fin[maxn]; inline bool cmp(const operation &amp;x,const operation &amp;y){return x.type&lt;y.type;} int a[maxn],ma[maxn][2]; vector&lt;operation&gt;o[maxn][2]; int main(){ int n=read(),m=read(),k=read(),x,y,len=0; operation p; for(register int i=1;i&lt;=n;++i)a[i]=read(); for(register int i=1;i&lt;=m;++i){ p.type=read(),x=read(),p.s=read(),p.m=1,p.num=i; if(p.type==1){ if(ma[x][0]&lt;p.s)ma[x][0]=p.s,ma[x][1]=i; continue; } if(p.type==3)--p.s; o[x][p.type-2].push_back(p); } for(register int i=1;i&lt;=n;++i){ long long sum=a[i]; if(ma[i][0]&gt;a[i])o[i][0].push_back((operation){1,ma[i][1],ma[i][0]-a[i],1}); sort(o[i][0].begin(),o[i][0].end()); for(vector&lt;operation&gt;::iterator iter=o[i][0].begin();iter!=o[i][0].end();++iter){ fin[++len]=(operation){iter-&gt;type,iter-&gt;num,iter-&gt;s,sum}; sum+=iter-&gt;s; } for(vector&lt;operation&gt;::iterator it=o[i][1].begin();it!=o[i][1].end();++it)fin[++len]=*it; } k=min(k,len); printf(&quot;%d\\n&quot;,k); sort(fin+1,fin+1+len); sort(fin+1,fin+1+k,cmp); for(register int i=1;i&lt;=k;++i)printf(&quot;%d &quot;,fin[i].num); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://ctz45562.github.io/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"降智の应急处理笔记","slug":"IQ-improvement","date":"2019-09-27T03:03:04.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/09/27/IQ-improvement/","link":"","permalink":"https://ctz45562.github.io/2019/09/27/IQ-improvement/","excerpt":"智商不够用，刷$DP$来凑。","text":"智商不够用，刷$DP$来凑。 前言和我去年同一时间的状态一样开始刷$DP$，预示了我$CSP$凉凉的结局。 题单来源于asuldb。以前做过的就不整理了，还混有一些我绝不会碰的题和抄不动题解自闭了的题也不写了。 至于后面没有出现的题，那就是刷不动了。 $update$:一些我被降智的题也被收录了。 DP的精髓——asuldb[GDOI2014]拯救莫莉斯$n\\times m\\le 50$，$\\min\\{n,m\\}\\le 7$，考虑状压。（以下$n&gt;m$） 设$f(i,j,k)$为前$i$行，第$i-1$行状态为$j$，第$i$行状态为$k$的最小花费。 先$O(m2^{3m})$处理出每个状态$j,k$能向那些状态转移，且$k$的油库满足。 然后直接$O(n2^{3m})$转移即可，还要输出方案数随便搞一搞就行了。 这样第一行和最后一行可能不满足，预处理和取答案时判断一下就好了。 [APIO2010]巡逻$k=1$显然是在直径两端点连边。 $k=2$时，若连的两端点形成的环与第一条边形成的环有交，交集的边就要走两次，也就是抵消了第一条边的贡献。 把直径上的边权值改为$-1$再求一遍直径即可。 [AHOI2008]逆序对题解 奇妙的性质：填进去的数是单调不降的。 然后就$O(nk)$随便$DP$了。 [NOI2009]管道取珠考虑$\\sum a_i^2$的含义：有两套管道，两套管道取出的珠子序列相同的方案数。 设$f(i,j,k,l)$为第一套上管道取了$i$个，下管道取了$j$个，第二套上管道取了$k$个，下管道取了$l$个，所得序列相同的方案数。 $i+j=k+l$可以消掉一维。 刷表转移：$f(i,j,k)\\rightarrow \\begin{cases}f(i+1,j,k+1)&amp;a_{i+1}=a_{k+1}\\\\f(i+1,j,k)&amp;a_{i+1}=b_{i+j-k+1}\\\\f(i,j+1,k+1)&amp;b_{j+1}=a_{k+1}\\\\f(i,j+1,k)&amp;b_{j+1}=b_{i+j-k+1}\\end{cases}$ [CQOI2018]解锁屏幕$n\\le 20$直接状压。 搞个状态数组$s[i][j]$，将点$i,j$间连线，经过的点在$s[i][j]$对应位上是$1$。 设$f(i,j)$表示状态为$j$（$1$表示已使用过），最后一个点为$i$的方案数，结合$s$数组随便转移即可。 [APIO2007]动物园状压。设$f(i,j)$为前$i$个围栏，第$i\\sim i+4$个围栏的状态为$j$（$1$表示留下）的最多高兴人数。 $O(n2^5)$预处理数组$cnt[i][j]$表示仅考虑第$i$个位置的人，$i\\sim i+4$的状态为$j$的高兴人数。 由于是个环，枚举第一个位置的状态依次$DP$，刷表转移$f(i,j)+cnt[i+1][j&gt;&gt;1]\\rightarrow f(i+1,j&gt;&gt;1),f(i,j)+cnt[i+1][j&gt;&gt;1|16]\\rightarrow f(i+1,j&gt;&gt;1|16)$ 取答案时只取与当前枚举的状态符合的答案。复杂度$O(2^{10}n)$。 [HAOI2015]树上染色考虑每条边的贡献。设$f(i,j)$为在子树$i$中钦定$j$个黑点，里面的边对整棵树的最大贡献。 转移时考虑连向子节点的边的贡献，即两侧黑点数的乘积加上白点数的乘积。 $f(i,j)=\\max\\limits_{x\\in son(i)}\\{f(i,j-k)+f(x,k)+edge(i,x).l\\times[k\\times(K-k)+(size_x-k)\\times(n-K-size_x+k)]\\}$ [SDOI2017]序列计数一开始我是想设$f(i,j,0/1)$表示前$i$个数、和模$p$等于$j$、是否出现过质数的方案数。 后来发现都搞的容斥。。。 设$f(i,j)$为前$i$个数、和模$p$等于$j$的方案数，枚举数字转移。两遍$DP$，第一遍没有限制，第二遍只枚举合数。用第一遍的减去第二遍的就是答案。 再来个矩乘优化就行了。 [SDOI2008]山贼集团$p\\le 12$显然状压。 设$f(i,j)$表示子树$i$状态为$j$（$1$表示在子树$i$建立分部）的最大收益。 转移类似树形背包：$f(i,j)=\\max\\limits_{x\\in son(i),(k)_2\\subseteq (j)_2}\\{f(x,k)+f(i,k\\ xor\\ j)\\}$ 其中$k\\ xor\\ j$相当于取补集。 由于要枚举子集，复杂度是$O(n3^p)$的。 [SDOI2009]Bill的挑战状压。第一眼以为要上$AC$自动机，发现串长都相等直接暴力$DP$。 $O(26|S|)$预处理一个状态数组$g[i][j]$，二进制下第$x$位为$1$表示$S_x$第$i$位是字母$j$或$?$。 设$f(i,j)$为填到第$i$位，当前还能匹配的串为状态$j$。 枚举字母刷表转移： $f(i,j)\\rightarrow f(i+1,j\\&amp;g[i+1][‘a’\\sim’z’])$ 复杂度$O(T26|S|2^n)$。 [POI2015]WIL-Wilcze doły这题和$DP$没啥关系。 不过我还是十分睿智地写了个二分，$O(2000000\\log 2000000)$才$4e7$不慌。 记$sum$为前缀和，$ma_i$为$sum_{i+d}-sum_{i-1}$。 某个区间的最小权值就是区间和减去长度为$d$的最大子段和，即$sum_r-sum_{l-1}-\\max\\limits_{i=l}^{r-d+1}\\{ma_i\\}$。 然后尺取就好了啊，中间要维护一个左右端点单调不降的区间$\\max$，上单调队列。 当然如果和我一样$zz$非要写二分我也不拦你。 [USACO09DEC]牛收费路径Cow Toll Paths非要说和$DP$有啥关系的话，大概是$floyd$吧。 直接对点权排序跑$floyd$就完了。 [USACO12FEB]附近的牛Nearby Cows题单逐渐水了起来。。。 由于$k\\le 20$，直接算出$f(i,j)$表示$i$子树中与$i$距离为$j$的点权和。 然后暴力跳$k$层父亲算上祖先的贡献，还要容斥减掉同一棵子树的点。 [USACO13NOV]没有找零No Change状压。 设$f(i)$为状态为$i$（$1$表示已用过该硬币）能买的最多的物品数。 枚举下一个用的硬币，二分出最大能买到的位置，刷表转移。复杂度$O(k2^k\\log n)$。 答案在满足$f(i)=n$的$i$里取即可。 [SCOI2009]粉刷匠一开始以为可以随便刷，是个神仙题。 后来发现只能横向刷，瞬间沦为$zz$题。 对每行处理出一个$g(i,j)$，表示该行对前$i$个格子刷$j$次最多的正确格子数。 转移就枚举上次刷的位置和刷的颜色：$g(i,j)=\\max\\limits_{k=0}^{i-1}\\{g(k,j-1)+\\max\\{sum_i-sum_k,i-k-sum_i+sum_k\\}\\}$（$sum_i$为前$i$个格子中蓝色格子数） 把每行看作一组，枚举刷的次数，$g(m,i)$看作若干件物品，直接做个分组背包即可。 [HAOI2008]木棍分割就是跳石头统计方案数。 $O(n\\log n)$预处理出每个点最靠左的端点$le_i$满足$sum_i-sum_{le_i}\\le ans$。 设$f(i,j)$为跳了$j$步到点$i$的方案数。 普及难度的转移：$f(i,j)=\\sum\\limits_{k=le_i}^{i-1}f(k,j-1)$ $O(nm)$的空间开不下。然后思维僵化了，$i$的取值与前面的都有关系滚不动咋办啊。 第一维滚不动滚第二维啊。 再来个前缀和优化就没了。 [TJOI2017]城市水の题解 简单题设$f(i)$为所有子集和中，$i$是否出现了奇数次。 实际上这就是个完全背包变形，bitset优化即可。 最后答案把所有$f(i)=1$的$i$异或起来。 复杂度$O(n\\sum a_i/32)$ Codeforces1025D Recovering BST先$O(n^2\\log a_i)$把边处理出来。 容易想到设$f(i,j,k)$为取$[j,k]$的点能否构成以$i$为根的$BST$。 然而时空都受不了。 重新搞状态：设$l(i,j)$为取$[i,j]$的点能否构成以$i$为根的$BST$，$r(i,j)$为取$[i,j]$的点能否构成以$j$为根的$BST$。 做个区间$DP$。若存在$l(1,i)\\&amp;r(i,n)=1$则可行。 [SNOI2017]英雄联盟正当逐渐走向自闭时，眼前一晃而过一抹绿色。 设$f(i,j)$为前$i$个英雄，用$j\\ QB$能买出的最大展示策略。 这不就一分组背包吗。 $f(i,j)=\\max\\limits_{k=1}^{K_i}\\{f(i-1,j-k\\times C_i)\\times k\\}$ 算一下$n$最大才$120$，背包容量也不超过$300000$。滚动数组优化一波就水过去了~ [SDOI2016]储能表题解 [CTSC2017]吉夫特题解 [JSOI2018]潜入行动题解 [SDOI2018]荣誉称号题解 [CQOI2007]涂色我是不是要重学区间$DP$了 设$f(i,j)$为涂完区间$[i,j]$的最少次数。 初始$f(i,i)=1$。 讨论转移： 若$a_i=a_j$，可以涂$a_i$的时候一块把$a_j$涂了，或者反过来，即$f(i,j)=\\min\\{f(i+1,j),f(i,j-1)\\}$ 若$a_i\\neq a_j$，枚举断点合并，$f(i,j)=\\min\\limits_{k=i}^{j-1}\\{f(i,k)+f(k+1,j)\\}$ Alice in linear land神仙题。 题意： 数轴原点上有一个机器人，终点为$D$。有$n$条命令，每条命令为$d_i$，机器人会向终点移动$d_i$距离，若移动后距离变大则不移动。给定$m$次询问，允许改变$d_{q_i}$为任意整数，若存在方案使机器人不能走到终点输出$YES$，否则输出$NO$。 先处理出$pos_i$，表示前$i$条命令后与终点的距离。 考虑一个朴素的$DP$，设$g(i,j)$为当前与终点距离为$j$，仅后$i$条指令能否到达终点。 转移：$g(i,j)=\\begin{cases}g(i+1,j)&amp;d_i\\ge 2j\\\\g(i+1,d_i-j)&amp;j&lt;d_i&lt;2j\\\\g(i+1,j-d_i)&amp;d_i\\le j\\end{cases}$ 修改$d_i$时，可视为改变到终点的距离，取值范围$[0,pos_{i-1}]$。若$g(i+1,[0,pos_{i-1}])$存在$0$的话，就把距离改过去，就不能走到终点了。 发现我们只需求出满足$g(i,j)=0$的最小的$j$，设$f(i)$为该值。 类比$g$转移： $f(i)=\\min\\begin{cases}f(i+1)&amp;d_i\\ge2f(i+1)\\\\d_i-f(i+1)&amp;d_i&gt;2f(i+1)\\\\f(i+1)+d_i\\end{cases}$ 初值$f(n+1)=1$，因为任意$g(i,0)=1$。 询问时判断$pos_{q_i-1}$与$f(q_i+1)$的大小即可。 [JSOI2016]最佳团体一看$\\dfrac{\\sum p_i}{\\sum s_i}$这样的式子就跑不掉$01$分数规划。 二分答案，问题转化为判定是否存在方案选$k$个人，使$\\sum p_i-\\sum mid\\times s_i\\ge 0$。 然后就是树形背包了。 话说$O(nk\\log)$能跑过去真是神奇。 さようなら ，IQ さんCodeforces55D Beautiful numbers数位$DP$。模$2520$的余数肯定是要记的。 然后钻到状压每个数字是否出现的牛角尖里出不来了。 实际上从$1\\sim 9$选若干个数，它们的$lcm$情况不到$50$种，把这个作为状态就没了。 Codeforces815C Karen and Supermarket硬核可怜题。 显然是个树形背包，但这个依赖关系是对优惠券来说的。 尝试构造这棵树，失败，告辞。 实际上再加一维$0/1$表示该点是否用优惠券就行了。。。 Codeforces1114D Flood Fill区间$DP$再起不能。 设$f(i,j)$为使区间$[i,j]$同色的最小次数。 若$i,j$同色，可以把$[i+1,j-1]$涂好后再变成$i$的颜色：$f(i,j)=f(i+1,j-1)+1$ 若$i,j$不同色，就从$[i+1,j]$和$[i,j-1]$里选代价最小的转移：$f(i,j)=\\min\\{f(i,j-1),f(i+1,j)\\}+1$ Codeforces922E Birds看数据范围状态显然与$n$和$\\sum c_i$有关。 设$f(i,j)$为到了第$i$棵树，有$j$只鸟的最大魔法值。 由于$B$是固定的，魔法上限也就确定了。直接枚举召唤几只鸟转移。 复杂度不对。然后优化，优化，优化。。。咋优化啊？ 这$TM$不就是个多重背包吗！二进制优化啊！ 有一点要注意的是不能直接把每棵树拆成若干件物品做$01$背包，只有当跨了一棵树才能魔法值$+X$。对每棵树单独背包，拆分前先把所有$f(i,j)$ 统一$+X$。 Codeforces983B XOR-pyramid$n\\le 5000$考虑$O(n^2)$预处理。 列个更美观的表： 1: 1 2 4 8 2: 3 6 12 3: 5 10 4: 15 设$f(i,j)$为$a$数组经过$i$轮变换，第$j$位上的数字是多少。 观察得到转移：$f(i,j)=f(i-1,j)xorf(i-1.j+1)$ 再观察可知：$f(i,j)$表示了$j$为左端点，长度为$i$的区间权值。 设$g(i,j)$为左端点大于等于$j$，长度不大于$i$的最大区间权值。 $g(i,j)=\\max\\{f(i,j),f(i-1,j+1),f(i-1,j)\\}$ [SHOI2008]循环的债务先搞个宏伟的$DP$数组： $f(i,j,k,a100,a50,a20,a10,a5,a1,b100,b50,b20,b10,b5,b1,c100,c50,c20,c10,c5,c1)$ 慢慢优化，优化不动，自闭了。 每种钞票是独立的，所以设$f(i,j,k)$为前$i$种钞票，$Alice$有$j$元，$Bob$有$k$元。钱的总和是定值所以把$Ciyang$压没了。(暝阳·梅勒) 枚举交换完第$i$种钞票后$Alice,Bob$分别有多少张$i$钞票，没了。 ATcoder3870 Reversed LCS我又双叒叕被区间$DP$虐了。 显然与反串的$LCS$是最长回文子序列长度。 设$f(i,j,k)$为区间$[i,j]$修改$k$个字符的最大值。 转移： 啥都不干：$f(i,j,k)=\\max\\{f(i+1,j,k),f(i,j-1,k)\\}$ $s_i$与$s_j$相同，回文子序列延长：$f(i,j,k)=\\max\\{f(i,j,k),f(i+1,j-1,k)+2\\}$ $k&gt;0$，修改$s_i$或$s_j$：$f(i,j,k)=\\max\\{f(i,j,k),f(i+1,j-1,k-1)+2\\}$ Codeforces946G Almost Increasing Array被同一场的F题吓到了，然而$G$比$F$简单？ 如果不带删除，其实是一个套路： 还是求最长上升子序列，考虑最朴素的方程$f(i)=\\max\\{f(j)\\}+1(j&lt;i,a_j&lt;a_i)$ 现在可以任意修改，要满足区间$[j,i]$能修改成上升的，所以还有个条件$i-j\\le a_i-a_j$。 我们发现这三个大小关系可以合并成$j&lt;i,a_i-i\\ge a_j-j$，令$a_i$减去$i$，求一遍最长不下降子序列，答案就是$n-\\max\\{f(i)\\}$。 考虑加上删除，让$f$再加一维$0/1$表示是否用过删除。 转移： $f(i,0)=\\max\\{f(j,0)\\}+1(j&lt;i,a_j\\le a_i)$ 在$j$之前用删除：$f(i,1)=\\max\\{f(j,1)\\}+1(j&lt;i,a_j\\le a_i)$ 在$[j+1,i-1]$之间用删除：$f(i,1)=\\max\\{f(j,0)\\}+1(j&lt;i-1,a_j\\le a_i+1)$ 由于在转移时没有考虑到被删的数不需要再修改了，所以答案为$\\max\\{n-\\max\\{f(i,0),f(i,1)\\}+1,0\\}$ 离散化+树状数组就能优化到$O(n\\log n)$。 Codeforces940E Cashback按分段长度$len$分别考虑： $len&lt;c$，这时不会去掉任何数。无论$len$为多少代价都是这一段的和，把它看做$len$个长度为$1$的段处理。 $len\\ge c$。设它要去掉$k$个数。定义$kth(A,k)$为可重集$A$的前$k$小数的和。显然有$\\sum\\limits_{i=1}^kkth(A_i,1)\\ge kth(\\bigcup\\limits_{i=1}^kA_i,k)$。所以当$len=c$时是最优的。 设$f(i)$为分完前$i$个数的最小代价。 根据上面两条，$f(i)=\\min\\{f(i-1)+a_i,f(i-k)+\\min\\{a_j\\}\\}(j\\in[i-k+1,i])$。 要维护一个滑动窗口的$\\min$，单调队列即可。 Codeforces505C Mr. Kitayuta, the Treasure Hunter大概是观摩一个沙雕网友过多了，从昨天下午起全机房都石乐志。我的智力水平再次刷新下限，已经切不动绿题了。 很自然能想到设$f(i,j)$为跳到位置$i$，上一步跳了$j$步的最大宝藏数。 $O(30000\\times 30000)$不大行。 我们发现真正有用的状态不多，可以队列优化$DP$，但是数组还是滚不起来。 于是我们得到了空间爆炸、时间无保证的优秀做法。 根据逛公园的经验，把状态定义改为跳到位置$i$，上一步跳的步数与第一步的步数差值为$j$的最大宝藏数。 最差情况是第一步为$1$，之后依次递增，等差数列求和会发现$j$最大不超过$300$。 这就没了啊。 [TJOI2013]拯救小矮人显然要让难出去的人先出去，按$a_i+b_i$排序。 设$f(i)$为跑了$i$个人剩下人的最大高度，搞个背包。 [ZJOI2006]超级麻将设$f(i,j,k,0/1)$为考虑到第$i$张牌，第$i-1$张牌剩余$j$张，第$i-2$张牌剩余$k$张，是否打出过对子，前$i-3$张牌都已打完是否可行。 先在内部把打$2,3,4$张的情况考虑完： $f(i,j,k,0/1)\\rightarrow \\begin{cases}f(i,j-3,k,0/1)\\\\f(i,j-4,k,0/1)\\\\f(i,j,k-3,0/1)\\\\f(i,j,k-4,0/1)\\end{cases}$ $f(i,j,k,0)\\rightarrow\\begin{cases}f(i,j-2,k,1)\\\\f(i,j,k-2,1)\\end{cases}$ 最后考虑顺子，因为要保证前$i-3$张都打完，$k$是多少就要打多少个顺子： $f(i,j,k,0/1)\\rightarrow f(i+1,a_i-k,j-k,0/1)$ 需要$DP$到$f(102,j,k,0/1)$，$f(103,0,0,1)$即为答案。 Codeforces846E Chemistry in Berland显然连上边是棵树。$DP$没啥难的，设$f(i)$为点$i$的需求量，$f(i)$为负表示有剩余。 贪心转移，如果儿子有剩余就全转过来，否则$i$需要给儿子转化。 $f(i)=a_i-b_i+\\sum\\limits_{j\\in son(i)}f(j)\\times [f(j)0]$ 判一下$f(1)$是否小于等于$0$就行。 然而这题很坑的地方是$f$的最大值$n\\times a\\times k$会爆$long\\ long$。 可以高精，本来$DP$是$O(n)$的压压位没问题。 更巧妙的处理方法：观察方程，$f(i)$单次最多减少$b$，$n$个点最多减少$n\\times b\\le 10^{17}$。所以$f(i)$只要超过$10^{17}$，就不可能达到要求，直接输出”NO”即可。 Codeforces727F Polycarp’s problems这都做不动是基本告别自行车了。 最简单的是贪心。倒着考虑，这个问题本质上就是用前面的正数尽可能多的抵消后面的负数。剩下的交给$b_i$解决。 非常显然的普及贪心，一个正数要优先抵消较大的负数。维护一个堆倒着扫一遍。 最后把堆里的元素取出来做个前缀和，对每个询问二分出$b_i$最大能抵消到哪儿。为了照顾$DP$所以$n\\le 750$，直接$O(nm)$枚举都行。 比贪心难想还不如贪心优的$DP$做法： 设$f(i,j)$为$i\\sim n$删掉$j$道题最小需要的心情。 枚举$i$删或不删：$f(i,j)=\\min\\{f(i+1,j-1),\\max\\{f(i+1,j)-a_i,0\\}\\}$ 最后在$f(1,i)$上二分或枚举。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ctz45562.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"贪心","slug":"贪心","permalink":"https://ctz45562.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"状态压缩","slug":"状态压缩","permalink":"https://ctz45562.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"},{"name":"数位DP","slug":"数位DP","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E4%BD%8DDP/"},{"name":"图论","slug":"图论","permalink":"https://ctz45562.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"洛谷 P4280 [AHOI2008]逆序对","slug":"洛谷-P4280-AHOI2008-逆序对","date":"2019-09-26T12:19:20.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/09/26/洛谷-P4280-AHOI2008-逆序对/","link":"","permalink":"https://ctz45562.github.io/2019/09/26/%E6%B4%9B%E8%B0%B7-P4280-AHOI2008-%E9%80%86%E5%BA%8F%E5%AF%B9/","excerpt":"传送门 深感智商下降，又开始刷$DP$了。","text":"传送门 深感智商下降，又开始刷$DP$了。 这题关键在于一个很重要的性质：填进去的数字是单调不降的。 考虑我有一个$a$和$b$，$a\\le b$。把$b$放到$a$前面，$a,b$会构成逆序对，而且把大的数放前面，与其他数会产生更多的逆序对，显然不优。 这样就随便$DP$了，设$f(i,j)$为前$i$个空位第$i$个空位为$j$的最小逆序对数。 $f(i,j)=\\min\\limits_{l=1}^jf(i-1,l)+S$ 其中$S$表示把$j$放在第$i$个空位与其他非空位产生的逆序对数。 维护前缀最小值+暴力修改前缀和就能$O(nk)$做了。最后答案还要加上序列原有的逆序对。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 10005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int f[2][105],a[maxn],sum[105],rev[105]; int main(){ int n=read(),m=read(),last=0,ans=0; for(register int i=1;i&lt;=n;++i){ a[i]=read(); if(~a[i])++rev[a[i]]; } for(register int i=1;i&lt;=m;++i)rev[i]+=rev[i-1]; for(register int i=1;i&lt;=n;++i){ if(a[i]==-1){ f[++last&amp;1][0]=inf; for(register int j=1;j&lt;=m;++j) f[last&amp;1][j]=min(f[last&amp;1][j-1],f[last&amp;1^1][j]+sum[m]-sum[j]+rev[j-1]); } else { for(register int j=a[i];j&lt;=m;++j)--rev[j],++sum[j]; ans+=rev[a[i]-1]; } } printf(&quot;%d\\n&quot;,f[last&amp;1][m]+ans); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"洛谷 P3242 [HNOI2015]接水果","slug":"洛谷-P3242-HNOI2015-接水果","date":"2019-09-25T02:25:24.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/09/25/洛谷-P3242-HNOI2015-接水果/","link":"","permalink":"https://ctz45562.github.io/2019/09/25/%E6%B4%9B%E8%B0%B7-P3242-HNOI2015-%E6%8E%A5%E6%B0%B4%E6%9E%9C/","excerpt":"传送门 不要…不要误会，我不是针对莫队，我是说在座的莫队都假了。 （虽然我也写的假莫队）","text":"传送门 不要…不要误会，我不是针对莫队，我是说在座的莫队都假了。 （虽然我也写的假莫队） 给你一棵树和若干条带权模式链，多次询问，给出一条链，求所有为其子链的模式链中，权值第$k$小是多少。 用树上莫队+分块解决。 关键在于怎么判断某条模式链是否为当前区间代表的链的子链。 首先能想到每个点开一个vector，把每个模式链插进两端点的vector中。移动指针时，扫一遍vector，如果一条链的另一个端点也位于当前链，就把它加进块里/从块里删除。 但这个做法复杂度对吗？ 用vector存信息时，必须保证每个vector被遍历的次数是均等的，才能把复杂度均摊掉。 显然莫队不能保证每个位置被扫过的次数是均等的。通俗来讲，莫队的指针移动次数是$O(n\\sqrt{m})$的，但每个位置被扫过的次数不是$O(\\sqrt{m})$的。 这样卡掉这个做法就很容易了，将模式链全部插入第一个块里，询问左端点也全放到第一个块里，构造右端点，使排序后的询问左端点会呈这种方式移动： 复杂度就是$O(nm)$的。只不过数据水没卡。 解决方案：把每个位置按vector的元素拆成若干个新点，重新制定询问区间。在新序列和新询问区间上跑莫队。 然而这样写很麻烦，细节很繁琐，所以我还是写的假莫队 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #define maxn 80005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int son[maxn],siz[maxn],seg[maxn],deep[maxn],fa[maxn],top[maxn],dis[maxn],ans[maxn],len; int fir[maxn],en[maxn],be[maxn],pos[maxn],h[maxn],bel[maxn],bc[maxn],c[maxn],num,cnt,all; vector&lt;pair&lt;int,int&gt; &gt;p[maxn]; vector&lt;pair&lt;int,int&gt; &gt;::iterator iter; bool vis[maxn]; struct edge{ int pre,to; }e[maxn]; struct Query{ int l,r,num,lc,k; bool operator &lt; (const Query &amp;x)const{ if(be[l]!=be[x.l])return be[l]&lt;be[x.l]; if(be[l]&amp;1)return r&lt;x.r; return r&gt;x.r; } }q[maxn&gt;&gt;1]; inline void adde(int from,int to){ e[++num]=(edge){h[from],to}; h[from]=num; } void dfs1(int node=1){ pos[fir[node]=++cnt]=node; siz[node]=1; for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(siz[x])continue; deep[x]=deep[node]+1,fa[x]=node; dfs1(x),siz[node]+=siz[x]; if(siz[x]&gt;siz[son[node]])son[node]=x; } pos[en[node]=++cnt]=node; } void dfs2(int node=1){ seg[node]=++all; if(!son[node])return; int x; top[son[node]]=top[node],dfs2(son[node]); for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(!seg[x])top[x]=x,dfs2(x); } } int lca(int x,int y){ while(top[x]!=top[y])deep[top[x]]&lt;deep[top[y]]?y=fa[top[y]]:x=fa[top[x]]; return deep[x]&lt;deep[y]?x:y; } void process(int x,int y,int k,int i){ int l=lca(x,y); if(l!=x&amp;&amp;l!=y){ if(en[x]&gt;fir[y])swap(x,y); q[i]=(Query){en[x],fir[y],i,l,k}; } else { if(l==y)swap(x,y); q[i]=(Query){fir[x],fir[y],i,0,k}; } } inline void add(int x){++c[x],++bc[bel[x]];} inline void del(int x){--c[x],--bc[bel[x]];} inline void modify(int x){ vis[x]^=1; if(!vis[x]){ for(iter=p[x].begin();iter!=p[x].end();++iter) if(vis[iter-&gt;first])del(iter-&gt;second); } else { for(iter=p[x].begin();iter!=p[x].end();++iter) if(vis[iter-&gt;first])add(iter-&gt;second); } } int main(){ int n=read(),m=read(),t=read(),sq,L,ssq,x,y,z; for(register int i=1;i&lt;n;++i)x=read(),y=read(),adde(x,y),adde(y,x); dfs1(),dfs2(); sq=cnt/sqrt(t),L=cnt/sq+bool(cnt%sq); for(register int i=1;i&lt;=L;++i) for(register int j=sq*(i-1)+1,r=min(cnt,j+sq-1);j&lt;=r;++j) be[j]=i; while(m--){ x=read(),y=read(),dis[++len]=z=read(); p[x].push_back(make_pair(y,z)),p[y].push_back(make_pair(x,z)); } sort(dis+1,dis+1+len); len=unique(dis+1,dis+1+len)-dis-1; ssq=sqrt(len),L=len/ssq+bool(len%ssq); for(register int i=1;i&lt;=L;++i) for(register int j=ssq*(i-1)+1,r=min(len,j+ssq-1);j&lt;=r;++j) bel[j]=i; for(register int i=1;i&lt;=n;++i) for(iter=p[i].begin();iter!=p[i].end();++iter) iter-&gt;second=lower_bound(dis+1,dis+1+len,iter-&gt;second)-dis; for(register int i=1;i&lt;=t;++i){ x=read(),y=read(),z=read(); process(x,y,z,i); } sort(q+1,q+1+t); int l=1,r=1,j; modify(pos[1]); for(register int i=1;i&lt;=t;++i){ while(l&lt;q[i].l)modify(pos[l++]); while(l&gt;q[i].l)modify(pos[--l]); while(r&lt;q[i].r)modify(pos[++r]); while(r&gt;q[i].r)modify(pos[r--]); if(q[i].lc)modify(q[i].lc); for(j=1;j&lt;=L&amp;&amp;q[i].k&gt;bc[j];++j)q[i].k-=bc[j]; for(j=(j-1)*ssq+1,x=min(n,j+ssq-1);j&lt;=x&amp;&amp;q[i].k&gt;c[j];++j)q[i].k-=c[j]; if(q[i].lc)modify(q[i].lc); ans[q[i].num]=dis[j]; } for(register int i=1;i&lt;=t;++i)printf(&quot;%d\\n&quot;,ans[i]); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"莫队","slug":"莫队","permalink":"https://ctz45562.github.io/tags/%E8%8E%AB%E9%98%9F/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"分块","slug":"分块","permalink":"https://ctz45562.github.io/tags/%E5%88%86%E5%9D%97/"}]},{"title":"Codeforces715C Digit Tree","slug":"Codeforces715C-Digit-Tree","date":"2019-09-23T13:14:44.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/09/23/Codeforces715C-Digit-Tree/","link":"","permalink":"https://ctz45562.github.io/2019/09/23/Codeforces715C-Digit-Tree/","excerpt":"传送门 快$CSP$了所以着重练习省选算法（？）","text":"传送门 快$CSP$了所以着重练习省选算法（？） 统计有序点对$\\langle x,y\\rangle$个数，满足$x$到$y$路径连成的数字能被$m(\\gcd(m,10)=1)$整除。 路径统计显然是点分了。 记$root$为分治中心，$dep_i$为点$i$到$root$的经过的边数，$a_{\\langle i,j\\rangle}$为点$i$到点$j$路径形成的数字模$m$的值。 则有向路径$\\langle i,j\\rangle$有贡献的条件为$a_{\\langle i,root\\rangle}+a_{\\langle root,j\\rangle}\\times10^{dep_i}\\equiv0\\pmod m$。 $\\gcd(m,10)=1$，直接把$10^{dep_i}$除掉： $a_{\\langle i,root\\rangle}\\times10^{-dep_i}+a_{\\langle root,j\\rangle}\\equiv0\\pmod m$ 处理波$10^a$的逆元开个map存$a_{\\langle i,root\\rangle}\\times 10^{-dep_i}$就行了。 不知道为啥unordered_map$T$了。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;map&gt; #define maxn 100005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int siz[maxn],h[maxn],inv[maxn],pw[maxn]={1},num,all,root,mx,mod; bool vis[maxn]; long long ans; map&lt;int,int&gt;tax; struct edge{ int pre,to,l; }e[maxn&lt;&lt;1]; inline void add(int from,int to,int l){ e[++num]=(edge){h[from],to,l}; h[from]=num; } void exgcd(int a,int b,int &amp;x,int &amp;y){ if(!b){x=1,y=0;return;} exgcd(b,a%b,y,x),y-=a/b*x; } inline int INV(int a){ int x,y; exgcd(a,mod,x,y); return (x%mod+mod)%mod; } void getroot(int node,int f=0){ int ma=all-siz[node]; for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(x==f||vis[x])continue; getroot(x,node),ma=max(ma,siz[x]); } if(ma&lt;mx)mx=ma,root=node; } void Count(int node,int d,int dep,int sum,int f=0){ tax[1ll*sum*inv[dep]%mod]+=d; for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(x==f||vis[x])continue; Count(x,d,dep+1,(10ll*sum%mod+e[i].l)%mod,node); } } void calc(int node,int sum,int dep,int f=0){ siz[node]=1,ans+=tax[(mod+mod-sum)%mod]; for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(x==f||vis[x])continue; calc(x,(sum+1ll*pw[dep]*e[i].l%mod)%mod,dep+1,node); siz[node]+=siz[x]; } } void solve(int node){ vis[node]=1,tax.clear(); int x; Count(node,1,0,0); ans+=tax[0]-1; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(vis[x])continue; Count(x,-1,1,e[i].l%mod,node); calc(x,e[i].l%mod,1); Count(x,1,1,e[i].l%mod,node); } for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(vis[x])continue; mx=inf,all=siz[x],getroot(x),solve(root); } } void dfs(int node=1){ siz[node]=1; for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(siz[x])continue; dfs(x),siz[node]+=siz[x]; } } int main(){ int n=read(); mod=read(); for(register int i=1;i&lt;=n;++i)pw[i]=10ll*pw[i-1]%mod; inv[n]=INV(pw[n]); for(register int i=n-1;~i;--i)inv[i]=10ll*inv[i+1]%mod; for(register int i=1,x,y,z;i&lt;n;++i)x=read()+1,y=read()+1,z=read(),add(x,y,z),add(y,x,z); dfs(),mx=inf,all=n,getroot(1),solve(root); printf(&quot;%I64d\\n&quot;,ans); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"点分治","slug":"点分治","permalink":"https://ctz45562.github.io/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"}]},{"title":"洛谷 P3649 [APIO2014]回文串","slug":"洛谷-P3649-APIO2014-回文串","date":"2019-09-22T03:19:46.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/09/22/洛谷-P3649-APIO2014-回文串/","link":"","permalink":"https://ctz45562.github.io/2019/09/22/%E6%B4%9B%E8%B0%B7-P3649-APIO2014-%E5%9B%9E%E6%96%87%E4%B8%B2/","excerpt":"传送门 致敬gay学长的三模哈希。","text":"传送门 致敬gay学长的三模哈希。 不会马拉车于是用刚学的哈希$+$二分找回文子串。 一个串的本质不同的回文子串个数是$O(n)$的。 枚举回文中心，不断从两头缩减其回文子串的长度，用unordered_map判重，$SAM+$树上倍增求出现次数即可。 然而$M$了，换后缀数组$+ST$表$+$二分$WA$了。 哈希模数是unsigned long long自然溢出，加了一个unsigned int自然溢出还是$WA$，又搞了个$10^9+7$模数才过。 实际上只用unsigned long long和$10^9+7$就能过。 不过心血来潮想要致敬$gayge$下划线派系的码风还是放上以下划线个数区分的三模哈希： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;tr1/unordered_map&gt; #define maxn 300005 #define inf 0x3f3f3f3f const unsigned long long base = 131; const unsigned int _base = 137; const int __base = 207; const int mod = 1e9 + 7; using namespace std; using namespace tr1; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int f[maxn][21],sa[maxn],rk[maxn],tp[maxn],tax[maxn],hei[maxn],lg[maxn],n,m; unsigned long long sum[maxn],rev[maxn],pw[maxn]={1}; unsigned int _sum[maxn],_rev[maxn],_pw[maxn]={1}; int __sum[maxn],__rev[maxn],__pw[maxn]={1}; unordered_map&lt;unsigned long long,bool&gt;unq; unordered_map&lt;unsigned int,bool&gt;_unq; unordered_map&lt;int,bool&gt;__unq; char s[maxn]; void Rsort(){ for(register int i=0;i&lt;=m;++i)tax[i]=0; for(register int i=1;i&lt;=n;++i)++tax[rk[i]]; for(register int i=1;i&lt;=m;++i)tax[i]+=tax[i-1]; for(register int i=n;i;--i)sa[tax[rk[tp[i]]]--]=tp[i]; } void Ssort(){ for(register int i=1;i&lt;=n;++i)rk[i]=s[i],tp[i]=i; m=225,Rsort(); for(register int k=1,p=0;p&lt;n;k&lt;&lt;=1,m=p){ p=0; for(register int i=1;i&lt;=k;++i)tp[++p]=n-k+i; for(register int i=1;i&lt;=n;++i)if(sa[i]&gt;k)tp[++p]=sa[i]-k; Rsort(); for(register int i=1;i&lt;=n;++i)tp[i]=rk[i]; rk[sa[1]]=p=1; for(register int i=2;i&lt;=n;++i) rk[sa[i]]=tp[sa[i]]==tp[sa[i-1]]&amp;&amp;tp[sa[i]+k]==tp[sa[i-1]+k]?p:++p; } } void get_height(){ int k=0,x; for(register int i=1;i&lt;=n;++i){ if(rk[i]==1)continue; if(k)--k; x=sa[rk[i]-1]; while(x+k&lt;=n&amp;&amp;i+k&lt;=n&amp;&amp;s[i+k]==s[x+k])++k; f[rk[i]][0]=hei[rk[i]]=k; } } void ST(){ for(register int i=2;i&lt;=n;++i)lg[i]=lg[i&gt;&gt;1]+1; for(register int j=1;j&lt;=lg[n];++j) for(register int i=1;i+(1&lt;&lt;(j-1))&lt;=n;++i) f[i][j]=min(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]); } inline int query(int l,int r){ int len=lg[r-l+1]; return min(f[l][len],f[r-(1&lt;&lt;len)+1][len]); } inline int lcp(int i,int j){ if(i==j)return n-i+1; return query(min(rk[i],rk[j])+1,max(rk[i],rk[j])); } inline unsigned long long sec(int l,int r){return sum[r]-sum[l-1]*pw[r-l+1];} inline unsigned long long rsec(int l,int r){return rev[l]-rev[r+1]*pw[r-l+1];} inline unsigned int _sec(int l,int r){return _sum[r]-_sum[l-1]*_pw[r-l+1];} inline unsigned int _rsec(int l,int r){return _rev[l]-_rev[r+1]*_pw[r-l+1];} inline int __sec(int l,int r){return (__sum[r]-1ll*__sum[l-1]*__pw[r-l+1]%mod+mod)%mod;} inline int __rsec(int l,int r){return (__rev[l]-1ll*__rev[r+1]*__pw[r-l+1]%mod+mod)%mod;} int get_siz(int L,int R){ int l=1,r=rk[L],ans,mid; while(l&lt;r){ mid=l+r&gt;&gt;1; if(lcp(sa[mid],L)&gt;=R-L+1)r=mid; else l=mid+1; } ans=l; l=rk[L],r=n; while(l&lt;r){ mid=l+r+1&gt;&gt;1; if(lcp(sa[mid],L)&gt;=R-L+1)l=mid; else r=mid-1; } return l-ans+1; } inline int rev1(int x){ int l=0,r=min(x-1,n-x),mid; while(l&lt;r){ mid=l+r+1&gt;&gt;1; if(sec(x-mid,x)==rsec(x,x+mid)&amp;&amp;_sec(x-mid,x)==_rsec(x,x+mid)&amp;&amp;__sec(x-mid,x)==__rsec(x,x+mid))l=mid; else r=mid-1; } return l; } inline int rev2(int x){ int l=0,r=min(x-1,n-x+1),mid; while(l&lt;r){ mid=l+r+1&gt;&gt;1; if(sec(x-mid,x-1)==rsec(x,x+mid-1)&amp;&amp;_sec(x-mid,x-1)==_rsec(x,x+mid-1)&amp;&amp;__sec(x-mid,x-1)==__rsec(x,x+mid-1))l=mid; else r=mid-1; } return l; } int main(){ int x,r; scanf(&quot;%s&quot;,s+1),n=strlen(s+1); for(register int i=1;i&lt;=n;++i){ sum[i]=sum[i-1]*base+s[i]-&#39;a&#39;+1,_sum[i]=_sum[i-1]*_base+s[i]-&#39;a&#39;+1,__sum[i]=(1ll*__sum[i-1]*__base%mod+s[i]-&#39;a&#39;+1)%mod; _pw[i]=_pw[i-1]*_base,pw[i]=pw[i-1]*base,__pw[i]=1ll*__pw[i-1]*__base%mod; } for(register int i=n;i;--i){ rev[i]=rev[i+1]*base+s[i]-&#39;a&#39;+1,_rev[i]=_rev[i+1]*_base+s[i]-&#39;a&#39;+1,__rev[i]=(1ll*__rev[i+1]*__base%mod+s[i]-&#39;a&#39;+1)%mod; } Ssort(),get_height(),ST(); long long ans=0; unsigned long long has; unsigned int _has; int __has; for(register int i=1;i&lt;=n;++i){ r=rev1(i); while(~r){ has=sec(i-r,i+r); _has=_sec(i-r,i+r); __has=__sec(i-r,i+r); if(unq[has]&amp;&amp;_unq[_has]&amp;&amp;__unq[__has])break; unq[has]=1,_unq[_has]=1,__unq[__has]=1; ans=max(ans,1ll*get_siz(i-r,i+r)*((r&lt;&lt;1)+1)); --r; } r=rev2(i); while(r){ has=sec(i-r,i+r-1); _has=_sec(i-r,i+r-1); __has=__sec(i-r,i+r-1); if(unq[has]&amp;&amp;_unq[_has]&amp;&amp;__unq[__has])break; unq[has]=1,_unq[_has]=1,__unq[__has]=1; ans=max(ans,1ll*get_siz(i-r,i+r-1)*r&lt;&lt;1); --r; } } printf(&quot;%lld\\n&quot;,ans); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://ctz45562.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"哈希","slug":"哈希","permalink":"https://ctz45562.github.io/tags/%E5%93%88%E5%B8%8C/"},{"name":"二分","slug":"二分","permalink":"https://ctz45562.github.io/tags/%E4%BA%8C%E5%88%86/"},{"name":"后缀数组","slug":"后缀数组","permalink":"https://ctz45562.github.io/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"},{"name":"ST表","slug":"ST表","permalink":"https://ctz45562.github.io/tags/ST%E8%A1%A8/"},{"name":"后缀自动机","slug":"后缀自动机","permalink":"https://ctz45562.github.io/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"}]},{"title":"洛谷 P5306 [COCI2019] Transport","slug":"洛谷-P5306-COCI2019-Transport","date":"2019-09-21T10:45:09.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/09/21/洛谷-P5306-COCI2019-Transport/","link":"","permalink":"https://ctz45562.github.io/2019/09/21/%E6%B4%9B%E8%B0%B7-P5306-COCI2019-Transport/","excerpt":"传送门 $loli$一场胡策让我发现自从写了快递员，我就再也写不出常规点分治了$QAQ$。","text":"传送门 $loli$一场胡策让我发现自从写了快递员，我就再也写不出常规点分治了$QAQ$。 下记$root$为分治中心，$dis_i$为$i$到$root$的距离，$sum_i$为$i$到$root$路径的点权和（不包括$root$的点权）。 对于每次分治，先把当前树内点作为起点判断是否能到根，并用平衡树存一下到达根后剩余油量。 使点$i$能到达根，就要满足$\\forall j$位于路径$i\\rightarrow root$，$sum_i-dis_i-sum_j+dis_j\\ge 0$。 $dfs$时维护最小的$dis_j-sum_j$判断即可。 再$dfs$一遍树，以每个点作为终点，判断是否存在一条路径和自己拼起来合法。 同理，维护一个最大的$dis_j-sum_{fa_j}$即可，注意是$fa_j$的$sum$。平衡树里查一下大于等于该值减去$a_{root}$的数作为贡献。减去$a_{root}$是因为这两次统计时都没有算上$root$的点权。还要减去同一子树的点的贡献。 复杂度是$O(n\\log^2 n)$的。 一开始想把剩余油量存数组里排个序build一棵平衡树。甚至可以把序列去重，不涉及插入删除直接搞一个$BST$出来。 build是$O(n)$的，于是总复杂度就成$O(n\\log n)$了，然后发现排序还是带个$\\log$. 然而我已经写出来了所以代码如此冗长丑陋$QAQ$： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 100005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } #define ls(x) ls[x] #define rs(x) rs[x] struct edge{ int pre,to,l; }e[maxn&lt;&lt;1]; int a[maxn],h[maxn],siz[maxn],s[maxn],ls[maxn],rs[maxn],c[maxn],cn[maxn],cnt,num,mx,root,all,len,rt; bool vis[maxn]; long long ans,base[maxn],b[maxn],dat[maxn]; void build(int l,int r,int &amp;node){ if(l&gt;r){node=0;return;} node=++cnt; int mid=l+r&gt;&gt;1; build(l,mid-1,ls(node)); build(mid+1,r,rs(node)); dat[node]=b[mid],c[node]=cn[mid]; s[node]=s[ls(node)]+s[rs(node)]+c[node]; } void clear(int node){ if(!node)return; clear(ls(node)),clear(rs(node)); ls(node)=rs(node)=0; } void change(long long x,int d){ int node=rt; while(node){ s[node]+=d; if(dat[node]==x){c[node]+=d;return;} if(dat[node]&lt;x)node=rs(node); else node=ls(node); } } int ask(long long d){ int node=rt,ans=0; while(node){ if(dat[node]&gt;=d)ans+=s[rs(node)]+c[node],node=ls(node); else node=rs(node); } return ans; } inline void add(int from,int to,int l){ e[++num]=(edge){h[from],to,l}; h[from]=num; } void getroot(int node,int f=0){ int x,ma=all-siz[node]; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(x==f||vis[x])continue; getroot(x,node),ma=max(ma,siz[x]); } if(ma&lt;mx)mx=ma,root=node; } void Count(int node,long long sum,long long dis,long long mi,int f=0){ sum+=a[node]; mi=min(mi,dis-sum); for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(vis[x]||x==f)continue; Count(x,sum,dis+e[i].l,mi,node); if(a[x]&gt;=e[i].l&amp;&amp;sum+a[x]-dis-e[i].l+mi&gt;=0)base[++len]=a[x]+sum-dis-e[i].l; } } void work(int node,int opt,long long sum,long long dis,long long mi,int f=0){ sum+=a[node]; mi=min(mi,dis-sum); for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(vis[x]||x==f)continue; work(x,opt,sum,dis+e[i].l,mi,node); if(a[x]&gt;=e[i].l&amp;&amp;sum+a[x]-dis-e[i].l+mi&gt;=0)change(a[x]+sum-dis-e[i].l,opt); } } void calc(int node,long long sum,long long dis,long long ma=0,int f=0){ ma=max(ma,dis-sum),sum+=a[node],siz[node]=1; ans+=ask(ma-a[root]); for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(x==f||vis[x])continue; calc(x,sum,dis+e[i].l,ma,node); siz[node]+=siz[x]; } } int uniq(){ sort(base+1,base+1+len); int pos,k=0; for(register int i=1;i&lt;=len;i=pos){ pos=i+1; while(pos&lt;=len&amp;&amp;base[pos]==base[i])++pos; b[++k]=base[i],cn[k]=pos-i; } return k; } void solve(int node){ int x; vis[node]=1,base[len=1]=0,cnt=0; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(vis[x])continue; Count(x,0,e[i].l,0); if(a[x]&gt;=e[i].l)base[++len]=a[x]-e[i].l; } ans+=len-1,len=uniq(); build(1,len,rt); for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(vis[x])continue; work(x,-1,0,e[i].l,0); if(a[x]&gt;=e[i].l)change(a[x]-e[i].l,-1); calc(x,0,e[i].l,e[i].l); work(x,1,0,e[i].l,0); if(a[x]&gt;=e[i].l)change(a[x]-e[i].l,1); } clear(rt); for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(vis[x])continue; mx=inf,all=siz[x],getroot(x),solve(root); } } void dfs(int node=1){ siz[node]=1; for(register int i=h[node],x;i;i=e[i].pre){ x=e[i].to; if(siz[x])continue; dfs(x),siz[node]+=siz[x]; } } int main(){ int n=read(); for(register int i=1;i&lt;=n;++i)a[i]=read(); for(register int i=1,x,y,z;i&lt;n;++i)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z); dfs(),all=n,mx=inf,getroot(1),solve(root); printf(&quot;%lld\\n&quot;,ans); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"点分治","slug":"点分治","permalink":"https://ctz45562.github.io/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"},{"name":"平衡树","slug":"平衡树","permalink":"https://ctz45562.github.io/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"}]},{"title":"Iconfont:一款功能强大的图标库","slug":"iconfont","date":"2019-09-18T01:48:12.000Z","updated":"2021-07-01T04:33:04.532Z","comments":true,"path":"2019/09/18/iconfont/","link":"","permalink":"https://ctz45562.github.io/2019/09/18/iconfont/","excerpt":"有了Iconfont，妈妈再也不用担心我找不到想要的图标啦！","text":"有了Iconfont，妈妈再也不用担心我找不到想要的图标啦！ 前言搭blog的时候图标一直在用Font Awesome库。然而图标只有不到700个。 如果科学上网去正规Font Awesome库的话，图标也只有7000多个，而且大部分都是付费的。 偶然看到Iconfont库，里面图标有60多万个，而且还有彩色的！ 于是有了这篇教程。 添加可以按这个教程下到本地，不过很麻烦不推荐。 直接用阿里云外链调用即可。 首先来到Iconfont官网，点右上角登录（github登录即可）。 点击首栏-&gt;图标管理-&gt;我的项目。 点击右上角紫色的新建项目。 项目名称、FontClass/Symbol前缀和Font Family随便填，后两项引用的时候要用。 搜索想要的图标。 点击图标上的“添加入库”按钮。 如果还有其他需要的，可以继续添加。 点击右上角的购物车，弹出的侧边栏里点击添加至项目，选择刚才创建的项目。 回到刚才的项目，在Font class中生成css外链。 复制css外链，在博客页面的&lt;head&gt;元素中引用： 使用通过&lt;i&gt;标签引用。 格式： &lt;i class=&quot;A B-C&quot;&gt;&lt;/i&gt; A为FontClass/Symbol前缀，B为Font Family，C为图标名称。 示例： &lt;i class=&quot;ctz ctz-snow&quot;&gt;&lt;/i&gt; 优点 图标数量大，样式美观 图标名多为中文名，便于搜索 阿里云外链，速度快 可以修改图标，甚至自制图标上传","categories":[{"name":"杂物","slug":"杂物","permalink":"https://ctz45562.github.io/categories/%E6%9D%82%E7%89%A9/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://ctz45562.github.io/tags/blog/"}]},{"title":"洛谷 P1084 疫情控制","slug":"洛谷-P1084-疫情控制","date":"2019-09-16T05:31:57.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/09/16/洛谷-P1084-疫情控制/","link":"","permalink":"https://ctz45562.github.io/2019/09/16/%E6%B4%9B%E8%B0%B7-P1084-%E7%96%AB%E6%83%85%E6%8E%A7%E5%88%B6/","excerpt":"传送门 不想倍增？数据结构来凑！","text":"传送门 不想倍增？数据结构来凑！ 答案具有单调性可以二分。 限制了答案后，有一个显然的贪心：在时间允许条件下，一支军队的驻扎点越靠上越优（封锁的点越多）。 那么尽可能把军队往上提。 不搞倍增，直接暴力向上合并。 维护所有位于当前节点的军队以及它们已耗费的时间。 把每个儿子的军队提上来，并给里面的军队时间都加上边权。 然后删掉耗费时间大于当前答案的军队。 于是需要一种支持快速合并、删除大于某个数的元素、整体加的数据结构。 左偏树（可并堆）！ 还有一个问题在于根节点不能驻扎。对于根节点不能封锁的儿子，需要将其他儿子剩余的军队移动过来。维护所有需要军队的儿子的边权，和剩余军队的到根节点耗费的时间。双指针扫一遍，把前者较大的和后者较小的匹配检验是否可行。 ちょっと待って。。。好像忽略了一种情况： （懒得画图了）设需要军队的点为$x$，$y$有一支剩余军队，$z$节点驻扎着一支军队且没有剩余。 可能存在把$z$的军队调往$x$驻扎,$y$的军队调往$z$驻扎满足答案，而直接把$y$的军队调往$x$驻扎不满足的情况。 用已耗费时间衡量军队的优劣的话，这种情况实际上就是把较优的$z$的军队用较劣的$y$的军队“置换”出来。 用$multiset$处理一波，把劣的军队置换出优的军队再检验。还要维护每个点是否有必要驻扎军队，必要的话就把最劣的军队留下。 时间复杂度$O(n\\log n\\log \\sum w)$。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;set&gt; #define maxn 50005 const long long inf = 1e18; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } #define ls(x) ls[x] #define rs(x) rs[x] long long dat[maxn],tag[maxn],ex[maxn],mid; int in[maxn],h[maxn],root[maxn],ls[maxn],rs[maxn],siz[maxn],deep[maxn],poi[maxn],ar[maxn],cnt,num; pair&lt;long long,int&gt;ch[maxn]; multiset&lt;long long&gt;s; bool ok[maxn],mov[maxn]; struct edge{ int pre,to,l; }e[maxn&lt;&lt;1]; inline void add(int from,int to,int l){ ++in[from]; e[++num].pre=h[from],h[from]=num,e[num].to=to,e[num].l=l; } inline bool cmp(const pair&lt;long long,int&gt; &amp;x,const pair&lt;long long,int&gt;&amp;y){ if(x.first!=y.first)return x.first&gt;y.first; return x.second&lt;y.second; } inline void update(int node){ deep[node]=deep[rs(node)]+1; siz[node]=siz[ls(node)]+siz[rs(node)]+1; } inline void datadown(int node,int d){ tag[node]+=d,dat[node]+=d; } inline void pushdown(int node){ if(ls(node))datadown(ls(node),tag[node]); if(rs(node))datadown(rs(node),tag[node]); tag[node]=0; } int merge(int x,int y){ if(!x||!y)return x|y; if(dat[x]&lt;dat[y])swap(x,y); if(tag[x])pushdown(x); rs(x)=merge(rs(x),y); if(deep[ls(x)]&lt;deep[rs(x)])swap(ls(x),rs(x)); update(x); return x; } void push(int &amp;rt,int x){ dat[++cnt]=x,siz[cnt]=deep[cnt]=1; ls(cnt)=rs(cnt)=tag[cnt]=0; rt=merge(rt,cnt); } void pop(int &amp;rt){ int l=ls(rt),r=rs(rt); if(tag[rt])pushdown(rt); rt=merge(l,r); } void dp(int node,int f=1){ ok[node]=mov[node]=in[node]-1; int x,s; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(x==f)continue; dp(x,node),datadown(root[x],e[i].l); root[node]=merge(root[node],root[x]); if(root[node]&amp;&amp;dat[root[node]]&lt;=mid)mov[node]=0; while(root[node]&amp;&amp;dat[root[node]]&gt;mid)pop(root[node]); mov[node]&amp;=ok[x],ok[node]&amp;=ok[x]; } while(root[node]&amp;&amp;dat[root[node]]&gt;mid)pop(root[node]); ok[node]|=root[node]; } inline multiset&lt;long long&gt;::iterator pre(int d){ multiset&lt;long long&gt;::iterator ans=s.lower_bound(d); if(ans==s.end())return --ans; if(*ans==d)return ans; return --ans; } int main(){ int n=read(),l1,l2,l3,x; long long l=0,r=0; multiset&lt;long long&gt;::iterator iter; for(register int i=1,y,z;i&lt;n;++i)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z),r+=z; int m=read(); for(register int i=1;i&lt;=m;++i)ar[i]=read(); if(in[1]&gt;m){puts(&quot;-1&quot;);return 0;} while(l&lt;r){ mid=l+r&gt;&gt;1,l1=l2=l3=0,cnt=0; s.clear(),s.insert(-inf); for(register int i=1;i&lt;=n;++i)root[i]=0; for(register int i=1;i&lt;=m;++i){ if(ar[i]==1)ch[++l3]=make_pair(0,0); else push(root[ar[i]],0); } for(register int i=h[1];i;i=e[i].pre){ x=e[i].to,dp(x); if(!ok[x])poi[++l1]=e[i].l; if(root[x])ch[++l3]=make_pair(dat[root[x]]+e[i].l,mov[x]?0:e[i].l),pop(root[x]); while(root[x])ch[++l3]=make_pair(dat[root[x]]+e[i].l,0),pop(root[x]); } sort(ch+1,ch+1+l3,cmp); for(register int i=1;i&lt;=l3;++i){ if(!ch[i].second)s.insert(ch[i].first); else { iter=pre(mid-ch[i].second); if(*iter==-inf)continue; s.erase(iter); s.insert(ch[i].first); } } for(iter=s.begin();iter!=s.end();++iter)ex[++l2]=*iter; reverse(ex+1,ex+1+l2),--l2; sort(poi+1,poi+1+l1); while(l1&amp;&amp;l2&amp;&amp;ex[l2]+poi[l1]&lt;=mid)--l1,--l2; if(l1)l=mid+1; else r=mid; } printf(&quot;%lld\\n&quot;,l); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://ctz45562.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"二分","slug":"二分","permalink":"https://ctz45562.github.io/tags/%E4%BA%8C%E5%88%86/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"左偏树","slug":"左偏树","permalink":"https://ctz45562.github.io/tags/%E5%B7%A6%E5%81%8F%E6%A0%91/"}]},{"title":"斐波那契数列懵逼笔记","slug":"斐波那契数列懵逼笔记","date":"2019-09-10T08:49:58.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/09/10/斐波那契数列懵逼笔记/","link":"","permalink":"https://ctz45562.github.io/2019/09/10/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E6%87%B5%E9%80%BC%E7%AC%94%E8%AE%B0/","excerpt":"真是恶zhuoer。","text":"真是恶zhuoer。 前言本来是在写往年$NOIP$的水题的，然后突然被恶zhuoer丢来了一道题： 这不$SB$题吗？ 十分钟切了后，恶zhuoer又丢来一道题： $emm…$ 利用题解+度娘发现斐波那契有很多肥肠神奇的性质。 抄袭来源 https://www.cnblogs.com/Milkor/p/4734763.html https://blog.csdn.net/m0_37109329/article/details/78481951 http://www.sohu.com/a/280601723_614593 http://www.doc88.com/p-7874575379525.html https://www.cnblogs.com/sssy/p/9418732.html 大型懵逼现场以下所有性质均懒得不予（也不会）证明。 通项公式$f_n=\\dfrac{1}{\\sqrt{5}}\\left[\\left(\\dfrac{1+\\sqrt{5}}{2}\\right)^n-\\left(\\dfrac{1-\\sqrt{5}}{2}\\right)^n\\right]$ 求和前n项和$\\sum\\limits_{i=1}^nf_i=f_{n+2}-1$ 前n项平方和$\\sum\\limits_{i=1}^nf^2_i=f_nf_{n+1}$ 前n项与自然数乘积和$\\sum\\limits_{i=1}^nif_i=nf_{n+2}-f_{n+3}+2$ 奇数和偶数项和$\\sum\\limits_{i=1}^nf_{2i-1}=f_{2n}$ $\\sum\\limits_{i=1}^nf_{2i}=f_{2n+1}-1$ 相邻项乘积之和$\\sum\\limits_{i=1}^nf_if_{i+1}=\\dfrac{1}{2}\\left(f^2_{n+2}-f_nf_{n+1}-1\\right)$ 各项之间的关系第n+m项$f_{n+m}=f_{m-1}f_n+f_mf_{n+1}$ 第2n项与第n项$\\dfrac{f_{2n}}{f_n}=f_{n-1}+f_{n+1}$ 第奇数项和第偶数项$f_{2n+1}=f^2_n+f^2_{n+1}$ $f_{2n}=f^2_{n+1}-f^2_{n-1}$ 第n-1项与第n+1项的积$f_{n-1}f_{n+1}=f^2_n+(-1)^n$ 第n项与第m项的gcd$\\gcd(f_n,f_m)=f_{\\gcd(n,m)}$ 整除与斐波那契数列$n|m\\leftrightarrow f_n|f_m$ 循环节模意义下的循环节记$g(mod)$为模$mod$意义下的最小循环节长度。 $mod$为素数：$g(mod)=\\begin{cases}3&amp;mod=2\\\\8&amp;mod=3\\\\20&amp;mod=5\\\\mod-1&amp;\\text{5是模mod的二次剩余}\\\\2(mod+1)&amp;otherwise\\end{cases}$ $mod$为素数$p$的$k$次方：$g(mod)=g(mod)\\times p^{k-1}$ $mod$为任意正整数： 用算数基本定理分解$mod$：$mod=\\sum\\limits_{i=1}^cp_i^{k_i}$ $g(mod)=\\operatorname{lcm}\\limits_{i=1}^cg(p_i^{k_i})$ 末位循环个位：周期$60$ 后两位：周期$300$ 后三位：周期$1500$","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ctz45562.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"斐波那契数列","slug":"斐波那契数列","permalink":"https://ctz45562.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"}]},{"title":"loliの胡策 Walk","slug":"loli的胡策-Walk","date":"2019-09-08T03:15:25.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/09/08/loli的胡策-Walk/","link":"","permalink":"https://ctz45562.github.io/2019/09/08/loli%E7%9A%84%E8%83%A1%E7%AD%96-Walk/","excerpt":"教练某场胡策的$T2$。","text":"教练某场胡策的$T2$。 题目描述 给定一棵$n$个节点的树，每条边的长度为$1$，同时有一个权值$w$。定义一条路径的权值为路径上所有边的权值的最大公约数。现在对于任意$i\\in[1,n]$，求树上所有长度为$i$的简单路径中权值最大的是多少。如果不存在长度为$i$的路径，则第$i$行输出$0$。 输入输出格式输入格式第一行，一个整数$n$，表示树的大小。 接下来$n-1$行，每行三个整数$u,v,w$，表示$u,v$间存在一条权值为$w$的边。 输出格式对于每种长度，输出一行，表示答案。 样例输入样例31 2 31 3 9 输出样例930 数据范围对于$30\\%$的数据，$n\\le 1000$。对于额外$30\\%$的数据，$w\\le 100$。对于$100\\%$的数据，$n\\le4*10^5$，$1\\le u,v\\le n$，$w\\le 10^6$。 题解考虑$w\\le 100$的数据。 暴力枚举$gcd$，忽略树上$w\\nmid gcd$的边。显然答案有单调性，将树的直径的答案更新为当前$gcd$。最后倒着取$\\max$即可。 复杂度$O(nw)$。 正解： 还是枚举$gcd$，把$w$为$gcd$的倍数的边建出一个森林，求森林的直径更新即可。 注意到只有当枚举到$w$的约数时，该边才会被加进去。所以复杂度为所有边的约数个数和。 而$10^6$内最大的约数个数只有$128$。 复杂度为跑不满的$O(128n+w\\log w)$。$w\\log w$是枚举倍数的调和级数。 代码#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #define maxn 400005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int f[maxn],ans[maxn],h[maxn],num,now,len; vector&lt;pair&lt;int,int&gt; &gt;ed[1000005]; vector&lt;int&gt;poi; bool vis[maxn],app[maxn]; struct edge{ int pre,to; }e[maxn&lt;&lt;1]; inline void add(int from,int to){ e[++num].pre=h[from],h[from]=num,e[num].to=to; } void dp(int node){ f[node]=0,vis[node]=1; int x; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(vis[x])continue; dp(x); len=max(len,f[node]+f[x]+1); f[node]=max(f[node],f[x]+1); } } int main(){ int n=read(),x,y,z,tp=0; for(register int i=1;i&lt;n;++i)x=read(),y=read(),tp=max(z=read(),tp),ed[z].push_back((pair&lt;int,int&gt;){x,y}); for(register int i=1;i&lt;=tp;++i){ poi.clear(),num=len=0; for(register int j=i;j&lt;=tp;j+=i){ for(vector&lt;pair&lt;int,int&gt; &gt;::iterator iter=ed[j].begin();iter!=ed[j].end();++iter){ if(!app[iter-&gt;first])poi.push_back(iter-&gt;first),app[iter-&gt;first]=1,h[iter-&gt;first]=0; if(!app[iter-&gt;second])poi.push_back(iter-&gt;second),app[iter-&gt;second]=1,h[iter-&gt;second]=0; add(iter-&gt;first,iter-&gt;second),add(iter-&gt;second,iter-&gt;first); } } for(register int j=0;j&lt;poi.size();++j) if(!vis[poi[j]])dp(poi[j]); for(register int j=0;j&lt;poi.size();++j)app[poi[j]]=vis[poi[j]]=0; ans[len]=i; } for(register int i=n-1;i;--i)ans[i]=max(ans[i],ans[i+1]); for(register int i=1;i&lt;=n;++i) printf(&quot;%d\\n&quot;,ans[i]); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"枚举","slug":"枚举","permalink":"https://ctz45562.github.io/tags/%E6%9E%9A%E4%B8%BE/"}]},{"title":"洛谷 P3920 [WC2014]紫荆花之恋","slug":"洛谷-P3920-WC2014-紫荆花之恋","date":"2019-09-07T08:19:11.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/09/07/洛谷-P3920-WC2014-紫荆花之恋/","link":"","permalink":"https://ctz45562.github.io/2019/09/07/%E6%B4%9B%E8%B0%B7-P3920-WC2014-%E7%B4%AB%E8%8D%86%E8%8A%B1%E4%B9%8B%E6%81%8B/","excerpt":"传送门 想题5分钟，调题20小时$QAQ$","text":"传送门 想题5分钟，调题20小时$QAQ$ 我做这题的历程： 这什么破玩意儿 如果您听说过「替罪羊式重构点分树」的话这题就很好想了。 首先考虑朴素的点分治： 每次分治统计路径经过分治中心的点对的贡献。 记$dis_i$为点$i$到分治中心的距离，条件即$dis_i+dis_j\\le r_i+r_j$。 移个项：$dis_i-r_i\\le r_j-dis_j$。 把$r_i-dis_i$插进平衡树里，查询平衡树中大于等于$dis_i-r_i$的数量。 动态的做法就很明显了，点分树上每个点开个平衡树。还要容斥减掉同一子树的贡献，用$vector$记录每层上用于容斥的平衡树。 加点直接在点分树上将$i$与$a_i$连边，暴力跳点分树在平衡树里查，并把自己的信息插进去。 注意到每次都会在某个点下方挂一个点，而点分树的树高要维持在$\\log$级别。 很像平衡树。旋转是不可能了，利用替罪羊树的思想重构点分树。 记$siz$为点分树上子树大小。当$\\max\\limits_{i\\in son(x)}siz_i\\ge siz_x\\times \\alpha$（$\\alpha$为平衡因子，我定的$0.7$）就重构点$i$的子树。 $asuldb$：重构多简单，不就点分治一下吗。 重构我们要干啥（$x$为待重构点）： 维护点分树上每个点的儿子，$bfs$得到要重构哪些点 清空每个点的平衡树 保留非重构点的容斥平衡树，清空其他的。注意到容斥的$vector$记录的平衡树在点分树上所属的点深度是递增的。一直pop_back并清空平衡树直到末尾元素为$fa(x)$即可。 点分治重构点分树 为了保证单次重构复杂度是$O(siz_x\\log siz_x)$的，把子树信息提出来排个序直接build。$treap$有随机权值不好build，$splay$太慢于是选择替罪羊树。 （其实假了，有个排序重构还是$O(siz_x\\log^2 siz_x)$的。。。） 还要支持查询点对的距离，可以倍增，我用的$LCT$。 复杂度为$O(n\\log^2 n)$。 注意垃圾回收。 全是细节的代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #include &lt;set&gt; #define maxn 100005 #define inf 0x3f3f3f3f const double alpha = 0.7; const int mod = 1e9; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } struct edge{ int pre,to,l; }e[maxn&lt;&lt;1]; struct ScapeGoatTree{ #define ls(x) son[x][0] #define rs(x) son[x][1] #define son(x,y) son[x][y] int son[maxn*50][2],dat[maxn*50],siz[maxn*50],pool[maxn*50],a[maxn&lt;&lt;1],len,cnt; bool isbad(int node){ return 1.0*max(siz[ls(node)],siz[rs(node)])&gt;=alpha*siz[node]; } void build(int *base,int l,int r,int &amp;node){ if(l&gt;r){node=0;return;} node=pool[cnt--]; int mid=l+r&gt;&gt;1; dat[node]=base[mid]; build(base,l,mid-1,ls(node)); build(base,mid+1,r,rs(node)); siz[node]=siz[ls(node)]+siz[rs(node)]+1; } void dfs(int node){ if(!node)return; dfs(ls(node)); a[++len]=dat[node]; dfs(rs(node)); pool[++cnt]=node; } int push(int &amp;node,int d){ if(!node){ dat[node=pool[cnt--]]=d,siz[node]=1; ls(node)=rs(node)=0; return 0; } ++siz[node]; int p=push(son(node,dat[node]&lt;d),d); if(isbad(node))return node; return p; } void clear(int &amp;node){ if(!node)return; clear(ls(node)),clear(rs(node)); pool[++cnt]=node,node=0; } void insert(int &amp;node,int d){ int p=push(node,d); if(p)len=0,dfs(p),build(a,1,len,p); } int find(int node,int x){ int ans=0; while(node){ if(dat[node]&gt;=x)ans+=siz[rs(node)]+1,node=ls(node); else node=rs(node); } return ans; } ScapeGoatTree(){ cnt=maxn*50-1; for(register int i=1;i&lt;=cnt;++i)pool[i]=i; } }sgt; struct LinkCutTree{ #define whson(x) (son(fa[x],1)==x) #define isroot(x) (son(fa[x],0)!=x&amp;&amp;son(fa[x],1)!=x) int son[maxn&lt;&lt;1][2],fa[maxn&lt;&lt;1],sum[maxn&lt;&lt;1],v[maxn&lt;&lt;1],rev[maxn&lt;&lt;1],sta[maxn&lt;&lt;1]; inline void update(int node){ sum[node]=sum[ls(node)]+sum[rs(node)]+v[node]; } inline void addedge(int s,int f,int wh){ if(s)fa[s]=f; son(f,wh)=s; } inline void reverdown(int node){ swap(ls(node),rs(node)),rev[node]^=1; } inline void pushdown(int node){ if(rev[node])reverdown(ls(node)),reverdown(rs(node)),rev[node]=0; } void zhuan(int x){ int f=fa[x],gf=fa[f],wh=whson(x); fa[x]=gf; if(!isroot(f))son(gf,whson(f))=x; addedge(son(x,wh^1),f,wh); addedge(f,x,wh^1); update(f),update(x); } void splay(int x){ int y=x,top=1; sta[1]=x; while(!isroot(y))sta[++top]=y=fa[y]; while(top)pushdown(sta[top--]); while(!isroot(x)){ y=fa[x]; if(!isroot(y))zhuan(whson(y)^whson(x)?x:y); zhuan(x); } } void access(int x){ for(register int y=0;x;y=x,x=fa[x]) splay(x),son(x,1)=y,update(x); } void makeroot(int x){ access(x),splay(x),reverdown(x); } void link(int x,int y){fa[x]=y;} int Get(int x,int y){ makeroot(x),access(y),splay(y); return sum[y]; } }lct; int r1[maxn],r2[maxn],h[maxn],siz[maxn],ts[maxn],pool[maxn&lt;&lt;2],num,cnt=(maxn&lt;&lt;2)-1,all,mx,root,l1,l2; int mp[maxn],rt[maxn],exc[maxn&lt;&lt;3],line[maxn],dep[maxn],fa[maxn],a[maxn]; bool vis[maxn],rub[maxn&lt;&lt;1]; vector&lt;int&gt;b[maxn]; set&lt;int&gt;son[maxn]; inline void add(int from,int to,int l){ e[++num].pre=h[from],h[from]=num,e[num].to=to,e[num].l=l; } void getroot(int node,int f=0){ int ma=0,x; siz[node]=1; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(x==f||vis[x])continue; getroot(x,node),ma=max(ma,siz[x]),siz[node]+=siz[x]; } ma=max(ma,all-siz[node]); if(ma&lt;mx)mx=ma,root=node; } void bfs(int node){ int head=0,tail=1,rc=cnt; dep[line[1]=node]=0; while(head&lt;tail){ int x=line[++head]; vis[x]=0; for(set&lt;int&gt;::iterator iter=son[x].begin();iter!=son[x].end();++iter) dep[line[++tail]=*iter]=dep[x]+1; while(dep[x]--){ sgt.clear(exc[*b[x].rbegin()]); if(!rub[*b[x].rbegin()])rub[pool[++cnt]=*b[x].rbegin()]=1; b[x].pop_back(); } sgt.clear(rt[x]); son[x].clear(); } for(register int i=rc+1;i&lt;=cnt;++i)rub[pool[i]]=0; } void dfs(int node,int len,int f){ r1[++l1]=r2[++l2]=a[node]-len,b[node].push_back(pool[cnt]); siz[node]=1; int x; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(x==f||vis[x])continue; dfs(x,len+e[i].l,node),siz[node]+=siz[x]; } } void build(int node){ vis[node]=ts[node]=1,mp[node]=0,r1[l1=1]=a[node]; int x; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(vis[x])continue; l2=0,dfs(x,e[i].l,node); sort(r2+1,r2+1+l2); sgt.build(r2,1,l2,exc[pool[cnt--]]); } sort(r1+1,r1+1+l1); sgt.build(r1,1,l1,rt[node]); for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(vis[x])continue; mx=inf,mp[node]=max(all=siz[x],mp[node]),getroot(x); ts[node]+=all,fa[root]=node,son[node].insert(root); build(root); } } void rebuild(int node){ int x=node,p=0; while(x){ mp[fa[x]]=max(mp[fa[x]],++ts[x]); if(1.0*mp[x]&gt;=alpha*ts[x])p=x; x=fa[x]; } if(p){ bfs(p); mx=inf,all=ts[p],getroot(p); fa[root]=fa[p],son[fa[p]].erase(p),son[fa[p]].insert(root); build(root); } } int main(){ memset(vis,1,sizeof vis); for(register int i=1;i&lt;=cnt;++i)pool[i]=i; read(); int n=read(),x,y,node; long long ans=0; read(),read(); ts[1]=1,sgt.insert(rt[1],a[1]=read()),puts(&quot;0&quot;); for(register int i=2;i&lt;=n;++i){ x=read&lt;long long&gt;()^(ans%mod),lct.v[n+i]=y=read(),a[i]=read(); fa[i]=node=x,son[x].insert(i),sgt.insert(rt[i],a[i]); add(i,x,y),add(x,i,y),lct.link(n+i,x),lct.link(i,n+i); b[i]=b[x],b[i].push_back(pool[cnt--]); for(register int j=b[i].size()-1;node;node=fa[node],--j){ int dis=lct.Get(i,node); ans+=sgt.find(rt[node],dis-a[i])-sgt.find(exc[b[i][j]],dis-a[i]); sgt.insert(rt[node],a[i]-dis),sgt.insert(exc[b[i][j]],a[i]-dis); } printf(&quot;%lld\\n&quot;,ans); rebuild(i); } }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"点分治","slug":"点分治","permalink":"https://ctz45562.github.io/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"LCT","slug":"LCT","permalink":"https://ctz45562.github.io/tags/LCT/"},{"name":"平衡树","slug":"平衡树","permalink":"https://ctz45562.github.io/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"},{"name":"点分树","slug":"点分树","permalink":"https://ctz45562.github.io/tags/%E7%82%B9%E5%88%86%E6%A0%91/"}]},{"title":"洛谷 P4211 [LNOI2014]LCA","slug":"洛谷-P4211-LNOI2014-LCA","date":"2019-09-02T11:11:49.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/09/02/洛谷-P4211-LNOI2014-LCA/","link":"","permalink":"https://ctz45562.github.io/2019/09/02/%E6%B4%9B%E8%B0%B7-P4211-LNOI2014-LCA/","excerpt":"传送门 复习物理时突然有了这个题的做法。 我也不知道为啥学物理会想到这个","text":"传送门 复习物理时突然有了这个题的做法。 我也不知道为啥学物理会想到这个 一个不用转化、不用扫描线、不用$LCT$树剖的$chuan$新做法：直接分块！ 每个块开个$vector$记录询问。 散块直接暴力。整块把该询问丢进$vector$里。 询问处理完后处理每个块： 记$l,r$为块的左右端点，对每个点$x$算出$\\sum\\limits_{i=l}^rdeep[lca(i,x)]$，最后把属于该块的每个询问点的贡献加进去即可。 $dfs$一遍树。考虑每个点为$lca$的贡献。记$siz(i)$为$i$子树中编号在$[l,r]$的点的个数。 点$i$会对其整棵子树有$deep(i)\\times siz(i)$的贡献，然后对其每个儿子$x$，要容斥减去$deep(i)\\times siz(x)$的不合法贡献。 子树加，$dfs$序+差分即可。 空间$O(n\\sqrt{n})$，用$O(1)LCA$的话时间为$O(n\\sqrt{n})$。 用$Tarjan\\ LCA$被卡空间了用树剖$LCA$被卡时间了被迫现学的$RMQ\\ LCA$，做LCA题学LCA没毛病 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #define maxn 50005 #define inf 0x3f3f3f3f const int mod = 201314; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int siz[maxn],h[maxn],seg[maxn],pos[maxn],low[maxn],deep[maxn]={inf,1},num,cnt; int be[maxn],a[maxn],ans[maxn],f[maxn&lt;&lt;1][22],fir[maxn],lg[maxn&lt;&lt;1],all; struct edge{ int pre,to; }e[maxn]; inline int cmp(int x,int y){return deep[x]&lt;deep[y]?x:y;} inline void add(int from,int to){ e[++num].pre=h[from],h[from]=num,e[num].to=to; } void dfs(int node=1){ f[fir[node]=++all][0]=pos[seg[node]=++cnt]=node; int x; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to,deep[x]=deep[node]+1,dfs(x); f[++all][0]=node; } low[node]=cnt; } void ST(){ for(register int i=2;i&lt;=all;++i)lg[i]=lg[i&gt;&gt;1]+1; for(register int j=1;j&lt;=lg[all];++j) for(register int i=1;i+(1&lt;&lt;(j-1))&lt;=all;++i) f[i][j]=cmp(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]); } inline int query(int l,int r){ if(l&gt;r)swap(l,r); int len=lg[r-l+1]; return cmp(f[l][len],f[r-(1&lt;&lt;len)+1][len]); } inline int lca(int x,int y){ return query(fir[x],fir[y]); } #define modify(x,d) a[seg[x]]+=d,a[low[x]+1]-=d #define id(x) (x&gt;=l&amp;&amp;x&lt;=r) struct BLOCK{ int l,r; vector&lt;pair&lt;int,int&gt; &gt;q; void calc(int node=1){ siz[node]=id(node); int x; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; calc(x),siz[node]+=siz[x]; } modify(node,deep[node]*siz[node]); for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; modify(x,(-deep[node]*siz[x])); } } void solve(){ calc(); for(register int i=1;i&lt;=cnt;++i)a[i]+=a[i-1]; for(vector&lt;pair&lt;int,int&gt; &gt;::iterator iter=q.begin();iter!=q.end();++iter) (ans[iter-&gt;second]+=a[iter-&gt;first])%=mod; } }b[250]; inline void odd(int l,int r,int x,int p){ for(register int i=l;i&lt;=r;++i)ans[p]+=deep[lca(i,x)]; } int main(){ int n=read(),m=read(),l,r,x,sq=sqrt(n),len=n/sq+bool(n%sq); for(register int i=2;i&lt;=n;++i)add(read()+1,i); dfs(),ST(); for(register int i=1;i&lt;=len;++i){ b[i].l=b[i-1].r+1,b[i].r=min(b[i].l+sq-1,n); for(register int j=b[i].l;j&lt;=b[i].r;++j) be[j]=i; } for(register int i=1;i&lt;=m;++i){ l=read()+1,r=read()+1,x=read()+1; if(be[l]==be[r]){odd(l,r,x,i);} else { odd(l,b[be[l]].r,x,i); odd(b[be[r]].l,r,x,i); x=seg[x]; for(register int j=be[l]+1;j&lt;be[r];++j) b[j].q.push_back((pair&lt;int,int&gt;){x,i}); } } for(register int i=1;i&lt;=len;++i)memset(a,0,sizeof a),b[i].solve(); for(register int i=1;i&lt;=m;++i)printf(&quot;%d\\n&quot;,(ans[i]%mod+mod)%mod); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"ST表","slug":"ST表","permalink":"https://ctz45562.github.io/tags/ST%E8%A1%A8/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"分块","slug":"分块","permalink":"https://ctz45562.github.io/tags/%E5%88%86%E5%9D%97/"},{"name":"LCA","slug":"LCA","permalink":"https://ctz45562.github.io/tags/LCA/"}]},{"title":"洛谷 P4886 快递员","slug":"洛谷-P4886-快递员","date":"2019-08-27T03:28:57.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/08/27/洛谷-P4886-快递员/","link":"","permalink":"https://ctz45562.github.io/2019/08/27/%E6%B4%9B%E8%B0%B7-P4886-%E5%BF%AB%E9%80%92%E5%91%98/","excerpt":"传送门 介是你没有体验过的$chuan$新做法。 暴力点分治算出每个点作为中心时的答案。","text":"传送门 介是你没有体验过的$chuan$新做法。 暴力点分治算出每个点作为中心时的答案。 对于路径$c\\rightarrow u\\rightarrow c\\rightarrow v\\rightarrow c$的长度除以$2$，我们可以看做$dis(u,v)+c$到路径$(u,v)$的距离乘$2$。 把路径分成两类： 经过分治中心的： 对于这种路径，$dfs$一遍树，当脱离了某条路径时，比如走边$(2,4)$或$(2,5)$，开始计算该路径的贡献。假设走边$(x,y)$脱离了该路径，则$y$子树内每个点$i$都会有$dis(i,x)\\times 2+dis(u,v)$的贡献。 具体实现：给每条边维护一个权值$V$，对每条路径上的边的$V$对$dis(u,v)$取$\\max$。算出每个点每条出边$V$的最大值和次大值。$dfs$时维护当前最大贡献$now$，对每个点，等于该点最大值的边选次小值更新$now$，否则选最大值，累加边权乘$2$即可。 这样会发现从根节点开始$dfs$时会出现这种情况： 此时，红色路径和绿色路径为最大和次大。 由于一条路径可能会占据根节点的两条出边，维护最大值和次大值就出$bug$了。 这样我们直接维护一个堆把每条路径加进去，从根节点出发时把每条经过该点的路径删掉，统计完再加回去。 不经过分治中心的： 把$(u,v)$的$lca$标记为关键点，并赋予一个权值$mx$为所有标记它的点对中最大的$dis(u,v)$。记$ma(i)$为$i$到其子树内所有关键点中（设关键点为$p$），最大的$mx(p)+dis(p,i)\\times 2$。 转移很简单：$ma(i)=\\max\\{mx(i),\\max\\limits_{edge(i,j)}\\{ma(j)+edge(i,j).l\\times 2\\}\\}$ 对根维护一个$ma1$和$ma2$表示根的儿子中最大和次大的$ma$。 $dfs$根的每个儿子$i$的子树，同样的，若$ma(i)=ma1$选$ma2$，否则选$ma1$为$now$，对每个点$j$的贡献就是$now+dis(root,j)\\times 2$。 注意不用也不能在统计时进一步更新$now$了。 繁琐的细节： 分类路径时，可以巧妙运用$tarjan\\ lca$。 处理边的$V$时，其实就是链取$\\max$单点查。由于这些路径都经过根节点，直接对两端点取$\\max$，统计子树最大值即可。 直接位于路径$(u,v)$的点算不上$(u,v)$的贡献，需要额外处理，可以在统计$V$时一块算，免去了树剖两个$\\log$或$lct$的大常数。 由于一些神奇的原因，形如$(u,u)$的路径不会被算到，把$u$拆出来$u’$连上长为$0$的边，把路径改为$(u,u’)$即可。 关于正确性： 如果一条路径经过根节点，就会统计上它对当前树内所有点的贡献。 否则会统计它对和它不属于根节点同一个儿子的子树的节点的贡献，然后分治它的子树。 我们就能把它对每个点的贡献算上。 关于复杂度： 随便想一想就会发现复杂度是$O((m+n)\\log n)$的。 代码： 我的$priority\\_queue$不知道为啥会在程序结束时炸掉于是抄手写的堆。 尽量精简了代码还是有$200+$行毕竟是暴力。 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #include &lt;queue&gt; #define maxn 200005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } namespace origin{ int h[maxn],num; struct edge{ int pre,to,l; }e[maxn&lt;&lt;1]; inline void add(int from,int to,int l){ e[++num].pre=h[from],h[from]=num,e[num].to=to,e[num].l=l; e[++num].pre=h[to],h[to]=num,e[num].to=from,e[num].l=l; } } int h[maxn],siz[maxn],top[maxn],son[maxn],deep[maxn],fa[maxn],F[maxn],qu[maxn][2],num,all,mx,root,cnt; int ma1[maxn],ma2[maxn],ema1[maxn],ema2[maxn],ans[maxn],dis[maxn],ee[maxn],bl[maxn],sp[maxn]; vector&lt;pair&lt;int,int&gt; &gt;v[maxn]; vector&lt;int&gt;poi[maxn]; bool vis[maxn],ap[maxn]; struct heap{ int H[maxn],heap_size; void push(int d){ int now=++heap_size; H[heap_size]=d; while(now&gt;1){ if(H[now]&lt;H[now&gt;&gt;1]) return; swap(H[now],H[now&gt;&gt;1]); now&gt;&gt;=1; } } void pop(){ int now=1,next; H[1]=H[heap_size--]; while((now&lt;&lt;1)&lt;=heap_size){ next=now&lt;&lt;1; if(next&lt;heap_size&amp;&amp;H[next+1]&gt;H[next]) next++; if(H[now]&gt;H[next]) return; swap(H[now],H[next]); now=next; } } bool empty(){return !(bool(heap_size));} }; struct del_heap{ heap q,d; void push(int x){q.push(x);} void del(int x){d.push(x);} void clear(){q.heap_size=d.heap_size=0;} int top(){ while(!d.empty()&amp;&amp;q.H[1]==d.H[1])q.pop(),d.pop(); if(q.empty())return -inf; return q.H[1]; } }q; struct edge{ int pre,to,l,v; }e[maxn&lt;&lt;1]; int find(int x){ if(F[x]==x)return x; return F[x]=find(F[x]); } inline void add(int from,int to,int l){ e[++num].pre=h[from],h[from]=num,e[num].to=to,e[num].l=l,e[num].v=-inf; } void dfs1(int node=1){ siz[node]=1; int x; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(siz[x])continue; fa[x]=node,deep[x]=deep[node]+1,dis[x]=dis[node]+e[i].l; dfs1(x),siz[node]+=siz[x]; if(siz[x]&gt;siz[son[node]])son[node]=x; } } void dfs2(int node=1){ vis[node]=1; if(son[node]){ top[son[node]]=top[node],dfs2(son[node]); int x; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(!vis[x])top[x]=x,dfs2(x); } } } inline int lca(int x,int y){ while(top[x]!=top[y])deep[top[x]]&lt;deep[top[y]]?y=fa[top[y]]:x=fa[top[x]]; return deep[x]&lt;deep[y]?x:y; } inline void check(int &amp;m1,int &amp;m2,int x){ if(x&gt;m1)m2=m1,m1=x; else if(x&gt;m2)m2=x; } void getroot(int node,int f){ int x,ma=0; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(x==f||vis[x])continue; getroot(x,node),ma=max(ma,siz[x]); } ma=max(ma,all-siz[node]); if(ma&lt;mx)mx=ma,root=node; } void init(int node,int f,int b){ int x; bl[node]=b,ema1[node]=ema2[node]=ma1[node]=ma2[node]=-inf,ap[node]=1,F[node]=node; for(vector&lt;pair&lt;int,int&gt; &gt;::iterator iter=v[node].begin();iter!=v[node].end();++iter) if(ap[iter-&gt;first]){ x=find(iter-&gt;first); if(x!=root)ma1[x]=max(ma1[x],iter-&gt;second); else { ee[iter-&gt;first]=max(ee[iter-&gt;first],iter-&gt;second),ee[node]=max(ee[node],iter-&gt;second); ma2[node]=max(ma2[node],iter-&gt;second),poi[b].push_back(iter-&gt;second); if(iter-&gt;first!=root)poi[bl[iter-&gt;first]].push_back(iter-&gt;second),ma2[iter-&gt;first]=max(ma2[iter-&gt;first],iter-&gt;second); q.push(iter-&gt;second); } } for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(x==f||vis[x])continue; init(x,node,b),F[x]=node,ma1[node]=max(ma1[node],ma1[x]+(e[i].l&lt;&lt;1)); } } void calc(int node,int f,int now){ siz[node]=1,ans[node]=max(ans[node],now); int x; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(x==f||vis[x])continue; calc(x,node,max(e[i].v==ema1[node]?ema2[node]:ema1[node],max(now,ma2[node]))+(e[i].l&lt;&lt;1)); siz[node]+=siz[x]; } } void calc_edge_value(int node,int f){ int x; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(x==f||vis[x])continue; calc_edge_value(x,node); ee[node]=max(ee[node],ee[x]),check(ema1[node],ema2[node],e[i].v=ee[x]); } ans[node]=max(ans[node],ee[node]); } void clear(int node,int f){ ap[node]=0,ee[node]=-inf; int x; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(x==f||vis[x])continue; clear(x,node),e[i].v=-inf; } } void solve(int node){ q.clear(),vis[node]=1; int x; ma1[node]=ma2[node]=-inf,F[node]=node,ap[node]=1,bl[node]=0; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(vis[x])continue; init(x,node,x),F[x]=node,check(ma1[node],ma2[node],ma1[x]+(e[i].l&lt;&lt;1)); } calc_edge_value(node,0); ans[node]=max(ans[node],ma1[node]); for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(vis[x])continue; for(register int j=0;j&lt;poi[x].size();++j)q.del(poi[x][j]); calc(x,node,max((ma1[x]+(e[i].l&lt;&lt;1)==ma1[node]?ma2[node]:ma1[node]),q.top())+(e[i].l&lt;&lt;1)); for(register int j=0;j&lt;poi[x].size();++j)q.push(poi[x][j]); poi[x].clear(); } clear(node,0); for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(vis[x])continue; mx=inf,all=siz[x],getroot(x,node),solve(root); } } void rebuild(int node=1,int f=0,int gf=0){ int x; if(node&gt;all)for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(x==f)continue; rebuild(x,node,f); } else for(register int i=origin::h[node];i;i=origin::e[i].pre){ x=origin::e[i].to; if(x==f||x==gf)continue; if(sp[x])add(node,sp[x],origin::e[i].l),add(sp[x],node,origin::e[i].l),add(sp[x],x,0),add(x,sp[x],0),x=sp[x]; else add(node,x,origin::e[i].l),add(x,node,origin::e[i].l); rebuild(x,node,f); } } int DIS(int x,int y){ return dis[x]+dis[y]-(dis[lca(x,y)]&lt;&lt;1); } int main(){ memset(ee,~0x3f,sizeof ee); int n=all=read(),m=read(),k=n,x,y,z,res=inf; for(register int i=1;i&lt;n;++i)x=read(),y=read(),z=read(),origin::add(x,y,z); for(register int i=1;i&lt;=m;++i){ qu[i][0]=x=read(),qu[i][1]=y=read(); if(x==y&amp;&amp;!sp[x])sp[x]=++k,qu[i][1]=k; } if(sp[1])add(sp[1],1,0),add(1,sp[1],0); rebuild(1,sp[1]),dfs1(),dfs2(); for(register int i=1;i&lt;=m;++i){ x=qu[i][0],y=qu[i][1],z=dis[x]+dis[y]-(dis[lca(x,y)]&lt;&lt;1); v[x].push_back((pair&lt;int,int&gt;){y,z}),v[y].push_back((pair&lt;int,int&gt;){x,z}); } memset(vis,0,sizeof vis); all=k,mx=inf,getroot(1,0),solve(root); for(register int i=1;i&lt;=n;++i)res=min(res,ans[i]); printf(&quot;%d\\n&quot;,res); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"点分治","slug":"点分治","permalink":"https://ctz45562.github.io/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"},{"name":"并查集","slug":"并查集","permalink":"https://ctz45562.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"LCA","slug":"LCA","permalink":"https://ctz45562.github.io/tags/LCA/"}]},{"title":"cdq分治学习笔记","slug":"cdq分治学习笔记","date":"2019-08-15T12:49:52.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/08/15/cdq分治学习笔记/","link":"","permalink":"https://ctz45562.github.io/2019/08/15/cdq%E5%88%86%E6%B2%BB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"点分治题给调吐了，于是来学$cdq$分治了（雾","text":"点分治题给调吐了，于是来学$cdq$分治了（雾 前言$cdq$分治是我第一个正规学习的离线算法。 $cdq$分治用于解决偏序问题，可以代替高级数据结构。 高级数据结构也可以代替cdq分治 抄袭来源 E:\\c\\c++\\学习资料\\sls讲课课件\\CDQ分治.pptx 偏序问题实现栗子 选择好想又好写的树套树 典型的三维偏序。 思考归并排序求逆序对，本质上是二维偏序。 第一维位置已经排好了，一定是左边对右边产生贡献。 当分治区间左半边和右半边都分别按第二维权值排好序时，我们只要用两个指针扫一遍即可。 现在是三维偏序，同样第一维排序，对第二维归并排序，考虑上第三维套个树状数组。 左指针移动时$c$位置上加$1$，右指针移动时查询小于等于$c$的数。 这就是$cdq$分治了。 甚至可以把树状数组换成$cdq$，$cdq$套$cdq$。 栗子里面由于都是小于等于，而$cdq$分治里限制了只有左边对右边会产生贡献，$a,b,c$都相同的元素之间贡献算不上。 将序列去重，每个元素记录个数，处理$c$的影响时要加上它的个数，统计答案时也要加上个数。 代码#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 100005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } template&lt;typename T&gt; inline T read(){ T x=0; int y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int dat[maxn&lt;&lt;1],f[maxn],g[maxn],ans[maxn],n,m; struct point{ int a,b,c,v; int *ans; bool operator &lt; (const point &amp;x)const{ if(a!=x.a)return a&lt;x.a; if(b!=x.b)return b&lt;x.b; return c&lt;x.c; } bool operator == (const point &amp;x){ return a==x.a&amp;&amp;b==x.b&amp;&amp;c==x.c; } }a[maxn],b[maxn]; #define lowb(x) (x&amp;-x) void add(int x,int d){ while(x&lt;=m)dat[x]+=d,x+=lowb(x); } int ask(int x){ int ans=0; while(x)ans+=dat[x],x-=lowb(x); return ans; } void cdq(int l=1,int r=n){ if(l==r)return; int mid=l+r&gt;&gt;1,k=l,pl=l,pr=mid+1; cdq(l,mid),cdq(mid+1,r); while(pl&lt;=mid&amp;&amp;pr&lt;=r){ if(a[pl].b&lt;=a[pr].b)add(a[pl].c,a[pl].v),b[k++]=a[pl++]; else *a[pr].ans+=ask(a[pr].c),b[k++]=a[pr++]; } while(pr&lt;=r)*a[pr].ans+=ask(a[pr].c),b[k++]=a[pr++]; for(register int i=l;i&lt;pl;++i)add(a[i].c,-a[i].v); while(pl&lt;=mid)b[k++]=a[pl++]; for(register int i=l;i&lt;=r;++i)a[i]=b[i]; } int main(){ n=read(),m=read(); for(register int i=1;i&lt;=n;++i)a[i].a=read(),a[i].b=read(),a[i].c=read(),a[i].v=1; sort(a+1,a+1+n); int len=0,rec=n; for(register int i=1;i&lt;=n;i+=a[i].v){ int k=i; while(k&lt;n&amp;&amp;a[i]==a[k+1])++a[i].v,++k; ++len,a[i].ans=f+len,b[len]=a[i],f[len]=(g[len]=a[i].v)-1; } n=len; for(register int i=1;i&lt;=len;++i)a[i]=b[i]; cdq(); for(register int i=1;i&lt;=n;++i)ans[f[i]]+=g[i]; for(register int i=0;i&lt;rec;++i)printf(&quot;%d\\n&quot;,ans[i]); } 复杂度非常显然的$O(n\\log^2 n)$。 $cdq$分治就跟线段树建树一个过程，最多$\\log n$层，每层合计要$O(n\\log n)$扫描，总复杂度$O(n\\log^2 n)$，常数还很小。 优化DP证明（并不是）$\\because$ 数据结构可以优化$DP$ 又$\\because cdq$分治可以代替高级数据结构 $\\therefore cdq$分治可以优化$DP$ 实现栗子 概括题意： 长度为$n$的序列，每个元素有两个属性$a,b$，求最长的子序列的长度，满足每一项的$a,b$都小于等于前一项。并求出每个元素出现在最长子序列中的概率。 设$f(i)$为以$i$为结尾的最长序列长度，$fc(i)$为序列个数，$g(i)$为以$i$为开头的最长序列长度，$gc(i)$类似于$fc(i)$。 设$ans=\\max\\{f(i)\\},cnt=\\sum\\limits_{i=1}^n[f(i)=ans]fc(i)$。 对于每个元素$i$，若$f(i)+g(i)-1=ans$，则其概率为$\\dfrac{fc(i)*gc(i)}{cnt}$，否则为$0$。 方程跟$LIS$的差不多： $f(i)=\\max\\limits_{j=1}^{i-1}\\{f(j)+1\\}(a_j\\ge a_i,b_j\\ge b_i)$ $fc(i)=\\sum\\limits_{j=1}^{i-1}[f(i)=f(j)+1]fc(j)(a_j\\ge a_i,b_j\\ge b_i)$ $g$和$gc$类似。 裸的树套树优化$DP$，空间$O(n\\log^2 n)$，常数和码量也不小（但是好想） 观察方程，实际上转移的条件为$j&lt;i,a_j\\ge a_i,b_j\\ge b_i$。 这不三维偏序吗。 假设分治区间为$[l,r]$，已经处理好$[l,mid]$的$f,fc$值，对$a$执行类似于归并排序的过程，再用树状数组维护一下前/后缀$DP$值（$b$需要离散化），大致和三维偏序一样。 为了使$DP$值是准确的，要先递归左区间，计算左区间对右区间的贡献，再递归右区间。 $g$和$gc$同样$cdq$分治。 时间复杂度$O(n\\log^2 n)$。 代码很鬼畜的是这题$fc$和$gc$的乘积会爆$long\\ long$，得用$double$存。。。 代码是$yy$出来的，很丑常数也不够优秀。 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 50005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } #define lowb(x) (x&amp;-x) int dis[maxn],len; struct point{ int d; double c; void clear(){d=0,c=0.0;} void operator += (const point &amp;x){ if(x.d&gt;d)*this=x; else if(x.d==d)c+=x.c; } void operator &lt;&lt; (const point &amp;x){ if(x.d+1&gt;d)*this=x,++d; else if(x.d+1==d)c+=x.c; } point(){d=1,c=1.0;} }f[maxn],g[maxn],dat[maxn]; struct miss{ int x,y; point *ans; }a[maxn],b[maxn],base[maxn]; inline bool cmp1(miss &amp;a,miss &amp;b){ return a.x&gt;b.x; } inline bool cmp2(miss &amp;a,miss &amp;b){ return a.x&lt;b.x; } inline void add(int x,point &amp;d){ while(x&lt;=len)dat[x]+=d,x+=lowb(x); } inline void clear(int x){ while(x&lt;=len)dat[x].clear(),x+=lowb(x); } inline point ask(int x){ point ans; ans.clear(); while(x)ans+=dat[x],x-=lowb(x); return ans; } void cdq1(int l,int r){ if(l==r)return; int mid=l+r&gt;&gt;1,pl=l,pr=mid+1; cdq1(l,mid); for(register int i=mid+1;i&lt;=r;++i)b[i]=a[i]; sort(b+mid+1,b+r+1,cmp1); while(pl&lt;=mid&amp;&amp;pr&lt;=r){ while(pl&lt;=mid&amp;&amp;a[pl].x&gt;=b[pr].x)add(len-a[pl].y+1,*a[pl].ans),++pl; *b[pr].ans&lt;&lt;ask(len-b[pr].y+1),++pr; } while(pr&lt;=r)*b[pr].ans&lt;&lt;ask(len-b[pr].y+1),++pr; for(register int i=l;i&lt;pl;++i)clear(len-a[i].y+1); cdq1(mid+1,r); sort(a+l,a+r+1,cmp1); } void cdq2(int l,int r){ if(l==r)return; int mid=l+r&gt;&gt;1,pl=l,pr=mid+1; cdq2(l,mid); for(register int i=mid+1;i&lt;=r;++i)b[i]=a[i]; sort(b+mid+1,b+r+1,cmp2); while(pl&lt;=mid&amp;&amp;pr&lt;=r){ while(pl&lt;=mid&amp;&amp;a[pl].x&lt;=b[pr].x)add(a[pl].y,*a[pl].ans),++pl; *b[pr].ans&lt;&lt;ask(b[pr].y),++pr; } while(pr&lt;=r)*b[pr].ans&lt;&lt;ask(b[pr].y),++pr; for(register int i=l;i&lt;pl;++i)clear(a[i].y); cdq2(mid+1,r); sort(a+l,a+r+1,cmp2); } int main(){ int n=read(); point ans; ans.clear(); for(register int i=1;i&lt;=n;++i)base[i].x=read(),base[i].y=dis[i]=read(); sort(dis+1,dis+1+n); len=unique(dis+1,dis+1+n)-dis-1; for(register int i=1;i&lt;=n;++i)base[i].y=lower_bound(dis+1,dis+1+len,base[i].y)-dis,a[i]=base[i],a[i].ans=f+i; for(register int i=1;i&lt;=len;++i)dat[i].clear(); cdq1(1,n); for(register int i=1,j=n;i&lt;j;++i,--j)swap(base[i],base[j]); for(register int i=1;i&lt;=n;++i)a[i]=base[i],a[i].ans=g+n-i+1; cdq2(1,n); for(register int i=1;i&lt;=n;++i)ans+=f[i]; printf(&quot;%d\\n&quot;,ans.d); for(register int i=1;i&lt;=n;++i) if(f[i].d+g[i].d-1==ans.d)printf(&quot;%.5lf &quot;,f[i].c*g[i].c/ans.c); else printf(&quot;0.00000 &quot;); } 其实$cdq$分治还能维护斜率优化然而我不会斜率优化告辞。 水题穷人的眼泪三道纯三维偏序板子，然而都是$bzoj$权限题 3963 2253 4430 天使玩偶/SJY摆棋子去掉绝对值，分四种情况讨论：在询问点左上、左下、右上、右下的点。 然后就成了三维分别为时间、$x$、$y$的最小值问题。跑四遍$cdq$，树状数组维护前/后缀最小值，复杂度$O((n+m)\\log^2n)$。 可能会卡常。每次$cdq$分治前预处理已有的$n$个点，按$x$为第一关键字，$y$为第二关键字排序，分治区间为在$[1,n]$时直接返回，复杂度降为$O(m\\log^2 n)$。 动态逆序对每个元素有被删除时间$t$、位置和权值$a_i$。 一个元素被删除后减少的逆序对为满足$t_j&gt;t_i,j&lt; i,a_j&gt;a_i$和$t_j&gt;t_i,j&gt;i,a_j&lt;a_i$的个数。 跑两遍$cdq$分治即可。 Mokia 摩基亚动态二维数点。 把查询矩形差分成四个矩形，然后就是时间、横坐标、纵坐标的三维偏序了。 序列以前拿树套树写的。 记$mi(i)$为位置$i$出现过的最小值，$ma(i)$为位置$i$出现过的最大值。 还是做一个$LIS$： $f(i)=\\max\\limits_{j=1}^{i-1}\\{f(j)+1\\}(mi(i)\\ge a_j,a_i\\ge ma(j))$ $cdq$分治优化即可。 真的找不到$cdq$分治的题啊$QAQ$","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ctz45562.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"cdq分治","slug":"cdq分治","permalink":"https://ctz45562.github.io/tags/cdq%E5%88%86%E6%B2%BB/"}]},{"title":"洛谷 P3714 [BJOI2017]树的难题","slug":"洛谷-P3714-BJOI2017-树的难题","date":"2019-08-15T11:11:17.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/08/15/洛谷-P3714-BJOI2017-树的难题/","link":"","permalink":"https://ctz45562.github.io/2019/08/15/%E6%B4%9B%E8%B0%B7-P3714-BJOI2017-%E6%A0%91%E7%9A%84%E9%9A%BE%E9%A2%98/","excerpt":"传送门 写了一天快吐了$QAQ$","text":"传送门 写了一天快吐了$QAQ$ 某个$zz$的假做法： 先考虑颜色不在边上而是在点上的做法。 $dis(i)$表示根节点到$i$的权值，$ma(i)$表示深度为$i$的点中最大的$dis$。 在合并路径时，根节点一定被经过。这样在计算$dis$时，不算上根节点的权值，计算时直接取恰当的$ma$加上即可，单调队列维护。 用$dis$更新$ma$时，再把根节点的权值加回来。 这是颜色在点上的情况，转到颜色在边上考虑拆边为点，拆出来的点颜色为原边的颜色。 那原有的点的颜色呢？ 它父节点指向它的边的颜色。。。 根节点呢？ 选一条出边为其颜色。。。 根节点不止一条出边呢？ 选一个度数为$1$的点为根节点。。。 写出来后成功喜提$20$分，发现这个做法完全是假的。。。 正解： 记$col(i)$为根节点到$i$的路径第一条边的颜色。 显然合并两条路径$x,y$时，若$col(x)=col(y)$需要减去$col(x)$的权值。 把$col$相同的放在一起考虑，对它们用单调队列维护，统计答案时减去该颜色的权值。 对$col$不同的还是单调队列，直接加起来统计。 为保证复杂度，不同$col$之间按包含路径中最大深度排序，优先处理深度小的。 同样地，相同$col$内部也优先处理深度小的。 统计时还要把深度相同的放一块处理，用$bfs$消去排序的$\\log$。 这样每次分治的复杂度为当前树大小。 总复杂度$O(n\\log n)$。 话说我就对个拍hack掉了所有有代码的题解。。。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #define maxn 200005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } struct Monoqueue{ int l1[maxn],l2[maxn],head,tail; void clear(){head=1,tail=0;} void check(int x){ while(head&lt;=tail&amp;&amp;l1[head]&gt;x)++head; } void push(int pos,int d){ if(d==-inf)return; while(head&lt;=tail&amp;&amp;l2[tail]&lt;d)--tail; l1[++tail]=pos,l2[tail]=d; } int front(){ if(head&lt;=tail)return l2[head]; return -inf; } }q1,q2; struct edge{ int pre,to,l; }e[maxn&lt;&lt;1]; int md[maxn],mmd[maxn],siz[maxn],v[maxn],c[maxn],h[maxn],col[maxn],L,R,mx,root,all,num,head,tail,ans; int f[maxn],line[maxn],deep[maxn],dis[maxn],sma[maxn],srec[maxn],dma[maxn]; vector&lt;int&gt;poi[maxn]; bool vis[maxn]; inline bool cmp1(int x,int y){return md[x]&lt;md[y];} inline bool cmp2(int x,int y){return mmd[x]&lt;mmd[y];} inline void add(int from,int to,int l){ e[++num].pre=h[from],h[from]=num,e[num].to=to,e[num].l=l; } void getroot(int node,int fa){ siz[node]=1; int x,ma=0; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(x==fa||vis[x])continue; getroot(x,node),siz[node]+=siz[x],ma=max(ma,siz[x]); } ma=max(ma,all-siz[node]); if(ma&lt;mx)mx=ma,root=node; } void bfs(int node){ int x,y; head=0,line[tail=1]=node,deep[node]=1; while(head&lt;tail){ x=line[++head]; if(deep[x]&gt;R){md[node]=R;return;} for(register int i=h[x];i;i=e[i].pre){ y=e[i].to; if(y==f[x]||vis[y])continue; c[y]=e[i].l,f[y]=x,line[++tail]=y,deep[y]=deep[x]+1; } } md[node]=deep[line[tail]]; } void calc(int node,int m){ q2.clear(); for(register int i=m;i&gt;=L;--i)q2.push(i,sma[i]); int x,y,l,r; head=0,line[tail=1]=node; while(head&lt;tail){ x=line[++head]; if(deep[x]&gt;R)return; dis[x]=dis[f[x]]+v[c[x]]*bool(c[x]^c[f[x]]); srec[deep[x]]=max(srec[deep[x]],dis[x]); for(register int i=h[x];i;i=e[i].pre){ y=e[i].to; if(y==f[x]||vis[y])continue; line[++tail]=y; } if(head==tail||deep[x]!=deep[line[head+1]]){ l=L-deep[x],r=R-deep[x]; q2.check(r); if(l&gt;=0)q2.push(l,sma[l]); ans=max(ans,q2.front()+srec[deep[x]]-dis[node]); } } } void calc_siz(int node,int f=0){ siz[node]=1; int x; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(x==f||vis[x])continue; calc_siz(x,node),siz[node]+=siz[x]; } } void solve(int node){ int x,y,z,len=0; vis[node]=1; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(vis[x])continue; if(poi[e[i].l].empty())col[++len]=e[i].l,mmd[e[i].l]=0; c[x]=e[i].l,f[x]=node,poi[c[x]].push_back(x),bfs(x); mmd[c[x]]=max(mmd[c[x]],md[x]); } c[node]=dis[node]=0; sort(col+1,col+1+len,cmp2); y=mmd[col[len]]; for(register int i=1;i&lt;=len;++i){ x=col[i],z=0; sort(poi[x].begin(),poi[x].end(),cmp1); for(vector&lt;int&gt;::iterator iter=poi[x].begin();iter!=poi[x].end();++iter){ dis[*iter]=v[x],calc(*iter,z); for(register int j=z=md[*iter];j;--j) sma[j]=max(sma[j],srec[j]),srec[j]=-inf; } q1.clear(); for(register int j=mmd[col[i-1]];j&gt;=L;--j)q1.push(j,dma[j]); for(register int j=1;j&lt;=mmd[x];++j){ q1.check(R-j); if(L&gt;=j)q1.push(L-j,dma[L-j]); ans=max(q1.front()+sma[j],ans); } for(register int j=mmd[x];j;--j) dma[j]=max(dma[j],sma[j]),sma[j]=-inf; poi[x].clear(); } for(register int i=y;i;--i)dma[i]=-inf; calc_siz(node); for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(vis[x])continue; root=0,all=siz[x],mx=inf,getroot(x,node),solve(root); } } int main(){ memset(sma,~0x3f,sizeof sma); memset(srec,~0x3f,sizeof srec); memset(dma,~0x3f,sizeof dma); ans=-inf,dma[0]=0; int n=read(),m=read(),x,y,z; L=read(),R=read(); for(register int i=1;i&lt;=m;++i)v[i]=read(); for(register int i=1;i&lt;n;++i)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z); mx=inf,all=n,getroot(1,0),solve(root); printf(&quot;%d\\n&quot;,ans); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"点分治","slug":"点分治","permalink":"https://ctz45562.github.io/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"},{"name":"单调队列","slug":"单调队列","permalink":"https://ctz45562.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"}]},{"title":"bzoj 3879 SvT","slug":"bzoj-3879-SvT","date":"2019-08-07T08:43:51.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/08/07/bzoj-3879-SvT/","link":"","permalink":"https://ctz45562.github.io/2019/08/07/bzoj-3879-SvT/","excerpt":"传送门 $SvT=SAM+Vitual\\ Tree$？（猜的）","text":"传送门 $SvT=SAM+Vitual\\ Tree$？（猜的） 其实是比较套路的$SAM$+虚树。把串反过来建$SAM$，找出每个后缀对应的节点，求在$parent\\ tree$上两两$LCA$的$len$和。 在$parent\\ tree$上造虚树，统计一下每个点子树中有多少个关键点记为$siz$。 考虑每个节点的贡献，它所有儿子两两之间会有$siz$之积的点数$LCA$是它，随便加一加乘一乘就好了。 （胡言乱语.jpg） 下面由我来展示一波高端错误： 建虚树时对$dfs$序排序，用的比较函数： inline bool cmp(int x,int y){return origin::seg[x]&lt;origin::seg[y]?x:y;} 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #define maxn 1000005 #define inf 0x3f3f3f3f const long long mod = 23333333333333333ll; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int n,m; namespace Suffix_Automaton{ #define son(x,y) son[x][y] char s[maxn]; int w[maxn],len[maxn],fa[maxn],son[maxn][26],last=1,cnt=1; void insert(int c){ int p=last,ne=last=++cnt; len[ne]=len[p]+1; while(p&amp;&amp;!son(p,c))son(p,c)=ne,p=fa[p]; if(!p)fa[ne]=1; else { int q=son(p,c); if(len[q]==len[p]+1)fa[ne]=q; else { int sp=++cnt; memcpy(son[sp],son[q],sizeof son[q]); len[sp]=len[p]+1,fa[sp]=fa[q],fa[q]=fa[ne]=sp; while(p&amp;&amp;son(p,c)==q)son(p,c)=sp,p=fa[p]; } } } void init(){ scanf(&quot;%s&quot;,s+1); for(register int i=n;i;--i)insert(s[i]-&#39;a&#39;); w[0]=1; for(register int i=1;i&lt;=n;++i)w[i]=son(w[i-1],s[n-i+1]-&#39;a&#39;); for(register int i=1;i&lt;=n&gt;&gt;1;++i)swap(w[i],w[n-i+1]); } } namespace origin{ int seg[maxn],top[maxn],son[maxn],siz[maxn],deep[maxn],fa[maxn],h[maxn],num,all; struct edge{ int pre,to; }e[maxn]; inline void add(int from,int to){ e[++num].pre=h[from],h[from]=num,e[num].to=to; } void dfs1(int node=1){ siz[node]=1; int x; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; deep[x]=deep[node]+1,fa[x]=node,dfs1(x); siz[node]+=siz[x]; if(siz[x]&gt;siz[son[node]])son[node]=x; } } void dfs2(int node=1){ seg[node]=++all; if(son[node]){ top[son[node]]=top[node],dfs2(son[node]); int x; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(x!=son[node])top[x]=x,dfs2(x); } } } int lca(int x,int y){ while(top[x]!=top[y])deep[top[x]]&lt;deep[top[y]]?y=fa[top[y]]:x=fa[top[x]]; return deep[x]&lt;deep[y]?x:y; } } namespace virt{ long long ans; int siz[maxn],h[maxn],num; vector&lt;int&gt;p; bool vis[maxn]; struct edge{ int pre,to; }e[maxn]; inline void add(int from,int to){ if(origin::seg[from]&gt;origin::seg[to])swap(from,to); e[++num].pre=h[from],h[from]=num,e[num].to=to; } inline bool cmp(int x,int y){return origin::seg[x]&lt;origin::seg[y];} struct Monostack{ int sta[maxn],top; void push(int x){sta[++top]=x;} void clear(){ for(register int i=2;i&lt;=top;++i)add(sta[i-1],sta[i]); top=0; } void check(int x){ int l=origin::lca(x,sta[top]); h[x]=0; if(l!=sta[top]){ while(origin::seg[l]&lt;origin::seg[sta[top-1]])add(sta[top-1],sta[top]),--top; --top; if(l!=sta[top])h[l]=0,add(sta[top+1],l),push(l); else add(sta[top+1],l); } push(x); } }s; void build(){ h[1]=0,s.push(1); for(vector&lt;int&gt;::iterator iter=p.begin();iter!=p.end();++iter)s.check(*iter); s.clear(); } void dfs(int node=1){ siz[node]=vis[node]; int x; long long k=0; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; dfs(x),k+=1ll*siz[x]*siz[node],siz[node]+=siz[x]; if(k&gt;=mod)k%=mod; } ans+=k*Suffix_Automaton::len[node]; if(ans&gt;=mod)ans%=mod; } void solve(){ ans=num=0,p.clear(); int t=read(),x; while(t--){ if(vis[x=Suffix_Automaton::w[read()]])continue; p.push_back(x),vis[x]=1; } sort(p.begin(),p.end(),cmp); build(),dfs(); for(vector&lt;int&gt;::iterator iter=p.begin();iter!=p.end();++iter)vis[*iter]=0; printf(&quot;%lld\\n&quot;,ans); } } int main(){ n=read(),m=read(); Suffix_Automaton::init(); for(register int i=2;i&lt;=Suffix_Automaton::cnt;++i)origin::add(Suffix_Automaton::fa[i],i); origin::dfs1(),origin::dfs2(); while(m--)virt::solve(); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://ctz45562.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"虚树","slug":"虚树","permalink":"https://ctz45562.github.io/tags/%E8%99%9A%E6%A0%91/"},{"name":"后缀自动机","slug":"后缀自动机","permalink":"https://ctz45562.github.io/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"}]},{"title":"Codeforces809E Surprise me!","slug":"洛谷-CF809E-Surprise-me","date":"2019-08-05T07:52:10.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/08/05/洛谷-CF809E-Surprise-me/","link":"","permalink":"https://ctz45562.github.io/2019/08/05/%E6%B4%9B%E8%B0%B7-CF809E-Surprise-me/","excerpt":"传送门 $\\text{wdnmd}$这题做起来刺激","text":"传送门 $\\text{wdnmd}$这题做起来刺激 转换一下$a_i$的定义：权值为$i$的点的编号。 这样求的答案就成了$\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^n\\varphi(i\\times j)dis(a_i,a_j)$ 反演还是很套路的： $=\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^n\\dfrac{\\varphi(i)\\varphi(j)gcd(i,j)}{\\varphi(gcd(i,j))}dis(a_i,a_j)$ $=\\sum\\limits_{d=1}^n\\dfrac{d}{\\varphi(d)}\\sum\\limits_{i=1}^n\\varphi(i)\\sum\\limits_{j=1}^n\\varphi(j)[gcd(i,j)=d]dis(a_i,a_j)$ $=\\sum\\limits_{d=1}^n\\dfrac{d}{\\varphi(d)}\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\varphi(id)\\sum\\limits_{j=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\varphi(jd)dis(a_{id},a_{jd})\\sum\\limits_{a|gcd(i,j)}\\mu(a)$ $=\\sum\\limits_{d=1}^n\\dfrac{d}{\\varphi(d)}\\sum\\limits_{a=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\mu(a)\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{ad}\\rfloor}\\varphi(iad)\\sum\\limits_{j=1}^{\\lfloor\\frac{n}{ad}\\rfloor}\\varphi(jad)dis(a_{iad},a_{jad})$ 令$T=ad$，枚举$T$： $=\\sum\\limits_{d=1}^n\\dfrac{d}{\\varphi(d)}\\sum\\limits_{T=1}^n[d|T]\\mu(\\dfrac{T}{d})\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{T}\\rfloor}\\varphi(iT)\\sum\\limits_{j=1}^{\\lfloor\\frac{n}{T}\\rfloor}\\varphi(jT)dis(a_{iT},a_{jT})$ $=\\sum\\limits_{T=1}^n\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{T}\\rfloor}\\varphi(iT)\\sum\\limits_{j=1}^{\\lfloor\\frac{n}{T}\\rfloor}\\varphi(jT)dis(a_{iT},a_{jT})\\sum\\limits_{d|T}\\mu(\\dfrac{T}{d})\\dfrac{d}{\\varphi(d)}$ 最后面$\\sum\\limits_{d|T}$的一坨是个卷积形式，可以线筛，不过$O(n\\log n)$枚举倍数预处理就够了。 看中间那一坨，考虑它的含义，其实就是把编号为$a_{iT}$的点拿出来，点权为$\\varphi(iT)$，求它们两两之间$value(i)\\times value(j)\\times dis(i,j)$之和。 而这个式子是个调和级数，总点数是$O(n\\log n)$的，大力对点集$\\{a_{iT}|i\\in \\mathbb{Z}\\}$上虚树。 记$siz(i)$为点$i$的子树权值和，考虑每条边$edge(i,j)$的贡献，为$length(edge(i,j))\\times siz(j)\\times(siz(root)-siz(j))$。 于是就能$O(n\\log^2n)$解决辣。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #define maxn 200005 #define inf 0x3f3f3f3f const int mod = 1e9 + 7; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int deep[maxn],seg[maxn],a[maxn],all; vector&lt;int&gt;p; bool vis[maxn]; namespace origin{ int top[maxn],fa[maxn],son[maxn],siz[maxn],h[maxn],num; struct edge{ int pre,to; }e[maxn&lt;&lt;1]; inline void add(int from,int to){ e[++num].pre=h[from],h[from]=num,e[num].to=to; } void dfs1(int node=1){ siz[node]=1; int x; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(siz[x])continue; fa[x]=node,deep[x]=deep[node]+1,dfs1(x),siz[node]+=siz[x]; if(siz[x]&gt;siz[son[node]])son[node]=x; } } void dfs2(int node=1){ seg[node]=++all; if(son[node]){ int x=son[node]; top[x]=top[node],dfs2(x); for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(!seg[x])top[x]=x,dfs2(x); } } } int lca(int x,int y){ while(top[x]!=top[y])deep[top[x]]&lt;deep[top[y]]?y=fa[top[y]]:x=fa[top[x]]; return deep[x]&lt;deep[y]?x:y; } } namespace virt{ int siz[maxn],h[maxn],num,ans; struct edge{ int pre,to,l; }e[maxn&lt;&lt;1]; inline void add(int from,int to){ int l=abs(deep[from]-deep[to]); e[++num].pre=h[from],h[from]=num,e[num].to=to,e[num].l=l; e[++num].pre=h[to],h[to]=num,e[num].to=from,e[num].l=l; } bool cmp(int x,int y){return seg[x]&lt;seg[y];} struct Monostack{ int sta[maxn],top; void push(int x){sta[++top]=x;} void clear(){ for(register int i=2;i&lt;=top;++i)add(sta[i],sta[i-1]); top=0; } void check(int x){ if(x==1)return; int l=origin::lca(x,sta[top]); h[x]=0; if(l!=sta[top]){ while(seg[l]&lt;seg[sta[top-1]])add(sta[top],sta[top-1]),--top; --top; if(l!=sta[top])h[l]=0,add(sta[top+1],l),push(l); else add(sta[top+1],l); } push(x); } }s; void build(){ h[1]=0,s.push(1); for(vector&lt;int&gt;::iterator iter=p.begin();iter!=p.end();++iter)s.check(*iter); s.clear(); } void dfs(int node=1,int fa=0){ if(!vis[node])siz[node]=0; int x; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(x!=fa)dfs(x,node),(siz[node]+=siz[x])%=mod; } } void calc(int node=1,int fa=0){ int x; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(x!=fa)calc(x,node),(ans+=1ll*e[i].l*siz[x]%mod*(siz[1]-siz[x])%mod)%=mod; } } int solve(){ sort(p.begin(),p.end(),cmp); num=0,ans=0,build(),dfs(),calc(); for(vector&lt;int&gt;::iterator iter=p.begin();iter!=p.end();++iter)vis[*iter]=siz[*iter]=0; return ans; } } namespace mobius{ int phi[maxn],mu[maxn],f[maxn],prime[maxn&gt;&gt;2],inv[maxn],cnt; bool is[maxn]; void solve(int n){ int ans=0; is[1]=phi[1]=mu[1]=inv[1]=1; for(register int i=2;i&lt;=n;++i){ inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod; if(!is[i])prime[++cnt]=i,phi[i]=i-1,mu[i]=-1; for(register int j=1;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=n;++j){ is[i*prime[j]]=1; if(i%prime[j]==0){ mu[i*prime[j]]=0,phi[i*prime[j]]=phi[i]*prime[j]; break; } phi[i*prime[j]]=phi[i]*(prime[j]-1),mu[i*prime[j]]=-mu[i]; } } for(register int i=1;i&lt;=n;++i) for(register int j=i;j&lt;=n;j+=i) (f[j]+=1ll*mu[j/i]*i*inv[phi[i]]%mod)%=mod; for(register int i=1;i&lt;=n;++i){ p.clear(); for(register int j=i;j&lt;=n;j+=i) p.push_back(a[j]),vis[a[j]]=1,virt::siz[a[j]]=phi[j]; (ans+=1ll*virt::solve()*f[i]%mod)%=mod; } ans=1ll*(ans&lt;&lt;1)*inv[n]%mod*inv[n-1]%mod; printf(&quot;%d\\n&quot;,(ans+mod)%mod); } } int main(){ using namespace origin; int n=read(),x,y; for(register int i=1;i&lt;=n;++i)a[read()]=i; for(register int i=1;i&lt;n;++i)x=read(),y=read(),add(x,y),add(y,x); dfs1(),dfs2(); mobius::solve(n); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"虚树","slug":"虚树","permalink":"https://ctz45562.github.io/tags/%E8%99%9A%E6%A0%91/"},{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"https://ctz45562.github.io/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"}]},{"title":"Codeforces613D Kingdom and its Cities","slug":"洛谷-CF613D-Kingdom-and-its-Cities","date":"2019-08-04T12:48:24.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/08/04/洛谷-CF613D-Kingdom-and-its-Cities/","link":"","permalink":"https://ctz45562.github.io/2019/08/04/%E6%B4%9B%E8%B0%B7-CF613D-Kingdom-and-its-Cities/","excerpt":"传送门 一个思路清奇代码复杂常数大看起来很假的$DP$做法。","text":"传送门 一个思路清奇代码复杂常数大看起来很假的$DP$做法。 建出虚树，设$f(i,0)$为使点$i$的子树内的关键点互不联通，且存在关键点与点$i$联通的最小代价；$f(i,1)$为使点$i$的子树内的关键点互不联通，且不存在关键点与点$i$联通的最小代价。 若$i$为关键点： $f(i,1)$的情况不可能成立（关键点$i$和$i$联通），$f(i,1)=inf$。 判断一下是否有$i$的儿子为关键点且与$i$在原树上有边，存在则无解。 对于$f(i,0)$，处于情况$0$的儿子为满足关键点互不联通，需断掉路径上的某个点，处于情况$1$的儿子不用管，$f(i,0)=\\sum\\limits_{j\\in son(i)}\\min\\{f(j,1),f(j,0)+1\\}$ 若$i$不为关键点： 若$i$有不少于$2$个点为关键点，不可能存在情况$0$，此时$f(i,0)=inf$。 否则其儿子里需有且只有处于情况$0$，即$f(i,0)=\\sum\\limits_{j\\in son(i)}f(j,1)+\\min\\limits_{j\\in son(i)}\\{f(j,0)-f(j,1)\\}$ 对于$f(i,1)$，要么断开点$i$，儿子随便选；要么儿子都处于情况$1$。即$f(i,1)=\\min\\{\\left(\\sum\\limits_{j\\in son(i)}\\min\\{f(j,0),f(j,1)\\}\\right)+1,\\sum\\limits_{j\\in son(i)}f(j,1)\\}$ 最后答案为$\\min\\{f(1,0),f(1,1)\\}$。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #define maxn 100005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } namespace origin{ int seg[maxn],top[maxn],son[maxn],fa[maxn],deep[maxn],siz[maxn],h[maxn],all,num; struct edge{ int pre,to; }e[maxn&lt;&lt;1]; inline void add(int from,int to){ e[++num].pre=h[from],h[from]=num,e[num].to=to; } void dfs1(int node=1){ siz[node]=1; int x; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(!siz[x]){ fa[x]=node,deep[x]=deep[node]+1,dfs1(x),siz[node]+=siz[x]; if(siz[x]&gt;siz[son[node]])son[node]=x; } } } void dfs2(int node=1){ seg[node]=++all; if(son[node]){ top[son[node]]=top[node],dfs2(son[node]); int x; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(!seg[x])top[x]=x,dfs2(x); } } } int lca(int x,int y){ while(top[x]!=top[y])deep[top[x]]&lt;deep[top[y]]?y=fa[top[y]]:x=fa[top[x]]; return deep[x]&lt;deep[y]?x:y; } } namespace virt{ int h[maxn],f[maxn][2],num,n; bool vis[maxn],flag; vector&lt;int&gt;p; struct edge{ int pre,to; bool l; }e[maxn&lt;&lt;1]; inline void add(int from,int to){ bool l=(origin::fa[from]==to)||(origin::fa[to]==from); e[++num].pre=h[from],h[from]=num,e[num].to=to,e[num].l=l; e[++num].pre=h[to],h[to]=num,e[num].to=from,e[num].l=l; } inline bool cmp(int x,int y){return origin::seg[x]&lt;origin::seg[y];} struct Monostack{ int sta[maxn],top; void push(int x){sta[++top]=x;} void clear(){ for(register int i=2;i&lt;=top;++i)add(sta[i],sta[i-1]); top=0; } void check(int x){ if(x==1)return; int l=origin::lca(x,sta[top]); h[x]=0; if(l!=sta[top]){ while(origin::seg[l]&lt;origin::seg[sta[top-1]])add(sta[top],sta[top-1]),--top; --top; if(l!=sta[top])h[l]=0,add(sta[top+1],l),push(l); else add(sta[top+1],l); } push(x); } }s; void dfs(int node=1,int fa=0){ f[node][0]=(vis[node]^1)*n,f[node][1]=vis[node]*n; int x,siz=0,rec=0,ma=0; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(x==fa)continue; siz+=vis[x],dfs(x,node); if(vis[node]){ if(vis[x]&amp;&amp;e[i].l)flag=1; f[node][0]+=min(f[x][1],f[x][0]+1); } else { ma=max(ma,f[x][1]-f[x][0]); rec+=min(f[x][0],f[x][1]); f[node][1]+=f[x][1]; } } if(!vis[node]){ if(siz&lt;=1)f[node][0]=f[node][1]-ma; f[node][1]=min(f[node][1],rec+1); } } void build(){ h[1]=0,s.push(1); for(vector&lt;int&gt;::iterator iter=p.begin();iter!=p.end();++iter)s.check(*iter); s.clear(); } void solve(){ p.clear(),flag=0,n=read(),num=0; int x; for(register int i=1;i&lt;=n;++i)p.push_back(x=read()),vis[x]=1; sort(p.begin(),p.end(),cmp); build(),dfs(); printf(&quot;%d\\n&quot;,flag?-1:min(f[1][0],f[1][1])); for(vector&lt;int&gt;::iterator iter=p.begin();iter!=p.end();++iter)vis[*iter]=0; } } int main(){ using namespace origin; int n=read(),x,y; for(register int i=1;i&lt;n;++i)x=read(),y=read(),add(x,y),add(y,x); dfs1(),dfs2(),n=read(); while(n--)virt::solve(); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"虚树","slug":"虚树","permalink":"https://ctz45562.github.io/tags/%E8%99%9A%E6%A0%91/"}]},{"title":"洛谷 P4103 [HEOI2014]大工程","slug":"洛谷-P4103-HEOI2014-大工程","date":"2019-08-03T12:19:02.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/08/03/洛谷-P4103-HEOI2014-大工程/","link":"","permalink":"https://ctz45562.github.io/2019/08/03/%E6%B4%9B%E8%B0%B7-P4103-HEOI2014-%E5%A4%A7%E5%B7%A5%E7%A8%8B/","excerpt":"传送门 挂上点分治的标签是因为如果数据范围小一点我就真的去写点分了。。。","text":"传送门 挂上点分治的标签是因为如果数据范围小一点我就真的去写点分了。。。 先把虚树造出来。统计所有路径的最值和权值和。。。点分治！ 成功被数据范围拦了下来。。。（刚学点分治和虚树的我表示两样能一块练多好） 考虑$DP$，最大值类似于树的直径，只不过两端点必须为关键点。 设$ma(i)$为以点$i$到其子树中的关键点的最长路径长度。若$i$为关键点，$ma(i)$初值为$0$，否则为$-inf$，然后和树的直径一样$DP$即可。最小值类似。 对于权值和，记$siz(i)$为点$i$的子树中关键点的个数（包括$i$），$len(i)$为点$i$到其子树中所有关键点的路径权值之和。 显然，$siz(i)=\\sum\\limits_{edge(i,j)}siz(j)$，$len(i)=\\sum\\limits_{edge(i,j)}len(j)+siz(j)*length(edge(i,j))$。 对答案的贡献即$\\sum\\limits_{edge(i,j)}siz(i)*[len(j)+siz(j)*length(edge(i,j))]+siz(j)*len(i)$，注意此处的$siz(i)$和$len(i)$是统计到$j$时的值。 其实还有更简单的方法，直接统计每条边被经过的次数乘上边长，即$length(edge(i,j))*siz(j)*(k-siz(j))$ 复杂度$O(\\sum k\\log n)$，$\\log n$是小常数树剖$lca$和排序。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #define maxn 1000005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } struct edge{ int pre,to,l; }; namespace origin{ int h[maxn],seg[maxn],top[maxn],son[maxn],fa[maxn],deep[maxn],siz[maxn],num,all; edge e[maxn&lt;&lt;1]; inline void add(int from,int to){ e[++num].pre=h[from],h[from]=num,e[num].to=to; } void dfs1(int node=1){ siz[node]=1; int x; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(!siz[x]){ fa[x]=node,deep[x]=deep[node]+1; dfs1(x),siz[node]+=siz[x]; if(siz[x]&gt;siz[son[node]])son[node]=x; } } } void dfs2(int node=1){ seg[node]=++all; if(son[node]){ top[son[node]]=top[node],dfs2(son[node]); int x; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(!seg[x])top[x]=x,dfs2(x); } } } int lca(int x,int y){ while(top[x]!=top[y])deep[top[x]]&lt;deep[top[y]]?y=fa[top[y]]:x=fa[top[x]]; return deep[x]&lt;deep[y]?x:y; } } namespace virt{ int ma[maxn],mi[maxn],h[maxn],siz[maxn],num,ans2,ans3; long long len[maxn],ans1; bool vis[maxn]; vector&lt;int&gt;p; edge e[maxn&lt;&lt;1]; inline void add(int from,int to){ int l=abs(origin::deep[from]-origin::deep[to]); e[++num].pre=h[from],h[from]=num,e[num].to=to,e[num].l=l; e[++num].pre=h[to],h[to]=num,e[num].to=from,e[num].l=l; } struct Monostack{ int sta[maxn],top; void clear(){ for(register int i=2;i&lt;=top;++i)add(sta[i],sta[i-1]); top=0; } void push(int x){ sta[++top]=x; } void check(int x){ if(x==1)return; int l=origin::lca(x,sta[top]); h[x]=0; if(l!=sta[top]){ while(origin::seg[l]&lt;origin::seg[sta[top-1]])add(sta[top],sta[top-1]),--top; --top; if(l!=sta[top])h[l]=0,add(sta[top+1],l),push(l); else add(sta[top+1],l); } push(x); } }s; inline bool cmp(int x,int y){ return origin::seg[x]&lt;origin::seg[y]; } void build(){ h[1]=0,s.push(1); for(vector&lt;int&gt;::iterator iter=p.begin();iter!=p.end();++iter)s.check(*iter); s.clear(); } void dfs(int node=1,int f=0){ siz[node]=vis[node],len[node]=0,mi[node]=vis[node]?0:inf,ma[node]=vis[node]?0:-inf; int x; long long l; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(x==f)continue; dfs(x,node); l=len[x]+1ll*e[i].l*siz[x]; ans1+=siz[node]*l+siz[x]*len[node]; siz[node]+=siz[x],len[node]+=l; ans2=min(ans2,mi[node]+mi[x]+e[i].l); ans3=max(ans3,ma[node]+ma[x]+e[i].l); mi[node]=min(mi[node],mi[x]+e[i].l); ma[node]=max(ma[node],ma[x]+e[i].l); } } void solve(){ p.clear(),num=ans1=ans3=0,ans2=inf; int n=read(),x; for(register int i=1;i&lt;=n;++i)p.push_back(x=read()),vis[x]=1; sort(p.begin(),p.end(),cmp); build(),dfs(); printf(&quot;%lld %d %d\\n&quot;,ans1,ans2,ans3); for(vector&lt;int&gt;::iterator iter=p.begin();iter!=p.end();++iter)vis[*iter]=0; } } int main(){ int n=read(),x,y; for(register int i=1;i&lt;n;++i)x=read(),y=read(),origin::add(x,y),origin::add(y,x); origin::dfs1(),origin::dfs2(); n=read(); while(n--)virt::solve(); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"虚树","slug":"虚树","permalink":"https://ctz45562.github.io/tags/%E8%99%9A%E6%A0%91/"},{"name":"点分治","slug":"点分治","permalink":"https://ctz45562.github.io/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"},{"name":"单调栈","slug":"单调栈","permalink":"https://ctz45562.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://ctz45562.github.io/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"}]},{"title":"虚树学习笔记","slug":"虚树学习笔记","date":"2019-08-03T07:13:01.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/08/03/虚树学习笔记/","link":"","permalink":"https://ctz45562.github.io/2019/08/03/%E8%99%9A%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"果然还是对概率期望不感冒。。。 还是种田很酷很炫的算法适合老子。","text":"果然还是对概率期望不感冒。。。 还是种田很酷很炫的算法适合老子。 前言又一个学长要讲而我还不会的算法。 对一棵树进行操作，而其中的关键点并不多，且非关键点是无关紧要的，就可以上虚树（$Virtual\\ Tree$），用$O$(关键点数)的时间搞事情了。 抄袭来源 https://oi-wiki.org/graph/virtual-tree/ 虚树实现经典栗子 有一个$O(n)$的$DP$： 设$f(i)$为阻断点$i$到其子树所有关键点最小代价。 记$x$为$i$的某个儿子，若$x$为关键点，有$len(edge(i,x))$的贡献；否则有$\\min\\{len(edge(i,x)),f(x)\\}$的贡献。答案为$f(1)$。 如果构造出虚树在虚树上$DP$，复杂度就是对的了。 虚树保留了关键点和它们两两之间的$lca$，就是酱紫（红色的为关键点）： 在栗子中，压缩进去的链以边权为其最小值的边代替。 虚树构造的核心是用单调栈维护虚树的一条链，单调栈从上至下$dfs$序递减，某个节点的爹是它在栈中下面的点。 对关键点按$dfs$序排序，先把点$1$加进去，再依次把每个关键点加进去： 求出它与栈顶的$lca$记为$l$。 若栈顶为$l$，说明新加的点挂在这条链下面，直接压进栈里。 （红色为当前的链，蓝色为新加的点） 若栈顶不为$l$，维护的链就会变为根节点到新点的链，栈中弹出$dfs$序比$l$大的点，并把弹出的点与它爹（它下面的点）连边。 这时可能$l$不在链上（下图右），需要额外加进去。 所有关键点处理完后，把栈中剩余的点之间连边。 代码细节很多。。。 int h[maxn],seg[maxn],num,n;//seg为dfs序,n为关键点数 vector&lt;int&gt;p;//p存储关键点 struct edge{ int pre,to,l; }e[maxn&lt;&lt;1]; inline bool cmp(int x,int y){return seg[x]&lt;seg[y];} inline void add(int from,int to){ int l=query(from,to);//query是查询两点间最小值 e[++num].pre=h[from],h[from]=num,e[num].to=to,e[num].l=l; e[++num].pre=h[to],h[to]=num,e[num].to=from,e[num].l=l; } struct Monostack{ int sta[maxn],top; void clear(){ for(register int i=2;i&lt;=top;++i)add(sta[i],sta[i-1]); top=0; } void push(int x){ sta[++top]=x; } void check(int x){ int l=lca(sta[top],x); h[x]=0; if(l!=sta[top]){ while(seg[l]&lt;seg[sta[top-1]])add(sta[top],sta[top-1]),--top; --top; if(l==sta[top])add(l,sta[top+1]); else h[l]=0,add(l,sta[top+1]),push(l); } push(x); } }s;//单调栈 void build(){ h[1]=0,s.push(1); sort(p.begin(),p.end(),cmp);//以dfs序排序 for(vector&lt;int&gt;::iterator iter=p.begin();iter!=p.end();++iter)s.check(*iter); s.clear(); } 每个点入栈时清空邻接表头指针，防止大量$memset$耗费时间 栗子完整代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #define maxn 250005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } namespace origin{ int h[maxn],seg[maxn],fa[maxn],deep[maxn],top[maxn],siz[maxn],son[maxn],f[maxn][22],lg[maxn],a[maxn],all,num,n; struct edge{ int pre,to,l; }e[maxn&lt;&lt;1]; inline void add(int from,int to,int l){ e[++num].pre=h[from],h[from]=num,e[num].to=to,e[num].l=l; } void dfs1(int node=1){ siz[node]=1; int x; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(!siz[x]){ a[x]=e[i].l,fa[x]=node,deep[x]=deep[node]+1,dfs1(x),siz[node]+=siz[x]; if(siz[x]&gt;siz[son[node]])son[node]=x; } } } void dfs2(int node=1){ f[seg[node]=++all][0]=a[node]; if(son[node]){ top[son[node]]=top[node],dfs2(son[node]); int x; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(!seg[x])top[x]=x,dfs2(x); } } } inline int lca(int x,int y){ while(top[x]!=top[y])deep[top[x]]&lt;deep[top[y]]?y=fa[top[y]]:x=fa[top[x]]; return deep[x]&lt;deep[y]?x:y; } void ST(){ for(register int i=2;i&lt;=n;++i)lg[i]=lg[i&gt;&gt;1]+1; for(register int j=1;j&lt;=lg[n];++j) for(register int i=1;i+(1&lt;&lt;j)-1&lt;=n;++i) f[i][j]=min(f[i][j-1],f[i+(1&lt;&lt;j-1)][j-1]); } inline void init(){ dfs1(),dfs2(),ST(); } inline int ask(int l,int r){ int len=lg[r-l+1]; return min(f[l][len],f[r-(1&lt;&lt;len)+1][len]); } int query(int x,int y){ int ans=inf; while(top[x]!=top[y]){ if(deep[top[x]]&lt;deep[top[y]])swap(x,y); ans=min(ans,ask(seg[top[x]],seg[x])); x=fa[top[x]]; } if(x==y)return ans; if(deep[x]&lt;deep[y])swap(x,y); return min(ans,ask(seg[y]+1,seg[x])); } } namespace virt{ int h[maxn],num,n; long long f[maxn]; bool vis[maxn]; vector&lt;int&gt;p; struct edge{ int pre,to,l; }e[maxn&lt;&lt;1]; inline void add(int from,int to){ int l=origin::query(from,to); e[++num].pre=h[from],h[from]=num,e[num].to=to,e[num].l=l; e[++num].pre=h[to],h[to]=num,e[num].to=from,e[num].l=l; } struct Monostack{ int sta[maxn],top; void clear(){ for(register int i=2;i&lt;=top;++i)add(sta[i],sta[i-1]); top=0; } void push(int x){ sta[++top]=x; } void check(int x){ h[x]=0; int l=origin::lca(sta[top],x); if(l!=sta[top]){ while(origin::seg[l]&lt;origin::seg[sta[top-1]])add(sta[top],sta[top-1]),--top; --top; if(l!=sta[top])h[l]=0,add(sta[top+1],l),push(l); else add(sta[top+1],l); } push(x); } }s; inline bool cmp(int x,int y){return origin::seg[x]&lt;origin::seg[y];} void build(){ h[1]=0,s.push(1); for(vector&lt;int&gt;::iterator iter=p.begin();iter!=p.end();++iter)s.check(*iter); s.clear(); } void dp(int node=1,int fa=0){ f[node]=0; int x; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(x!=fa){ if(vis[x])f[node]+=e[i].l; else dp(x,node),f[node]+=min(1ll*e[i].l,f[x]); } } } void solve(){ num=0,p.clear(),n=read(); int x; for(register int i=1;i&lt;=n;++i)p.push_back(x=read()),vis[x]=1; sort(p.begin(),p.end(),cmp); build(),dp(); printf(&quot;%lld\\n&quot;,f[1]); for(vector&lt;int&gt;::iterator iter=p.begin();iter!=p.end();++iter)vis[*iter]=0; } } int main(){ origin::n=read(); int x,y,z,t; for(register int i=1;i&lt;origin::n;++i)x=read(),y=read(),z=read(),origin::add(x,y,z),origin::add(y,x,z); origin::init(); t=read(); while(t--)virt::solve(); } 复杂度$n$个关键点的虚树点数不超过$2n-1$，感觉是比较显然的吧。。。 栗子中用树剖+ST表求链最小值，树剖求$lca$，复杂度为$O(\\sum k\\log n)$。 从代码里也能看出整个虚树构造是$O(k\\log n)$的，若用$O(1)LCA$的话还是带一个排序的$\\log k$。 水题大工程题解 Kingdom and its Cities并不可靠の题解 世界树题解 Surprise me!莫比乌斯反演+虚树。 题解 SvT$SAM$+虚树。 题解","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ctz45562.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"虚树","slug":"虚树","permalink":"https://ctz45562.github.io/tags/%E8%99%9A%E6%A0%91/"},{"name":"单调栈","slug":"单调栈","permalink":"https://ctz45562.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}]},{"title":"洛谷 P3232 [HNOI2013]游走","slug":"洛谷-P3232-HNOI2013-游走","date":"2019-08-02T10:40:32.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/08/02/洛谷-P3232-HNOI2013-游走/","link":"","permalink":"https://ctz45562.github.io/2019/08/02/%E6%B4%9B%E8%B0%B7-P3232-HNOI2013-%E6%B8%B8%E8%B5%B0/","excerpt":"传送门 我要被「冰菓」的狗粮甜死了。。。","text":"传送门 我要被「冰菓」的狗粮甜死了。。。 设$f(i)$为期望经过点$i$的次数。 显然，$f(i)=\\sum\\limits_{edge(i,v)}\\dfrac{f(v)}{d(v)}$，$d(v)$为点$v$的度数。 由于是无向连通图，没法直接$DP$，得用高斯消元解出来。（吓得我又重背学了遍高消） 还有俩特殊点：$1$和$n$。点$1$为起点，$f(1)$要$+1$；点$n$为终点，列方程时不要管点$n$，只解出前$n-1$个点。 设$g(i)$为期望经过边$i$的次数。 经过边$i$是从两个端点过来的，于是$g(i)=\\dfrac{x_i}{d(x_i)}+\\dfrac{y_i}{d(y_i)}$ 因为不会从点$n$走过来，所以$x_i,y_i\\neq n$。 最后排个序贪心标号即可。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #define maxn 505 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } double a[maxn][maxn],f[maxn],g[maxn*maxn]; int n,d[maxn],x[maxn*maxn],y[maxn*maxn]; vector&lt;int&gt;e[maxn]; void Gauss(){ for(register int i=1;i&lt;n;++i){ int now=i; for(register int j=i+1;j&lt;n;++j) if(fabs(a[now][i])&lt;fabs(a[j][i]))now=j; if(i!=now)for(register int j=i;j&lt;=n;++j)swap(a[now][j],a[i][j]); double main=a[i][i]; for(register int j=i;j&lt;=n;++j)a[i][j]/=main; for(register int j=i+1;j&lt;n;++j){ double p=a[j][i]; for(register int k=i;k&lt;=n;++k) a[j][k]-=p*a[i][k]; } } for(register int i=n-1;i;--i){ f[i]=a[i][n]; for(register int j=i+1;j&lt;n;++j) f[i]-=a[i][j]*f[j]; } } int main(){ n=read(); int m=read(); double ans=0.0; for(register int i=1;i&lt;=m;++i){ ++d[x[i]=read()],++d[y[i]=read()]; e[x[i]].push_back(y[i]),e[y[i]].push_back(x[i]); } for(register int i=1;i&lt;n;++i){ for(vector&lt;int&gt;::iterator iter=e[i].begin();iter!=e[i].end();++iter) if(*iter!=n)a[i][*iter]=-1.0/(1.0*d[*iter]); a[i][i]=1.0; } a[1][n]=1.0; Gauss(); for(register int i=1;i&lt;=m;++i){ if(x[i]!=n)g[i]=f[x[i]]/(double)d[x[i]]; if(y[i]!=n)g[i]+=f[y[i]]/(double)d[y[i]]; } sort(g+1,g+1+m); for(register int i=1;i&lt;=m;++i) ans+=g[i]*(double)(m-i+1); printf(&quot;%.3lf\\n&quot;,ans); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://ctz45562.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"概率期望","slug":"概率期望","permalink":"https://ctz45562.github.io/tags/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/"},{"name":"高斯消元","slug":"高斯消元","permalink":"https://ctz45562.github.io/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"}]},{"title":"点分治&点分树学习笔记","slug":"点分治&点分树学习笔记","date":"2019-08-02T01:01:25.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/08/02/点分治&点分树学习笔记/","link":"","permalink":"https://ctz45562.github.io/2019/08/02/%E7%82%B9%E5%88%86%E6%B2%BB&%E7%82%B9%E5%88%86%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"擅长捉弄夫人的高木同学","text":"擅长捉弄夫人的高木同学 前言本来在学概率期望的，然而学长要讲点分治，好像还不讲板子于是过来学了。 点分治一般用于解决树上路径统计问题（满足某某条件的路径有多少条）。 顺便把点分树学了。 抄袭来源 「算法竞赛·进阶指南」？ https://oi-wiki.org/graph/dynamic-tree-divide/ #define$siz(i)$：子树$i$的大小。 $ma(i)$：将点$i$从树中去掉后，产生的新子树中最大的$siz$。 树的重心：$ma$最小的点。 $dis(i)$：点$i$到根的距离。 $deep(i)$：点$i$到根的边数。 $tax$：桶。 $root$：当前分治中心。 树的重心去掉一个点，产生的新子树就是它儿子和爹的子树，一个$O(n)$的做法就很显然了： int siz[maxn],all,mx=inf,root;//all为原树大小,mx为当前ma最小的点，root为重心 void get_point(int node,int f){ siz[node]=1; int x,ma=0; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(x!=f)get_point(x,node),siz[node]+=siz[x],ma=max(ma,siz[x]); } ma=max(ma,all-siz[node]); if(ma&lt;mx)mx=ma,root=node; } 点分治实现对于一棵树，路径无非有两种：经过根的路径和根子树内部的路径。 我们先统计出经过根的路径，再把根的每个子树递归下去。 当然会被链卡成$O(n^2)$的，选取树的重心递归就能稳定$O(n\\log n)$。 栗子在根的两个不同子树中取两个点$x,y$，满足$dis(x)+dis(y)=k$就满足条件。 $k$只有$1e7$，开个$1e7$的桶暴力统计即可。 代码由于是自己yy的所以十分丑陋 int tax[10000001]={1},siz[maxn],h[maxn],all,ma,root,num,k; bool vis[maxn],ans; struct edge{ int pre,to,l; }e[maxn&lt;&lt;1]; inline void add(int from,int to,int l){ e[++num].pre=h[from],h[from]=num,e[num].to=to,e[num].l=l; } void get_point(int node,int f=0){ siz[node]=1; int mx=0,x; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(x!=f&amp;&amp;!vis[x])get_point(x,node),siz[node]+=siz[x],mx=max(siz[x],mx); } mx=max(mx,all-siz[node]); if(mx&lt;ma)ma=mx,root=node; } void Count(int node,int len,int v,int f=0){ if(len&gt;k)return; int x; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(x!=f&amp;&amp;!vis[x])Count(x,len+e[i].l,v,node); } tax[len]+=v; }//计算答案 void calc(int node,int len,int f=0){ if(len&gt;k)return; int x; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(x!=f&amp;&amp;!vis[x])calc(x,len+e[i].l,node); } ans|=tax[k-len]; }//统计 void calc_siz(int node,int f=0){ siz[node]=1; int x; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(x==f||vis[x])continue; calc_siz(x,node),siz[node]+=siz[x]; } } void solve(int node){ int x; vis[node]=1; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(!vis[x])calc(x,e[i].l),Count(x,e[i].l,1);//先算答案再统计，否则子树内部会影响 } for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(!vis[x])Count(x,e[i].l,-1); }//清空桶子 calc_siz(node); for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(!vis[x])all=siz[x],ma=inf,get_point(x),solve(root); }//递归计算子树 } int main(){ int n=read(),m=read(),x,y,z; for(register int i=1;i&lt;n;++i)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z); while(m--)memset(vis,0,sizeof vis),k=read(),all=n,ma=inf,ans=0,get_point(1),solve(root),puts(ans?&quot;AYE&quot;:&quot;NAY&quot;); } 点分树栗子 单独拿出一个询问，不求树的直径，可以用点分治解决。 现在带修了，于是点分树来了。 实现先考虑朴素的点分治。 为了方便点分树的食用，统计时用一种繁琐的方法： 对$root$的每个儿子，$dfs$算出子树内最大$deep$，选取最大的两个加和就是$root$的答案。 答案就是每个$root$的最大值。 注意到，修改一个点只会影响到它上面的$root$的答案，而每个点所属的$root$是$\\log n$级别的！ 把$root$向下一层的$root$连边，就能得到一棵最大深度为$\\log n$的树，这就是点分树了。 一个点能影响的为其祖宗，修改直接暴力往上跳修改。 前面统计的都是最大值，为了能带修换成可删堆。 每个点记录在每个所属$root$的$deep$，在对应的堆插入/删除即可。 时间复杂度$O((m+n)\\log^2 n)$，空间复杂度$O((m+n)\\log n)$。 代码#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define maxn 100005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int d[maxn][21],t[maxn][21],siz[maxn],h[maxn],fa[maxn],dc[maxn],num,root,mx=inf,all,tp; bool vis[maxn],is[maxn]; struct edge{ int pre,to; }e[maxn&lt;&lt;1]; struct Heap{ priority_queue&lt;int&gt;q,d; void push(int x){q.push(x);} void del(int x){d.push(x);} int top(){ while(!d.empty()&amp;&amp;q.top()==d.top())q.pop(),d.pop(); if(q.empty())return -inf; return q.top(); } int top2(){ int rec=top(),ans=0; while(!d.empty()&amp;&amp;q.top()==d.top())q.pop(),d.pop(); if(!q.empty())q.pop(),ans=top(); q.push(rec); return ans+rec; } }son[maxn&lt;&lt;1],rt[maxn],ans; inline void add(int from,int to){ e[++num].pre=h[from],h[from]=num,e[num].to=to; } void getroot(int node,int f=0){ siz[node]=1; int x,ma=0; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(x==f||vis[x])continue; getroot(x,node),siz[node]+=siz[x],ma=max(ma,siz[x]); } ma=max(ma,all-siz[node]); if(ma&lt;mx)mx=ma,root=node; } void init(int node,int f){ son[tp].push(d[node][++dc[node]]=d[f][dc[f]]+1),t[node][dc[node]]=tp; int x; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(x==f||vis[x])continue; init(x,node); } } void calc_siz(int node,int f=0){ siz[node]=1; int x; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(x==f||vis[x])continue; calc_siz(x,node),siz[node]+=siz[x]; } } void build(int node){ rt[node].push(0),vis[node]=1; int x; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(vis[x])continue; ++tp,init(x,0),rt[node].push(son[tp].top()); } ans.push(rt[node].top2()); calc_siz(node); for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(vis[x])continue; all=siz[x],mx=inf,getroot(x),fa[root]=node,build(root); } } int main(){ int n=read(),x,y,oop=n; char s[3]; for(register int i=1;i&lt;n;++i)x=read(),y=read(),add(x,y),add(y,x); all=n,getroot(1),build(root); int m=read(); while(m--){ scanf(&quot;%s&quot;,s); if(s[0]==&#39;C&#39;){ x=read(),is[x]^=1; if(is[x]){ --oop; ans.del(rt[x].top2()),rt[x].del(0),ans.push(rt[x].top2()); for(register int i=dc[x],node=fa[x];node;--i,node=fa[node]){ ans.del(rt[node].top2()); rt[node].del(son[t[x][i]].top()),son[t[x][i]].del(d[x][i]),rt[node].push(son[t[x][i]].top()); ans.push(rt[node].top2()); } } else { ++oop; ans.del(rt[x].top2()),rt[x].push(0),ans.push(rt[x].top2()); for(register int i=dc[x],node=fa[x];node;--i,node=fa[node]){ ans.del(rt[node].top2()); rt[node].del(son[t[x][i]].top()),son[t[x][i]].push(d[x][i]),rt[node].push(son[t[x][i]].top()); ans.push(rt[node].top2()); } } } else { if(!oop)puts(&quot;-1&quot;); else if(oop==1)puts(&quot;0&quot;); else printf(&quot;%d\\n&quot;,ans.top()); } } } 水题不知道受啥误导了看到单点加单点查就想用平衡树 聪聪可可询问有多少条路径长度为$3$的倍数。 就是统计路径长度$\\%3$等于$0$的路径条数，跟模板差不多。 Tree询问有多少条路径长度$\\le k$。 $calc$里查询$\\le k-dis(i)$的点的数量，可以用树状数组维护，复杂度$O(n\\log^2 n)$。 如果$k$更大的话可以用平衡树，清空也更方便。 Race$k$只有$1e6$，开个桶记录$tax[len]$保存最小的$deep(i)$满足$dis(i)=len$，统计时答案对$deep(i)+tax[k-dis(i)]$取$\\min$。 还可以有些小剪枝比如当$deep(i)\\ge ans$时返回。 $zz$的我上来写了个$O(n\\log^2 n)$的平衡树居然只比$O(n\\log n)$正解慢$750ms$？ 树的难题题解 重建计划二分答案，把树上所有边权减去当前答案，检验是否存在长度大于$0$且边数满足条件的路径。 记录每个$deep$最大的$dis$。按$deep$排序，满足条件的$deep$是一个单向移动的区间，用单调队列维护最大值，为了消掉排序的$log$需要$bfs$实现。 由于同一子树内部的路径会互相影响，对每个子树都要清空单调队列重新统计。按子树内部最大$deep$排序后可以保证复杂度为$siz(root)$。 树上游戏神仙题。有点分治、扫描线、树上差分、虚树等各种解法。 点分治我们考虑每种颜色的贡献。开一个数组$fir$。 $dfs$一遍子树，统计出子树大小，如果在某条链上点$i$的颜色第一次出现，就将它颜色的$fir$加上$siz(i)$。 统计答案，若颜色$i$从某个点到根路径上未出现过，就会产生$fir(i)$的贡献；否则会产生$siz(root)-siz(x)$的贡献（$x$为其所属子树）。 由于子树内部会互相影响，还需要先$dfs$一边减去当前子树的$fir$，统计完再加上。 剩下的就是全是细节的代码了。。。 快递员题解 点分树的题： 震波建出点分树，每个点维护一棵平衡树，维护该点为$root$时每个深度的点权和。 对于修改，暴力往上跳，在平衡树内修改权值。 对于查询，暴力往上跳，查询平衡树内小于等于$k-dis$的权值和。 然后会发现多加了和$x$在同一子树的点的权值，还要维护每个$root$的每棵子树的信息减去。 平衡树有个十分优美的处理方法： 把每个深度的点权和提出来，直接依照这个数组build一棵平衡树。 我们发现修改操作直接找到对应深度的点修改即可。也就是说压根没有插入删除。 于是没必要写什么平衡树，直接裸上$BST$就行$QwQ$。 （darkbzoj过了bzoj被卡常了真是恶） 开店还是每个点维护一棵$BST$，维护该点为$root$时每个颜色的距离和和出现次数。 暴力查每棵平衡树里颜色在$[L,R]$的距离和加上$dis$乘上出现次数。同样要减去同一子树的信息。 每个点度数不超过$3$可以用来优化常数不过我不会。 能在$loj$上$AC$，洛谷上$T$一个点。把$BST$换成$vector+$二分就卡过去了。 QTREE5比较像栗子。 每个点用可删堆维护最小的$dis(i)$（$i$为白点）。 查询时跳父亲，答案对查询点到当前点距离+最小$dis$取$\\min$。 为了去重要维护$root$的每个儿子的堆，若当前所属儿子的堆顶等于最小$dis$则取次小$dis$。 紫荆花之恋替罪羊式重构点分树。 题解 幻想乡战略游戏随便定个根$r$，用$s_x$表示点$x$的子树和。 考虑把重心从$r$移到儿子$x$的代价：$dis(r,x)\\times(s_r-s_x-s_x)$ 若$x$比$r$优，则代价小于$0$，即$2s_x&gt;s_r$。 再考虑把重心从$x$移到儿子$y$的代价：$dis(x,y)\\times(s_r-s_y-s_y)$ 若$y$比$x$优，则$2s_y&gt;s_r$。 于是得到找重心的方法：从根节点不断走满足$2s&gt;s_r$的节点，直到找不到为止。 这样太慢了，如果$2s_x&gt;s_r$，则重心一定在$x$的子树里，从$x$的子树中找一个点走。每次找分治中心就能$\\log$实现。 考虑拓展到点分树：把点分树建出来。假设$root$在上一层分治时属于$u$的子树。用点分树上$root$子树大小表示$u$的子树大小。但这样$u$所在的子树大小还少了原树中$u$上面的节点，可以把缺失的部分加到$u$的点权上，每往下走一步就给$u$加上$s_{fa[root]}-s_{root}$。 求出来重心后就是套路地用点分树查询答案了。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ctz45562.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"点分治","slug":"点分治","permalink":"https://ctz45562.github.io/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"},{"name":"点分树","slug":"点分树","permalink":"https://ctz45562.github.io/tags/%E7%82%B9%E5%88%86%E6%A0%91/"}]},{"title":"杜爷の胡策「7.17数数」做题笔记","slug":"杜爷の胡策「7.17数数」做题笔记","date":"2019-07-17T03:35:31.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/07/17/杜爷の胡策「7.17数数」做题笔记/","link":"","permalink":"https://ctz45562.github.io/2019/07/17/%E6%9D%9C%E7%88%B7%E3%81%AE%E8%83%A1%E7%AD%96%E3%80%8C7.17%E6%95%B0%E6%95%B0%E3%80%8D%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/","excerpt":"杜爷的式子都好神仙啊。","text":"杜爷的式子都好神仙啊。 三角形题目描述 求出周长为$n$，边长为整数的不同三角形的个数. 注意边是无序的，即$3,4,5$和$4,5,3$算同一个三角形. 由于出题人害怕卡不掉乱搞答案可能很大，你只需要输出答案对$10^9+7$取模的结果. 输入输出格式输入格式一行一个整数$n$ 输出格式一行一个整数表示答案对$10^9+7$取模的结果. 样例输入样例110 输出样例12 输入样例2100000000 输出样例2331875002 数据范围对于$40\\%$的数据，$n\\leq 10^7$ 对于$60\\%$的数据，$n\\leq 10^9$ 对于$100\\%$的数据，$1\\leq n\\leq 10^{18}$ 思路应该是签到题了吧，能不能A完全取决于推出来的式子会不会被卡精度 设三角形三边为$a,b,c$，且$a\\le b\\le c$。 要成三角形就有$a+b+c=n,a+b&gt;c$。 于是先枚举$a+b$，易知其下界为$\\left\\lfloor\\dfrac{n}{2}\\right\\rfloor+1$。 上界我们看条件$b\\le c$，设$a+b=k$，$c=n-k$，此时$b$的最小值为$\\left\\lceil\\dfrac{k}{2}\\right\\rceil$，则有$\\left\\lceil\\dfrac{k}{2}\\right\\rceil\\le n-k$。 则其上界为$\\left\\lfloor\\dfrac{2n}{3}\\right\\rfloor+1$。 再枚举$a$，要满足$a\\le b$，其上界为$\\left\\lfloor\\dfrac{k}{2}\\right\\rfloor$，还要满足$b\\le c$。 即$a+b-a\\le c$，$k-a\\le n-k$。 可知其下界为$2k-n$。 于是答案为$\\sum\\limits_{i=\\lfloor\\frac{n}{2}\\rfloor+1}^{\\lfloor\\frac{2n}{3}\\rfloor+1}\\left\\lfloor\\dfrac{i}{2}\\right\\rfloor-2i+n+1$ $\\left\\lfloor\\dfrac{i}{2}\\right\\rfloor-2i$可以转成等差数列求和，$n+1$乘上就好。 拍一下发现$3|n$时答案总是少$1$，猜测是由于$a=b=c=\\dfrac{n}{3}$没算上，还要再加上。 这题取模真的恶心。。。反正复杂度是$O(1)$的随便模。 题解杜爷の题解 杜爷直接容斥然后一顿推式子。 只会枚举的我瑟瑟发抖。 代码#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 100005 #define pn putchar(&#39;\\n&#39;) const int mod = 1e9 + 7; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } template&lt;typename T&gt; inline T read(){ T x=0; int y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } #define int long long signed main(){ int n=read&lt;long long&gt;(),l=(n&gt;&gt;1)+1,r=((n&lt;&lt;1)/3+1),ans=((n%3==0)+(n%mod+1)*(r%mod-l%mod+1)%mod-(l%mod+r%mod)*(r%mod-l%mod+1)%mod)%mod; if(l&amp;1)--l,(ans-=l&gt;&gt;1)%mod; if(!(r&amp;1))++r,(ans-=r&gt;&gt;1)%=mod; (ans+=(((l&gt;&gt;1)+(r&gt;&gt;1))%mod*((r-l+1&gt;&gt;1)%mod))%mod)%=mod; printf(&quot;%lld\\n&quot;,(ans+mod)%mod); } 直角三角形题目描述 求所有周长不超过$n$，边长为整数的直角三角形的个数.注意，边是无序的，换句话说$a-b-c$和$a-c-b$是同一个三角形. 如果你不知道直角三角形的判定方法，可以看这里 输入输出格式输入格式一行一个正整数$n$ 输出格式一行一个整数表示答案. 样例输入样例112 输出样例11 输入样例2100 输出样例217 输入样例3100000 输出样例364741 数据范围对于$30\\%$的数据，$n\\leq 1000$ 对于$70\\%$的数据，$n\\leq 10^6$ 对于$100\\%$的数据，$n\\leq 10^{10}$ 提示这篇文章可能会有帮助 思路我会$O(n^2)$枚举三边！ 获得了$30$分的好成绩。 通过阅读提示里的文章，知道了： 勾股数组：若$a,b,c\\in N^*$且$a^2+b^2=c^2$，则$(a,b,c)$称为勾股数组。 本原勾股数组：$a,b,c$没有公因数的勾股数组。 勾股数组定理：若奇数$s,t$满足$s&gt;t\\ge 1$且$gcd(s,t)=1$，则$a=st,b=\\dfrac{s^2-t^2}{2},c=\\dfrac{s^2+t^2}{2}$可构成本原勾股数组。 我会枚举所有奇数！ 好像并没有什么改进。。。 一个直角三角形的周长为$a+b+c=st+s^2=s(t+s)$。 枚举构成的三角形周长为$i$，显然$s|i$。 这样我们只要检验一下$i$的每个约数即可，大概能获得$70$分。 然而不知道哪里写挂了没调出来。。。 $zz$的我并没有发现由于周长为$st+s^2$，则$s$只要枚举到$\\sqrt{n}$即可。。。 题解头一回见$odd(i)$（$i$为奇数）和$even(i)$（$i$为偶数），孤陋寡闻了。。。 杜爷の题解 神仙反演啊，下面基本都是抄的。 答案为$\\sum\\limits_{s,t}[s&gt;t\\ge 1][odd(s)][odd(t)][gcd(s,t)=1]\\left\\lfloor\\dfrac{n}{s(s+t)}\\right\\rfloor$ 枚举$d=s+t$： $=\\sum\\limits_{s,t,d}[d=s+t][s&gt;t\\ge 1][odd(s)][odd(t)][gcd(s,t)=1]\\left\\lfloor\\dfrac{n}{sd}\\right\\rfloor$ $gcd(s,t)=gcd(s,d-s)=gcd(d,s)$；因为$s,t$均为奇数，所以$d$为偶数。而若$s,t$均为偶数时$d$也为偶数，此时$gcd(s,d)\\neq 1$，所以直接把$[odd(s)][odd(t)]$换为$[even(d)]$： $=\\sum\\limits_{s,t,d}[d=s+t][s&gt;t\\ge 1][even(d)][gcd(s,d)=1]\\left\\lfloor\\dfrac{n}{sd}\\right\\rfloor$ 消掉$[even(d)]$，枚举$2d$： $=\\sum\\limits_{s,t,d}[2d=s+t][s&gt;t\\ge 1][gcd(s,2d)=1]\\left\\lfloor\\dfrac{n}{2sd}\\right\\rfloor$ 消掉$t$，把$2d=s+t$代入$s&gt;t\\ge 1$得： $=\\sum\\limits_{s,d}[d&lt;s&lt;2d][gcd(s,2d)=1]\\left\\lfloor\\dfrac{n}{2sd}\\right\\rfloor$ 套路反演： $=\\sum\\limits_{s,d,k}[d&lt;s&lt;2d][k|s][k|2d]\\mu(k)\\left\\lfloor\\dfrac{n}{2sd}\\right\\rfloor$ 分类$k$的奇偶： $=\\sum\\limits_{s,d,k}[d&lt;s&lt;2d][k|s][k|d][odd(k)]\\mu(k)\\left\\lfloor\\dfrac{n}{2sd}\\right\\rfloor+\\sum\\limits_{s,d,k}[d&lt;s&lt;2d][k|s][\\frac{k}{2}|d][even(k)]\\mu(k)\\left\\lfloor\\dfrac{n}{2sd}\\right\\rfloor$ 分开算，奇数部分： $\\sum\\limits_{s,d,k}[d&lt;s&lt;2d][k|s][k|d][odd(k)]\\mu(k)\\left\\lfloor\\dfrac{n}{2sd}\\right\\rfloor$ $=\\sum\\limits_{s,d,k}[d&lt;s&lt;2d][k\\ge 1][(2k-1)|s][(2k-1)|d]\\mu(2k-1)\\left\\lfloor\\dfrac{n}{2sd}\\right\\rfloor$ $s,d$改为枚举$2k-1$的倍数： $=\\sum\\limits_{s,d,k}[d&lt;s&lt;2d][k\\ge 1]\\mu(2k-1)\\left\\lfloor\\dfrac{n}{2sd(2k-1)^2}\\right\\rfloor$ 令$t=\\left\\lfloor\\dfrac{n}{2(2k-1)^2}\\right\\rfloor$，给$s,d,k$实际的枚举范围： $=\\sum\\limits_{k=1}^{\\sqrt{n}}\\mu(2k-1)\\sum\\limits_{d=2}^{\\sqrt{t}}\\sum\\limits_{s=d+1}^{\\min\\{2d-1,\\lfloor\\frac{t}{d}\\rfloor\\}}\\left\\lfloor\\dfrac{t}{sd}\\right\\rfloor$ 设$g(n)=\\sum\\limits_{i=2}^{\\sqrt{n}}\\sum\\limits_{j=i+1}^{\\min\\{2i-1,\\frac{n}{i}\\}}\\left\\lfloor\\dfrac{n}{ij}\\right\\rfloor$ 该部分即为$\\sum\\limits_{k=1}^{\\sqrt{n}}\\mu(2k-1)g(t)$ 再来看偶数部分： $\\sum\\limits_{s,d,k}[d&lt;s&lt;2d][k|s][\\frac{k}{2}|d][even(k)]\\mu(k)\\left\\lfloor\\dfrac{n}{2sd}\\right\\rfloor$ $=\\sum\\limits_{s,d,k}[d&lt;s&lt;2d][2k|s][k|d]\\mu(2k)\\left\\lfloor\\dfrac{n}{2sd}\\right\\rfloor$ $=\\sum\\limits_{s,d,k}[\\dfrac{d}{2}&lt;s&lt;d]\\mu(2k)\\left\\lfloor\\dfrac{n}{4sdk^2}\\right\\rfloor$ 令$t’=\\left\\lfloor\\dfrac{n}{4k^2}\\right\\rfloor$ $=\\sum\\limits_{k=1}^{\\sqrt{n}}\\mu(2k)\\sum\\limits_{d=2}^{\\sqrt{2t’}}\\sum\\limits_{s=\\frac{d}{2}+1}^{\\min\\{d-1,\\lfloor\\frac{t’}{d}\\rfloor\\}}\\left\\lfloor\\dfrac{t’}{sd}\\right\\rfloor$ 设$h(n)=\\sum\\limits_{i=2}^{\\sqrt{2n}}\\sum\\limits_{j=\\frac{i}{2}+1}^{\\min\\{i-1,\\lfloor\\frac{n}{i}\\rfloor\\}}\\left\\lfloor\\dfrac{n}{ij}\\right\\rfloor$ 总答案即为$\\sum\\limits_{k=1}^{\\sqrt{n}}\\mu(2k-1)g(\\left\\lfloor\\dfrac{n}{2(2k-1)^2}\\right\\rfloor)+\\sum\\limits_{k=1}^{\\sqrt{n}}\\mu(2k)h(\\left\\lfloor\\dfrac{n}{4k^2}\\right\\rfloor)$ 关于$g$和$h$因为比较诡异只能外层暴力内层整除分块算，复杂度是$O(n^{\\frac{3}{4}})$的。 答案中$\\sum\\limits_{k=1}^{\\sqrt{n}}$也是暴力算，杜爷用积分算出来复杂度还是$O(n^{\\frac{3}{4}})$的。 代码#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 1000001 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } template&lt;typename T&gt; inline T read(){ T x=0; int y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int mu[maxn],prime[maxn&gt;&gt;2],cnt; bool is[maxn]; long long g(long long n){ long long tp,di,ans=0; for(register int i=2;1ll*i*i&lt;=n;++i){ tp=min((1ll*i&lt;&lt;1)-1,di=n/i); for(register int l=i+1,r;l&lt;=tp;l=r+1){ r=min(tp,di/(di/l)); ans+=(r-l+1)*(di/l); } } return ans; } long long h(long long n){ long long tp,di,ans=0; for(register int i=2;1ll*i*i&lt;=n&lt;&lt;1;++i){ tp=min(1ll*i-1,di=n/i); for(register int l=(i&gt;&gt;1)+1,r;l&lt;=tp;l=r+1){ r=min(tp,di/(di/l)); ans+=(r-l+1)*(di/l); } } return ans; } int main(){ is[1]=mu[1]=1; for(register int i=2;i&lt;maxn;++i){ if(!is[i])prime[++cnt]=i,mu[i]=-1; for(register int j=1;j&lt;=cnt&amp;&amp;i*prime[j]&lt;maxn;++j){ is[i*prime[j]]=1; if(i%prime[j]==0){mu[i*prime[j]]=0;break;} mu[i*prime[j]]=-mu[i]; } } long long n=read&lt;long long&gt;(),ans=0; for(register int i=1;1ll*i*i&lt;=n;++i) ans+=g(n/(2ll*((i&lt;&lt;1)-1)*((i&lt;&lt;1)-1)))*mu[(i&lt;&lt;1)-1]+h(n/(4ll*i*i))*mu[i&lt;&lt;1]; printf(&quot;%lld\\n&quot;,ans); } 等腰直角三角形题目描述 求$\\sum\\limits_{i=1}^n\\varphi(ik)\\pmod {10^9+7}$ 输入输出格式输入格式一行两个正整数$n$和$k$ 输出格式一行一个整数表示答案对$10^9+7$取模的结果 样例输入样例100 100 输出样例170520 数据范围对于$20\\%$的数据，$n,k\\leq 10000$ 对于另外$20\\%$的数据，$n\\leq 10^{10},k\\leq 2$ 对于再另外$20\\%$的数据，$n\\leq 10^7,k\\leq 10^{10}$ 对于$100\\%$的数据，$n,k\\leq 10^{10}$ 思路刚学到的$\\varphi$的性质：$\\varphi(ij)=\\dfrac{\\varphi(i)\\varphi(j)gcd(i,j)}{\\varphi(gcd(i,j))}$ $n,k\\le 10000$直接暴力求每个数的欧拉函数$O(n\\sqrt{nk})=n^2$即可重背了遍求单个数的欧拉函数。 $k=1$时就是裸的杜教筛。 这是个积性函数虽然我不会证，于是$n\\le 10^7$可以考虑线筛。 对于质数$p$，$f(p)=\\dfrac{(p-1)\\varphi(k)gcd(p,k)}{\\varphi(gcd(p,k))},f(p^{m+1})=pf(p^m)$。 提前算出$\\varphi(k)$，我们仅对每个质数做$gcd$，复杂度是$O(n)$的。 不知道为啥没想着去线筛它于是只拿到了$30$分。 题解杜爷の题解 还是反演： $\\sum\\limits_{i=1}^n\\varphi(ik)$ $=\\varphi(k)\\sum\\limits_{i=1}^n\\dfrac{\\varphi(i)gcd(i,k)}{\\varphi(gcd(i,k))}$ $=\\varphi(k)\\sum\\limits_{i=1}^n\\varphi(i)\\sum\\limits_{d=1}^n\\dfrac{[gcd(i,k)=d]d}{\\varphi(d)}$ $=\\varphi(k)\\sum\\limits_{d=1}^n\\dfrac{d}{\\varphi(d)}\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\varphi(id)\\sum\\limits_{a=1}^{\\lfloor\\frac{n}{d}\\rfloor}[d|k][a|i][a|\\frac{k}{d}]\\mu(a)$ $=\\varphi(k)\\sum\\limits_{a|k}\\mu(a)\\sum\\limits_{d|\\frac{k}{a}}\\dfrac{d}{\\varphi(d)}\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{ad}\\rfloor}\\varphi(iad)$ 令$T=ad$ $=\\varphi(k)\\sum\\limits_{T|k}\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{T}\\rfloor}\\varphi(iT)\\sum\\limits_{d|T}\\mu(\\dfrac{T}{d})\\dfrac{d}{\\varphi(d)}$ 设$f(T)=\\sum\\limits_{d|T}\\mu(\\dfrac{T}{d})\\dfrac{d}{\\varphi(d)},S(n,k)=\\sum\\limits_{i=1}^n\\varphi(ik)$ $S(n,k)=\\varphi(k)\\sum\\limits_{T|k}S(\\left\\lfloor\\dfrac{n}{T}\\right\\rfloor,T)f(T)=\\varphi(k)\\left(S(n,1)f(1)+\\sum\\limits_{T|k,T&gt;1}S(\\left\\lfloor\\dfrac{n}{T}\\right\\rfloor,T)f(T)\\right)$ 显然$\\dfrac{d}{\\varphi(d)}$是积性函数，和$\\mu$卷起来还是积性函数。 对于质数$p$，$f(p)=\\dfrac{1}{p-1},f(p^m)=\\dfrac{p^m}{\\varphi(p^m)}-\\dfrac{p^{m-1}}{\\varphi(p^{m-1})}=0$。 于是可以质因数分解求$f(T)$。 $S(n,1)$可以杜教筛，递归计算$S(\\left\\lfloor\\dfrac{n}{T}\\right\\rfloor,T)$。 杜爷算出来复杂度是$O(d(k)\\sqrt{k})$的。 代码要特判掉$k=1$的情况，否则会一直在$S(n,1)$递归下去。 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 20000001 #define inf 0x3f3f3f3f const int mod = 1e9 + 7; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } template&lt;typename T&gt; inline T read(){ T x=0; int y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } const int Mod = 3e6 + 7; #define int long long struct hash{ int h[Mod],d[Mod],nex[Mod],cnt; long long s[Mod]; void insert(long long x,int y){ s[++cnt]=x,x%=Mod,nex[cnt]=h[x],d[h[x]=cnt]=y; } int find(long long x){ for(register int i=h[x%Mod];i;i=nex[i]) if(s[i]==x)return d[i]; return mod; } }mphi; int phi[maxn],sum_phi[maxn],prime[maxn&gt;&gt;2],cnt; bool is[maxn]; long long PHI(long long x){ if(x&lt;maxn)return phi[x]; long long ans=x; for(register int i=2;1ll*i*i&lt;=x;++i){ if(x%i==0){ ans-=ans/i; while(x%i==0)x/=i; } } if(x&gt;1)ans-=ans/x; return ans; } int f(long long x,long long ans){ for(register int i=2;1ll*i*i&lt;=x;++i){ if(x%i==0){ if(x/i%i==0)return 0; ans/=i-1,x/=i; } } if(x&gt;1)ans/=x-1; return ans; } int sphi(long long n){ if(n&lt;maxn)return sum_phi[n]; int ans=mphi.find(n); if(ans!=mod)return ans; ans=(n%mod*(n%mod+1)&gt;&gt;1)%mod; for(long long l=2,r;l&lt;=n;l=r+1){ r=n/(n/l); (ans-=1ll*(r-l+1)*sphi(n/l)%mod)%=mod; } mphi.insert(n,ans); return ans; } int s(long long n,long long k){ if(!n)return 0; long long phik=PHI(k); int F,ans=phik%mod*sphi(n)%mod,p; for(register int i=2;i*i&lt;=k&amp;&amp;i&lt;=n;++i){ if(k%i==0){ F=f(i,phik); if(F)(ans+=1ll*F*s(n/i,i)%mod)%=mod; if((p=(k/i))!=i){ F=f(p,phik); if(F)(ans+=1ll*F*s(n/p,p)%mod)%=mod; } } } if(k&lt;=n){ F=f(k,phik); if(F)(ans+=F*s(n/k,k)%mod)%=mod; } return ans; } #undef int int main(){ long long n=read&lt;long long&gt;(),k=read&lt;long long&gt;(); is[1]=phi[1]=sum_phi[1]=1; for(register int i=2;i&lt;maxn;++i){ if(!is[i])prime[++cnt]=i,phi[i]=i-1; sum_phi[i]=(sum_phi[i-1]+phi[i])%mod; for(register int j=1;j&lt;=cnt&amp;&amp;i*prime[j]&lt;maxn;++j){ is[i*prime[j]]=1; if(i%prime[j]==0){phi[i*prime[j]]=phi[i]*prime[j];break;} phi[i*prime[j]]=phi[i]*(prime[j]-1); } } if(k==1)printf(&quot;%lld\\n&quot;,(sphi(n)+mod)%mod); else printf(&quot;%lld\\n&quot;,(s(n,k)+mod)%mod); }","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ctz45562.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"枚举","slug":"枚举","permalink":"https://ctz45562.github.io/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"https://ctz45562.github.io/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"name":"杜教筛","slug":"杜教筛","permalink":"https://ctz45562.github.io/tags/%E6%9D%9C%E6%95%99%E7%AD%9B/"}]},{"title":"洛谷 P3704 [SDOI2017]数字表格","slug":"洛谷-P3704-SDOI2017-数字表格","date":"2019-07-15T13:46:28.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/07/15/洛谷-P3704-SDOI2017-数字表格/","link":"","permalink":"https://ctz45562.github.io/2019/07/15/%E6%B4%9B%E8%B0%B7-P3704-SDOI2017-%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC/","excerpt":"きりま しゃろ 、お誕生日おめでとうございます！ 传送门","text":"きりま しゃろ 、お誕生日おめでとうございます！ 传送门 设$g(k)=\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m[gcd(i,j)=k]$ $g$的反演就很老套了，$g(k)=\\sum\\limits_{d=1}^{\\lfloor\\frac{n}{k}\\rfloor}\\mu(d)\\left\\lfloor\\dfrac{n}{kd}\\right\\rfloor\\left\\lfloor\\dfrac{m}{kd}\\right\\rfloor$ 直接枚举$gcd$： $\\prod\\limits_{i=1}^n\\prod\\limits_{j=1}^mf(gcd(i,j))$ $=\\prod\\limits_{d=1}^nf(d)^{g(d)}$ $=\\prod\\limits_{d=1}^nf(d)^{\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\mu(i)\\lfloor\\frac{n}{id}\\rfloor\\lfloor\\frac{m}{id}\\rfloor}$ 推到这里复杂度是$O(T(n^{\\frac{3}{4}}+\\sqrt{n}\\log n))$的，然而常数太大过不去。 设$T=id$，有$d|T$，枚举$T$： $=\\prod\\limits_{d=1}^nf(d)^{\\sum\\limits_{T=1}^n[d|T]\\mu(\\frac{T}{d})\\lfloor\\frac{n}{T}\\rfloor\\lfloor\\frac{m}{T}\\rfloor}$ $=\\prod\\limits_{T=1}^n\\left(\\prod\\limits_{d|T}f(d)^{\\mu(\\frac{T}{d})}\\right)^{\\lfloor\\frac{n}{T}\\rfloor\\lfloor\\frac{m}{T}\\rfloor}$ 预处理出$f$的前缀积、前缀逆元和$\\prod\\limits_{d|T}f(d)\\mu(\\frac{T}{d})$就能$O(T\\sqrt{n}\\log n)$做了。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 1000001 #define inf 0x3f3f3f3f const int mod = 1e9 + 7; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int mu[maxn],prime[maxn&gt;&gt;2],f[maxn]={0,1},g[maxn]={1,1},pre[maxn]={1},inv[maxn]={1},cnt; bool is[maxn]; int INV(int x){return x==1?1:1ll*(mod-mod/x)*INV(mod%x)%mod;} int quickpow(int x,int y){ int ans=1; while(y){ if(y&amp;1)ans=1ll*ans*x%mod; x=1ll*x*x%mod; y&gt;&gt;=1; } return ans; } void workinv(){ int all=INV(pre[maxn-1]),now=1; for(register int i=maxn-1;i;--i)inv[i]=1ll*all*now%mod*pre[i-1]%mod,now=1ll*now*g[i]%mod; } int main(){ is[1]=mu[1]=1; for(register int i=2;i&lt;maxn;++i){ f[i]=(f[i-1]+f[i-2])%mod,g[i]=1; if(!is[i])prime[++cnt]=i,mu[i]=-1; for(register int j=1;j&lt;=cnt&amp;&amp;i*prime[j]&lt;maxn;++j){ is[i*prime[j]]=1; if(i%prime[j]==0){mu[i*prime[j]]=0;break;} mu[i*prime[j]]=-mu[i]; } } for(register int i=1;i&lt;maxn;++i){ int p=INV(f[i]); for(register int j=i;j&lt;maxn;j+=i){ if(mu[j/i]==-1)g[j]=1ll*g[j]*p%mod; else if(mu[j/i]==1)g[j]=1ll*g[j]*f[i]%mod; } } for(register int i=1;i&lt;maxn;++i)mu[i]+=mu[i-1],g[i]=1ll*g[i-1]*g[i]%mod,pre[i]=1ll*pre[i-1]*g[i]%mod; workinv(); int t=read(),n,m,ans; while(t--){ n=read(),m=read(),ans=1; if(n&gt;m)swap(n,m); for(register int l=1,r;l&lt;=n;l=r+1){ r=min(n/(n/l),m/(m/l)); ans=1ll*ans*quickpow(1ll*g[r]*inv[l-1]%mod,1ll*(n/l)*(m/l)%(mod-1))%mod; } printf(&quot;%d\\n&quot;,ans); } }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"https://ctz45562.github.io/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"}]},{"title":"洛谷 P3768 简单的数学题","slug":"洛谷-P3768-简单的数学题","date":"2019-07-12T09:06:37.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/07/12/洛谷-P3768-简单的数学题/","link":"","permalink":"https://ctz45562.github.io/2019/07/12/%E6%B4%9B%E8%B0%B7-P3768-%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E5%AD%A6%E9%A2%98/","excerpt":"传送门 恶心的取模调了一下午。。。","text":"传送门 恶心的取模调了一下午。。。 求$\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^nijgcd(i,j)$ 枚举$gcd$： $=\\sum\\limits_{d=1}^n\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^nijd[gcd(i,j)=d]$ 枚举$d$的倍数： $=\\sum\\limits_{d=1}^n\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{n}{d}\\rfloor}ijd^3[gcd(i,j)=1]$ 套路反演： $=\\sum\\limits_{d=1}^nd^3\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{n}{d}\\rfloor}ij\\sum\\limits_{k|gcd(i,j)}\\mu(k)$ $=\\sum\\limits_{d=1}^nd^3\\sum\\limits_{k=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{n}{d}\\rfloor}[k|i][k|j]ij\\mu(k)$ 枚举$k$的倍数： $=\\sum\\limits_{d=1}^nd^3\\sum\\limits_{k=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\mu(k)k^2\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{kd}\\rfloor}i\\sum\\limits_{j=1}^{\\lfloor\\frac{n}{kd}\\rfloor}j$ 到这里复杂度还是不够优秀，继续往下推： 设$g(n)=\\sum\\limits_{i=1}^ni$，即自然数前$n$项和。 令$T=kd$，则有$d|T$。 枚举$T$： $=\\sum\\limits_{d=1}^nd^3\\sum\\limits_{T=1}^n[d|T]\\mu(\\dfrac{T}{d})\\left(\\dfrac{T}{d}\\right)^2g^2(\\dfrac{n}{T})$ 变换求和顺序： $=\\sum\\limits_{T=1}^ng^2(\\dfrac{n}{T})T^2\\sum\\limits_{d|T}\\mu(\\dfrac{T}{d})d$ 后面那个$\\sum$其实是个卷积： $\\sum\\limits_{d|T}\\mu(\\dfrac{T}{d})d$ $=\\mu*id$ $=\\mu*\\varphi*1$ $=\\varphi$ 我们要求的就成了 $\\sum\\limits_{T=1}^ng^2(\\dfrac{n}{T})T^2\\varphi(T)$ 考虑杜教筛$\\sum\\limits_{i=1}^ni^2\\varphi(i)$。 给$i^2\\varphi(i)$卷个$id^2$： $\\sum\\limits_{d|n}d^2\\varphi(d)\\dfrac{n^2}{d^2}=n^3$ 然后就能$O(n^{\\frac{2}{3}})$做了。 通过查阅题解还发现了一种更$NB$的推法： 根据$n=\\sum\\limits_{d|n}\\varphi(d)$ 原式直接化为$\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^nij\\sum\\limits_{d|gcd(i,j)}\\varphi(d)$ 剩下的就都是套路了。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 10000001 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } const int Mod = 5e6 + 7; int mod,phi[maxn],prime[maxn&gt;&gt;2],cnt,inv6; bool is[maxn]; struct hash{ int h[Mod],d[Mod],nex[Mod],cnt; long long s[Mod]; void insert(long long x,int y){ s[++cnt]=x,x%=Mod,nex[cnt]=h[x],d[h[x]=cnt]=y; } int find(long long x){ for(register int i=h[x%Mod];i;i=nex[i]) if(s[i]==x)return d[i]; return mod; } }mphi; int INV(int x){return x==1?1:1ll*(mod-mod/x)*INV(mod%x)%mod;} int pow2(long long n){ if(n&gt;=mod)n%=mod; return n*(n+1)%mod*((n&lt;&lt;1)+1)%mod*inv6%mod; } int pow3(long long n){ if(n&gt;=mod)n%=mod; int ans=(n*(n+1)&gt;&gt;1)%mod; return 1ll*ans*ans%mod; } int sphi(long long n){ if(n&lt;maxn)return phi[n]; int ans=mphi.find(n); if(ans!=mod)return ans; ans=pow3(n); for(long long l=2,r;l&lt;=n;l=r+1){ r=n/(n/l); (ans-=1ll*(pow2(r)-pow2(l-1))*sphi(n/l)%mod)%=mod; } mphi.insert(n,ans); return ans; } int main(){ mod=read(),inv6=INV(6); is[1]=phi[1]=1; for(register int i=2;i&lt;maxn;++i){ if(!is[i])prime[++cnt]=i,phi[i]=i-1; for(register int j=1;j&lt;=cnt&amp;&amp;i*prime[j]&lt;maxn;++j){ is[i*prime[j]]=1; if(i%prime[j]==0){phi[i*prime[j]]=phi[i]*prime[j];break;} phi[i*prime[j]]=phi[i]*(prime[j]-1); } } for(register int i=2;i&lt;maxn;++i)phi[i]=(phi[i-1]+1ll*phi[i]*i%mod*i%mod)%mod; long long n=read&lt;long long&gt;(),p; int ans=0; for(long long l=1,r;l&lt;=n;l=r+1){ p=n/l,r=n/p,p%=mod,p=(p*(p+1)&gt;&gt;1)%mod; (ans+=p*p%mod*(sphi(r)-sphi(l-1))%mod)%=mod; } printf(&quot;%d\\n&quot;,(ans+mod)%mod); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"https://ctz45562.github.io/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"name":"杜教筛","slug":"杜教筛","permalink":"https://ctz45562.github.io/tags/%E6%9D%9C%E6%95%99%E7%AD%9B/"}]},{"title":"洛谷 P1829 [国家集训队]Crash的数字表格","slug":"洛谷-P1829-国家集训队-Crash的数字表格","date":"2019-07-10T08:32:59.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/07/10/洛谷-P1829-国家集训队-Crash的数字表格/","link":"","permalink":"https://ctz45562.github.io/2019/07/10/%E6%B4%9B%E8%B0%B7-P1829-%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F-Crash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC/","excerpt":"传送门 颓莫比乌斯反演题好爽啊！","text":"传送门 颓莫比乌斯反演题好爽啊！ 小学数论知识：$lcm(i,j)=\\dfrac{ij}{gcd(i,j)}$ 以下规定$n&lt;m$。 $\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^mlcm(i,j)$ $=\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m\\dfrac{ij}{gcd(i,j)}$ 套路枚举$gcd$： $=\\sum\\limits_{d=1}^n\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m\\dfrac{ij[gcd(i,j)=d]}{d}$ 套路枚举$d$的倍数： $=\\sum\\limits_{d=1}^n\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{m}{d}\\rfloor}ijd[gcd(i,j)=1]$ $=\\sum\\limits_{d=1}^n\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{m}{d}\\rfloor}ijd\\sum\\limits_{a|gcd(i,j)}\\mu(a)$ $=\\sum\\limits_{d=1}^nd\\sum\\limits_{a=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\mu(a)\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{m}{d}\\rfloor}ij[a|i][a|j]$ 套路枚举$a$的倍数： $=\\sum\\limits_{d=1}^nd\\sum\\limits_{a=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\mu(a)\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{ad}\\rfloor}ia\\sum\\limits_{j=1}^{\\lfloor\\frac{m}{ad}\\rfloor}ja$ $=\\sum\\limits_{d=1}^nd\\sum\\limits_{a=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\mu(a)a^2\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{ad}\\rfloor}i\\sum\\limits_{j=1}^{\\lfloor\\frac{m}{ad}\\rfloor}j$ 设$g(n)=\\sum\\limits_{i=1}^ni$（就是自然数前$n$项和）,$f(n,m)=\\sum\\limits_{i=1}^n\\mu(i)i^2g(\\lfloor\\dfrac{n}{i}\\rfloor)g(\\lfloor\\dfrac{m}{i}\\rfloor)$ 这个$f(n,m)$显然可以预处理$\\mu(i)i^2$后整除分块。 我们求的就成了$\\sum\\limits_{d=1}^ndf(\\lfloor\\dfrac{n}{d}\\rfloor,\\lfloor\\dfrac{m}{d}\\rfloor)$ 又可以整除分块了。 整除分块套整除分块复杂度是$O(n^{\\frac{3}{4}})$的。 然后发现了一个有趣的东西： 暴力计算$f(n,m)$是$O(n)$的。 设$F(n)$为$\\lfloor\\dfrac{n}{i}\\rfloor(i\\le n)$所有不同取值的和，它近似于在$f(n,m)$不整除分块时的整个算法复杂度。 经过计算在$F(1e7)\\approx 9e7$。试着改了一下不吸氧就过了。。。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 10000001 #define inf 0x3f3f3f3f const int mod = 20101009; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int mu[maxn],sum[maxn],psum[maxn],prime[maxn&gt;&gt;3],cnt; bool is[maxn]; inline int f(int n,int m){ if(n&gt;m)swap(n,m); int ans=0; for(register int l=1,r;l&lt;=n;l=r+1){ r=min(n,min(n/(n/l),m/(m/l))); (ans+=1ll*(psum[r]-psum[l-1])*sum[n/l]%mod*sum[m/l]%mod)%=mod; } return ans; } int main(){ mu[1]=is[1]=sum[1]=psum[1]=1; for(register int i=2;i&lt;maxn;++i){ if(!is[i])prime[++cnt]=i,mu[i]=-1; sum[i]=(sum[i-1]+i)%mod,psum[i]=(psum[i-1]+1ll*i*i*mu[i]%mod)%mod; for(register int j=1;j&lt;=cnt&amp;&amp;i*prime[j]&lt;maxn;++j){ is[i*prime[j]]=1; if(i%prime[j]==0){mu[i*prime[j]]=0;break;} mu[i*prime[j]]=-mu[i]; } } int n=read(),m=read(),ans=0; if(n&gt;m)swap(n,m); for(register int l=1,r;l&lt;=n;l=r+1){ r=min(n,min(n/(n/l),m/(m/l))); (ans+=1ll*(sum[r]-sum[l-1])*f(n/l,m/l)%mod)%=mod; } printf(&quot;%d\\n&quot;,(ans+mod)%mod); } $update$： 由于$O(n^{\\frac{3}{4}})$足以通过此题，所以当时没继续往下推。然而还是很容易优化到$O(\\sqrt{n})$的。 $\\sum\\limits_{d=1}^nd\\sum\\limits_{a=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\mu(a)a^2g(\\left\\lfloor\\dfrac{n}{ad}\\right\\rfloor)g(\\left\\lfloor\\dfrac{m}{ad}\\right\\rfloor)$ 设$T=ad$，有$d|T$。改为枚举$T$： $=\\sum\\limits_{d=1}^nd\\sum\\limits_{T=1}^n[d|T]\\mu(\\dfrac{T}{d})\\left(\\dfrac{T}{d}\\right)^2g(\\left\\lfloor\\dfrac{n}{T}\\right\\rfloor)g(\\left\\lfloor\\dfrac{m}{T}\\right\\rfloor)$ $=\\sum\\limits_{T=1}^ng(\\left\\lfloor\\dfrac{n}{T}\\right\\rfloor)g(\\left\\lfloor\\dfrac{m}{T}\\right\\rfloor)T\\sum\\limits_{d|T}\\mu(\\dfrac{T}{d})\\dfrac{T}{d}$ $=\\sum\\limits_{T=1}^ng(\\left\\lfloor\\dfrac{n}{T}\\right\\rfloor)g(\\left\\lfloor\\dfrac{m}{T}\\right\\rfloor)T\\sum\\limits_{d|T}\\mu(d)d$ 设$F(T)=\\sum\\limits_{d|T}\\mu(d)d$。可以证明$F$是积性函数（懒得写了挂个有证明的链接吧） 对于质数$p$，$F(p)=1-p$，$F(p^{k+1})=F(p^k)$，就能线筛了。 复杂度降为$O(\\sqrt{n})$。","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"https://ctz45562.github.io/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"}]},{"title":"洛谷 P3327 [SDOI2015]约数个数和","slug":"洛谷-P3327-SDOI2015-约数个数和","date":"2019-07-10T04:22:50.000Z","updated":"2020-06-21T10:14:42.000Z","comments":true,"path":"2019/07/10/洛谷-P3327-SDOI2015-约数个数和/","link":"","permalink":"https://ctz45562.github.io/2019/07/10/%E6%B4%9B%E8%B0%B7-P3327-SDOI2015-%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C/","excerpt":"传送门 颓颓颓推式子。","text":"传送门 颓颓颓推式子。 首先有一个玄学的式子：$d(ij)=\\sum\\limits_{a|i}\\sum\\limits_{b|j}[gcd(a,b)=1]$ 然后就可以推了：（以下默认$n&lt;m$） $\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^md(ij)$ $=\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m\\sum\\limits_{d|i}\\sum\\limits_{e|j}[gcd(d,e)=1]$ $=\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m\\sum\\limits_{d|i}\\sum\\limits_{e|j}\\sum\\limits_{a|gcd(d,e)}\\mu(a)$ $=\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m\\sum\\limits_{d|i}\\sum\\limits_{e|j}\\sum\\limits_{a|d,a|e}\\mu(a)$ 枚举$a,d,e$： $=\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m\\sum\\limits_{d=1}^n\\sum\\limits_{e=1}^m\\sum\\limits_{a=1}^n[d|i][e|j][a|d][a|e]\\mu(a)$ $=\\sum\\limits_{a=1}^n\\sum\\limits_{d=1}^n\\sum\\limits_{i=1}^n[d|i]\\sum\\limits_{e=1}^m\\sum\\limits_{j=1}^m[e|j][a|d][a|e]\\mu(a)$ $=\\sum\\limits_{a=1}^n\\sum\\limits_{d=1}^n\\left\\lfloor\\dfrac{n}{d}\\right\\rfloor[a|d]\\sum\\limits_{e=1}^m\\left\\lfloor\\dfrac{m}{e}\\right\\rfloor[a|e]\\mu(a)$ $=\\sum\\limits_{a=1}^n\\sum\\limits_{d=1}^{\\lfloor\\frac{n}{a}\\rfloor}\\left\\lfloor\\dfrac{n}{ad}\\right\\rfloor\\sum\\limits_{e=1}^{\\lfloor\\frac{m}{a}\\rfloor}\\left\\lfloor\\dfrac{m}{ae}\\right\\rfloor\\mu(a)$ 设$f(n)=\\sum\\limits_{i=1}^n\\left\\lfloor\\dfrac{n}{i}\\right\\rfloor$ 现在我们求的就是$\\sum\\limits_{a=1}^nf(\\left\\lfloor\\dfrac{n}{a}\\right\\rfloor)f(\\left\\lfloor\\dfrac{m}{a}\\right\\rfloor)\\mu(a)$ 显然预处理出$f$就可以整除分块了。 $n$只有$50000$珂以暴力继续整除分块$O(n\\sqrt{n})$预处理。 不过考虑这玩意的含义，就是约数个数前缀和。$O(n\\log n)$筛出$d$就行了（懒得线筛了） 答案要开$long\\ long$。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 50005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int mu[maxn],prime[maxn&gt;&gt;2],sum[maxn],cnt; bool is[maxn]; int main(){ int t=read(); mu[1]=is[1]=1; for(register int i=2;i&lt;=50000;++i){ if(!is[i])prime[++cnt]=i,mu[i]=-1; for(register int j=1;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=50000;++j){ is[i*prime[j]]=1; if(i%prime[j]==0){mu[i*prime[j]]=0;break;} mu[i*prime[j]]=-mu[i]; } } for(register int i=1;i&lt;=50000;++i) for(register int j=i;j&lt;=50000;j+=i) ++sum[j]; for(register int i=2;i&lt;=50000;++i)mu[i]+=mu[i-1],sum[i]+=sum[i-1]; while(t--){ int n=read(),m=read(); long long ans=0; if(n&gt;m)swap(n,m); for(register int l=1,r;l&lt;=n;l=r+1){ r=min(n,min(n/(n/l),m/(m/l))); ans+=1ll*sum[n/l]*sum[m/l]*(mu[r]-mu[l-1]); } printf(&quot;%lld\\n&quot;,ans); } }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"https://ctz45562.github.io/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"}]},{"title":"洛谷 P4595 [COCI2011-2012#5]POPLOCAVANJE","slug":"洛谷-P4595-【-COCI2011-2012-5-POPLOCAVANJE】","date":"2019-07-09T04:30:56.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/07/09/洛谷-P4595-【-COCI2011-2012-5-POPLOCAVANJE】/","link":"","permalink":"https://ctz45562.github.io/2019/07/09/%E6%B4%9B%E8%B0%B7-P4595-%E3%80%90-COCI2011-2012-5-POPLOCAVANJE%E3%80%91/","excerpt":"传送门 省队集训=自闭+水题+颓废","text":"传送门 省队集训=自闭+水题+颓废 卡空间的$AC$自动机板子题。不会什么奇技淫巧于是选择了线性空间的$SAM$。 显然要对母串造$SAM$，把模式串在$SAM$跑一遍。如果一个模式串在节点$i$停下，它就能和所有属于$endpos_i$的位置匹配。 维护一个$ma_i$表示在节点$i$停下的最长的模式串长度。每个节点给区间$[\\max\\{pos-ma_i+1,1\\},pos] (pos\\in endpos_i)$加$1$。某个位置大于$0$说明可以修补，差分即可。 当然我们并不需要对每个节点都操作。一个点的$endpos$都来自于$parent\\ tree$的子树，把$ma$推下去在叶子结点操作即可。 一开始开的$map$，不过额外空间开销不小还是$M$了，于是厚颜无耻地开数组靠动态内存$A$了。要没有动态内存的话。。。也许要手写平衡树？ 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;map&gt; #define maxn 600005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } #define son(x,y) son[x][y] int son[maxn][26],fa[maxn],len[maxn],ma[maxn],sum[maxn],pos[maxn],cur[maxn],tax[maxn],all,num,last=1,cnt=1; char s[maxn]; inline void modify(int l,int r){ ++sum[l],--sum[r+1]; } void insert(int c){ int p=last,ne=last=++cnt; pos[ne]=len[ne]=len[p]+1; while(p&amp;&amp;!son(p,c))son(p,c)=ne,p=fa[p]; if(!p)fa[ne]=1; else { int q=son(p,c); if(len[q]==len[p]+1)fa[ne]=q; else { int sp=++cnt; memcpy(son[sp],son[q],sizeof son[q]); len[sp]=len[p]+1,fa[sp]=fa[q],fa[q]=fa[ne]=sp; while(p&amp;&amp;son(p,c)==q)son(p,c)=sp,p=fa[p]; } } } int main(){ int n=read(),m,t,node,ans=0; scanf(&quot;%s&quot;,s+1); for(register int i=1;i&lt;=n;++i)insert(s[i]-&#39;a&#39;); for(register int i=1;i&lt;=cnt;++i)++tax[len[i]]; for(register int i=1;i&lt;=n;++i)tax[i]+=tax[i-1]; for(register int i=1;i&lt;=cnt;++i)cur[tax[len[i]]--]=i; t=read(); while(t--){ scanf(&quot;%s&quot;,s+1),m=strlen(s+1),node=1; for(register int i=1;i&lt;=m&amp;&amp;node;++i)node=son(node,s[i]-&#39;a&#39;); if(node)ma[node]=max(ma[node],m); } for(register int i=2;i&lt;=cnt;++i){ t=cur[i]; ma[t]=max(ma[t],ma[fa[t]]); if(ma[t]&amp;&amp;pos[t])modify(max(pos[t]-ma[t]+1,1),pos[t]); } for(register int i=1;i&lt;=n;++i){ sum[i]+=sum[i-1]; if(!sum[i])++ans; } printf(&quot;%d\\n&quot;,ans); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://ctz45562.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"后缀自动机","slug":"后缀自动机","permalink":"https://ctz45562.github.io/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"}]},{"title":"莫比乌斯反演学习笔记","slug":"莫比乌斯反演学习笔记","date":"2019-06-27T08:36:50.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/06/27/莫比乌斯反演学习笔记/","link":"","permalink":"https://ctz45562.github.io/2019/06/27/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"讲道理莫比乌斯反演也算组合数学，不过因为听起来很高大上所以新开了一篇。","text":"讲道理莫比乌斯反演也算组合数学，不过因为听起来很高大上所以新开了一篇。 抄袭来源 https://www.cnblogs.com/peng-ym/p/8647856.html https://www.cnblogs.com/peng-ym/p/9446555.html https://www.luogu.org/blog/An-Amazing-Blog/mu-bi-wu-si-fan-yan-ji-ge-ji-miao-di-dong-xi https://www.cnblogs.com/asuldb/p/10205579.html #define$[A]$：若事件$A$成立为$1$，反之为$0$。 $\\dfrac{n}{i}$：默认向下取整。有的懒得打向下取整号了 凡出现$n$和$m$，默认$n&lt;m$。 整除分块在$O(\\sqrt{n})$时间内求出$\\sum\\limits_{i=1}^n\\left\\lfloor\\dfrac{n}{i}\\right\\rfloor$。 显然$\\left\\lfloor\\dfrac{n}{i}\\right\\rfloor$只有$O(\\sqrt{n})$种取值。 然后有个性质就是对于$\\forall i\\in[l,(n/(n/l))]$，都有$\\left\\lfloor\\dfrac{n}{i}\\right\\rfloor=\\left\\lfloor\\dfrac{n}{l}\\right\\rfloor$。 这样就能把$n$分成$\\sqrt{n}$段，每段统一求和。 int sum(int n){ int ans=0; for(register int l=1,r;l&lt;=n;l=r+1){ r=n/(n/l); ans+=(r-l+1)*(n/l); } return ans; } 同理也能做到$O(\\sqrt{n})$求$\\sum\\limits_{i=1}^n\\left\\lfloor\\dfrac{n}{i}\\right\\rfloor\\left\\lfloor\\dfrac{m}{i}\\right\\rfloor$，也能把r-l+1换成别的，甚至可以用于求$\\sum\\limits_{i=1}^nf(\\lfloor\\dfrac{n}{i}\\rfloor,\\lfloor\\dfrac{m}{i}\\rfloor)$。 证明的话「算法竞赛·进阶指南」关于「余数求和」一题的解法写的就很好。 莫比乌斯函数定义定义$\\mu(n)$为莫比乌斯函数。 根据算数基本定理将$n$分解：$n=\\prod\\limits_{i=1}^kp_i^{c_i}$ 如果$\\exists c_i&gt;1$，则$\\mu(n)=0$。 否则$\\mu(n)=(-1)^k$。 特别的，$\\mu(1)=1$。 性质1.$\\mu(n)$为积性函数 于是就能线筛它： int prime[maxn],mu[maxn],cnt,n; bool is[maxn]; void sieve(){ mu[1]=is[1]=1; for(register int i=2;i&lt;=n;++i){ if(!is[i])prime[++cnt]=i,mu[i]=-1; for(register int j=1;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=n;++j){ is[i*prime[j]]=1; if(i%prime[j]==0){mu[i*prime[j]]=0;break;} mu[i*prime[j]]=-mu[i]; } } } 2.$\\sum\\limits_{d|n}\\mu(d)=[n=1]$ 肥肠重要的性质。 证明： $n=1$时为$1$。 $n&gt;1$时，将$n$分解为$\\prod\\limits_{i=1}^kp_i^{c_i}$。 考虑它每个约数的贡献，若$c_i&gt;1$则贡献为零，我们只考虑$c_i\\le 1$的情况，也就相当于选出若干个$p_i$。 选$i$个$p_i$有$C_k^i$种情况，贡献和为： $\\sum\\limits_{i=0}^kC_k^i(-1)^i$ 后面乘上个$1^{k-i}$： $=\\sum\\limits_{i=0}^kC_k^i(-1)^i1^{k-i}$ 这不二项式定理吗？ $=(-1+1)^k$ $=0$ 3.$\\sum\\limits_{d|n}\\dfrac{\\mu(d)}{d}=\\dfrac{\\varphi(n)}{n}$ 狄雷克雷卷积中会证明。 狄雷克雷卷积杜教筛里会用到，这里也用来证明莫比乌斯反演。 常见积性函数欧拉函数$\\varphi(n)$，约数个数函数$d(n)$，约数和函数$\\sigma(n)$，莫比乌斯函数$\\mu(n)$ 下面是一些刚见到的完全积性函数： 元函数$e(n)=[n=1]$ 常函数$1(n)=1$ 单位函数$id(n)=n$ 幂函数$id^k(n)=n^k$ 定义卷积的符号为$*$。 对于函数$f(n)$和$g(n)$，定义： $(f*g)(n)=\\sum\\limits_{d|n}f(d)g(\\dfrac{n}{d})$ 写的时候可以把$(n)$省略掉。 性质1.交换律 $f*g=g*f$ 2.结合律 $(f*g)*h=f*(g*h)$ 3.分配律 $(f+g)*h=f*h+g*h$ 4.积性函数卷积性函数还是积性函数 5.$e(n)$就是卷积里的单位元，即$f*e=f$ 下面$2$条是由$\\mu,\\varphi$自身的性质得来的： 6.$\\mu*1=e$ 7.$\\varphi*1=id$ 我们来用这$2$条性质证明$\\sum\\limits_{d|n}\\dfrac{\\mu(d)}{d}=\\dfrac{\\varphi(n)}{n}$： 给$\\mu$卷个$id$： $\\mu*id=\\mu*\\varphi*1$ $\\mu*id=\\varphi*e$ $\\sum\\limits_{d|n}\\mu(d)\\dfrac{n}{d}=\\varphi(n)$ $\\sum\\limits_{d|n}\\dfrac{\\mu(d)}{d}=\\dfrac{\\varphi(n)}{n}$ 莫比乌斯反演式子就是这个： $f(n)=\\sum\\limits_{d|n}g(d)\\leftrightarrow g(n)=\\sum\\limits_{d|n}\\mu(d)f(\\dfrac{n}{d})$ 还有一种形式： $f(d)=\\sum\\limits_{d|n}g(n)\\leftrightarrow g(d)=\\sum\\limits_{d|n}\\mu(\\dfrac{n}{d})f(n)$ 证明$f(n)=\\sum\\limits_{d|n}g(d)$ 可以看做$f=g*1$ 两边都卷个$\\mu$： $f*\\mu=g*1*\\mu$ 前面写过$\\mu*1=e,f*e=f$ 则$f*\\mu=g$ 即$g(n)=\\sum\\limits_{d|n}f(d)\\mu(\\dfrac{n}{d})$ 栗子莫比乌斯反演能干啥？ 举个栗子：求$\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m[gcd(i,j)=k]$ 正规做法设$f(d)=\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m[gcd(i,j)=d],g(d)=\\sum\\limits_{d|n}f(n)$ 可以发现$g(d)$就是在枚举$d|gcd(i,j)$的倍数的情况，即前$n$个数中能被$d$整除的数的个数和前$m$个数中能被$d$整除的数的个数。 则$g(d)=\\left\\lfloor\\dfrac{n}{d}\\right\\rfloor\\left\\lfloor\\dfrac{m}{d}\\right\\rfloor$。 显然可以莫比乌斯反演，$f(i)=\\sum\\limits_{i|d}\\mu(\\dfrac{d}{i})g(d)=\\sum\\limits_{i|d}\\mu(\\dfrac{d}{i})\\left\\lfloor\\dfrac{n}{d}\\right\\rfloor\\left\\lfloor\\dfrac{m}{d}\\right\\rfloor$。 答案为$f(k)=\\sum\\limits_{k|d}\\mu(\\dfrac{d}{k})\\left\\lfloor\\dfrac{n}{d}\\right\\rfloor\\left\\lfloor\\dfrac{m}{d}\\right\\rfloor$，枚举$k$的倍数，上界显然为$\\left\\lfloor\\dfrac{n}{k}\\right\\rfloor$： $f(k)=\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{k}\\rfloor}\\mu(i)\\left\\lfloor\\dfrac{n}{ik}\\right\\rfloor\\left\\lfloor\\dfrac{m}{ik}\\right\\rfloor$ 把$n,m$都除以$k$，预处理$\\mu$的前缀和，后面这一坨就能整除分块$O(\\sqrt{n})$做了。 常见做法真的做反演题的时候用得最多的还是$\\sum\\limits_{d|n}\\mu(d)=[n=1]$。 还是这道题，枚举$k$的倍数： $\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m[gcd(i,j)=k]$ $=\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{k}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{m}{k}\\rfloor}[gcd(i,j)=1]$ 直接把$\\mu$的性质往上套： $=\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{k}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{m}{k}\\rfloor}\\sum\\limits_{d|gcd(i,j)}\\mu(d)$ $d|gcd(i,j)$和$d|i,d|j$是等价的，然后我们改为枚举$d$，上界为$\\left\\lfloor\\dfrac{n}{k}\\right\\rfloor$，再变换一下求和顺序： $=\\sum\\limits_{d=1}^{\\lfloor\\frac{n}{k}\\rfloor}\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{k}\\rfloor}[d|i]\\sum\\limits_{j=1}^{\\lfloor\\frac{m}{k}\\rfloor}[d|j]\\mu(d)$ 显然，$\\sum\\limits_{i=1}^n[d|i]=\\left\\lfloor\\dfrac{n}{d}\\right\\rfloor$： $=\\sum\\limits_{d=1}^{\\lfloor\\frac{n}{k}\\rfloor}\\mu(d)\\left\\lfloor\\dfrac{n}{dk}\\right\\rfloor\\left\\lfloor\\dfrac{m}{dk}\\right\\rfloor$ 杜教筛做反演题的时候有些是需要杜教筛的，然后就被送过来学了。 杜教筛可以在$O(n^{\\frac{2}{3}})$求出某些数论函数的单项前缀和。 推导假设我们有函数$f$，前缀和记为$S$，求$S(n)$。 设出另外两个函数$g,h$，满足$h=f*g$。 即$h=\\sum\\limits_{d|n}g(d)f(\\dfrac{n}{d})$ 对$h$做个前缀和： $\\sum\\limits_{i=1}^nh(i)=\\sum\\limits_{i=1}^n\\sum\\limits_{d|i}g(d)f(\\dfrac{i}{d})$ 我们发现等号后面两个$\\sum$就是把$1\\sim n$的约数枚举了一遍。 于是改为枚举$d$： $\\sum\\limits_{i=1}^nh(i)=\\sum\\limits_{d=1}^ng(d)\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}f(\\dfrac{id}{d})=\\sum\\limits_{d=1}^ng(d)S(\\dfrac{n}{d})$ 把$d=1$提出来： $\\sum\\limits_{i=1}^nh(i)=g(1)S(n)+\\sum\\limits_{d=2}^ng(d)S(\\dfrac{n}{d})$ 移项： $g(1)S(n)=\\sum\\limits_{i=1}^nh(i)-\\sum\\limits_{d=2}^ng(d)S(\\dfrac{n}{d})$ $g(1)S(n)=\\sum\\limits_{i=1}^n(f*g)(i)-\\sum\\limits_{d=2}^ng(d)S(\\dfrac{n}{d})$ 如果选取了合适的$g$使$f*g$的前缀和便于计算的话，就能整除分块递归计算$S(\\dfrac{n}{d})$了。 应用莫比乌斯函数我们知道$\\mu* 1=e$，显然$e$的前缀和就是$1$。 把$g$配为$1$，就有$S(n)=1-\\sum\\limits_{d=2}^nS(\\dfrac{n}{d})$ 欧拉函数欧拉函数有$\\varphi*1=id$，$id$前缀和就是自然数前$n$项和。 于是$S(n)=\\sum\\limits_{i=1}^ni-\\sum\\limits_{d=2}^nS(\\dfrac{n}{d})$ 奇怪的欧拉函数求$\\sum\\limits_{i=1}^ni\\varphi(i)$。 要消去烦人的$i$，给$i\\varphi(i)$卷上$id$： $i\\varphi(i)*id=\\sum\\limits_{d|n}d\\varphi(d)\\dfrac{n}{d}=n\\sum\\limits_{d|n}\\varphi(d)=n^2$ $S(n)=\\sum\\limits_{i=1}^ni^2-\\sum\\limits_{d=2}^ndS(\\dfrac{n}{d})$ 实现一般是先线筛出部分前缀和，再配合上记忆化。 以$\\mu$为例： #define maxn 10000001 #define inf 0x3f3f3f3f const int Mod = 1e6 + 7; struct hash{ int h[Mod],d[Mod],s[Mod],nex[Mod],cnt; void insert(int x,int y){ s[++cnt]=x,x%=Mod,nex[cnt]=h[x],d[h[x]=cnt]=y; } int find(int x){ for(register int i=h[x%Mod];i;i=nex[i]) if(s[i]==x)return d[i]; return -inf; } }mmu;//哈希记忆化 int mu[maxn],prime[maxn&gt;&gt;2],cnt; bool is[maxn]; void sieve(){ is[1]=mu[1]=1; for(register int i=2;i&lt;maxn;++i){ if(!is[i])prime[++cnt]=i,mu[i]=-1; for(register int j=1;j&lt;=cnt&amp;&amp;i*prime[j]&lt;maxn;++j){ is[i*prime[j]]=1; if(i%prime[j]==0){mu[i*prime[j]]=0;break;} mu[i*prime[j]]=-mu[i]; } } for(register int i=2;i&lt;maxn;++i)mu[i]+=mu[i-1]; }//筛出前maxn的前缀和 int smu(int n){ if(n&lt;maxn)return mu[n]; int ans=mmu.find(n); if(ans!=-inf)return ans; ans=1; for(register int l=2,r;l&lt;=n;l=r+1){ r=n/(n/l); ans-=(r-l+1)*smu(n/l); } mmu.insert(n,ans); return ans; } vim没有c++11开不了unordered_map只好手写哈希 还有种更高端的记忆化。 由于求的前缀和都是$N$的约数，开一个$\\sqrt{N}$大小的数组$mmu$。 若$n\\le \\sqrt{n}$返回$mmu[n]$，否则返回$mmu[\\sqrt{N}+N/n]$。 然而每次都要清空$mmu$数组。 复杂度不提前线筛的话复杂度是$O(n^{\\frac{3}{4}})$ 如果线筛出前$n^{\\frac{2}{3}}$的前缀和的话是$O(n^{\\frac{2}{3}})$ 不会证（理直气壮） 还有个很有意思的东西： 整除分块套杜教筛： for(register int l=1,r;l&lt;=n;l=r+1){ r=n/(n/l); ans+=(smu(r)-smu(l-1))*(n/l); } 上面这个的复杂度是$O(\\sqrt{n}+n^{\\frac{2}{3}})$的！ 由于每个块的右端点都是$n/(n/l)$，而$l-1$相当于上一个块的右端点，我们可以看做取遍了$\\left\\lfloor\\dfrac{n}{i}\\right\\rfloor$。而在杜教筛中求$S(n)$的时候已经把$S(\\left\\lfloor\\dfrac{n}{i}\\right\\rfloor)$都算过了，所以记忆化之后这些值都可以$O(1)$得到，整个复杂度就是加起来的。 同理，杜教筛套杜教筛的复杂度为$O(n^{\\frac{2}{3}})$。 水题Problem b其实是个容斥，也算是二维前缀和。 设$f(n,m)=\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m[gcd(i,j)=k]$ 求$\\sum\\limits_{i=a}^b\\sum\\limits_{j=c}^{d}[gcd(i,j)=k]$ 我们暴力展开或者把它想象成二维平面上的一个矩形，就变成了$f(b,d)-f(b,c-1)-f(a-1,d)+f(a-1,c-1)$ 然后就是栗子了。 YY的GCD求$\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m[gcd(i,j)\\in prime]$ 暴力枚举质数： $=\\sum\\limits_{a\\in prime}\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m[gcd(i,j)=a]$ 套路地变换： $=\\sum\\limits_{a\\in prime}\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{a}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{m}{a}\\rfloor}\\sum\\limits_{d|gcd(i,j)}\\mu(d)$ $=\\sum\\limits_{a\\in prime}\\sum\\limits_{d=1}^{\\lfloor\\frac{n}{a}\\rfloor}\\left\\lfloor\\dfrac{n}{ad}\\right\\rfloor\\left\\lfloor\\dfrac{m}{ad}\\right\\rfloor\\mu(d)$ 这样复杂度还是太高。 设$k=ad$，显然$a|k$。改为枚举$k$： $=\\sum\\limits_{a\\in prime}\\sum\\limits_{k=1}^n[a|k]\\left\\lfloor\\dfrac{n}{k}\\right\\rfloor\\left\\lfloor\\dfrac{m}{k}\\right\\rfloor\\mu(d)$ 变换求和顺序： $=\\sum\\limits_{k=1}^n\\left\\lfloor\\dfrac{n}{k}\\right\\rfloor\\left\\lfloor\\dfrac{m}{k}\\right\\rfloor\\sum\\limits_{a\\in prime}[a|k]\\mu(d)$ 这样前面的可以整除分块，后面那一坨可以预处理。对于每个质数，给它的倍数加上$\\mu$即可。 约数个数和题解 Crash的数字表格题解 选数这个题直接把我送去学杜教筛了。 个人习惯把$H$看作$R$，把$N$看作$n$。 求$\\sum\\limits_{i_1=L}^R\\sum\\limits_{i_2=L}^R···\\sum\\limits_{i_n=L}^R[gcd(i_1,i_2,…i_n)=k]$ 如果玩套路的话感觉有点麻烦，试试正规反演： 先转化一下，枚举$k$的倍数，这样$R=\\lfloor\\dfrac{R}{k}\\rfloor,L=\\lceil\\dfrac{L}{k}\\rceil$ 就成了$\\sum\\limits_{i_1=L}^R\\sum\\limits_{i_2=L}^R···\\sum\\limits_{i_n=L}^R[gcd(i_1,i_2,…i_n)=1]$ 设$f(d)=\\sum\\limits_{i_1=L}^R\\sum\\limits_{i_2=L}^R···\\sum\\limits_{i_n=L}^R[gcd(i_1,i_2,…i_n)=d],g(d)=\\sum\\limits_{d|n}f(n)$ 考虑$g$的含义，就是有$n$个值域为$[L,R]$的数，它们的$gcd$为$d$的倍数。 $g(d)=\\left(\\left\\lfloor\\dfrac{R}{d}\\right\\rfloor-\\left\\lfloor\\dfrac{L-1}{d}\\right\\rfloor\\right)^{n}$ 反演得：$f(d)=\\sum\\limits_{d|n}\\mu(n)g(\\dfrac{n}{d})$ 答案为$f(1)=\\sum\\limits_{i=1}^R\\mu(i)g(i)$ 后面$g$可以整除分块，$R$达到$1e9$要杜教筛。复杂度为$O(n^{\\frac{2}{3}}+\\sqrt{n}\\log n)$。 于神之怒加强版上面那道题送我去学了杜教筛，这道题送我去重学了遍线筛。 推法很套路，最后求的是$\\sum\\limits_{T=1}^n\\left\\lfloor\\dfrac{n}{T}\\right\\rfloor\\left\\lfloor\\dfrac{m}{T}\\right\\rfloor\\sum\\limits_{d|T}d^k\\mu(\\dfrac{T}{d})$ 然后就是筛$f(T)=\\sum\\limits_{d|T}d^k\\mu(\\dfrac{T}{d})$。$n$有$5e6$，简单的$O(n\\log n)$筛法不好过了。 显然$f=\\mu*id^k$是个积性函数，可以考虑线筛。 对于质数$p$： $f(p)=p^k-1$ $f(p^m)=(p^m)^k-(p^{m-1})^k$ 我们要推到$f(p^{m+1})=(p^m)^k-(p^{m-1})^k=(p^k-1)(p^k)^m=f(p)(p^k)^m$ 对于所有仅有一个质因子的数维护函数$g(p^m)=(p^k)^m$，这个是可以推上去的。 则$f(p^{m+1})=f(p)g(p^m)$。 考虑到我们仅对每个质数做快速幂，复杂度还是$O(\\dfrac{n}{\\ln n}\\log k)=O(n)$的。 线筛代码： #define maxn 5000001 const int mod = 1000000007; int g[maxn],f[maxn],low[maxn],prime[maxn&gt;&gt;2],cnt; bool is[maxn]; void sieve(){ f[1]=is[1]=1; for(register int i=2;i&lt;maxn;++i){ if(!is[i])prime[++cnt]=i,f[i]=quickpow(i,k)-1,g[i]=f[i]+1,low[i]=i; for(register int j=1;j&lt;=cnt&amp;&amp;i*prime[j]&lt;maxn;++j){ is[i*prime[j]]=1; if(i%prime[j]==0){ low[i*prime[j]]=low[i]*prime[j]; if(low[i]==i)g[i*prime[j]]=1ll*g[i]*g[prime[j]]%mod,f[i*prime[j]]=1ll*g[i]*f[prime[j]]%mod; else f[i*prime[j]]=1ll*f[i/low[i]]*f[low[i]*prime[j]]%mod; break; } low[i*prime[j]]=prime[j]; f[i*prime[j]]=1ll*f[i]*f[prime[j]]%mod; } } } 简单的数学题题解 数表求$\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^m\\sigma(gcd(i,j))[\\sigma(gcd(i,j))\\le a]$ 套路推完式子长这样：$\\sum\\limits_{T=1}^n\\left\\lfloor\\dfrac{n}{i}\\right\\rfloor\\left\\lfloor\\dfrac{m}{i}\\right\\rfloor\\sum\\limits_{d|T,\\sigma(d)\\le a}\\mu(\\dfrac{T}{d})\\sigma(d)$ 所有数按$\\sigma$排序，把询问离线下来按$a$排序。 处理每个询问前依次把$\\sigma(i)\\le a$的数的贡献算上。 这样就是若干个单点加和区间查，树状数组维护即可。 模数是$2^{31}$可以自然溢出$int$。 复杂度$O(n\\log^2n+T\\sqrt{n}\\log n)$ 数字表格题解","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ctz45562.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"组合数学","slug":"组合数学","permalink":"https://ctz45562.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"https://ctz45562.github.io/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"name":"杜教筛","slug":"杜教筛","permalink":"https://ctz45562.github.io/tags/%E6%9D%9C%E6%95%99%E7%AD%9B/"}]},{"title":"洛谷 P2624 [HNOI2008]明明的烦恼","slug":"洛谷-P2624-HNOI2008-明明的烦恼","date":"2019-06-27T06:12:10.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/06/27/洛谷-P2624-HNOI2008-明明的烦恼/","link":"","permalink":"https://ctz45562.github.io/2019/06/27/%E6%B4%9B%E8%B0%B7-P2624-HNOI2008-%E6%98%8E%E6%98%8E%E7%9A%84%E7%83%A6%E6%81%BC/","excerpt":"传送门 好玩但没啥用的$prufer$序列。","text":"传送门 好玩但没啥用的$prufer$序列。 记$S$为有度数限制的点的集合，$cnt$为不属于$S$的点的数量，$sum=\\sum\\limits_{i\\in S}d(i)-1$。 先把$S$中的点扔到$prufer$序列里，$C_{n-2}^{sum}$选好位置，序列数有$\\dfrac{sum!}{\\prod\\limits_{i\\in S}[d(i)-1]!}$种。 再把剩下的$cnt$个点扔进去，也就是剩下的$n-2-sum$个位置，每个位置有$cnt$种取值，即$cnt^{n-2-sum}$。 答案就是$C_{n-2}^{sum}\\dfrac{sum!}{\\prod\\limits_{i\\in S}[d(i)-1]!}cnt^{n-2-sum}$。注意判一下无解。 最后就是恶心的高精了。又双叒叕把别人的板子抄了过来 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 1005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int d[maxn]; #include &lt;stack&gt; const int N=10000,B=3,base=1000; struct long_long{ private: int len,a[N]; inline void clear(){while(!a[len]&amp;&amp;len&gt;1) --len;} public: long_long(){memset(a,0,sizeof a);len=0;} long_long(int x){memset(a,0,sizeof a);a[len=1]=x;} void print(){ printf(&quot;%d&quot;,a[len]); for(int i=len-1;i&gt;0;--i) for(int j=base/10;j&gt;0;j/=10) printf(&quot;%d&quot;,a[i]/j%10); pn; } long_long &amp;operator =(int x){ stack&lt;char&gt; st;string s; if(!x) return *this=&quot;0&quot;; while(x){st.push(x%10+&#39;0&#39;);x/=10;} while(!st.empty()) s+=st.top(),st.pop(); return *this=s; } long_long &amp;operator =(const string &amp;s){ memset(a,0,sizeof a);len=0; int l=s.length(); for(int i=0;i&lt;=l;++i){ int j=(l-i+(B-1))/B; a[j]=(a[j]&lt;&lt;1)+(a[j]&lt;&lt;3)+(s[i]^48); } len=(l+(B-1))/B; return *this; } long_long operator +(const long_long &amp;x)const{ long_long res;res.len=max(len,x.len);int k=0; for(int i=1;i&lt;=res.len;++i){ res.a[i]=a[i]+x.a[i]+k; k=res.a[i]/base; res.a[i]%=base; } if(k&gt;0) res.a[++res.len]=k; return res; } long_long operator -(const long_long &amp;x)const{ long_long res=*this; for(int i=1;i&lt;=len;++i){ res.a[i]-=x.a[i]; if(res.a[i]&lt;0) --res.a[i+1],res.a[i]+=base; } res.clear(); return res; } long_long operator *(const int &amp;x)const{ long_long res=*this; for(int i=1;i&lt;=len;++i) res.a[i]*=x; for(int i=1;i&lt;=len;++i) res.a[i+1]+=res.a[i]/base,res.a[i]%=base; int &amp;end=res.len; while(res.a[end+1]&gt;0){++end;res.a[end+1]+=res.a[end]/base,res.a[end]%=base;} return res; } long_long operator *(const long_long &amp;x)const{ long_long res;res.len=len+x.len; for(int i=1;i&lt;=len;++i) for(int j=1;j&lt;=x.len;++j){ res.a[i+j-1]+=a[i]*x.a[j]; res.a[i+j]+=res.a[i+j-1]/base; res.a[i+j-1]%=base; } res.clear(); return res; } long_long operator /(const int &amp;x)const{ long_long res;res.len=len;int k=0; for(int i=len;i&gt;0;--i){ k=k*base+a[i]; res.a[i]=k/x; k%=x; } res.clear(); return res; } int operator %(const int &amp;x)const{ int k=0; for(int i=len;i&gt;0;--i){ k=k*base+a[i]; k%=x; } return k; } bool operator &lt;(const long_long &amp;x)const{ if(len==x.len){ int i; for(i=len;a[i]==x.a[i]&amp;&amp;i&gt;1;--i); if(i&gt;=1) return a[i]&lt;x.a[i]; return false; } return len&lt;x.len; } bool operator &gt;(const long_long &amp;x)const{return !(*this&lt;x);} void operator += (const int &amp;x){*this=*this+x;} void operator *= (const int &amp;x){*this=*this*x;} void operator /= (const int &amp;x){*this=*this/x;} }ans=1; int main(){ int n=read(),sum=0,cnt=0; for(register int i=1;i&lt;=n;++i){ d[i]=read(); if(d[i]==-1)++cnt; else if(d[i]==0){puts(&quot;0&quot;);return 0;} else sum+=d[i]-1; } if(n==1){printf(&quot;%d\\n&quot;,d[1]==0?1:0);return 0;} if(!n||sum&gt;n-2){puts(&quot;0&quot;);return 0;} for(register int i=n-2-sum+1;i&lt;=n-2;++i)ans*=i; for(register int i=2;i&lt;=sum;++i)ans/=i; for(register int i=2;i&lt;=sum;++i)ans*=i; for(register int i=1;i&lt;=n-2-sum;++i)ans*=cnt; for(register int i=1;i&lt;=n;++i) if(d[i]!=-1)for(register int j=2;j&lt;d[i];++j)ans/=j; ans.print(); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"组合数学","slug":"组合数学","permalink":"https://ctz45562.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"prufer序列","slug":"prufer序列","permalink":"https://ctz45562.github.io/tags/prufer%E5%BA%8F%E5%88%97/"}]},{"title":"洛谷 P4859 已经没有什么好害怕的了","slug":"洛谷-P4859-已经没有什么好害怕的了","date":"2019-06-25T09:37:52.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/06/25/洛谷-P4859-已经没有什么好害怕的了/","link":"","permalink":"https://ctz45562.github.io/2019/06/25/%E6%B4%9B%E8%B0%B7-P4859-%E5%B7%B2%E7%BB%8F%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%AE%B3%E6%80%95%E7%9A%84%E4%BA%86/","excerpt":"传送门 「魔法少女小圆」题面好评。 虽然第一眼看成了正在补的「Charlotte」","text":"传送门 「魔法少女小圆」题面好评。 虽然第一眼看成了正在补的「Charlotte」 好像这种题挺套路来着，还是我太蒻了。。。 设$a$为糖果的能量，$b$为药片的能量。 求$\\sum[a&gt;b]-\\sum[b&gt;a]=k$相当于$\\sum[a&gt;b]=\\dfrac{n+k}{2}$，那么以下的$k$都代表$\\dfrac{n+k}{2}$。 先把$a,b$排个序。设$f(i,j)$表示前$i$个$a$，和所有$b$共匹配$j$组（有的$a$可能未匹配），且该$j$组都满足$a&gt;b$。 转移先考虑$a_i$是否匹配。不匹配就是$f(i-1,j)$。 若选一个匹配，前$i-1$个$a$就要匹配$j-1$个。记$cnt_i$为比$a_i$小的$b$的数量。因为我们排过序了，所以前$i-1$个里匹配的$j-1$个一定都来自于前$cnt_i$的$b$。显然$a_i$不能抢占匹配好的$b$，那只有$cnt_i-(j-1)$个$b$可以选。 即$f(i,j)=f(i-1,j)+(cnt_i-j+1)\\times f(i-1,j-1)$ 对于$f(n,i)$来说，有$n-i$个$a$未匹配，乘上$(n-i)!$就能得到至少$i$个$a&gt;b$的方案数。 那么设$f(i)=f(n,i)\\times(n-i)!$，$g(i)$为恰好$i$个$a&gt;b$。 容易发现每个$g(j)$在$f(i)$里出现了$C_j^i$次。 则$f(i)=\\sum\\limits_{j=i}^nC_j^ig(j)$ 二项式反演得： $g(i)=\\sum\\limits_{j=i}^n(-1)^{j-i}C_j^if(j)$ 答案就是$g(k)$。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 2005 #define inf 0x3f3f3f3f const int mod = 1e9 + 9; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int f[maxn],fac[maxn]={1},inv[maxn],a[maxn],b[maxn];//f滚起来 int INV(int x){return x==1?1:1ll*(mod-mod/x)*INV(mod%x)%mod;} inline long long pow1(int x){return x&amp;1?-1ll:1ll;} inline int C(int n,int m){ return 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod; } int main(){ int n=read(),k=n+read()&gt;&gt;1,p=0,ans=0; for(register int i=1;i&lt;=n;++i)a[i]=read(); for(register int i=1;i&lt;=n;++i)b[i]=read(); sort(a+1,a+1+n),sort(b+1,b+1+n); f[0]=1; for(register int i=1;i&lt;=n;++i){ while(p+1&lt;=n&amp;&amp;b[p+1]&lt;a[i])++p; for(register int j=i;j;--j) f[j]=(f[j]+1ll*(p-j+1)*f[j-1]%mod)%mod; } for(register int i=1;i&lt;=n;++i)fac[i]=1ll*fac[i-1]*i%mod; inv[n]=INV(fac[n]); for(register int i=n-1;~i;--i)inv[i]=1ll*inv[i+1]*(i+1)%mod; for(register int i=k;i&lt;=n;++i) (ans+=pow1(i-k)*C(i,k)*f[i]%mod*fac[n-i]%mod)%=mod; printf(&quot;%d\\n&quot;,(ans+mod)%mod); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"组合数学","slug":"组合数学","permalink":"https://ctz45562.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"二项式反演","slug":"二项式反演","permalink":"https://ctz45562.github.io/tags/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/"}]},{"title":"洛谷 P2523 [HAOI2011]Problem c","slug":"洛谷-P2523-HAOI2011-Problem-c","date":"2019-06-24T08:34:31.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/06/24/洛谷-P2523-HAOI2011-Problem-c/","link":"","permalink":"https://ctz45562.github.io/2019/06/24/%E6%B4%9B%E8%B0%B7-P2523-HAOI2011-Problem-c/","excerpt":"传送门 妙啊！","text":"传送门 妙啊！ 先考虑不合法的方案长啥样： 设$sum_i$为$a_i\\ge i$的个数。如果$\\exists i,sum_i&gt;n-i+1$，则该方案不合法。 这个很好理解，对于某种方案来说，会有$sum_i$个人坐到$[i,n]$的位置，而$[i,n]$最多容纳$n-i+1$个人，即$sum_i\\le n-i+1$。 再设$f(i,j)$为未确定位置的人中，$a_i\\ge i$的有$j$个人的方案数，$cnt_i$为已确定位置的人中，$a_i\\ge i$的个数。 初始状态$f(n+1,0)=1$。 转移我们枚举有多少人$a_i=i$。 则$f(i,j)=\\sum\\limits_{k=0}^jf(i+1,j-k)$ 因为入座的时候是有次序的，还要再$C_j^k$枚举一下哪些人$a_i=i$。 即$f(i,j)=\\sum\\limits_{k=0}^jf(i+1,j-k)C_k^j$ 要满足$sum_i\\le n-i+1$，已经有$cnt_i$个人被钦定为$a_i\\ge i$，那么仅考虑未确定位置的人的$sum$时，有$sum_i-cnt_i\\le n-i+1$ 也就是说$j\\in [0,n-i+1-cnt_i]$。 显然$sum_1$就是总人数，答案就是$f(1,n-m)$。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 305 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int mod,f[maxn][maxn],sum[maxn],c[maxn][maxn]; int main(){ int t=read(),n,m; c[0][0]=1; while(t--){ n=read(),m=read(),mod=read(); for(register int i=1;i&lt;=n;++i){ c[i][0]=1; for(register int j=1;j&lt;=i;++j) c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod; } memset(f,0,sizeof f); memset(sum,0,sizeof sum); for(register int i=1;i&lt;=m;++i)read(),++sum[read()]; for(register int i=n;i;--i){ sum[i]+=sum[i+1]; if(sum[i]&gt;n-i+1)goto Bad_Option; } f[n+1][0]=1; for(register int i=n;i;--i) for(register int j=0;j&lt;=n-i+1-sum[i];++j) for(register int k=0;k&lt;=j;++k) (f[i][j]+=1ll*c[j][k]*f[i+1][j-k]%mod)%=mod; printf(&quot;YES %d\\n&quot;,f[1][n-m]); continue; Bad_Option: puts(&quot;NO&quot;); } }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"组合数学","slug":"组合数学","permalink":"https://ctz45562.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}]},{"title":"洛谷 P1350 车的放置","slug":"洛谷-P1350-车的放置","date":"2019-06-20T12:56:27.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/06/20/洛谷-P1350-车的放置/","link":"","permalink":"https://ctz45562.github.io/2019/06/20/%E6%B4%9B%E8%B0%B7-P1350-%E8%BD%A6%E7%9A%84%E6%94%BE%E7%BD%AE/","excerpt":"传送门 啊啊啊啊啊没有组合数学的题单我怎么一直切水题啊$QAQ$","text":"传送门 啊啊啊啊啊没有组合数学的题单我怎么一直切水题啊$QAQ$ 先设$f(n,m,k)$为在$n\\times m$的矩形中放$k$个车的方案。 把这个阶梯状的棋盘分割成两个$a\\times b$和$(a+c)\\times d$的矩形。 然后枚举在这两个矩形放几个车。 答案就是$\\sum\\limits_{i=0}^kf(a,b,i)f(a+c-i,d,k-i)$ 再来处理$f$。 显然在一个$n\\times n$的棋盘里放$n$个车的方案数为$n!$。 从$n\\times m$的棋盘里抽出一个$k\\times k$的棋盘，有$C_n^kC_m^k$中方案。 那么$f(n,m,k)=C_n^kC_m^kk!$，注意特判$k&gt;n,m$的情况。 这题就没了。 （数据范围明明可以开到$1e7$或者套个卢卡斯啊） 之所以挂上枚举的标签是因为我觉得这就是枚举（雾 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 3005 #define inf 0x3f3f3f3f const int mod = 100003; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int fac[maxn]={1},inv[maxn]; int INV(int x){return x==1?1:1ll*(mod-mod/x)*INV(mod%x)%mod;} inline int C(int n,int m){ return 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod; } inline int f(int n,int m,int k){ if(k&gt;n||k&gt;m)return 0; return 1ll*C(n,k)*C(m,k)%mod*fac[k]%mod; } int main(){ int a=read(),b=read(),c=read(),d=read(),k=read(),tp=max(b,max(a+c,d)),ans=0; for(register int i=1;i&lt;=tp;++i)fac[i]=1ll*fac[i-1]*i%mod; inv[tp]=INV(fac[tp]); for(register int i=tp-1;~i;--i)inv[i]=1ll*inv[i+1]*(i+1)%mod; for(register int i=0;i&lt;=k;++i)(ans+=1ll*f(a,b,i)*f(a+c-i,d,k-i)%mod)%=mod; printf(&quot;%d\\n&quot;,ans); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"组合数学","slug":"组合数学","permalink":"https://ctz45562.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"枚举","slug":"枚举","permalink":"https://ctz45562.github.io/tags/%E6%9E%9A%E4%B8%BE/"}]},{"title":"洛谷 P3255 [JLOI2013]地形生成","slug":"洛谷-P3255-JLOI2013-地形生成","date":"2019-06-20T07:41:27.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/06/20/洛谷-P3255-JLOI2013-地形生成/","link":"","permalink":"https://ctz45562.github.io/2019/06/20/%E6%B4%9B%E8%B0%B7-P3255-JLOI2013-%E5%9C%B0%E5%BD%A2%E7%94%9F%E6%88%90/","excerpt":"传送门 快合格考了发现自己啥都不会没啥希望过，于是又回来刷题了。。。","text":"传送门 快合格考了发现自己啥都不会没啥希望过，于是又回来刷题了。。。 这个$DP$很有意思。 第一问就是个套路$DP$，按高度降序排序，依次把山插进去。因为题目要求的是严格大于，排序时高度相同的按关键值降序排序就好了。 第二问一开始想了个$O(n)$的假做法，显然数据范围是要$O(n^2)$的。。。 好难啊不会了告辞 还是排好序，我们考虑把相同高度的山一块插进去。对于每一段相同高度的区间$[l,r]$设$f(i,j)$为这段区间中前$i$座山，插进所有山中前$j$座山的前面的方案数。 每座山要么插到第$j$座山前面（$j\\le $关键值），有$f(i-1,j)$种方案；要么插到前$j-1$座山前面，有$f(i,j-1)$种方案。 也就是$f(i,j)=f(i,j-1)+f(i-1,j)$。 因为相同高度的山是单独考虑的，根据乘法原理答案为所有$f(r-l+1,min\\{l,H[r].cnt\\})$的乘积。 $f$要滚起来，要不然清空太慢。 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;stack&gt; #define maxn 1005 #define inf 0x3f3f3f3f const int mod = 2011; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } struct hill{ int h,cnt; bool operator &lt; (const hill &amp;x)const{ if(h!=x.h)return h&gt;x.h; return cnt&lt;x.cnt; } }H[maxn]; int f[2][maxn]; int main(){ int n=read(),ans=1,sum1=0,sum2=0,p; for(register int i=1;i&lt;=n;++i)H[i].h=read(),H[i].cnt=read(); sort(H+1,H+1+n); for(register int i=2;i&lt;=n;++i){ if(H[i].h==H[i-1].h)++sum1; else sum2=i-1,sum1=0; ans=1ll*ans*(min(H[i].cnt-1,sum2)+sum1+1)%mod; } printf(&quot;%d &quot;,ans); ans=1; for(register int i=1;i&lt;=n;i=p+1){ memset(f,0,sizeof f); p=i+1; while(p&lt;=n&amp;&amp;H[p].h==H[i].h)++p; --p; for(register int j=1;j&lt;=i;++j)f[0][j]=1; for(register int j=i;j&lt;=p;++j) for(register int k=1;k&lt;=i;++k){ f[j-i+1&amp;1][k]=f[j-i+1&amp;1][k-1]; if(k&lt;=H[j].cnt)(f[j-i+1&amp;1][k]+=f[j-i&amp;1][k])%=mod; } ans=1ll*ans*f[p-i+1&amp;1][min(i,H[p].cnt)]%mod; } printf(&quot;%d\\n&quot;,ans); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"blogの搭建之sakura","slug":"blogの搭建之sakura","date":"2019-06-04T04:42:45.000Z","updated":"2021-09-25T05:14:01.946Z","comments":true,"path":"2019/06/04/blogの搭建之sakura/","link":"","permalink":"https://ctz45562.github.io/2019/06/04/blog%E3%81%AE%E6%90%AD%E5%BB%BA%E4%B9%8Bsakura/","excerpt":"索引：blogの搭建之next 不知不觉已经有两千多行了啊。。。虽然大部分是代码 甚至还有很多小地方我没写进去。如果当初搞一个更新日志的话，现在至少得有一百多条了吧。","text":"索引：blogの搭建之next 不知不觉已经有两千多行了啊。。。虽然大部分是代码 甚至还有很多小地方我没写进去。如果当初搞一个更新日志的话，现在至少得有一百多条了吧。 前言很久以前在一个wordpress博客上看到了$sakura$主题，很对我口味。 然而我是hexo博客，不想转到wordpress上我现在也没钱买服务器，于是默默收藏了起来，要是以后我用wordpress就用这个主题。 前几天没事翻了翻hexo的主题，居然发现有人把$sakura$搬到了hexo上。 于是果断抛弃$next$立刻用了四天时间转到$sakura$主题并大量魔改，追求足够美观而尽量精简。 $sakura$很多配置当然比不上懒人必备的$next$，存在着很多能魔改的地方给了我颓废的契机，但教程实在是少。 只能凭借少量的教程、自己的$YY$和半吊子现学现卖的html,css,js来搞。（以及抄袭+搬代码） 本文记录我修改$sakura$主题的过程（也算是个教程），其中部分内容同样适用于其他hexo主题。同时声明一点：我会写在这里面的都是网上没有教程或难以找到的东西，常见的问题还是请找万能百度或更万能的谷歌。 在我退役前会不定期更新。 感谢以下教程对我的帮助： https://github.com/honjun/hexo-theme-sakura/blob/master/README-zh_cn.md https://yremp.club/2019/05/26/teach/ https://blog.csdn.net/u014630987/article/details/78670258 http://moxfive.xyz/2015/10/25/hexo-tag-cloud/ https://github.com/wizardforcel/hexo-theme-landfarz/blob/master/layout/_partial/post/tag.ejs https://yremp.live/sakura-js/ https://www.tomori.xyz/2019/06/15/emojis-plug-in-unit-for-bilibili/ https://zxsama.top/7990d08f 也感谢wordpress作者mashiro和hexo作者hojun创造出$sakura$这一主题以及Tian-Xing对本文的纠错。 基本配置Mathjax纠错markdown与$\\LaTeX$冲突会导致公式渲染出错，尤其是两个下划线会被转移成斜体。 之前用$next$的时候是通过修改kramed源文件解决的，于是还是选择把hexo-renderer-marked换成hexo-renderer-kramed，请自行用npm安装。 在\\node_modules\\kramed\\lib\\rules\\inline.js 中，第$11$行： - escape: /^\\\\([\\\\`*{}\\[\\]()#$+\\-.!_&gt;])/, + escape: /^\\\\([`*\\[\\]()#$+\\-.!_&gt;])/, 第$20$行： - em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, + em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, 加速一般$mathjax$源都是$cloudflare$，然而是国外的，速度怎么样我放张图自己体会： （测速工具） 于是我把源换成了国内的$bootcdn$： 在\\themes\\sakura\\layout\\_widget\\common-article.ejs中，修改： - &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt; + &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/mathjax/2.7.6/latest.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt; 在\\themes\\sakura\\source\\js\\sakura-app.js中，修改： - $.getScript(&#39;//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML&#39;, function () { + $.getScript(&#39;https://cdn.bootcss.com/mathjax/2.7.6/MathJax.js?config=TeX-MML-AM_CHTML&#39;, function () { 再 放 送： 代码高亮刚用的时候代码框十分诡异而且压根就没有高亮。找了几种方法并不可行。 最后发现应该是$hexo$自带的高亮冲突了，只要把站点配置文件中： highlight: enable: true $true$改为$false$就行了。 搜索搜索一直不能用啊。。。 经过一晚上的配置毫无进展，最后在$hexo$博客群里问了下$dalao$，就是少了个插件。 git bash中执行： npm install hexo-generator-json-content --save Fancybox update on 2020.1.12： 去$sakura$的github页面发现其实已经配置好$Fancybox$了。。。只需要以｛% fb_img src caption %｝的格式引用即可。其中src为地址，caption为描述（可以不加）。 不过这样是没法通过内嵌html自定义图片样式的，还是需要自己配置。 $Fancybox$就是那个点击图片进行幻灯片放映所有图片的东西。 $sakura$其实已经引入了$Fancybox$的js和css了，但是图片没有处理成对应的格式。 在\\themes\\sakura\\layout\\_widget\\common-article.ejs中添加： &lt;script&gt; function imgInit(){ var imgs=document.getElementsByClassName(&#39;entry-content&#39;).item(0).getElementsByTagName(&#39;img&#39;),dsrc=record.getAttribute(&quot;data-src&quot;); for(var i=0;i&lt;imgs.length;++i){ var element = document.createElement(&quot;a&quot;),record=imgs[i]; element.setAttribute(&quot;data-fancybox&quot;,&quot;gallery&quot;); element.setAttribute(&quot;href&quot;,dsrc||imgs[i].src); imgs[i].parentNode.appendChild(element); imgs[i].parentNode.removeChild(imgs[i]); element.appendChild(record); } } imgInit(); &lt;/script&gt; 添加&lt;!--more--&gt;支持作为$next$前用户，我很喜欢&lt;!--more--&gt;的便捷性。 简单来说，&lt;!--more--&gt;截取了文章开头，以其原本的亚子显示。 然而$sakura$是不支持的，只能用description属性，不支持markdown和$\\LaTeX$。 经过我的瞎改努力钻研，终于搞出来了。 主页添加在\\themes\\sakura\\layout\\_widget\\index-items.ejs中找到： &lt;div class=&quot;float-content&quot;&gt; 删除下面的： &lt;p style=&quot;text-align:left&quot;&gt;&lt;%= post.description %&gt;&lt;/p&gt; &lt;div class=&quot;post-bottom&quot;&gt; &lt;a href=&quot;&lt;%- url_for(post.path) %&gt;&quot; class=&quot;button-normal&quot;&gt; &lt;i class=&quot;iconfont icon-caidan&quot;&gt;&lt;/i&gt; &lt;/a&gt; &lt;/div&gt; 在上面添加： &lt;% if(post.excerpt) { %&gt; &lt;div class=&quot;readmore&quot;&gt; &lt;%- post.excerpt %&gt; &lt;/div&gt; &lt;% } else { %&gt; &lt;p style=&quot;text-align:left&quot;&gt;&lt;%= post.description %&gt;&lt;/p&gt; &lt;% } %&gt; 配置样式在\\themes\\sakura\\sourcr\\css\\style.css中，添加： .readmore{ text-align:left; position:relative; margin-top:10px; } .readmore a { color:#08f; text-decoration:underline dotted rgba(0,0,0,.1) } .readmore a:hover { color:#05f !important; text-decoration:underline #05f } .readmore p { color:#5c5c5c; line-height:27px; margin: 0; } .readmore hr { margin-top:40px; margin-bottom:40px; display:block; border:0; text-align:center; background:none } .readmore hr:before { display:inline-block; margin-left:.6em; color:rgba(0,0,0,.8); position:relative; top:-30px; font-size:28px; letter-spacing:.6em } .readmore img{transform:none!important;} .readmore blockquote { margin-bottom: 10px; padding:10px 15px; border-radius: 1.3rem; } .readmore blockquote:before { font-size:1.2rem; top:-5px; left:-2px; } .readmore blockquote:after { font-size:1.2rem; bottom:-15px; right:0px; } 这里我只添加了&lt;a&gt;,&lt;p&gt;,&lt;hr&gt;,&lt;blockquote&gt;的样式和对&lt;img&gt;$BUG$的修复，其他有需要的得把.entry-content的搬过来。 这样有&lt;!--more--&gt;标签的会优先显示，否则显示description。 js支持一些仅用于文章里的js例如$\\LaTeX$也要作用于&lt;!--more--&gt;。 以$\\LaTeX$为例： 添加到\\themes\\sakura\\layout\\index.ejs中。 &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/x-mathjax-config&quot;&gt; MathJax.Hub.Config({tex2jax: {inlineMath: [[&#39;$&#39;,&#39;$&#39;], [&#39;\\\\(&#39;,&#39;\\\\)&#39;]]}}); &lt;/script&gt; 其他的例如$Fancybox$和下文的模糊字体请自行添加。 解决「显示更多」js不加载问题这里用了个非常丑陋的方法：暴力设定时器。也懒得改了。 在\\themes\\sakura\\source\\sakura-app.js中找到函数： mashiro_global.post_list_show_animation = new function () { 整个修改为： var previousFlag=false; mashiro_global.post_list_show_animation = new function () { this.ini = function (ajax) { $(&#39;article.post-list-thumb&#39;).each(function (i) { if (ajax) { var window_height = $(window).height() } else { if ($(&#39;.headertop&#39;).hasClass(&#39;headertop-bar&#39;)) { var window_height = 0 } else { var window_height = $(window).height() - 300 } } if (!mashiro_global.landing_at_home) { window_height += 300 } var article_height = $(&#39;article.post-list-thumb&#39;).eq(i).offset().top if ($(window).height() + $(window).scrollTop() &gt;= article_height) { $(&#39;article.post-list-thumb&#39;).eq(i).addClass(&#39;post-list-show&#39;) previousFlag=true; } $(window).scroll(function () { var scrolltop = $(window).scrollTop() if (scrolltop + window_height &gt;= article_height &amp;&amp; scrolltop) { $(&#39;article.post-list-thumb&#39;).eq(i).addClass(&#39;post-list-show&#39;) previousFlag=true; } }) }) } }() setInterval(function(){ if(previousFlag &amp;&amp; MathJax){ previousFlag=false; if(MathJax)MathJax.Hub.Queue([&quot;Typeset&quot;, MathJax.Hub]); } },1000); 其他的请自行添加到定时器setInterval里。 文章列表文章列表用&lt;!--more--&gt;截断会比较丑陋，空白区域太小了还不支持换行。 一开始我保留了desciription，但因为两者差距太大了，主页和文章列表无法统一。我强迫症犯了，直接暴力解决：删掉文章描述！ 光删掉之后太空荡了，于是用文章信息如日期、分类、标签代替了，右上角的日期就去掉了。 在\\themes\\sakura\\layout\\_widget\\category-items.ejs中，找到： &lt;div class=&quot;p-time&quot;&gt; &lt;i class=&quot;iconfont icon-time&quot;&gt; &lt;/i&gt; &lt;%= date(post.date, &#39;YYYY-M-D&#39;) %&gt;&lt;/div&gt; 替换为： &lt;div class=&quot;category-meta&quot; style=&quot;margin:8px 0 0 17.4%&quot;&gt; &lt;span&gt;&lt;i class=&quot;fa fa-calendar&quot;&gt;&lt;/i&gt;&amp;nbsp; &lt;%= date(post.date, &#39;YYYY-M-D&#39;) %&gt;&lt;/span&gt;&lt;em&gt;·&lt;/em&gt; &lt;span&gt; &lt;i class=&quot;fa fa-archive&quot;&gt;&lt;/i&gt;&amp;nbsp; &lt;% post.categories.each((category)=&gt;{ %&gt; &lt;a href=&quot;&lt;%- url_for(category.path) %&gt;&quot; class=&quot;set-color&quot;&gt;&lt;%= category.name %&gt;&lt;em&gt;·&lt;/em&gt;&lt;/a&gt; &lt;% }) %&gt; &lt;/span&gt; &lt;span&gt;&lt;i class=&quot;fa fa-tags&quot;&gt;&lt;/i&gt; &lt;% post.tags.each((tag)=&gt;{ %&gt; &lt;a href=&quot;&lt;%- url_for(tag.path) %&gt;&quot; class=&quot;set-color&quot;&gt;&lt;%= tag.name %&gt;&lt;em&gt;·&lt;/em&gt;&lt;/a&gt; &lt;% }) %&gt; &lt;/span&gt; &lt;style&gt; .set-color:hover{color: #3ca0ff;} &lt;/style&gt; &lt;/div&gt; 其中&lt;style&gt;里面规定了链接颜色，我用的自己的主题色，需要自行修改（默认为orange）。 在\\themes\\sakura\\source\\css\\style.css中，添加： .category-meta,.category-meta a { color:#888; font-size:13px } .category-meta em { margin: 0 5px; color: #666; } 大清洗为了追求简洁，去掉了不少东西。 网易云播放器目前我并不想把音乐放到$blog$上，留着影响加载速度。 在\\themes\\sakura\\layout\\layout.ejs里注释掉下面这两行： &lt;%- partial(&#39;_partial/mheader&#39;, null, {cache: !config.relative_link}) %&gt; &lt;%- partial(&#39;_partial/aplayer&#39;, null, {cache: !config.relative_link}) %&gt; 这样就可以了。如果想再精简的话可以在\\themes\\sakura\\source\\css\\style.css里注释掉有关aplayer的部分。 主页的视频功能主页右下角有一个播放键，可以放上视频播放的。 显然我用不着。。。 在\\themes\\sakura\\layout\\_partial\\headertop.ejs中只注释掉下面这两行： &lt;div id=&quot;video-btn&quot; class=&quot;loadvideo videolive&quot;&gt; &lt;/div&gt; 不知道为啥注释掉其他有关video的部分会出现一些神奇的$bug$ 打赏和转载在\\themes\\sakura\\layout\\_widget\\common-articles.ejs中注释掉以下部分： &lt;div class=&quot;single-reward&quot;&gt; &lt;div class=&quot;reward-open&quot;&gt;赏&lt;div class=&quot;reward-main&quot;&gt; &lt;ul class=&quot;reward-row&quot;&gt; &lt;li class=&quot;alipay-code&quot;&gt;&lt;img src=&quot;&lt;%- (theme.cdn || &#39;&#39;) + theme.donate.alipay%&gt;&quot;&gt;&lt;/li&gt; &lt;li class=&quot;wechat-code&quot;&gt;&lt;img src=&quot;&lt;%- (theme.cdn || &#39;&#39;) + theme.donate.wechat%&gt;&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;text-align:center; width: 100%&quot; class=&quot;social-share share-mobile&quot; data-disabled=&quot;diandian, tencent&quot;&gt;&lt;/div&gt; &lt;footer class=&quot;post-footer&quot;&gt; &lt;div class=&quot;post-lincenses&quot;&gt;&lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;&lt;i class=&quot;fa fa-creative-commons&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; 知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议&lt;/a&gt;&lt;/div&gt; &lt;div class=&quot;post-tags&quot;&gt; &lt;/div&gt; &lt;div class=&quot;post-share&quot;&gt; &lt;div class=&quot;social-share sharehidden share-component&quot;&gt;&lt;/div&gt; &lt;i class=&quot;iconfont show-share icon-forward&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;/footer&gt;&lt;!-- .entry-footer --&gt; 复制附加版权信息复制的时候会额外加上一段“著作权归作者所有。。。”，很不方便。 在\\themes\\sakura\\source\\js\\sakura-app.js中找到： var htmlData = &#39;&#39; + &#39;著作权归作者所有。&lt;br&gt;&#39; + &#39;商业转载请联系作者获得授权，非商业转载请注明出处。&lt;br&gt;&#39; + &#39;作者：&#39; + mashiro_option.author_name + &#39;&lt;br&gt;&#39; + &#39;链接：&#39; + window.location.href + &#39;&lt;br&gt;&#39; + &#39;来源：&#39; + mashiro_option.site_name + &#39;&lt;br&gt;&lt;br&gt;&#39; + window.getSelection().toString().replace(/\\r\\n/g, &#39;&lt;br&gt;&#39;) var textData = &#39;&#39; + &#39;著作权归作者所有。\\n&#39; + &#39;商业转载请联系作者获得授权，非商业转载请注明出处。\\n&#39; + &#39;&#39; + mashiro_option.author_name + &#39;\\n&#39; + &#39;链接：&#39; + window.location.href + &#39;\\n&#39; + &#39;来源：&#39; + mashiro_option.site_name + &#39;\\n\\n&#39; + window.getSelection().toString().replace(/\\r\\n/g, &#39;\\n&#39;) 改为： var htmlData = window.getSelection() var textData = window.getSelection() 如果要去掉复制成功的信息的话删去： addComment.createButterbar(&#39;复制成功！&lt;br&gt;Copied to clipboard successfully!&#39;, 1000) 页面底部版权信息和转发功能在\\themes\\sakura\\layout\\_partial\\footer.ejs中，注释掉： &lt;p style=&quot;color: #666666;&quot;&gt;&amp;copy 2018&lt;/p&gt; 在\\themes\\sakura\\layout\\_widget\\common-page.ejs中，删除： &lt;footer class=&quot;post-footer&quot;&gt; &lt;div class=&quot;post-lincenses&quot;&gt;&lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;&lt;i class=&quot;fa fa-creative-commons&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; 知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议&lt;/a&gt;&lt;/div&gt; &lt;div class=&quot;post-tags&quot;&gt; &lt;/div&gt; &lt;div class=&quot;post-share&quot;&gt; &lt;div class=&quot;social-share sharehidden share-component&quot;&gt;&lt;/div&gt; &lt;i class=&quot;iconfont show-share icon-forward&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;/footer&gt;&lt;!-- .entry-footer --&gt; &lt;/article&gt; &lt;!-- #post-## --&gt; &lt;section class=&quot;author-profile&quot;&gt; &lt;div class=&quot;info&quot; itemprop=&quot;author&quot; itemscope=&quot;&quot; itemtype=&quot;http://schema.org/Person&quot;&gt; &lt;a href=&quot;/about/&quot; class=&quot;profile gravatar&quot;&gt;&lt;img src=&quot;&lt;%- (theme.cdn || &#39;&#39;) + theme.avatar%&gt;&quot; itemprop=&quot;image&quot; alt=&quot;&lt;%- theme.siteName %&gt;&quot; height=&quot;70&quot; width=&quot;70&quot;&gt;&lt;/a&gt; &lt;div class=&quot;meta&quot;&gt; &lt;span class=&quot;title&quot;&gt;Author&lt;/span&gt; &lt;h3 itemprop=&quot;name&quot;&gt; &lt;a href=&quot;&lt;%- theme.url%&gt;&quot; itemprop=&quot;url&quot; rel=&quot;author&quot;&gt;&lt;%- theme.siteName %&gt;&lt;/a&gt; &lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;hr&gt; &lt;p&gt;&lt;i class=&quot;iconfont icon-write&quot;&gt;&lt;/i&gt;&lt;%- theme.description%&gt;&lt;/p&gt; &lt;/section&gt; 代码框打开功能点击代码框的标题会全屏显示代码，感觉很影响阅读体验。 在\\themes\\sakura\\source\\js\\sakura-app.js中，注释掉： $(&#39;pre&#39;).on(&#39;click&#39;, function (e) { if (e.target !== this) return $(this).toggleClass(&#39;code-block-fullscreen&#39;) $(&#39;html&#39;).toggleClass(&#39;code-block-fullscreen-html-scroll&#39;) }) 外观美化个性化css$next$有一个custom.styl文件可以自己写$css$，于是给$sakura$搞了一个。 其实很简单，在\\themes\\sakura\\source下新建一个code.css的文件，在\\themes\\sakura\\layout\\layout.ejs中第二行&lt;body class=&quot;...&quot;&gt;下面添加： &lt;style type=&quot;text/css&quot;&gt; @import url(&quot;/code.css&quot;); &lt;/style&gt; 就可以在code.css里编辑$css$啦。比如改鼠标样式、字体都可以在里面搞。 主题工具就是左下角那个。 这玩意我研究了很长时间。也非常实用，在保留简洁性的前提下给访客高度的个性化能力。 添加在themes\\sakura\\layout\\layout.ejs中： &lt;div class=&quot;scrollbar&quot; id=&quot;bar&quot;&gt; &lt;/div&gt; 前面添加： &lt;%- partial(&#39;_partial/setdisplay&#39;) %&gt; &lt;%- partial(&#39;_partial/set&#39;, null, {cache: !config.relative_link}) %&gt; 原版是在&lt;%- partial(&#39;_partial/mheader&#39;, null, {cache: !config.relative_link}) %&gt;前添加的，但要这样字体切换会出$bug$。 在\\themes\\sakura\\layout\\_partial中新建set.ejs，内容： &lt;div class=&quot;changeSkin-gear no-select&quot;&gt; &lt;div class=&quot;keys&quot; id=&quot;setbtn&quot;&gt; &lt;span id=&quot;open-skinMenu&quot;&gt; SCHEME TOOL | 主题工具 &amp;nbsp; &lt;i class=&quot;iconfont icon-gear inline-block rotating&quot;&gt; &lt;/i&gt; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; 新建setdisplay.ejs，内容： &lt;div class=&quot;skin-menu no-select&quot; id=&quot;mainskin&quot; style=&quot;position: fixed&quot;&gt; &lt;div class=&quot;theme-controls row-container&quot;&gt; &lt;p style=&quot;text-align:center;font-family:&#39;Monaco&#39;;font-weight:bold;color:#444&quot;&gt;&lt;i style=&quot;color:grey&quot; class=&quot;fa fa-chevron-left&quot;&gt;&lt;/i&gt; background &lt;i style=&quot;color:grey&quot; class=&quot;fa fa-chevron-right&quot;&gt;&lt;/i&gt;&lt;/p&gt; &lt;ul class=&quot;menu-list&quot;&gt; &lt;li id=&quot;white-bg&quot;&gt; &lt;i class=&quot;fa fa-television&quot; aria-hidden=&quot;true&quot;&gt; &lt;/i&gt; &lt;/li&gt; &lt;li id=&quot;sakura-bg&quot;&gt; &lt;i class=&quot;iconfont icon-sakura&quot;&gt; &lt;/i&gt; &lt;/li&gt; &lt;li id=&quot;gribs-bg&quot;&gt; &lt;i class=&quot;fa fa-slack&quot; aria-hidden=&quot;true&quot;&gt; &lt;/i&gt; &lt;/li&gt; &lt;li id=&quot;KAdots-bg&quot;&gt; &lt;i class=&quot;iconfont icon-dots&quot;&gt; &lt;/i&gt; &lt;/li&gt; &lt;li id=&quot;totem-bg&quot;&gt; &lt;i class=&quot;fa fa-optin-monster&quot; aria-hidden=&quot;true&quot;&gt; &lt;/i&gt; &lt;/li&gt; &lt;li id=&quot;pixiv-bg&quot;&gt; &lt;i class=&quot;iconfont icon-pixiv&quot;&gt; &lt;/i&gt; &lt;/li&gt; &lt;li id=&quot;bing-bg&quot;&gt; &lt;i class=&quot;iconfont icon-bing&quot;&gt; &lt;/i&gt; &lt;/li&gt; &lt;li id=&quot;dark-bg&quot;&gt; &lt;i class=&quot;fa fa-moon-o&quot; aria-hidden=&quot;true&quot;&gt; &lt;/i&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;canvas id=&quot;night-mode-cover&quot;&gt; &lt;/canvas&gt; &lt;/div&gt; 还要修点$bug$： 在\\themes\\sakura\\source\\js\\sakura-app.js中，找到函数$(&#39;.skin-menu #dark-bg&#39;).click(function ()，函数最底下添加： setCookie(&#39;bgImgSetting&#39;,&#39;https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/starry_sky.png&#39;,30) 把所有形如： $(&#39;.changeSkin-gear, .toc&#39;).css(&#39;background&#39;, &#39;none&#39;) 或 $(&#39;.changeSkin-gear, .toc&#39;).css(&#39;background&#39;, &#39;rgba(255,255,255,0.8)&#39;) 里的.changeSkin-gear,删掉。 这只是初始版，后面还有更高级的。 更换图片$bing$主题是从$bing$随机图片api获取一张图片做背景，可以更换。 在\\themes\\sakura\\source\\js\\sakura-app.js中，下面两句： changeBGnoTrans(&#39;#bing-bg&#39;, &#39;https://api.shino.cc/bing/&#39;) else if (bgurl == &#39;https://api.shino.cc/bing/&#39;) 其中的网址换成其他url。 随机图片url可以点这里哦 其他主题类似，找到url位置修改。 位置和外观在set.ejs里直接用css美化，可能还要修正setdisplay.ejs。 参考配置： set.ejs： &lt;div class=&quot;changeSkin-gear no-select&quot; style=&quot;background: rgba(0, 0, 0, 0) none repeat scroll 0% 0%; visibility: visible; bottom: 0px;&quot;&gt; &lt;div class=&quot;keys&quot; id=&quot;setbtn&quot;&gt; &lt;button id=&quot;open-skinMenu&quot;&gt; &lt;style&gt; button#open-skinMenu{ transition: all 0.2s linear 0s; outline:none; position:fixed; bottom:13px; left:15px; font-size:16px; background-color: rgba(255,255,255,.95); border-radius: 20px; box-shadow: 0 3px 8px 0 rgba(0,0,0,0.1), 0 3px 8px 0 rgba(0,0,0,0.1); } button#open-skinMenu:hover{ transition: all 0.2s linear 0s; background-color: rgb(255, 165, 0); color: rgba(255,255,255); } &lt;/style&gt; &lt;i class=&quot;iconfont icon-gear inline-block rotating&quot;&gt; &lt;/i&gt; SCHEME TOOL | 主题工具 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; 其中： position:fixed; bottom:13px; left:15px; 用于把位置移到左边去，不需要可以删掉；如果需要，还要更改setdisplay.ejs（第一行）： &lt;div class=&quot;skin-menu no-select&quot; id=&quot;mainskin&quot; style=&quot;position: fixed;bottom:65px;left:31px;&quot;&gt; 字体切换wordpress上有字体切换功能。 翻了翻sakura-app.js，发现字体切换功能函数已经写好了，直接用就行。 setdisplay.ejs中，在&lt;canvas id=&quot;night-mode-cover&quot;&gt;前添加： &lt;hr&gt; &lt;p style=&quot;text-align:center;font-family:&#39;Monaco&#39;;font-weight:bold;color:#444&quot;&gt;&lt;i style=&quot;color:grey&quot; class=&quot;fa fa-chevron-left&quot;&gt;&lt;/i&gt; font &lt;i style=&quot;color:grey&quot; class=&quot;fa fa-chevron-right&quot;&gt;&lt;/i&gt;&lt;/p&gt; &lt;div class=&quot;font-family-controls row-container&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;control-btn-serif &quot; data-mode=&quot;serif&quot; onclick=&quot;mashiro_global.font_control.change_font()&quot;&gt;Serif&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;control-btn-sans-serif&quot; data-mode=&quot;sans-serif&quot; onclick=&quot;mashiro_global.font_control.change_font()&quot;&gt;Sans Serif&lt;/button&gt; &lt;/div&gt; 在sakura-app.js中，找到： this.ini = function () { if (document.body.clientWidth &gt; 860) { if (!getCookie(&#39;font_family&#39;) || getCookie(&#39;font_family&#39;) == &#39;serif&#39;) { $(&#39;body&#39;).addClass(&#39;serif&#39;) } } if (getCookie(&#39;font_family&#39;) == &#39;sans-serif&#39;) { $(&#39;body&#39;).removeClass(&#39;sans-serif&#39;) $(&#39;.control-btn-serif&#39;).removeClass(&#39;selected&#39;) $(&#39;.control-btn-sans-serif&#39;).addClass(&#39;selected&#39;) } } 改为： this.ini = function () { var font = getCookie(&#39;font_family&#39;) if (document.body.clientWidth &gt; 860) { if (! font || font == &#39;serif&#39;) { $(&#39;body&#39;).addClass(&#39;serif&#39;) $(&#39;.control-btn-serif&#39;).addClass(&#39;selected&#39;) } } if (font == &#39;sans-serif&#39;) { $(&#39;body&#39;).addClass(&#39;sans-serif&#39;).removeClass(&#39;serif&#39;) $(&#39;.control-btn-sans-serif&#39;).addClass(&#39;selected&#39;) } } 在\\themes\\sakura\\source\\css\\style.css中，找到.font-family-controls button {，下面添加： outline: none; 找到： .serif { font-family:&#39;Source Han Serif SC&#39;,&#39;Source Han Serif&#39;,&#39;source-han-serif-sc&#39;,&#39;PT Serif&#39;,&#39;SongTi SC&#39;,&#39;MicroSoft Yahei&#39;,Georgia,serif } 改为： .serif { font-family:&#39;Noto Serif SC&#39;, &#39;Source Han Serif SC&#39;, &#39;Source Han Serif&#39;, source-han-serif-sc, &#39;PT Serif&#39;, &#39;SongTi SC&#39;, &#39;MicroSoft Yahei&#39;, Georgia, serif } 换字体后主页的startdash可能会被挤变形，需要在style.css中找到： .top-feature-row { width:100%; height:auto; margin-top:55px } 把width改大点就行。 加特技本人的创新，添加背景特效及开关。 樱花雨特效来自yremp.live。彩带特效来自主题butterfly。 （顺便吐槽一下彩带特效：彩带只会在较靠上的区域生成。当文章较长时，翻到下面彩带就出不来了。咱也看不懂js源码也不会改） setdisplay.ejs中，在&lt;canvas id=&quot;night-mode-cover&quot;&gt;前添加： &lt;hr&gt; &lt;p style=&quot;text-align:center;font-family:&#39;Monaco&#39;;font-weight:bold;color:#444&quot;&gt;&lt;i style=&quot;color:grey&quot; class=&quot;fa fa-chevron-left&quot;&gt;&lt;/i&gt; script &lt;i style=&quot;color:grey&quot; class=&quot;fa fa-chevron-right&quot;&gt;&lt;/i&gt;&lt;/p&gt; &lt;div class=&quot;theme-controls row-container&quot;&gt; &lt;ul class=&quot;menu-list&quot;&gt; &lt;li id=&quot;empty-effect&quot;&gt; &lt;i class=&quot;fa fa-ban&quot;&gt; &lt;/i&gt; &lt;/li&gt; &lt;li id=&quot;sakura-rain-effect&quot;&gt; &lt;i class=&quot;iconfont icon-sakura&quot;&gt; &lt;/i&gt; &lt;/li&gt; &lt;li id=&quot;snowy-effect&quot;&gt; &lt;i class=&quot;fa fa-snowflake-o&quot;&gt; &lt;/i&gt; &lt;/li&gt; &lt;li id=&quot;lines-effect&quot;&gt; &lt;i class=&quot;fa fa-chevron-left&quot;&gt; &lt;/i&gt; &lt;/li&gt; &lt;li id=&quot;colorful-belts-effect&quot;&gt; &lt;i class=&quot;fa fa-map&quot;&gt;&lt;/i&gt; &lt;/i&gt; &lt;/li&gt; &lt;li id=&quot;words-rain-effect&quot;&gt; &lt;i class=&quot;fa fa-font&quot;&gt;&lt;/i&gt; &lt;/li&gt; &lt;li id=&quot;point-rain-effect&quot;&gt; &lt;i class=&quot;iconfont icon-dots&quot;&gt;&lt;/i&gt; &lt;/li&gt; &lt;li id=&quot;rain-drop-effect&quot;&gt; &lt;i class=&quot;fa fa-tint&quot;&gt;&lt;/i&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 在\\themes\\sakura\\source\\js\\sakura-app.js中，找到： function closeSkinMenu () { 前面添加： $(&#39;.skin-menu #empty-effect&#39;).click(function(){ sakuraEffectClear() snowEffectClear() lineEffectClear() beltEffectClear() wordEffectClear() pointEffectClear() rainEffectClear() closeSkinMenu() }) $(&#39;.skin-menu #sakura-rain-effect&#39;).click(function(){ var effect = sakuraEffectClear() if(!effect) { effect = document.createElement(&quot;script&quot;) effect.setAttribute(&quot;src&quot;,&quot;https://cdn.jsdelivr.net/gh/yremp/yremp-js@1.5/sakura.js&quot;) effect.setAttribute(&quot;id&quot;,&quot;sakura-effect&quot;) document.getElementsByTagName(&quot;body&quot;).item(0).appendChild(effect) setCookie(&#39;sakuraEffectCookie&#39;,&#39;use&#39;,30) } closeSkinMenu() }) $(&#39;.skin-menu #snowy-effect&#39;).click(function(){ var effect = snowEffectClear() if(!effect){ effect = document.createElement(&quot;script&quot;) effect.setAttribute(&quot;src&quot;,&quot;https://cdn.jsdelivr.net/gh/ctz45562/cdn@1.3.3/js/snow.js&quot;) effect.setAttribute(&quot;id&quot;,&quot;snow-effect&quot;) document.getElementsByTagName(&quot;body&quot;).item(0).appendChild(effect) setCookie(&#39;snowyEffectCookie&#39;,&#39;use&#39;,30) } closeSkinMenu() }) $(&#39;.skin-menu #lines-effect&#39;).click(function(){ var effect = lineEffectClear() if(!effect){ effect = document.createElement(&quot;script&quot;) effect.setAttribute(&quot;src&quot;,&quot;https://cdn.jsdelivr.net/gh/ctz45562/cdn@1.3.3/js/line.js&quot;) effect.setAttribute(&quot;id&quot;,&quot;line-effect&quot;) document.getElementsByTagName(&quot;body&quot;).item(0).appendChild(effect) setCookie(&#39;linesEffectCookie&#39;,&#39;use&#39;,30) } closeSkinMenu() }) $(&#39;.skin-menu #colorful-belts-effect&#39;).click(function(){ var effect = beltEffectClear() if(!effect){ effect = document.createElement(&quot;script&quot;) effect.setAttribute(&quot;src&quot;,&quot;https://cdn.jsdelivr.net/gh/ctz45562/cdn@1.4.0/js/piao.js&quot;) effect.setAttribute(&quot;id&quot;,&quot;belt-effect&quot;) document.getElementsByTagName(&quot;body&quot;).item(0).appendChild(effect) setCookie(&#39;beltsEffectCookie&#39;,&#39;use&#39;,30) } closeSkinMenu() }) $(&#39;.skin-menu #words-rain-effect&#39;).click(function(){ var effect = wordEffectClear() if(!effect){ effect = document.createElement(&quot;script&quot;) effect.setAttribute(&quot;src&quot;,&quot;https://cdn.jsdelivr.net/gh/ctz45562/cdn@1.4.0/js/coderain.js&quot;) effect.setAttribute(&quot;id&quot;,&quot;words-effect&quot;) document.getElementsByTagName(&quot;body&quot;).item(0).appendChild(effect) setCookie(&#39;wordsEffectCookie&#39;,&#39;use&#39;,30) } closeSkinMenu() }) $(&#39;.skin-menu #point-rain-effect&#39;).click(function(){ var effect = pointEffectClear() if(!effect){ effect = document.createElement(&quot;script&quot;) effect.setAttribute(&quot;src&quot;,&quot;https://cdn.jsdelivr.net/gh/ctz45562/cdn@1.4.3/js/pointrain.js&quot;) effect.setAttribute(&quot;id&quot;,&quot;point-effect&quot;) document.getElementsByTagName(&quot;body&quot;).item(0).appendChild(effect) setCookie(&#39;pointEffectCookie&#39;,&#39;use&#39;,30) } closeSkinMenu() }) $(&#39;.skin-menu #rain-drop-effect&#39;).click(function(){ var effect = rainEffectClear() if(!effect){ effect = document.createElement(&quot;script&quot;) effect.setAttribute(&quot;src&quot;,&quot;https://cdn.jsdelivr.net/gh/ctz45562/cdn@1.4.5/js/raindrop.js&quot;) effect.setAttribute(&quot;id&quot;,&quot;raindrop-effect&quot;) document.getElementsByTagName(&quot;body&quot;).item(0).appendChild(effect) setCookie(&#39;rainEffectCookie&#39;,&#39;use&#39;,30) } closeSkinMenu() }) function sakuraEffectClear(){ var effect = document.getElementById(&quot;sakura-effect&quot;) if(effect){ effect.parentNode.removeChild(effect) effect = document.getElementById(&quot;canvas_sakura&quot;) effect.parentNode.removeChild(effect) setCookie(&#39;sakuraEffectCookie&#39;,&#39;&#39;,30) } return effect; } function snowEffectClear(){ var effect = document.getElementById(&quot;snow-effect&quot;) if(effect){ effect.parentNode.removeChild(effect) clearInterval(CIYANG) var snow = document.getElementById(&quot;snowbox&quot;) while(snow){ snow.parentNode.removeChild(snow) snow = document.getElementById(&quot;snowbox&quot;) } setCookie(&#39;snowyEffectCookie&#39;,&#39;&#39;,30) } return effect } function lineEffectClear(){ var effect = document.getElementById(&quot;line-effect&quot;) if(effect){ effect.parentNode.removeChild(effect) var lines = document.getElementById(&quot;lines&quot;) lines.parentNode.removeChild(lines) setCookie(&#39;linesEffectCookie&#39;,&#39;&#39;,30) } return effect } function beltEffectClear(){ var effect = document.getElementById(&quot;belt-effect&quot;) if(effect){ effect.parentNode.removeChild(effect) effect = document.getElementById(&quot;belts1&quot;) effect.parentNode.removeChild(effect) setCookie(&#39;beltsEffectCookie&#39;,&#39;&#39;,30) } return effect } function wordEffectClear(){ var effect = document.getElementById(&quot;words-effect&quot;) if(effect){ effect.parentNode.removeChild(effect) effect = document.getElementById(&quot;coderain&quot;) effect.parentNode.removeChild(effect) setCookie(&#39;wordsEffectCookie&#39;,&#39;&#39;,30) } return effect } function pointEffectClear(){ var effect = document.getElementById(&quot;point-effect&quot;) if(effect){ effect.parentNode.removeChild(effect) effect = document.getElementById(&quot;point&quot;) effect.parentNode.removeChild(effect) setCookie(&#39;pointEffectCookie&#39;,&#39;&#39;,30) } return effect } function rainEffectClear(){ var effect = document.getElementById(&quot;raindrop-effect&quot;) if(effect){ effect.parentNode.removeChild(effect) document.body.removeChild(document.getElementById(&#39;rain&#39;)) setCookie(&#39;rainEffectCookie&#39;,&#39;&#39;,30) } return effect } 找到： if (document.body.clientWidth &gt; 860) { checkBgImgCookie() } 改为： function checkEffectsCookie() { var efurl = getCookie(&#39;sakuraEffectCookie&#39;) if(efurl) { var effect = document.createElement(&quot;script&quot;) effect.setAttribute(&quot;src&quot;,&quot;https://cdn.jsdelivr.net/gh/yremp/yremp-js@1.5/sakura.js&quot;) effect.setAttribute(&quot;id&quot;,&quot;sakura-effect&quot;) document.getElementsByTagName(&quot;body&quot;).item(0).appendChild(effect) } efurl = getCookie(&#39;snowyEffectCookie&#39;) if(efurl) { var effect = document.createElement(&quot;script&quot;) effect.setAttribute(&quot;src&quot;,&quot;https://cdn.jsdelivr.net/gh/ctz45562/cdn@1.3.3/js/snow.js&quot;) effect.setAttribute(&quot;id&quot;,&quot;snow-effect&quot;) document.getElementsByTagName(&quot;body&quot;).item(0).appendChild(effect) } efurl = getCookie(&#39;linesEffectCookie&#39;) if(efurl) { var effect = document.createElement(&quot;script&quot;) effect.setAttribute(&quot;src&quot;,&quot;https://cdn.jsdelivr.net/gh/ctz45562/cdn@1.3.3/js/line.js&quot;) effect.setAttribute(&quot;id&quot;,&quot;line-effect&quot;) document.getElementsByTagName(&quot;body&quot;).item(0).appendChild(effect) } efurl = getCookie(&#39;beltsEffectCookie&#39;) if(efurl){ var effect = document.createElement(&quot;script&quot;) effect.setAttribute(&quot;src&quot;,&quot;https://cdn.jsdelivr.net/gh/ctz45562/cdn@1.4.0/js/piao.js&quot;) effect.setAttribute(&quot;id&quot;,&quot;belt-effect&quot;) document.getElementsByTagName(&quot;body&quot;).item(0).appendChild(effect) } efurl = getCookie(&#39;wordsEffectCookie&#39;) if(efurl){ var effect = document.createElement(&quot;script&quot;) effect.setAttribute(&quot;src&quot;,&quot;https://cdn.jsdelivr.net/gh/ctz45562/cdn@1.4.0/js/coderain.js&quot;) effect.setAttribute(&quot;id&quot;,&quot;words-effect&quot;) document.getElementsByTagName(&quot;body&quot;).item(0).appendChild(effect) } efurl = getCookie(&#39;pointEffectCookie&#39;) if(efurl){ var effect = document.createElement(&quot;script&quot;) effect.setAttribute(&quot;src&quot;,&quot;https://cdn.jsdelivr.net/gh/ctz45562/cdn@1.4.3/js/pointrain.js&quot;) effect.setAttribute(&quot;id&quot;,&quot;point-effect&quot;) document.getElementsByTagName(&quot;body&quot;).item(0).appendChild(effect) } efurl = getCookie(&#39;rainEffectCookie&#39;) if(efurl){ var effect = document.createElement(&quot;script&quot;) effect.setAttribute(&quot;src&quot;,&quot;https://cdn.jsdelivr.net/gh/ctz45562/cdn@1.4.5/js/raindrop.js&quot;) effect.setAttribute(&quot;id&quot;,&quot;raindrop-effect&quot;) document.getElementsByTagName(&quot;body&quot;).item(0).appendChild(effect) } } if (document.body.clientWidth &gt; 860) { checkBgImgCookie() checkEffectsCookie() } 注：我使用了iconfont图标，若按上文教程食用与我博客上的会不一样，需要的请自行更改。 拓展在原始主题中，文章顶端的图片很扁（比例大概是$4:1$？），个人觉得不美观，就改成其他主题的排版（比例$2:1$）： 说实话自己也没弄明白怎么搞的，可能会出$BUG$，怕误人子弟就不写了。 有兴趣的可以找我私聊。 更换时间和阅读数的图标就是文章顶部的日历和眼睛图标。 在\\themes\\sakura\\layout\\_widget\\common-article.ejs中： ·&lt;/span&gt; &lt;%= date(post.date, &#39;YYYY-M-D&#39;) %&gt;&lt;span class=&quot;bull&quot;&gt; &lt;/span&gt;前的·换成&lt;i class=&quot;fa fa-calendar&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; ·&lt;/span&gt; &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次阅读&lt;/p&gt; &lt;/span&gt;前的·换成&lt;i class=&quot;fa fa-eye&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; 首页文章描述左对齐$update$：现在已经加上了&lt;!--more--&gt;支持，其中所有的文字为显示正常均调成左对齐。 吐槽：sakura是不支持&lt;!--more--&gt;阅读全文的，只能用文章的description元素设置。这样就不支持markdown和$\\LaTeX$了。。。 首页中，图片靠左的文章描述（description）是右对齐的，看着很别扭。 在\\themes\\sakura\\layout\\_widget\\index-items.ejs中，找到： &lt;p&gt;&lt;%= post.description %&gt;&lt;/p&gt; 修改为： &lt;p style=&quot;text-align:left&quot;&gt;&lt;%= post.description %&gt;&lt;/p&gt; 分割线为啥原版的&lt;hr&gt;都是三个点啊。。。 感谢Tian-Xing找到了&lt;hr&gt;样式的地方。 本以为是通过很深层的html改的，没想到是css。。。 在\\themes\\sakura\\source\\css\\style.css删除： hr { box-sizing:content-box; height:0 } hr { background-color:#ccc; border:0; height:1px; margin-bottom:1.5em } .entry-content hr:before里的： content:&#39;...&#39;; 最底下添加： hr { height: 3px !important; border: none !important; background-color: #bfbfbf !important; background-image: repeating-linear-gradient(-45deg, #fff, #fff 4px, transparent 4px, transparent 8px) !important; } （搬的next的样式） 这还没完，因为除归档外所有列出文章的地方都用&lt;hr&gt;分割了，css同样会起作用。 那就把&lt;hr&gt;改成&lt;br&gt;呗： 在\\themes\\sakura\\layout\\_widget\\category-items.ejs中，将倒数第二行的&lt;hr&gt;改为&lt;br&gt;。 还有NEXT POST和PREVIOUS POST按钮也要改。直接删除\\themes\\sakura\\layout\\_widget\\common-article.ejs中，&lt;%= post.prev.title%&gt;&lt;/h3&gt;和&lt;%= post.next.title%&gt;&lt;/h3&gt;下面的&lt;hr&gt;。 代码行高亮wordpress上的$sakura$里，鼠标放到代码上，对应行会高亮。 $F12$查看元素属性就会发现只是一个简单的css实现。 在\\themes\\sakura\\source\\css\\style.css（如果您配置了个性化css的话也可以在code.css里）中添加： .hljs-ln-line:hover { background-color: rgba(255, 255, 255, .1); } .hljs-ln-line.hljs-ln-n:hover{ background-color: rgba(0,0,0,0) !important; } 如果没有下面那条，鼠标放在行号上行号会高亮。。。 表情来自https://www.tomori.xyz/2019/06/15/emojis-plug-in-unit-for-bilibili/ 博客源文件夹下安装： npm i hexo-tag-emojis-bycoda --save 这个版本有点低，到github下载压缩包，将里面的文件覆盖掉\\node_modules\\hexo-tag-emojis-bycoda的内容。 在\\themes\\sakura\\layout\\_partial\\head.ejs中，&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/zoom.css&quot; media=&quot;all&quot;&gt;下添加： &lt;style&gt; .emoji-coda { display: inline-block !important; position: relative; width: 45px; top: 2px; margin: -3px 3px !important; padding: 0; } &lt;/style&gt; 修改width一栏可以调整表情大小。 使用方式： 在\\node_modules\\hexo-tag-emojis-bycoda\\emojis找到想用的表情，格式： {% emoji_coda 文件夹/表情名%} 示例： 表情示例（喝水）{% emoji_coda 2233/heshui %} 表情示例（喝水） 虽然可以直接引用图片实现，但这样表情可以和文字位于一行，而且大小已经预设好了，使用方便。 更改主题颜色心血来潮把颜色翻新了一遍。 整体$sakura$颜色以橙色为主，将所有文件（应该只有style.css、sakura-app.js、head.ejs）里orange和#FE9600替换为想要的颜色。 最好是了解十六进制颜色码或rgb/rgba来选择颜色。 主题工具和归档页面的按钮颜色要手动改。 链接在\\themes\\sakura\\source\\css\\style.css里找到.entry-content a修改color。 若要修改鼠标放上去的颜色，修改下面的.entry-content a:hover的color即可。 代码块在style.css里找到.entry-content code修改color和background。 搜索框修改鼠标放到搜索结果上时背景的颜色。 在\\themes\\sakura\\source\\css\\insight.styl中，修改第六行的ins-background-orange。 文章信息文字阴影加深我写文章都会配二次元图，有很多浅色图片，导致文章的标题、时间、阅读量等信息与背景融为一体： 于是加深了一下阴影。在\\themes\\sakura\\layout\\_widget\\common-article.ejs中，修改： - &lt;header class=&quot;pattern-header single-header&quot;&gt; + &lt;header class=&quot;pattern-header single-header&quot; style=&quot;text-shadow: 0 0 7px #000,0 0 7px #000&quot;&gt; 效果还是很明显的： 修改文章配图height在\\themes\\sakura\\source\\css\\style.css中，找到： .pattern-attachment-img { background-repeat:no-repeat; background-size:cover; background-position:center center; background-origin:border-box; width :100%; height:400px } 你会找到两个。。。估计是作者的$BUG$，删掉其中一个，修改另一个的height即可。 文章列表图片拉伸问题の解决其实一直想修。。。 浏览某个分类或标签下的文章下时，配图是被压缩成正方形的： 度娘发现了一个神奇的css属性：object-fit。 在\\themes\\sakura\\source\\css\\style.css中，找到.feature img，内部添加： object-fit: cover; 引用样式修改对引用内容的样式进行了一定的修改。 修改内容包括： 引号大小缩小 增添浅灰色背景色 边框与引号的位置自适应文本 在\\themes\\sakura\\source\\css\\style.css中，把blockquote、blockquote:before、blockquote:after三项的内容替换为： blockquote { width:fit-content; width:-webkit-fit-content; width:-moz-fit-content; width:-ms-fit-content; width:-o-fit-content; margin:0; margin-bottom: 20px; padding:12px 45px; position:relative; border-radius: 1.5rem; background: rgba(225, 225, 225, .43); } blockquote:before { content:&quot;\\f10d&quot; !important; font-size:2rem; position:absolute; top:-25px; left:2px; color:#50bdff; font-family:FontAwesome } blockquote:after { content:&#39;\\f10e&#39; !important; font-size:2rem; position:absolute; bottom:-25px; right:0px; color:#50bdff; font-family:FontAwesome } 主要还是为了我自己看着顺眼。 主页startdash美（丑）化为了实用性舍弃美观性。 $sakura$主页的startdash一栏我都是用来当置顶文章的。但是通过观看了他人访问我的blog的过程和我亲自体验，发现这玩意太不明显了。 上面写着一个颜色很浅难以察觉的top，下面几张图片，怎么看都像是图片展览，除非把鼠标放上去才会发现是文章链接。 于是我直接把标题改到外面去了，同时对其样式进行了调整： 在\\themes\\sakura\\source\\css\\style.css中： 将.the-feature.from_left_and_right .info里的内容替换为： position:absolute; top:0; bottom:0; left:0; right:0; text-align:center; -webkit-backface-visibility:hidden; backface-visibility:hidden; background:transparent; -webkit-transition:all .35s ease-in-out; -moz-transition:all .35s ease-in-out; transition:all .35s ease-in-out 将.the-feature.from_left_and_right .info h3里的内容替换为： text-transform:uppercase; color:rgba(255, 255, 255); text-align:center; font-size:22px; letter-spacing:1px; text-shadow: 0 0 8px #000,0 0 8px #000; font-weight:bold; padding:10px; margin:30px 0 0 0; background:transparent; -webkit-transition:all .35s ease-in-out; -moz-transition:all .35s ease-in-out; transition:all .35s ease-in-out; -webkit-transform:translateY(50%); -moz-transform:translateY(50%); -ms-transform:translateY(50%); -o-transform:translateY(50%); transform:translateY(50%) 在下面添加： .the-feature.from_left_and_right .info:hover h3{ background:rgba(22, 22, 22, 0.85); letter-spacing: 0; text-shadow: none; font-size:17px; } 在.the-feature.from_left_and_right a:hover .info里添加： background: rgba(0,0,0,0.6); 通告栏美化和startdash一个问题，不够明显。 在上面添加了图标和Notice文字，稍稍加深了边框和文字颜色，微调位置。 在\\themes\\sakura\\source\\css\\style.css中，找到.notice，修改以下属性： padding:17px; border:1px dashed #cacacaed; color:#707070; margin:-10px 0 -25px 0; 在\\themes\\sakura\\layout\\index.ejs中，将： &lt;% if (theme.notice) { %&gt; &lt;div class=&quot;notice&quot; style=&quot;margin-top:60px&quot;&gt; &lt;i class=&quot;iconfont icon-notification&quot;&gt; &lt;/i&gt; &lt;div class=&quot;notice-content&quot;&gt;&lt;%= theme.notice%&gt;&lt;/div&gt; &lt;/div&gt; &lt;% } %&gt; 替换为： &lt;% if (theme.notice) { %&gt; &lt;h1 class=&quot;main-title&quot; style=&quot;font-family:&#39;Ubuntu&#39;,sans-serif;margin-top:60px&quot;&gt; &lt;i class=&quot;fa fa-commenting&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; Notice&lt;/h1&gt; &lt;div class=&quot;notice&quot;&gt; &lt;i class=&quot;iconfont icon-notification&quot;&gt;&lt;/i&gt; &lt;div class=&quot;notice-content&quot;&gt;&lt;%= theme.notice%&gt;&lt;/div&gt; &lt;/div&gt; &lt;% } %&gt; 菜单图标美化基础推荐先了解一下FontAwesome是什么。 在FontAwesome里找到想要的图标，点进去，复制fa-*一项。 在主题配置文件中，找到menu。 每一栏有path和fa（有的有子菜单submenus），而fa就是对图标样式的控制。把刚才的fa-*替换掉里面的fa-*。 支持iconfont索引：iconfont是什么？怎么添加 众所周知$sakura$主题配置文件的菜单图标只支持FontAwesome，由于种类太少需要添加iconfont支持。 其实就是很基础的html知识： 在\\themes\\sakura\\layout\\_partial\\header.ejs中修改： - &lt;i class=&quot;fa &lt;%= theme.menus[menu].fa %&gt;&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; + &lt;i class=&quot;&lt;%= theme.menus[menu].fa %&gt;&quot;&gt;&lt;/i&gt; - &lt;i class=&quot;fa &lt;%= theme.menus[menu].submenus[submenu].fa %&gt;&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; + &lt;i class=&quot;&lt;%= theme.menus[menu].submenus[submenu].fa %&gt;&quot;&gt;&lt;/i&gt; 要注意的是原来用FontAwesome的图标要加上fa。 动态图标鼠标放到菜单上的时候图标会有动画效果。实际上这是来自于这个仓库的特效。被放在了\\themes\\sakura\\source\\css\\lib.min.css。 食用方法： 首先在这里可以看到预览，找到需要的，把后面的faa-*粘到（原来有的话就替换）主题配置文件里menu-&gt;fa。 如果要改速度的话就再加上faa-fast/faa-slow。 这时你会发现iconfont并不支持动画。 解决方案非常简单，在\\thems\\sakura\\source\\css\\style.css中添加： .ctz{display: inline-block;} （把ctz替换成你的FontClass/Symbol前缀） 最后我强迫症，修一个小问题： 有的时候把鼠标放到菜单某一栏上，下面的条已经出来了，但是图标并没有动。 在\\themes\\sakura\\layout\\_partial\\header.ejs中，删除&lt;span class=&quot;faa-parent animated-hover&quot;&gt;和其对应的&lt;/span&gt;，在它上面的&lt;a href=&quot;&lt;%- url_for(theme.menus[menu].path) %&gt;&quot;&gt;内部添加class=&quot;faa-parent animated-hover&quot;。 板块化这是目前对$sakura$效果最大的一次改动，直接改变了主题风格。 本来$sakura$在白色背景下文本都是和背景融为一体的，这次将文本主题、目录和评论区都加上了板块并添加了阴影。其实我本来只是想优化valine外观来着 emm…具体过程没法语言描述，只能靠f12研究了。 可能用得到的核心css： .gather{ width:830px; margin:0 auto; margin-bottom: 25px; box-shadow: 0px 0px 30px rgba(0,0,0,0.6); background:rgba(255,255,255,0.8) !important; border-radius:15px; } #vcomments{ width:800px; padding:2.3% 1% 2% 1%; margin:0 auto; } $2020.10.2update$： 有人好像对这个板块化感兴趣，但是退役后很少打理博客了所以不知道。。。 板块化不算是个简单的改动，需要一定的html基础和魔改主题的经验，我也不好给出一个很标准的模板。大致的思路就是在文章和评论对应的div外再套一个div，我给的css中.gather就是修饰这个div的。还有一些细节比如图片和文章的合并和阴影问题，我现在已经忘得差不多了可以用f12对着我的网页改。希望这些能帮到你。 杂七杂八评论Valine输入框内容更改在\\themes\\sakura\\layout\\_partial\\comment.ejs中，修改placeholder一栏即可。 不过我在\\themes\\sakura\\source\\js\\sakura-app.js中也找到了$Valine$的设置，不放心也改了。 找到以下内容： VA: function () { if (!valine) { var valine = new Valine() valine.init({ el: &#39;#vcomments&#39;, appId: mashiro_option.v_appId, appKey: mashiro_option.v_appKey, path: window.location.pathname, placeholder: &#39;你是我一生只会遇见一次的惊喜 ...&#39; }) } }, 同样修改placeholder。 Valine外观美化评论框的背景：在\\themes\\sakura\\source\\css\\style.css中，修改#veditor中的background-image。 其他： /* 输入昵称、邮箱下方虚线的颜色 */ .vinput:focus{border-bottom-color: #3ca0ff !important;} /* 评论者的昵称颜色 */ .vnick:not(.vinput){color:#006eff!important;} /* 鼠标悬浮时，评论者的昵称颜色 */ .vnick:not(.vinput):hover{color:#04f!important;} /* 回复按钮的颜色*/ .vat{ color:#3ca0ff !important; margin-right:3px; border:1px solid #3ca0ff; border-radius:4px; padding:0 0.5% 0 0.5%; } /* 评论框的边框 */ .vwrap{ border:none !important; border-radius:12px !important; background:rgba(255, 255, 255, 0.3); box-shadow:0px 0px 18px #bbb; padding:14px; margin-top:10px; } Valine炸了最近$leancloud$爆炸了，导致$Valine$无法正常使用。然而我发现原来$next$评论是正常的，于是查阅了一下$next$的$Valine$配置，有了解决方案： 在\\themes\\sakura\\layout\\_partial\\footer.ejs中，把： &lt;script src=&#39;//unpkg.com/valine@1.3.4/dist/Valine.min.js&#39;&gt;&lt;/script&gt; 替换为： &lt;script src=&#39;//unpkg.com/valine/dist/Valine.min.js&#39;&gt;&lt;/script&gt; 我不用Valine啦！（雾）个人是很喜欢$Valine$的，不过现在$Valine$要实名认证很麻烦。 虽然最后我还是实名了，还是提供一个sakura安装gitalk的教程给弃了$Valine$的同志。 Valine超进化——Volantis！Volantis是基于Valine的升级版。 进化效果： 评论必须填写昵称和邮箱 可以自定义js（虽然valine也可以） 表情大翻新，甚至可以个性化表情 但是作者说即将关闭volantis的仓库，以后可能没有原版volantis的源码，所以这里直接提供我的js代码。 添加如果你想直接照搬我的： 在/themes/sakura/layout/_partial/footer.ejs中，找到关于Valine的引用，长这个样子： &lt;script src=&quot;...valine...&quot;&gt;&lt;/script&gt; 替换为： &lt;script src=&quot;https://cdn.jsdelivr.net/gh/ctz45562/cdn@2.1.4/js/volantis.min.js&quot;&gt;&lt;/script&gt; 如果你想DIY，下载 https://cdn.jsdelivr.net/gh/ctz45562/cdn@2.1.4/js/volantis.min.js 并引用。 在/themes/sakura/source/css/style.css中，添加： #v-qq{height:30px;} #v-tieba{height:35px;} #v-menhera:not(.v-avoid){max-width: 6.5%;} #v-chino:not(.v-avoid){max-width: 8%;} 表情强化需要js基础。 因为volantis.min.js已经经过混淆处理，需要先用一些工具美化回去。 在2300多行，e.exports后面，格式：表情名: 表情路径。 你可以看到里面已经通过上面的函数添加了一些表情，照葫芦画瓢可以添加，比如aru1: b(1),。 如果想要更多表情（我添加了menhera酱和智乃酱的），需要自己写函数或直接用路径添加。 VolantisのDIY会js的话直接改文件就好了。 比如我把昵称、邮箱、网站的框的内容修改了。 添加标签标签页在\\themes\\sakura\\layout\\_widget\\common-page.ejs中找到： &lt;% if (post.photos &amp;&amp; post.photos.length){ %&gt; &lt;div class=&quot;pattern-center &quot;&gt; &lt;div class=&quot;pattern-attachment-img&quot;&gt; &lt;img src=&quot;&lt;%- theme.lazyloadImg%&gt;&quot; data-src=&quot;&lt;%= post.photos %&gt;&quot; class=&quot;lazyload&quot; onerror=&quot;imgError(this,3)&quot; style=&quot;width: 100%; height: 100%; object-fit: cover; pointer-events: none;&quot;&gt; &lt;/div&gt; &lt;header class=&quot;pattern-header &quot;&gt; &lt;h1 class=&quot;entry-title&quot;&gt; &lt;%= post.keywords %&gt;&lt;/h1&gt; &lt;/header&gt; &lt;/div&gt; &lt;% } %&gt; 在下面添加： &lt;% if (page.path === &quot;tags/index.html&quot;){ %&gt; &lt;div class=&quot;site-content&quot;&gt; &lt;br&gt;&lt;br&gt; &lt;div class=&quot;tag-cloud-title&quot; style=&quot;text-align:center&quot;&gt; 目前共计 &lt;%=site.tags.length%&gt; 个标签 &lt;/div&gt; &lt;p&gt;&lt;/p&gt; &lt;div class=&quot;tags&quot; style=&quot;text-align:center&quot;&gt; &lt;%- tagcloud({ min_font: 14, max_font: 35, amount: 999, color: true, start_color: &#39;gray&#39;, end_color: &#39;black&#39;, }) %&gt; &lt;/div&gt; &lt;style&gt; .article-entry ul li:before{ display: none; } .article-inner { text-align: center; } .tags { max-width: 40em; margin: 2em auto; margin-top: 0em; } .tags a { margin-right: 1em; border-bottom: 1px solid gray; line-height: 65px; white-space: nowrap; } .tags a:hover { transition: all 0.15s linear 0s; border-bottom-color: #07f !important; color: #07f !important; } &lt;/style&gt; &lt;/div&gt; &lt;% } %&gt; 文章标签注：文章标签有多个版本，且除非有特殊说明，每个版本的添加方式都是独立的，请先阅读完或直接跳到最后一项再添加。 v1.0：landfarzの朴素文字$sakura$在文章界面是不显示标签的。 在\\themes\\sakura\\layout\\_widget\\common-article.ejs中可以找到 &lt;div class=&quot;post-tags&quot;&gt;&lt;/div&gt; 显然里面啥都没有。。。 如果去掉了页面底部版权信息，这句也被删掉了。没去掉的话就先删掉。 至于怎么添加，我直接十分暴力地魔改了landfarz的代码过来。 在common-article.ejs中找到以下代码： &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次阅读&lt;/p&gt; 下面添加： &lt;% if (post.tags &amp;&amp; post.tags.length){ %&gt; &lt;% var tags = []; post.tags.forEach(function(tag){tags.push(&#39;&lt;a href=&quot;&#39; + config.root + tag.path + &#39;&quot;&gt;&#39; + tag.name + &#39;&lt;/a&gt;&#39;);});%&gt; &lt;div class=&quot;tags&quot;&gt; &lt;style scoped&gt; a{color: #fff;} &lt;/style&gt; &amp;nbsp&lt;i class=&quot;fa fa-tag&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&amp;nbsp &lt;%- tags.join(&#39;&amp;nbsp &amp;nbsp&#39;) %&gt; &lt;/div&gt; &lt;% } %&gt; 就可以了。 这是添加到顶部，放到下面的话就加进&lt;footer&gt;元素里。若删掉了&lt;footer&gt;再加回去就好了。 v2.0：来自butterflyの支持看久了感觉只有文字的标签好$low$啊。。。 标签得有标签的亚子，怎么也得带个框啊。 尝试把SPFK的标签样式抄过来。。。 抄不动抄不动 于是把butterfly抄了过来： 在\\themes\\sakura\\source\\css\\style.css中，添加： .butterfly-tags{ display: inline-block; width: fit-content; margin: 0.4rem 0.4rem 0.4rem 0; padding: 0rem 0.5rem; border: 1px solid #3187ff; border-radius: 1rem; background: #fff; color: #3187ff; text-decoration: none; font-size: 14px; text-shadow: none; transition: all 0.1s linear; } .butterfly-tags:hover{ transition: all 0.1s linear; color: #fff; background: #3187ff; } 按v1.0添加html代码，其中第二行&gt;前添加class=&quot;butterfly-tags&quot;，删除倒数第三行的&amp;nbsp &amp;nbsp。 v3.0：强♂迫SPFK支持$butterfly$的样式我还是不满意，肝了一上午的尝试有了最终方案： 在common-article.ejs中找到以下代码： &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次阅读&lt;/p&gt; 下面添加： &lt;% if (post.tags &amp;&amp; post.tags.length){ %&gt; &lt;% var tags = []; post.tags.forEach(function(tag){tags.push(&#39;&lt;li class=&quot;spfk-li&quot;&gt;&lt;a href=&quot;&#39; + config.root + tag.path + &#39;&quot; class=&quot;butterfly-tags&quot;&gt;&#39; + tag.name + &#39;&lt;/a&gt;&lt;/li&gt;&#39;);});%&gt; &lt;div&gt; &lt;ul class=&quot;spfk-ul&quot;&gt; &amp;nbsp&lt;i class=&quot;fa fa-tag&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp &lt;%- tags.join(&#39;&#39;) %&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; function colorInit(c,num){for(var i=1;i&lt;=num;++i)c.push(i+&#39;&#39;);} function paintTags(){ var colorNumber=8,tagColors=[],tags=document.getElementsByClassName(&#39;butterfly-tags&#39;); for(var i = 0 ; i &lt; tags.length ; ++i){ if(!tagColors.length)colorInit(tagColors,colorNumber); var j=Math.floor(Math.random()*tagColors.length); tags[i].classList.add(&quot;spfk-color&quot;+tagColors[j]); tagColors.splice(j,1); } } paintTags() &lt;/script&gt; &lt;% } %&gt; 在\\themes\\sakura\\source\\css\\style.css中，（如果有的话）删除.butterfly-tags的样式，添加： .butterfly-tags{ display: inline-block; margin: 0.4rem 1rem 0.4rem 0; padding: 0rem 0.45rem; border: 1px solid transparent; border-radius: 1px 6px 6px 1px; color: #fff; text-decoration: none; font-size: 13px; text-shadow: none; position: relative; transition: all 0.1s linear; } .butterfly-tags:hover{ transition: all 0.1s linear; opacity: 0.85; color: inherit; } .butterfly-tags:focus{color: #fff;} .butterfly-tags:before{ content: &quot; &quot;; position: absolute; border: 11px solid transparent; left: -23px; top: -1px; } .butterfly-tags:after{ content: &quot; &quot;; width: 4px; height: 4px; background-color: #fff; border-radius: 4px; -webkit-box-shadow: 0px 0px 0px 1px rgba(0,0,0,0.3); box-shadow: 0px 0px 0px 1px rgba(0,0,0,0.3); position: absolute; left: -2px; top: 8px; } .spfk-ul{ float: left; padding: 0; margin: 0; } .spfk-li{display: inline-block;} .spfk-color1{ background: #39b3d7; border-color: #39b3d7; } .spfk-color1:before{border-right-color: #39b3d7;} .spfk-color2{ background: #4cae4c; border-color: #4cae4c; } .spfk-color2:before{border-right-color: #4cae4c;} .spfk-color3{ background: #f4a83c; border-color: #f4a83c; } .spfk-color3:before{border-right-color: #f4a83c;} .spfk-color4{ background: #ee6252; border-color: #ee6252; } .spfk-color4:before{border-right-color: #ee6252;} .spfk-color5{ background: #e23794; border-color: #e23794; } .spfk-color5:before{border-right-color: #e23794;} .spfk-color6{ background: #9537ff; border-color: #9537ff; } .spfk-color6:before{border-right-color: #9537ff;} .spfk-color7{ background: #0a5dff; border-color: #0a5dff; } .spfk-color7:before{border-right-color: #0a5dff;} .spfk-color8{ background: #cb3800; border-color: #cb3800; } .spfk-color8:before{border-right-color: #cb3800;} 可把我累坏了 同时发现了$SPFK$的$BUG$： $SPFK$的三角形标签样式是通过伪元素:before实现的，而其位置的控制是通过position:absolute及left和top属性，这样在缩放页面时，三角形会脱离标签。更要命的是，在和我机房电脑屏幕比例不一样的电脑上，不需要缩放三角形就会自动脱离标签。 v4.0：缩放BUG？不存在的！肝了半个上午和半个下午把缩放$BUG$解决了。 在common-article.ejs中&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次阅读&lt;/p&gt;下面添加： &lt;% if (post.tags &amp;&amp; post.tags.length){ %&gt; &lt;% var tags = []; post.tags.forEach(function(tag){tags.push(&#39;&lt;li class=&quot;spfk-li&quot;&gt;&lt;span class=&quot;triangle&quot;&gt;&lt;/span&gt;&lt;a href=&quot;&#39; + config.root + tag.path + &#39;&quot; class=&quot;butterfly-tags&quot;&gt;&#39; + tag.name + &#39;&lt;/a&gt;&lt;/li&gt;&#39;);});%&gt; &lt;div&gt; &lt;ul class=&quot;spfk-ul&quot;&gt; &amp;nbsp&lt;i class=&quot;fa fa-tag&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&amp;nbsp;&lt;%- tags.join(&#39;&#39;) %&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; function colorInit(c,num){for(var i=1;i&lt;=num;++i)c.push(i+&#39;&#39;);} function paintTags(){ var colorNumber=8,tagColors=[],tags=document.getElementsByClassName(&#39;spfk-li&#39;); for(var i = 0 ; i &lt; tags.length ; ++i){ if(!tagColors.length)colorInit(tagColors,colorNumber); var j=Math.floor(Math.random()*tagColors.length); tags[i].classList.add(&quot;spfk-color&quot;+tagColors[j]); tagColors.splice(j,1); } } paintTags() &lt;/script&gt; &lt;% } %&gt; 在style.css里，添加： .butterfly-tags{ display: inline-block; margin: 0.4rem 1rem 0.4rem 0; padding: 0rem 0.45rem; border: 1px solid transparent; border-radius: 1px 6px 6px 1px; color: #fff; text-decoration: none; font-size: 13px; text-shadow: none; position: relative; transition: all 0.1s linear; height:22px; } .spfk-li:hover{ transition: all 0.1s linear; opacity: 0.85; color: inherit; } .butterfly-tags:hover{color: inherit;} .butterfly-tags:focus{color: #fff;} .butterfly-tags:after{ content: &quot; &quot;; width: 4px; height: 4px; background-color: #fff; border-radius: 4px; -webkit-box-shadow: 0px 0px 0px 1px rgba(0,0,0,0.3); box-shadow: 0px 0px 0px 1px rgba(0,0,0,0.3); position: absolute; left: -2px; top: 8px; } .spfk-ul{ float: left; padding: 0; margin: 0; } .triangle{ border:11px solid transparent; display:inline-block; position:relative; top:6px; } .spfk-li{ display: inline-block; margin-right:-17px; margin-left:-2px; } .spfk-color1 a{ background: #39b3d7; border-color: #39b3d7; } .spfk-color1 span{border-right-color: #39b3d7;} .spfk-color2 a{ background: #4cae4c; border-color: #4cae4c; } .spfk-color2 span{border-right-color: #4cae4c;} .spfk-color3 a{ background: #f4a83c; border-color: #f4a83c; } .spfk-color3 span{border-right-color: #f4a83c;} .spfk-color4 a{ background: #ee6252; border-color: #ee6252; } .spfk-color4 span{border-right-color: #ee6252;} .spfk-color5 a{ background: #e23794; border-color: #e23794; } .spfk-color5 span{border-right-color: #e23794;} .spfk-color6 a{ background: #9537ff; border-color: #9537ff; } .spfk-color6 span{border-right-color: #9537ff;} .spfk-color7 a{ background: #0a5dff; border-color: #0a5dff; } .spfk-color7 span{border-right-color: #0a5dff;} .spfk-color8 a{ background: #cb3800; border-color: #cb3800; } .spfk-color8 span{border-right-color: #cb3800;} 这样三角形就不会脱离了。但是还是有一个小$BUG$：缩放时三角形的高度与方框不一致，导致轻微的上下错位。不过放大基本是看不出来的，至少得240%才会触发；而缩小虽然明显能观察到，但是$sakura$本身字体已经够小了，我想一般也很少有人会往小了缩吧。 归档页面优化「全部展开/收缩」按钮优化在\\themes\\sakura\\layout\\archive.ejs中，找到： &lt;p style=&quot;text-align:right;&quot;&gt; [&lt;span id=&quot;al_expand_collapse&quot; style=&quot;cursor: s-resize;&quot;&gt;全部展开/收缩&lt;/span&gt;]&lt;/p&gt; 修改为： &lt;p style=&quot;text-align:left;&quot;&gt; &lt;button id=&quot;al_expand_collapse&quot;&gt; &lt;style&gt; button#al_expand_collapse { color: white; border-radius: 16px; font-weight: bold; font-size: 15px; background-color: #ff9100; transition-duration: 0.3s; box-shadow: 0 3px 8px 0 rgba(0,0,0,0.11), 0 3px 8px 0 rgba(0,0,0,0.11); outline: none; } button#al_expand_collapse:hover { transition: all 0.2s linear 0s; background-color: #ff5900; } &lt;/style&gt; &lt;i class=&quot;fa fa-bars&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; 全部展开/收缩 &lt;/button&gt; &lt;/p&gt; 页首优化浏览各个主页面的时候总觉得怪怪的，发现原来是归档页面没有配图。 然而归档是一个特殊页面，没有md文件也没法配图。 于是暴力修改ejs文件，顺便使其样式与其它页面相同： 在\\themes\\sakura\\layout\\archive.ejs中，在第一行： &lt;div class=&quot;blank&quot; style=&quot;padding-top: 75px;&quot;&gt; &lt;/div&gt; 修改为 &lt;div class=&quot;pattern-center-blank&quot; style=&quot;padding-top: 75px;&quot;&gt; &lt;/div&gt; &lt;% if ( theme.archivesimg &amp;&amp; theme.archivesimg.length ){ %&gt; &lt;div class=&quot;pattern-center-sakura&quot;&gt; &lt;div class=&quot;pattern-attachment-img&quot;&gt; &lt;img src=&quot;&lt;%- theme.lazyloadImg%&gt;&quot; data-src=&quot;&lt;%= theme.archivesimg %&gt;&quot; class=&quot;lazyload&quot; onerror=&quot;imgError(this,3)&quot; style=&quot;width: 100%; height: 100%; object-fit: cover; pointer-events: none;&quot;&gt; &lt;/div&gt; &lt;header class=&quot;pattern-header &quot;&gt; &lt;h1 class=&quot;entry-title&quot;&gt; 归档&lt;/h1&gt; &lt;/header&gt; &lt;/div&gt; &lt;% } %&gt; 删除： &lt;header class=&quot;page-header&quot;&gt; &lt;h1 class=&quot;cat-title&quot;&gt; 归档&lt;/h1&gt; &lt;span class=&quot;cat-des&quot;&gt; &lt;p&gt; Archives&lt;/p&gt; &lt;/span&gt; &lt;/header&gt; 在主题配置文件中添加： archivesimg: 后面填上图片路径，注意加空格。 标题修改归档页面的标题一直叫archive_a，肥肠神奇。 在\\themes\\sakura\\languages\\zh-cn.yml开头添加： archive_a: 归档 我不用不蒜子啦！一直对不蒜子阅读量统计不满意，加载速度慢，经常卡住。 $Valine$同样有阅读量统计，而且$leancloud$的速度我是很信任的。 在\\themes\\sakura\\source\\js\\sakura-app.js中，找到函数valine.init，在appKey一行下面添加： + visitor: true, 在\\themes\\sakura\\layout\\_partial\\comment.ejs中进行同样的修改。 删除： - $.getScript(&#39;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&#39;); 在\\themes\\sakura\\layout\\_widget\\common-article.ejs中，替换（有两处）： - &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次阅读 + &lt;span id=&#39;/&lt;%= page.path %&gt;&#39; class=&quot;leancloud-visitors&quot; data-flag-title=&quot;&lt;%= page.title %&gt;&quot;&gt;&lt;a class=&quot;leancloud-visitors-count&quot;&gt;1000000&lt;/a&gt;&lt;a class=&quot;post-meta-item-text&quot;&gt; 次阅读&lt;/a&gt;&lt;/span&gt; 在\\themes\\sakura\\layout\\_partial\\footer.ejs中删除： - &lt;script src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 原来的阅读量丢失了？$Valine$阅读量统计以及评论有一个非常大的特点，就是随意更改。 到$leancloud$你创建的应用里，存储→Counter就是阅读量统计了。不过没啥好办法，只能一个一个改。 我不用Hexo啦！（雾）神秘の传送门 偶然间发现的，魔改博客园为$sakura$样式！而且还原度极高！ 试了试水，效果很惊艳。 当然我没有想法转到博客园上，链接挂在这给需要的同志，并膜拜+资瓷作者。 加个游戏 我们不生产游戏，我们只是代码的搬运工。 步骤都是一样的（name代指游戏名）： 1.在\\source中新建name.html，把链接里的内容粘进去。 注：我为了缩小html体积使用了html美化工具压缩，如果想魔改需要美化回去。 2.在站点配置文件中，skip_render一栏添加：name.html。如果有多项按如下格式添加： skip_render: - ... - ... - name.html 3.访问博客地址/name.html开始游戏（去掉.html后缀也行） 闲扯：本来是想直接挂一个下载链接的，但是不知道为啥我的blog的&lt;a&gt;标签无法用download属性转成下载链接，只好挂github链接。。。 2048来源： 直接从这位dalaoのblog里搬来的。 链接：2048 说明： 原博客采用的$K-ON$风格，我魔改成了点兔的，同时也对html结构进行了少量修改。 若想修改图片（需要一些html、css的基础知识）在引入的main.css中能找到，懂的自然懂~ flappy bird来源：https://github.com/sharpwind612/My-flappy-bird 链接：flappy bird 五子棋来源：http://kai.xlightgod.cf/ 链接：gobang 生火间来源：https://github.com/doublespeakgames/adarkroom 链接：a dark room 说明： 由于我剽的时候疏忽了，没有改js里的路径，恰好我的git无法push，更新不了html文件。生火间需要额外在\\themes\\sakura\\source\\css里新建dark.css，内容戳这儿。 水果忍者来源：https://blog.csdn.net/aaa333qwe/article/details/72879188 链接：fruit ninja 模糊字体从这个博客发现的。 就像这样： 戳这儿→ 被你发现了 在\\themes\\sakura\\source\\css\\style.css中，添加： span.spoiler:hover {text-shadow: grey 0px 0px 4px;} span.spoiler { color: rgba(0, 0, 0, 0); background-color: rgba(0, 0, 0, 0); text-shadow: grey 0px 0px 8px; cursor: pointer; -webkit-transition: text-shadow .5s ease; -moz-transition: text-shadow .5s ease; transition: text-shadow .5s ease; } span.spoiler.revealed {text-shadow: grey 0px 0px 0px;} 在\\themes\\sakura\\layout\\_widget\\common-article.js中，添加： &lt;script&gt; var spoiler=document.getElementsByClassName(&#39;spoiler&#39;); for(var i=0;i&lt;spoiler.length;++i) spoiler[i].onclick=function(){this.classList.toggle(&quot;revealed&quot;);}; &lt;/script&gt; 按如下格式食用： &lt;span class=&quot;spoiler&quot;&gt;文本&lt;/span&gt; 文章信息添加「分类于」在\\themes\\sakura\\layout\\_widget\\common-article.ejs中，&lt;%= date(post.date, &#39;YYYY-M-D&#39;) %&gt;下面添加： &lt;span class=&quot;bull&quot;&gt;&lt;/span&gt; &lt;% if(post.categories &amp;&amp; post.categories.length){ %&gt; &lt;span&gt;&lt;i class=&quot;fa fa-archive&quot;&gt;&lt;/i&gt; 分类于 &lt;% post.categories.each((category)=&gt;{ %&gt;&lt;span class=&quot;article-category&quot;&gt;&lt;a href=&quot;&lt;%- url_for(category.path) %&gt;&quot; &gt; &lt;%= category.name %&gt;&lt;/a&gt;&lt;/span&gt; &lt;% }) %&gt; &lt;/span&gt; &lt;% } %&gt; 在\\themes\\sakura\\source\\css\\style.css中，添加： .article-category{ display: inline-block; line-height: 0 !important; margin: 0; padding: 0.55rem 0.2rem; border: 1px solid #0a87ff; background: rgba(255, 255, 255, 0.93); color: #0a87ff !important; text-decoration: none; font-size: 13px; text-shadow: none; box-shadow: 0 0 6px #111; transition: all 0.1s linear; border-radius:10%; } .article-category:hover{ transition: all 0.1s linear; color: #fff !important; background: #0a89ffec; } .article-category a{color:inherit !important;} 施工中…闲的蛋疼加了这么一个功能 如果某篇文章没有完成不传上去不就行了，在front-matter里加上一句incomplete: true，文章底部就会酱紫： 施工中... 不要问我为什么是哔咔娘 在\\themes\\sakura\\layout\\_widget\\common-article.ejs中，&lt;%- post.content %&gt;下面添加： &lt;% if(post.incomplete&amp;&amp;post.incomplete==true) {%&gt; &lt;hr&gt; &lt;center&gt;&lt;img class=&quot;lazyload&quot; onerror=&quot;imgError(this,3)&quot; src=&quot;https://cdn.jsdelivr.net/gh/ctz45562/cdn@1.7.9/lazyload.gif&quot; data-src=&quot;https://cdn.jsdelivr.net/gh/ctz45562/cdn@2.0.3/emojis/gif/23.gif&quot;&gt;&lt;/center&gt; &lt;p style=&quot;font-size:32px;text-align:center;margin-top:-2px&quot;&gt;施工中...&lt;/p&gt; &lt;% } %&gt; 瞎搞记录一下瞎删掉的东西，要是有了$BUG$还原一下。 1.在\\themes\\sakura\\source\\js\\sakura-app.js中，$.getScript(&#39;//cdn.jsdelivr.net/vue/latest/vue.min.js&#39;, function () {一行下面，删除了： $.getScript(&#39;//unpkg.com/botui/build/botui.min.js&#39;, function () { bot_ui_ini() }) 2.在\\themes\\sakura\\layout\\_widget\\common-article.ejs中删除了： &lt;div class=&quot;toc&quot; style=&quot;background: none;&quot;&gt;&lt;/div&gt; 3.在\\themes\\sakura\\source\\css\\style.css中，删除了： button:hover,input[type=&quot;button&quot;]:hover,input[type=&quot;reset&quot;]:hover,input[type=&quot;submit&quot;]:hover { /*border-color:#ccc #bbb #aaa;*/ /*box-shadow:inset 0 1px 0 rgba(255,255,255,.8),inset 0 15px 17px rgba(255,255,255,.8),inset 0 -5px 12px rgba(0,0,0,.02)*/ } button:focus,input[type=&quot;button&quot;]:focus,input[type=&quot;reset&quot;]:focus,input[type=&quot;submit&quot;]:focus,button:active,input[type=&quot;button&quot;]:active,input[type=&quot;reset&quot;]:active,input[type=&quot;submit&quot;]:active { /*border-color:#aaa #bbb #bbb;*/ /*box-shadow:inset 0 -1px 0 rgba(255,255,255,.5),inset 0 2px 5px rgba(0,0,0,.15)*/ } #bgvideo { position:absolute; top:0; left:0; margin:0; padding:0; min-width:99.999%; min-height:550px; z-index:0 } #video-btn,#video-add { position:absolute; bottom:3px; right:5px; width:32px; height:32px; z-index:7; background-position:center; background-size:cover; cursor:pointer; opacity:.8; -moz-animation:poi-face 10s linear infinite alternate; -webkit-animation:poi-face 10s linear infinite alternate; -o-animation:poi-face 10s linear infinite alternate; animation:poi-face 10s linear infinite alternate } #video-btn:hover,#video-add:hover { opacity:1 } .video-play,.loadvideo { background-image:url(&#39;https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/play@32x32.png&#39;) } .video-pause { background-image:url(&#39;https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/pause@32x32.png&#39;) } #video-add { background-image:url(&#39;https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/add@32x32.png&#39;); bottom:45px; display:none } .video-stu { position:absolute; bottom:-100px; left:0; right:0; margin:auto; padding:6px 15px; text-align:center; color:#fff; width:100%; background-color:rgba(0,0,0,.8); border-radius:0; font-size:18px; -webkit-transition:.4s ease all; -moz-transition:.4s ease all; -o-transition:.4s ease all; transition:.4s ease all } cursor:url(https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/cursor/No_Disponible.cur),auto; cursor:url(https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/cursor/normal.cur),auto cursor:url(https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/cursor/texto.cur),auto 4.\\themes\\sakura\\source\\css\\style.css： - .logolink a:hover .sakurasono { - background-color:orange; - color:#fff - } .logolink .sakurasono： - background-color:rgba(255,255,255,.5); 在.logolink a:hover .shironeko,.logolink a:hover rt前添加了：.logolink a:hover .sakurasono, 5.\\themes\\sakura\\layout\\_partial\\head.ejs： - &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/sharejs.css&quot;&gt; - &lt;link rel=&quot;stylesheet&quot; href=&quot;https://fonts.googleapis.com/css?family=Noto+SerifMerriweather|Merriweather+Sans|Source+Code+Pro|Ubuntu:400,700|Noto+Serif+SC&quot; media=&quot;all&quot;&gt; - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/lib.min.css&quot; media=&quot;all&quot;&gt;\\ + &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/gh/ctz45562/cdn@1.4.1/css/googlefont.css&quot; media=&quot;all&quot;&gt; + &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/gh/ctz45562/cdn@1.4.1/css/lib.min.css&quot; media=&quot;all&quot;&gt; 6.\\themes\\sakura\\layout\\_partial\\footer.ejs： - &lt;script src=&quot;https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js&quot;&gt;&lt;/script&gt; + &lt;script src=&quot;https://cdn.jsdelivr.net/gh/ctz45562/cdn@1.4.2/js/clipboard.min.js&quot;&gt;&lt;/script&gt; 7.在\\themes\\sakura\\source\\js\\sakura-app.js中，修改了： - $.getScript(&#39;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&#39;); + $.getScript(&#39;//cdn.jsdelivr.net/gh/ctz45562/cdn@1.4.0/js/busuanzi.pure.mini.js&#39;); 8.在\\themes\\sakura\\layout\\_widget\\common-page.ejs倒数第二行： - &lt;/div&gt; + &lt;/article&gt; 9.在style.css中： #page { - min-height: calc(100vh - 150px); + min-height: calc(100vh - 45562px); } 10.在common-article中： - &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/sharejs.css&quot;&gt; - &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css&quot;&gt; + &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.bootcss.com/tocbot/4.8.0/tocbot.css&quot;&gt; 11.在\\_partial\\footer.ejs中： - &lt;img src=&quot;https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/disqus-preloader.svg&quot;&gt; 12.在\\layout\\_widget\\index-items.ejs中： - &lt;div class=&quot;float-content&quot;&gt;&lt;/div&gt; 13.在\\source\\css\\style.css中： @media(max-width:800px) { .changeSkin-gear span::before { content:&quot;&quot; } .changeSkin i {font-size:20px} .changeSkin-gear i {font-size:20px} } - position:relative; - z-index:99; - cursor:pointer - } 14.删除了关于主题配置文件中的prefixName。 在\\layout\\_partial\\header.ejs中： - &lt;span class=&quot;sakurasono&quot;&gt;&lt;%= theme.prefixName %&gt;&lt;/span&gt; - &lt;span class=&quot;shironeko&quot;&gt;&lt;%= theme.siteName %&gt;&lt;/span&gt; + &lt;span class=&quot;sakurasono&quot;&gt;&lt;%= theme.siteName %&gt;&lt;/span&gt; 在\\source\\css\\style.css中，删除了所有.shironeko。`` To be continued...","categories":[{"name":"杂物","slug":"杂物","permalink":"https://ctz45562.github.io/categories/%E6%9D%82%E7%89%A9/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://ctz45562.github.io/tags/blog/"}]},{"title":"bzoj 2839 集合计数","slug":"bzoj-2839-集合计数","date":"2019-06-03T12:46:29.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/06/03/bzoj-2839-集合计数/","link":"","permalink":"https://ctz45562.github.io/2019/06/03/bzoj-2839-%E9%9B%86%E5%90%88%E8%AE%A1%E6%95%B0/","excerpt":"传送门 最近搭$blog$导致极度颓废。。。","text":"传送门 最近搭$blog$导致极度颓废。。。 权限题，简述一下题意： 在有$n(n\\le 1e6)$个元素的所有子集（包含空集）中选出若干个，有多少种选法使它们交集大小恰好为$k(k\\le n)$？ 设$f(n)$表示在有$n$个元素的集合中取若干个子集，它们交集为空的方案数。 再设$g(n)$表示在有$n$个元素的集合中取任意个子集的方案数，显然$g(n)=2^{2^n}$。 考虑把$g(n)$分类，把交集大小相同的分到一起，就有$g(n)=\\sum\\limits_{i=0}^nC_n^{n-i}f(i)=\\sum\\limits_{i=0}^nC_n^if(i)$ 上二项式定理：$f(n)=\\sum\\limits_{i=0}^n(-1)^{n-i}C_n^ig(i)$ 答案就是$C_n^kf(n-k)$ 对于$g$，有$g(0)=2,g(n)=2^{2^n}=2^{2^{n-1}+2^{n-1}}=2^{2^{n-1}}2^{2^{n-1}}=g(n-1)g(n-1)$，就能$O(n)$预处理了。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 1000005 #define inf 0x3f3f3f3f const int mod = 1e9 + 7; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int fac[maxn]={1},inv[maxn],pow2[maxn]={2}; int INV(int x){return x==1?1:1ll*(mod-mod/x)*INV(mod%x)%mod;} inline long long pow1(int x){ return x&amp;1?-1ll:1ll; } inline int C(int n,int m){ return 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod; } int main(){ int n=read(),k=read(),ans=0; for(register int i=1;i&lt;=n;++i)fac[i]=1ll*fac[i-1]*i%mod,pow2[i]=1ll*pow2[i-1]*pow2[i-1]%mod; inv[n]=INV(fac[n]); for(register int i=n-1;~i;--i)inv[i]=1ll*inv[i+1]*(i+1)%mod; for(register int i=0;i&lt;=n-k;++i) (ans+=pow1(n-k-i)*C(n-k,i)*pow2[i]%mod)%=mod; printf(&quot;%d\\n&quot;,(1ll*C(n,k)*ans%mod+mod)%mod); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"组合数学","slug":"组合数学","permalink":"https://ctz45562.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"二项式反演","slug":"二项式反演","permalink":"https://ctz45562.github.io/tags/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/"}]},{"title":"洛谷 P1641 [SCOI2010]生成字符串","slug":"洛谷-P1641-SCOI2010-生成字符串","date":"2019-05-30T09:07:12.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/05/30/洛谷-P1641-SCOI2010-生成字符串/","link":"","permalink":"https://ctz45562.github.io/2019/05/30/%E6%B4%9B%E8%B0%B7-P1641-SCOI2010-%E7%94%9F%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"传送门 一个单次回答$O(n)$的非正解，介于该题数据水所以能过。","text":"传送门 一个单次回答$O(n)$的非正解，介于该题数据水所以能过。 总方案数为$C_{m+n}^n$，用总方案数减去不合法的即为答案。 枚举一下第一个不合法的位置$i$。换句话说，枚举一个位置$i$，在它前面的$0,1$数量相等，在该位上放一个$0$，就能产生一种不合法的情况。显然$i$为奇数。 前面$0,1$数量相等就是卡特兰数$C_{i-1}$，后面$n+m-i$个位置放$n-\\frac{i-1}{2}$个$1$，有$C_{n+m-i}^{n-\\frac{i-1}{2}}$种情况，乘起来就是答案。 其实这个式子应该能化成正解的式子，然而太复杂而且足以通过此题。 因为$n+m$超模数了所以还要再套个卢卡斯，不过这里只是个极小的小常数了。 这个思路还是蛮好想的$QwQ$ 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 4000005 #define inf 0x3f3f3f3f const int mod = 20100403; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int fac[maxn]={1},inv[maxn]; int INV(int x){return x==1?1:1ll*(mod-mod/x)*INV(mod%x)%mod;} inline int C(int n,int m){ if(n&lt;m)return 0; if(n&gt;=mod)return 1ll*C(n/mod,m/mod)*(n%mod,m%mod)%mod; return 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod; } inline int Cat(int n){ return 1ll*fac[n&lt;&lt;1]*inv[n]%mod*inv[n+1]%mod; } int main(){ int n=read(),m=read(); for(register int i=1;i&lt;=n+m&lt;&lt;1;++i)fac[i]=1ll*fac[i-1]*i%mod; inv[n+m&lt;&lt;1]=INV(fac[n+m&lt;&lt;1]); for(register int i=(n+m&lt;&lt;1)-1;~i;--i)inv[i]=1ll*inv[i+1]*(i+1)%mod; int ans=0; for(register int i=1;i&lt;=n+m;i+=2) (ans+=1ll*Cat(i-1&gt;&gt;1)*C(n+m-i,n-(i-1&gt;&gt;1))%mod)%=mod; printf(&quot;%d\\n&quot;,(C(n+m,n)-ans+mod)%mod); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"组合数学","slug":"组合数学","permalink":"https://ctz45562.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"卢卡斯定理","slug":"卢卡斯定理","permalink":"https://ctz45562.github.io/tags/%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86/"},{"name":"卡特兰数","slug":"卡特兰数","permalink":"https://ctz45562.github.io/tags/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/"}]},{"title":"洛谷 P4345 [SHOI2015]超能粒子炮·改","slug":"洛谷-4345-SHOI2015-超能粒子炮·改","date":"2019-05-29T09:55:13.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/05/29/洛谷-4345-SHOI2015-超能粒子炮·改/","link":"","permalink":"https://ctz45562.github.io/2019/05/29/%E6%B4%9B%E8%B0%B7-4345-SHOI2015-%E8%B6%85%E8%83%BD%E7%B2%92%E5%AD%90%E7%82%AE%C2%B7%E6%94%B9/","excerpt":"传送门 思路很妙的$Lucas$。","text":"传送门 思路很妙的$Lucas$。 设$f(n,k)=\\sum\\limits_{i=0}^kC_n^i$ 套上卢卡斯： $f(n,k)=\\sum\\limits_{i=0}^kC_{n/p}^{i/p}C_{n\\% p}^{i\\% p}$ $i$每增长$p$，$i/p$才会加$1$。把$C_{n/p}^{i/p}$拆出来： $=\\left(\\sum\\limits_{i=0}^{k/p-1}C_{n/p}^i\\sum\\limits_{j=0}^{p-1}C_{n\\% p}^{j}\\right)+C_{n/p}^{k/p}\\sum\\limits_{i=0}^{k\\% p}C_{n\\% p}^{i}$ $=f(n/p,k/p-1)f(n\\% p,p-1)+C_{n/p}^{k/p}f(n\\% p,k\\% p)$ $f$相当于是组合数的前缀和，$O(p^2)$预处理$0\\sim p-1$的$f$，递归计算$f(n/p,k/p-1)$，$C_{n/p}^{k/p}$用卢卡斯计算即可。 注意特判递归时$k&lt;0$的情况。 复杂度：$O(t\\log_p^2n)$ 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 100005 #define inf 0x3f3f3f3f const int mod = 2333; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } template&lt;typename T&gt; inline T read(){ T x=0; int y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int c[mod+1][mod+1],f[mod+1][mod+1]; int C(long long n,long long m){//注意long long if(n&lt;m)return 0; if(n&gt;=mod)return C(n/mod,m/mod)*C(n%mod,m%mod)%mod; return c[n][m]; } int F(long long n,long long k){ if(k&lt;0)return 0; if(k&gt;=mod||n&gt;=mod)return (f[n%mod][mod-1]*F(n/mod,k/mod-1)%mod+C(n/mod,k/mod)*f[n%mod][k%mod]%mod)%mod; return f[n][k]; } int main(){ c[0][0]=1; for(register int i=0;i&lt;mod;++i)f[0][i]=1; for(register int i=1;i&lt;mod;++i){ c[i][0]=f[i][0]=1; for(register int j=1;j&lt;mod;++j) c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod,f[i][j]=(f[i][j-1]+c[i][j])%mod; } int t=read(); long long n,k; while(t--)n=read&lt;long long&gt;(),k=read&lt;long long&gt;(),printf(&quot;%d\\n&quot;,F(n,k)); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"组合数学","slug":"组合数学","permalink":"https://ctz45562.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"卢卡斯定理","slug":"卢卡斯定理","permalink":"https://ctz45562.github.io/tags/%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86/"}]},{"title":"bzoj 4403 序列统计","slug":"bzoj-4403-序列统计","date":"2019-05-27T07:50:16.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/05/27/bzoj-4403-序列统计/","link":"","permalink":"https://ctz45562.github.io/2019/05/27/bzoj-4403-%E5%BA%8F%E5%88%97%E7%BB%9F%E8%AE%A1/","excerpt":"传送门 发现组合数有些有意思的式子要背证，哪天写个总结吧。 还现学了卢卡斯。","text":"传送门 发现组合数有些有意思的式子要背证，哪天写个总结吧。 还现学了卢卡斯。 设$m=r-l$，则值域为$[l,r]$的方案数和$[0,m]$的方案数一样。 考虑长度为$n$的单调不降序列有多少种： 可以从$[0,m]$中取$n$个数（每个数可以重复取），升序排序就能得到一种方案。 也就是可重复组合$C_{m+n}^n$ 答案就是$\\sum\\limits_{i=1}^nC_{m+i}^i$ 然后通过百度发现$C$有这么个性质： $\\sum\\limits_{i=0}^nC_{m+i}^i=C_{m+n+1}^n$ 简单证一下： $C_m^0+C_{m+1}^1+C_{m+2}^2+…+C_{m+n}^n$$ $=C_{m+1}^0+C_{m+1}^1+C_{m+2}^2+…+C_{m+n}^n$ $=C_{m+2}^1+C_{m+2}^2+…+C_{m+n}^n$ $=C_{m+n}^{n-1}+C_{m+n}^n$ $=C_{m+n+1}^n$ 答案就成了$C_{m+n+1}^n-1$。 套个卢卡斯就行了。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 1005 #define inf 0x3f3f3f3f const int mod = 1e6 + 3; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int fac[mod]={1},inv[mod]; int INV(int x){return x==1?1:1ll*(mod-mod/x)*INV(mod%x)%mod;} int C(int n,int m){ if(n&lt;m)return 0; if(n&gt;=mod||m&gt;=mod)return 1ll*C(n/mod,m/mod)*C(n%mod,m%mod)%mod; return 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod; } int main(){ for(register int i=1;i&lt;mod;++i)fac[i]=1ll*fac[i-1]*i%mod; inv[mod-1]=INV(fac[mod-1]); for(register int i=mod-2;~i;--i)inv[i]=1ll*inv[i+1]*(i+1)%mod; int t=read(),n,l,m; while(t--){ n=read(),l=read(),m=read()-l; printf(&quot;%d\\n&quot;,(C(m+n+1,n)-1+mod)%mod); } }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"组合数学","slug":"组合数学","permalink":"https://ctz45562.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"卢卡斯定理","slug":"卢卡斯定理","permalink":"https://ctz45562.github.io/tags/%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86/"}]},{"title":"洛谷 P4921 情侣？给我烧了！","slug":"洛谷-P4921-情侣？给我烧了！","date":"2019-05-23T12:37:05.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/05/23/洛谷-P4921-情侣？给我烧了！/","link":"","permalink":"https://ctz45562.github.io/2019/05/23/%E6%B4%9B%E8%B0%B7-P4921-%E6%83%85%E4%BE%A3%EF%BC%9F%E7%BB%99%E6%88%91%E7%83%A7%E4%BA%86%EF%BC%81/","excerpt":"传送门 被强化の传送门 最近补课有种退役的感觉。。。甚至已经想退役了","text":"传送门 被强化の传送门 最近补课有种退役的感觉。。。甚至已经想退役了 一眼看上去很像错排。$k$位错排问题可以先$C_n^{n-k}$选出配对的$n-k$个，剩下的$k$个完全错排。 用$f(n)$表示不考虑坐的次序（只考虑谁和谁坐一起），$n$对情侣完全错排的方案数。 然后考虑$n$对情侣至少$i$对的配对的方案数。 $C_n^i$选出配对的$i$对，剩下的$2n-2i$个人任意配对。这里定义$g(n)=\\prod\\limits_{i=1}^{\\frac{n}{2}}(2i-1)$，则有$g(2n-2i)$种方案。 $g(n)$可以预处理，当然可以优雅地百度推导： \\prod\\limits_{i=1}^{\\frac{n}{2}}(2i-1)=\\dfrac{n!}{\\prod\\limits_{i=1}^{\\frac{n}{2}}(2i)}=\\dfrac{n!}{(\\frac{n}{2})!2^{\\frac{n}{2}}}套路地容斥一下： f(n)=\\sum\\limits_{i=0}^{n}(-1)^iC_n^ig(2n-2i)=\\sum\\limits_{i=0}^{n}(-1)^iC_n^i\\dfrac{(2n-2i)!}{(n-i)!2^{n-i}}对于任意$n$和$k$，就能先$C_n^k$选出配对的情侣，剩下的$f(n-k)$完全错排，考虑次序，有$n!$种排列，配对的两人之间可以互换，有$2^n$种情况。 答案就是$C_n^kf(n-k)n!2^n$，预处理阶乘、阶乘逆元、$2$的$n$次幂、$2$的$n$次幂的逆元，$O(n^2)$预处理$f$，$O(n)$回答每个询问，足以通过普通版。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 2005 #define inf 0x3f3f3f3f const int mod = 998244353; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int pow2[maxn]={1},fac[maxn]={1},inv[maxn],inv2[maxn],f[maxn],n; int INV(int x){return x==1?1:1ll*(mod-mod/x)*INV(mod%x)%mod;} inline int C(int m,int n){return 1ll*fac[n]*inv[n-m]%mod*inv[m]%mod;} inline long long pow_1(int x){return x&amp;1?-1ll:1ll;} int main(){ for(register int i=1;i&lt;=2000;++i)fac[i]=1ll*fac[i-1]*i%mod,pow2[i]=(pow2[i-1]&lt;&lt;1)%mod; inv[2000]=INV(fac[2000]),inv2[2000]=INV(pow2[2000]); for(register int i=1999;~i;--i)inv[i]=1ll*inv[i+1]*(i+1)%mod,inv2[i]=(inv2[i+1]&lt;&lt;1)%mod; for(register int i=0;i&lt;=2000;f[i]=(f[i]+mod)%mod,++i) for(register int j=0;j&lt;=i;++j) (f[i]+=pow_1(j)*C(j,i)%mod*fac[i-j&lt;&lt;1]%mod*inv[i-j]%mod*inv2[i-j]%mod)%=mod; int t=read(); while(t--){ n=read(); for(register int i=0;i&lt;=n;++i) printf(&quot;%d\\n&quot;,1ll*C(i,n)%mod*f[n-i]%mod*pow2[n]%mod*fac[n]%mod); } } 加强版的看题解表示并不会生成函数也不想递推，咕咕咕","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"容斥","slug":"容斥","permalink":"https://ctz45562.github.io/tags/%E5%AE%B9%E6%96%A5/"},{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"组合数学","slug":"组合数学","permalink":"https://ctz45562.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}]},{"title":"bzoj 4487 [JSOI2015]染色问题","slug":"bzoj-4487-JSOI2015-染色问题","date":"2019-05-16T13:50:32.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/05/16/bzoj-4487-JSOI2015-染色问题/","link":"","permalink":"https://ctz45562.github.io/2019/05/16/bzoj-4487-JSOI2015-%E6%9F%93%E8%89%B2%E9%97%AE%E9%A2%98/","excerpt":"传送门 我又双叒叕尝试学习数论辣！ 算是我的组合数学+容斥的入门题。","text":"传送门 我又双叒叕尝试学习数论辣！ 算是我的组合数学+容斥的入门题。 把可行方案数转成总方案数减去不可行方案数。 然后把不可行方案分成三类：不满足条件$1$、$2$、$3$的。容斥加加减减就完了。 推完长这样： (c+1)^{mn}-\\sum\\limits_{i=1}^{n}(-1)^{i+1}C_n^i(c+1)^{m(n-i)}-\\sum\\limits_{i=1}^{m}(-1)^{i+1}C_m^i(c+1)^{n(m-i)}-\\sum\\limits_{i=1}^{c}(-1)^{i+1}C_c^i(c+1-i)^{mn}+\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{m}(-1)^{i+j}C_n^iC_m^j(c+1)^{(n-i)(m-j)}+\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{c}(-1)^{i+j}C_n^iC_c^j(c+1-j)^{m(n-i)}+\\sum\\limits_{i=1}^{m}\\sum\\limits_{j=1}^{c}(-1)^{i+j}C_m^iC_c^j(c+1-j)^{n(m-i)}-\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{m}\\sum\\limits_{k=1}^{c}(-1)^{i+j+k+1}C_n^iC_m^jC_c^k(c+1-k)^{(m-j)(n-i)}感觉我推的十分鬼畜。。。查阅一下$asuldb$的题解发现他推的长这样： \\sum_\\limits{i=0}^n\\sum\\limits_{j=0}^m\\sum\\limits_{k=0}^c(-1)^{i+j+k}C_n^iC_m^jC_c^k (c-k+1)^{(m-j)(n-i)}应该是可以化简的然而懒得化了反正复杂度一样 这个复杂度是$O(nmc\\log nm)$的，会$T$，瓶颈在于 \\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{m}\\sum\\limits_{k=1}^{c}(-1)^{i+j+k+1}C_n^iC_m^jC_c^k(c+1-k)^{(m-j)(n-i)}有两种方案： 1.瞎JB改式子 调换一下顺序： \\sum\\limits_{k=1}^{c}\\sum\\limits_{j=1}^{m}\\sum\\limits_{i=1}^{n}(-1)^{i+j+k+1}C_n^iC_m^jC_c^k(c+1-k)^{(m-j)(n-i)}倒序循环$i$，会发现$i$每减少$1$，后面的幂就会乘上$(c+1-k)^{m-j}$，那么在第二层循环里可以先算出$(c+1-k)^{m-j}$，乘起来即可，就能把$\\log$去掉。甚至可以把前面的幂这样处理优化常数。 2.黑科技分块光速幂 这个我只会口胡 分块光速幂可以达到$O(n\\sqrt{V})$（$n$为底数值域，$V$为指数值域）预处理，$O(1)$回答$n^V$。 然后就能很暴力地$O(c\\sqrt{mn})$预处理，$O(1)$求$(c+1-k)^{(m-j)(n-i)}$了。同样可以去掉前面的所有快速幂的$\\log$。 最终复杂度为$O(nmc)$ #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 405 #define inf 0x3f3f3f3f const int mod = 1e9 + 7; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } long long quickpow(long long x,int y){ long long ans=1; while(y){ if(y&amp;1)ans=ans*x%mod; x=x*x%mod; y&gt;&gt;=1; } return ans; } inline int fac(int x){ return x&amp;1?-1:1; } int C[maxn][maxn]; int main(){ C[0][0]=1; int n=read(),m=read(),c=read(),M=max(max(n,m),c); long long ans=0; for(register int i=1;i&lt;=M;++i){ C[0][i]=1; for(register int j=1;j&lt;=M;++j) C[j][i]=(C[j][i-1]+C[j-1][i-1])%mod; } for(register int i=1;i&lt;=n;++i)(ans+=quickpow(c+1,m*(n-i))*C[i][n]*fac(i+1))%=mod; for(register int i=1;i&lt;=m;++i)(ans+=quickpow(c+1,n*(m-i))*C[i][m]*fac(i+1))%=mod; for(register int i=1;i&lt;=c;++i)(ans+=quickpow(c+1-i,m*n)*C[i][c]*fac(i+1))%=mod; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=m;++j) (ans+=quickpow(c+1,(n-i)*(m-j))*C[i][n]%mod*C[j][m]*fac(i+j+1))%=mod; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=c;++j) (ans+=quickpow(c+1-j,m*(n-i))*C[i][n]%mod*C[j][c]*fac(i+j+1))%=mod; for(register int i=1;i&lt;=m;++i) for(register int j=1;j&lt;=c;++j){ (ans+=quickpow(c+1-j,n*(m-i))*C[i][m]%mod*C[j][c]*fac(i+j+1))%=mod; } for(register int k=1;k&lt;=c;++k){ long long p=1; for(register int j=m;j;--j){ long long q=1; for(register int i=n;i;--i,q=q*p%mod) (ans+=q*C[i][n]%mod*C[j][m]%mod*C[k][c]*fac(i+j+k+1))%=mod; p=p*(c+1-k)%mod; } } printf(&quot;%lld\\n&quot;,(quickpow(c+1,n*m)-ans+mod)%mod);//注意模成正数 }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"容斥","slug":"容斥","permalink":"https://ctz45562.github.io/tags/%E5%AE%B9%E6%96%A5/"},{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"组合数学","slug":"组合数学","permalink":"https://ctz45562.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}]},{"title":"组合数学食用笔记","slug":"组合数学食用笔记","date":"2019-05-13T12:03:49.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/05/13/组合数学食用笔记/","link":"","permalink":"https://ctz45562.github.io/2019/05/13/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E9%A3%9F%E7%94%A8%E7%AC%94%E8%AE%B0/","excerpt":"从头开始学组合数学，所以里面有大量很水的芝士。","text":"从头开始学组合数学，所以里面有大量很水的芝士。 抄袭来源 https://blog.csdn.net/litble/article/details/75913032 http://lanqi.org/skills/10939/ https://www.cnblogs.com/COLIN-LIGHTNING/p/8450053.html http://blog.miskcoo.com/2015/12/inversion-magic-binomial-inversion https://blog.csdn.net/werkeytom_ftd/article/details/74701513 https://www.cnblogs.com/ivorysi/p/9058093.html https://www.cnblogs.com/zwfymqz/p/8869956.html https://www.cnblogs.com/asuldb/p/10917496.html https://www.cnblogs.com/zhouzhendong/p/Stirling-Number.html https://www.cnblogs.com/candy99/p/6420935.html 组合数一些神奇的性质大部分 是从抄袭来源第一篇里整理来的。 1.$\\sum\\limits_{i=0}^mC_{n+i}^i=C_{m+n+1}^m$ 证明： $\\sum\\limits_{i=0}^mC_{n+i}^i$ $=C_n^0+C_{n+1}^1+C_{n+2}^2+…+C_{n+m}^{m}$ $=C_{n+1}^0+C_{n+1}^1+C_{n+2}^2+…+C_{n+m}^m$ $=C_{n+2}^1+C_{n+2}^2+…C_{n+m}^m$ $=C_{n+m+1}^m$ 2.$C_m^nC_n^r=C_m^rC_{m-r}^{n-r}$ 证明： $C_m^nC_n^r$ $=\\dfrac{m!}{n!(m-n)!}\\dfrac{n!}{r!(n-r)!}$ $=\\dfrac{m!}{(m-n)!}\\dfrac{1}{r!(n-r)!}$ $=\\dfrac{m!}{r!(m-r)!}\\dfrac{(m-r)!}{(m-n)!(n-r)!}$ $=C_m^rC_{m-r}^{n-r}$ 也可以考虑它的组合含义： $C_m^nC_n^r$就是从大小为$m$的集合里选出大小为$n$的子集，再从这个子集选出大小为$r$的子集。 倒过来算，先选大小为$r$的子集，再算出它被多少个大小为$n$的子集包含，即$C_m^rC_{m-r}^{n-r}$ 3.$(x+1)^n=\\sum\\limits_{i=0}^nC_n^ix^i$ 根据二项式定理显然。 4.$\\sum\\limits_{i=0}^n(-1)^iC_n^i=0$ 若$n$为奇数，根据$C_n^m=C_{n}^{n-m}$显然 若$n$为偶数，用递推公式展开： $\\sum\\limits_{i=0}^n(-1)^iC_n^i$ $=C_n^0-C_n^1+C_n^2-C_n^3+…+C_n^n$ $=C_{n-1}^0-C_{n-1}^0-C_{n-1}^1+C_{n-1}^1+C_{n-1}^2-…+C_{n-1}^{n-1}$ $=0$ $update$： 被抄袭来源误导了，直接用二项式定理就行： $\\sum\\limits_{i=0}^n(-1)^iC_n^i$ $=\\sum\\limits_{i=0}^nC_n^i(-1)^i1^{n-i}$ $=(-1+1)^n$ $=0$ 5.$C_{m+n}^r=\\sum\\limits_{i=0}^rC_m^iC_n^{r-i}$ 这玩意叫范德蒙恒等式。 把$m+n$分成两组，分别有$m$个物品和$n$个物品，枚举在这两组中各取几个。 特别的，当$r=n$时，根据$C_n^m=C_n^{n-m}$，有： $C_{m+n}^n=\\sum\\limits_{i=0}^nC_m^iC_n^i$ 更特别的，当$r=m=n$时，有： $C_{2n}^n=\\sum\\limits_{i=0}^nC_n^iC_n^{n-i}=\\sum\\limits_{i=0}^n(C_n^i)^2$ 6.$nC_m^n=mC_{m-1}^{n-1}$ 证明： $nC_m^n$ $=n\\dfrac{m!}{n!(m-n)!}$ $=m\\dfrac{(m-1)!}{(n-1)!(m-n)!}$ $=mC_{m-1}^{n-1}$ 7.$\\sum\\limits_{i=1}^niC_n^i=n2^{n-1}$ 证明： $\\sum\\limits_{i=1}^niC_n^i$ $=\\sum\\limits_{i=1}^ni\\dfrac{n!}{i!(n-i)!}$ $=n\\sum\\limits_{i=1}^n\\dfrac{(n-1)!}{(i-1)!(n-i)!}$ $=n\\sum\\limits_{i=1}^nC_{n-1}^{i-1}$ $=n\\sum\\limits_{i=0}^{n-1}C_n^i$ $=n2^{n-1}$ 8.$\\sum\\limits_{i=1}^ni^2C_n^i=n(n+1)2^{n-2}$ 证明： $\\sum\\limits_{i=1}^ni^2C_n^i$ $=\\sum\\limits_{i=1}^ni^2\\dfrac{n!}{i!(n-i)!}$ $=n\\sum\\limits_{i=1}^ni\\dfrac{(n-1)!}{(i-1)!(n-i)!}$ $=n\\sum\\limits_{i=0}^{n-1}(i+1)C_n^i$ $=n\\left(\\sum\\limits_{i=0}^{n-1}iC_n^i+\\sum\\limits_{i=0}^{n-1}C_n^i\\right)$ $=n\\left((n-1)2^{n-2}+2^{n-1}\\right)$ $=n(n+1)2^{n-2}$ 9.$\\sum\\limits_{i=0}^nC_i^m=C_{n+1}^{m+1}$ 考虑组合意义。从$n+1$个物品里选$m+1$个，枚举最后一个选的位置为$i+1$，在前$i$个里选$m$个，即$\\sum\\limits_{i=0}^nC_i^m$。 10.$\\sum\\limits_{i=0}^nC_n^i[2|i]=\\sum\\limits_{i=0}^nC_n^i[2\\nmid i]=2^{n-1}$ 考虑组合意义，在$n$个物品里选偶数个，先在前$n-1$个里任选，选了偶数个第$n$个就不选，选了奇数个就选第$n$个。 容斥最近刷了刷容斥和二项式反演，感觉有点理解了，于是重写了一遍。 定义容斥就是一个式子： $|\\bigcup\\limits_{i=1}^nA_i|=\\sum\\limits_{1\\le i\\le n}|A_i|-\\sum\\limits_{1\\le i&lt; j\\le n}|A_i\\bigcap A_j|+\\sum\\limits_{1\\le i &lt; j &lt;k\\le n}|A_i\\bigcap A_j\\bigcap A_k|-…+(-1)^{n-1}|A_1\\bigcap A_2…\\bigcap A_n|$ 简单来说（请$yy$一个维恩图出来）： 假设我们要求满足某几个条件的方案数。 算出总方案数，减去不合法的。分别算出不满足条件$1$的方案数、不满足条件$2$的方案数。。。 这时我们发现同时不满足$1,2$、$2,3$、$1,3$。。。的方案被减去了两次，于是要再把它们加回来。 然而同时不满足$1,2,3$、$2,3,4$、$1,2,4$。。。的方案又被加了两次，再减去。 算到$n$个条件都不满足就到头了，也就是答案。 形象的说，就是拆了东墙补西墙，补着补着。。。就补好了。 应用一种最直接的应用就是根据定义去容斥，直接枚举子集算出方案数，乘上容斥系数$(-1)^{|S|}$。比如这道题（题解） 另一种是算出至少的方案数。其实说至少不太贴切，这里是指枚举有多少不合法的，钦定它们的方案，剩下的随便放。这样会有算重的，容斥减掉。 举个栗子，经典的错排问题：求出长度为$n$满足$p_i\\neq i$的排列数。 枚举有多少位置$p_i=i$，$C_n^i$选出是那些位置，剩下位置$(n-i)!$随便放。 于是有$\\sum\\limits_{i=0}^n(-1)^iC_n^i(n-i)!$ 也就是说涉及到“恰好”，就可以考虑容斥转到“至少/多”上了。而“至少/多”一般易于计算。 其他的容斥还有$\\min-\\max$容斥、子集容斥，甚至莫比乌斯反演也算是容斥。我太菜了就不说了。 二项式反演就是几个式子： $f(n)=\\sum\\limits_{i=0}^n(-1)^iC_n^ig(i)\\leftrightarrow g(n)=\\sum\\limits_{i=0}^n(-1)^iC_n^if(i)$ $f(n)=\\sum\\limits_{i=0}^nC_n^ig(i)\\leftrightarrow g(n)=\\sum\\limits_{i=0}^n(-1)^{n-i}C_n^if(i)$ $f(i)=\\sum\\limits_{j=i}^n(-1)^jC_j^ig(j)\\leftrightarrow g(i)=\\sum\\limits_{j=i}^n(-1)^jC_j^if(j)$ $f(i)=\\sum\\limits_{j=i}^nC_j^ig(j)\\leftrightarrow g(i)=\\sum\\limits_{j=i}^n(-1)^{j-i}C_j^if(j)$ 其中第二个和第四个用的最多。 证明可能以后会搞。 二项式反演本质就是容斥。但是有的时候用二项式反演更无脑，因为你只要设出两个函数，找到关系，反演过去就没了。 一般用二项式反演也是涉及“恰好”，在求恰好$k$个#!%&amp;@时尤有奇效。根据套路，设$f(i)$为恰好有$i$个#!%&amp;@，$g(i)$为至少有$i$个#!%&amp;@（这里的至少和容斥里的类似）。 $g(i)$一般比较好算，还是钦定$i$个#!%&amp;@，剩下的随意。有的时候要结合$DP$来算。 这时会发现对于一种恰好有$i$个#!%&amp;@的方案，它会在$g(j)$中被计算$C_j^i$次。 于是就能列出式子$g(i)=\\sum\\limits_{j=i}^nC_j^if(j)$ 二项式反演得$f(i)=\\sum\\limits_{j=i}^n(-1)^{j-i}C_j^ig(j)$，对于任意的$i$我们都可以用这个式子求了。 求至多类似。例题已经没有什么好害怕的了（题解）。里面至少要用$DP$求。 另一种二项式反演的套路是把所有方案分类。比如集合计数。 套路大概是设$f(i)$为恰好，$g(n)$为$n$个东西的总方案数。列出$g(n)=\\sum\\limits_{i=0}^nC_n^if(i)$的式子反演过去。 卢卡斯定理当$C_n^m$的$n,m$太大时或者超过了模数，就得上卢卡斯： $C_n^m=C_{n/p}^{m/p}C_{n\\%p}^{m\\%p}(\\bmod p)$ 其中$p$为质数。 然后递归计算$C_{n/p}^{m/p}$即可，复杂度$O(\\log_pn)$ 代码： const int mod = 2333; int fac[mod],inv[mod];//阶乘、阶乘逆元 int C(int n,int m){ if(n&lt;m)return 0; if(n&gt;=mod)return 1ll*C(n/mod,m/mod)*C(n%mod,m%mod)%mod; return 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod; } 并不想也不会证明。 当然卢卡斯也不光能干这个，比如这道题。 还有扩展卢卡斯，可以解决模数非质数情况。不过好像没什么用就没学。 卡特兰数公式 我考一考你。卡特兰数的第$n$项，怎么算的？ 卡特兰数有四种算法，你知道吗？ 1.$C_n=\\dfrac{C_{2n}^n}{n+1}=C_{2n}^n-C_{2n}^{n-1}$ 2.$C_n=\\dfrac{\\sum\\limits_{i=0}^n(C_n^i)^2}{n+1}$ 3.$C_{n+1}=\\sum\\limits_{i=0}^nC_iC_{n-i},C_0=1$ 4.$C_{n+1}=\\dfrac{4n+2}{n+2}C_n,C_0=1$ 模型坐标系游走在一个坐标系中从原点出发，只能向右或向上走，有多少种走法不跨越直线$y=x$到达点$(n,n)$？ 如图（图片来源） 以此来推导一下卡特兰数： 总方案数有$C_{2n}^n$种，考虑不合法的方案数。 如果跨越了$y=x$这条直线，则一定到达直线$y=x+1$。 对某条不合法的路线，沿$y=x+1$翻折一下： （图片来源） 起点就变成了$(-1,1)$。则不合法的情况为从$(-1,1)$走到$(n,n)$的方案数，即$C_{2n}^{n-1}$。 所以$C_n=C_{2n}^n-C_{2n}^{n-1}$ 合法出栈序列一个足够大的栈的入栈序列为$1,2,3,…n$，求有多少种合法的出栈序列？（也可以是合法的括号序列数） 设$f(n)$为答案。枚举最后一个出栈的是几号元素，设为$i$。 那么在$i$入栈前，$1\\sim i-1$都要先出栈，有$f(i-1)$种序列。 在$i$出栈前，$i+1\\sim n$都要先出栈，有$f(n-i)$种序列。 所以$f(n)=\\sum\\limits_{i=1}^nf(i-1)f(n-i)$，即卡特兰数。 或者抽象成坐标系游走，入栈看作向右走，出栈看作向上走。 满2B树计数求节点数为$2n+1$的满二叉树个数。 设$f(n)$为答案。枚举根节点左右子树节点的个数，就有$f(n)=\\sum\\limits_{i=0}^{n-1}f(i)f(n-1-i)$，还是卡特兰数。 噶凸多边形求连接一个凸$n+3$边形的对角线使它们互不相交，将其分成若干个三角形的方案数。 同样设$f(n)$为答案，从一个顶点开始枚举它连向的点，还是有$f(n)=\\sum\\limits_{i=0}^{n-1}f(i)f(n-1-i)$ 造楼梯求用$n$个任意尺寸的矩形造出高度为$n$的楼梯的方案数。 如图（图片来源） 设$f(n)$为答案。选一个高度$k$，在这一层上覆盖一个大长方形（下图红色部分）。 然后填满蓝色区域和绿色区域，有$f(n-k)f(k-1)$种方案。每个高度加起来，就是卡特兰数。 （吐槽一句：题水就拿高精凑） 奥义·强化坐标系游走！如果坐标系游走终点为$(n,m)$，有多少种方案？ 属于卡特兰数的拓展。 总方案数为$C_{n+m}^n$，和坐标系游走一样推导，易知不合法方案数为$C_{n+m}^{m-1}$ 所以答案为$C_{n+m}^n-C_{n+m}^{m-1}$ Prufer序列一棵无根树可以唯一对应一个$prufer$序列。 用来解决有关节点度数的无根树计数问题。 构造不断找到当前编号最小的叶节点，把与它相连的点的编号写入$prufer$序列中并删除该叶节点，直到整棵树只有$2$个节点。 也就是说$n$个节点的无根树$prufer$序列长度为$n-2$。 比如这棵无根树： 它的$prufer$序列为$\\{2,7,2,1,1\\}$ 容易发现$prufer$序列的一个重要性质：某个点在$prufer$序列中出现次数等于它的度数-1。 还原维护一个点集$P$，初始包含$n$个点。 不断找到$P$中不在$prufer$序列中出现的编号最小的节点，把它与$prufer$序列中第一个点相连，在$P$中删除它并删去$prufer$序列的第一个点，直到$prufer$序列为空。最后把$P$中剩余的$2$个点相连。 应用n个点的有标号无根树计数或者说$n$个点的完全图生成树计数。 相当于值域为$[1,n]$、长为$n-2$的序列计数。 即$n^{n-2}$。 这个也叫$Cayley$公式。 限制度数的无根树计数也就是点$i$在$prufer$序列中出现次数为$d(i)-1$。 用一下无标号转有标号再转回无标号的$trick$易知答案为$\\dfrac{(n-2)!}{\\prod\\limits_{i=1}^n(d(i)-1)!}$ 这个题比较坑的就是高精和判无解。 若存在$d(i)=0$且$n&gt;1$，或$\\sum\\limits_{i=1}^nd(i)-1\\neq n-2$则无解。 更高端的计数 有标号有根树计数给一棵无根树任意定根，有$n$种情况。 即$n^{n-1}$。 斯特林数第二类斯特林数定义用$\\begin{Bmatrix}n\\\\m\\end{Bmatrix}$表示把$n$个有标号元素划分成$m$个无标号集合（不允许有空集）的方案数。也可写作$S(n,m)$。 递推公式考虑第$n$个元素的去向。可以单独一个集合，也可以放到已经有的$m$个集合里。 $\\begin{Bmatrix}n\\\\m\\end{Bmatrix}=\\begin{Bmatrix}n-1\\\\m-1\\end{Bmatrix}+m\\times\\begin{Bmatrix}n-1\\\\m\\end{Bmatrix}$ 边界：$\\begin{Bmatrix}0\\\\0\\end{Bmatrix}=1,\\begin{Bmatrix}n\\\\0\\end{Bmatrix}=0(n&gt;0)$ 通项公式先计算集合有标号的方案数，用容斥。 枚举至少有多少个集合是空的，$C_m^i$选出来，剩下$m-i$个集合放$n$个元素，转无标号除以$m!$： $\\begin{Bmatrix}n\\\\m\\end{Bmatrix}=\\dfrac{1}{m!}\\sum\\limits_{i=0}^m(-1)^iC_m^i(m-i)^n$ 把组合数拆开：$\\sum\\limits_{i=0}^m\\dfrac{(-1)^i}{i!}\\cdot\\dfrac{(m-i)^n}{(m-i)!}$ 惊奇地发现这是个卷积的形式。于是可以用$FFT/NTT$在$O(m\\log n)$内算出$\\begin{Bmatrix}n\\\\0\\sim m\\end{Bmatrix}$。（板子） 应用自然数幂次方转下降幂简单说一下下降幂：$m^{\\underline n}=m(m-1)(m-2)\\cdots(m-n+1)=\\dfrac{m!}{(m-n)!}=A_m^n$ 考虑$m^n$的含义：把$n$个有标号小球放进$m$个有标号盒子里（允许有空盒子）的方案数。这和第二类斯特林数有点像。 以非空集的个数把$m^n$种方案分类： $m^n=\\sum\\limits_{i=1}^n\\begin{Bmatrix}n\\\\i\\end{Bmatrix}C_m^ii!=\\sum\\limits_{i=1}^n\\begin{Bmatrix}n\\\\i\\end{Bmatrix}m^{\\underline i}$ 当然下标从$0$开始也可以，反正$\\begin{Bmatrix}n\\\\0\\end{Bmatrix}=0$。 而$i$的上界其实是$\\min\\{n,m\\}$，$i&gt;m$时$C_m^i=0$，$i&gt;n$时$\\begin{Bmatrix}n\\\\i\\end{Bmatrix}=0$。所以写$n,m$皆可。 自然数幂次方和用上面那个来推。 $\\sum\\limits_{i=0}^ni^k$ $=\\sum\\limits_{i=0}^n\\sum\\limits_{j=0}^k\\begin{Bmatrix}k\\\\j\\end{Bmatrix}C_i^jj!$ $=\\sum\\limits_{j=0}^k\\begin{Bmatrix}k\\\\j\\end{Bmatrix}j!\\sum\\limits_{i=0}^nC_i^j$ （上文提到过$\\sum\\limits_{i=0}^nC_i^m=C_{n+1}^{m+1}$） $=\\sum\\limits_{j=0}^k\\begin{Bmatrix}k\\\\j\\end{Bmatrix}j!C_{n+1}^{j+1}$ $=\\sum\\limits_{j=0}^k\\begin{Bmatrix}k\\\\j\\end{Bmatrix}\\dfrac{(n+1)^{\\underline{j+1}}}{j+1}$ 不考虑斯特林数的复杂度，如果预处理出阶乘和逆元可以做到$O(n)$预处理，$O(k)$回答；如果暴力算后面那一坨的话可以做到$O(k^2)$回答。 朴素的算法是$O(n\\log k)$的。通过斯特林数我们得到了去掉$\\log$的算法和与$n$无关的算法，普天同庆皆大欢喜啊。 第一类斯特林数定义用$\\begin{bmatrix}n\\\\m\\end{bmatrix}$表示把$n$个有标号元素形成$m$个环（圆排列）的方案数。也可写作$s(n,m)$。 递推公式还是考虑第$n$个元素的去向，单独成环，或者与放在前$n-1$个元素里任意一个元素前面。 $\\begin{bmatrix}n\\\\m\\end{bmatrix}=\\begin{bmatrix}n-1\\\\m-1\\end{bmatrix}+(n-1)\\begin{bmatrix}n-1\\\\m\\end{bmatrix}$。 边界：$\\begin{bmatrix}0\\\\0\\end{bmatrix}=1,\\begin{bmatrix}n\\\\0\\end{bmatrix}=\\begin{bmatrix}0\\\\m\\end{bmatrix}=0(n,m&gt;0)$ 这个递推可以用生成函数搞一搞但我不会生成函数告辞。 应用证明什么的好麻烦啊自己搜去吧 阶乘相关$n!=\\sum\\limits_{i=0}^n\\begin{bmatrix}n\\\\i\\end{bmatrix}$ 下降幂转幂次方$x^{\\underline n}=\\sum\\limits_{i=0}^n(-1)^{n-i}\\begin{bmatrix}n\\\\i\\end{bmatrix}x^i$ 斯特林反演式子一个不会证的式子： $\\sum\\limits_{i=1}^n(-1)^{n-i}\\begin{bmatrix}n\\\\i\\end{bmatrix}\\begin{Bmatrix}i\\\\m\\end{Bmatrix}=\\sum\\limits_{i=1}^n(-1)^{n-i}\\begin{Bmatrix}n\\\\i\\end{Bmatrix}\\begin{bmatrix}i\\\\m\\end{bmatrix}=[n=m]$ 由这个我们可以推出： $f(n)=\\sum\\limits_{i=0}^n\\begin{Bmatrix}n\\\\i\\end{Bmatrix}g(i)\\leftrightarrow g(n)=\\sum\\limits_{i=0}^n(-1)^{n-i}\\begin{bmatrix}n\\\\i\\end{bmatrix}f(i)$ $f(n)=\\sum\\limits_{i=0}^n\\begin{bmatrix}n\\\\i\\end{bmatrix}g(i)\\leftrightarrow g(n)=\\sum\\limits_{i=0}^n(-1)^{n-i}\\begin{Bmatrix}n\\\\i\\end{Bmatrix}f(i)$ 栗子 一个$n$行$m$列的矩阵，每个格子填入一个$[1,c]$的数。求任意两行、任意两列均不同的方案数。$n,m\\le 5000$ 设$g(i)$为$n$行$i$列的矩阵，任意两行不同的方案数。 容易得到$g(i)=A_{c^i}^n$。 设$f(i)$为$n$行$i$列的矩阵的答案。 枚举$g(m)$有多少种不同的列把$g(m)$分类： $g(m)=\\sum\\limits_{i=0}^m\\begin{Bmatrix}m\\\\i\\end{Bmatrix}f(i)$ 解释一下：把$i$种不同列看作$i$个集合，把$m$列分配进$i$个集合里，即$\\begin{Bmatrix}m\\\\i\\end{Bmatrix}$。而对列去重之后就是一个$n$行$i$列的行列都不同的矩阵，即$f(i)$。 反演得$f(m)=\\sum\\limits_{i=0}^m(-1)^{m-i}\\begin{bmatrix}m\\\\i\\end{bmatrix}g(i)$ 矩阵树定理绝大部分内容不予证明。 行列式定义行列式是一个数。 记$\\det(A)$或$|A|$为$n$阶矩阵$A$的行列式，$P$为$(p_1,p_2…p_n)$，即$1\\sim n$的一个排列，$r(P)$为$P$的逆序对数。 $\\det(A)=\\sum\\limits_P(-1)^{r(P)}\\prod\\limits_{i=1}^na_{i,p_i}$ 性质1.$\\det(A)=\\det(A^T)$ 2.将矩阵任意两行交换，行列式取相反数 交换两行可以看做交换排列中的两个数。 假设交换$i,j$行，则会影响到的只有$i,j$之间的逆序对。 记$k$为$i,j$之间任意一行。若$p_k&lt;\\min\\{p_i,p_j\\}$或$p_k&gt;\\max\\{p_i,p_j\\}$对逆序对数显然没有影响；若$p_i&lt;p_k&lt;p_j$，交换后就多了$2$个逆序对，反过来就是少了$2$个逆序对，也就是说$i,j$之间逆序对数变化一定是偶数。 最后$i,j$两者之间一定有$\\pm1$的贡献，所以总逆序对数变化量为奇数。行列式取相反数。 推论：存在两行相同时，行列式的值为$0$ 3.任意一行乘$k$，行列式的值乘$k$ 4.任意一行减去另一行乘$k$，行列式不变 5.根据性质2,4用高斯消元把$A$消成新的上三角矩阵记为$A’$，则$\\det(A)=\\det(A’)$ 计算显然一个上三角矩阵的行列式就是对角线的数的乘积。 根据性质$4$，把矩阵$O(n^3)$消成上三角直接求即可。 但是矩阵树定理一般会涉及到取模的问题，不能直接用两个浮点数做运算。 考虑高斯消元的过程，我们只是想使对应位置消成$0$。 使用辗转相除法。具体地说，如果矩阵有两行： $\\begin{bmatrix}a_1\\cdots\\\\a_2\\cdots\\end{bmatrix}$ 第$1$行减去第$2$行乘$\\left\\lfloor\\frac{a_1}{a_2}\\right\\rfloor$，再交换两行（根据性质$2$答案要取相反数）得到新矩阵： $\\begin{bmatrix}a_2\\cdots\\\\a_1\\bmod a_2\\cdots\\end{bmatrix}$ 类似于求$\\gcd$，不断辗转相除，最终使得第$2$行第$1$列为$0$，复杂度多一个$\\log$，但保证了取模问题。 代码见下文。 矩阵树定理内容矩阵树定理用于解决无向图生成树计数问题。 记$n$阶矩阵$D$为度数矩阵，$A$为邻接矩阵。 $D_{i,i}$为$i$的度数，$A_{i,j}$为$i,j$之间的边数。 令基尔霍夫（Kirchhoff）矩阵$K=D-A$。 对于任意$i$，去掉$K$的第$i$行和第$i$列，所得矩阵的行列式等于改无向图的生成树计数。 实际使用中，对于一条边$(x,y)$，++a[x][x],++a[y][y],--a[x][y],--a[y][x]，对$a$的$2\\sim n$或$1\\sim n-1$行求行列式即可。 代码#define maxn 105 const int mod = 998244353; int a[maxn][maxn],n; inline void add(int x,int y){++a[x][x],++a[y][y],--a[x][y],--a[y][x];} int Gauss(){ int ans=1; for(register int i=2;i&lt;=n;++i){ for(register int j=i+1;j&lt;=n;++j){ while(a[j][i]){ int t=a[i][i]/a[j][i]; for(register int k=i;k&lt;=n;++k)(a[i][k]-=1ll*t*a[j][k]%mod)%=mod,swap(a[i][k],a[j][k]); ans=-ans; } } ans=1ll*ans*a[i][i]%mod; } return (ans+mod)%mod; } 变元矩阵树定理把$D_{i,i}$的定义改为与$i$相连的边权之和，$A_{i,j}$改为$i,j$之间边权之和，就能求出所有生成树边权之积的和。 水题详情请咨询没意思的算法の学习笔记 广义二项式定理推广组合数首先推广组合数到实数域：$C_n^m=\\dfrac{n^{\\underline{m}}}{m!}$ 这里的组合数就没什么实际意义了，只是作为一个式子。 由此能得出负数下的组合数： $C_n^m(n&lt;0)$ $=\\dfrac{n(n-1)(n-2)\\dots(n-m+1)}{m!}$ $=(-1)^m\\dfrac{-n(-n+1)(-n+2)\\dots(-n+m-1)}{m!}$ $=(-1)^m\\dfrac{(m-n-1)^{\\underline{m}}}{m!}$ $=(-1)^mC_{m-n-1}^m$ 推广二项式定理把$(x+y)^k=\\sum\\limits_{n=0}^kC_k^nx^ny^{k-n}$推广到实数域。 展开$(x+y)^\\alpha,\\alpha\\in R$。 这时我们不能确定$n$取到多少这个组合数为$0$，所以上界为$+\\infty$ $(x+y)^\\alpha=\\sum\\limits_{n=0}^\\infty C_\\alpha^nx^ny^{\\alpha-n}$ 这就是牛顿广义二项式定理。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ctz45562.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"容斥","slug":"容斥","permalink":"https://ctz45562.github.io/tags/%E5%AE%B9%E6%96%A5/"},{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"组合数学","slug":"组合数学","permalink":"https://ctz45562.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"斯特林数","slug":"斯特林数","permalink":"https://ctz45562.github.io/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"},{"name":"二项式反演","slug":"二项式反演","permalink":"https://ctz45562.github.io/tags/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/"},{"name":"卢卡斯定理","slug":"卢卡斯定理","permalink":"https://ctz45562.github.io/tags/%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86/"},{"name":"卡特兰数","slug":"卡特兰数","permalink":"https://ctz45562.github.io/tags/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/"},{"name":"prufer序列","slug":"prufer序列","permalink":"https://ctz45562.github.io/tags/prufer%E5%BA%8F%E5%88%97/"},{"name":"矩阵树定理","slug":"矩阵树定理","permalink":"https://ctz45562.github.io/tags/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/"}]},{"title":"洛谷 P5112 FZOUTSY","slug":"洛谷-P5112FZOUTSY","date":"2019-05-11T12:13:27.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/05/11/洛谷-P5112FZOUTSY/","link":"","permalink":"https://ctz45562.github.io/2019/05/11/%E6%B4%9B%E8%B0%B7-P5112FZOUTSY/","excerpt":"传送门 不知道是莫队写假了还是人丑常数大，随便一交就是最劣解$QwQ$。","text":"传送门 不知道是莫队写假了还是人丑常数大，随便一交就是最劣解$QwQ$。 首先来看数据范围：$n^2m\\le 10^{15}$ 开个方：$n\\sqrt{m}\\le 3\\times 10^7$ 这不莫队吗？考虑怎么$O(1)$添加、删除一个后缀的影响。 把串翻转一下就是前缀的最长公共后缀，也就是$SAM$里$parent\\ tree$的$LCA$的$len$。 而且某个点子孙的$len$一定大于它自己的$len$。 这样找到所有最高的$len\\ge k$的节点，它子树中任意两个节点都能产生$1$贡献。 染个色计数跑一遍莫队就完了。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 6000005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } #define son(x,y) son[x][y] struct Query{ int l,r,be,num; bool operator &lt; (const Query &amp;x)const{ if(x.be!=be)return be&lt;x.be; if(be&amp;1)return r&lt;x.r; return r&gt;x.r; } }q[100005]; struct edge{ int pre,to; }e[maxn]; int trans[150],son[maxn][7],fa[maxn],len[maxn],c[maxn],top[maxn],h[maxn],w[maxn]={1},num,cnt=1,last=1,k; long long ans[100005],all; char s[maxn]; inline void add(int from,int to){ e[++num].pre=h[from],h[from]=num,e[num].to=to; } void dfs(int node=1,int tp=0){ if(!tp&amp;&amp;len[node]&gt;=k)tp=node; top[node]=tp; for(register int i=h[node];i;i=e[i].pre)dfs(e[i].to,tp); } void insert(int c){ int p=last,ne=last=++cnt; len[ne]=len[p]+1; while(p&amp;&amp;!son(p,c))son(p,c)=ne,p=fa[p]; if(!p)fa[ne]=1; else { int q=son(p,c); if(len[q]==len[p]+1)fa[ne]=q; else { int sp=++cnt; memcpy(son[sp],son[q],sizeof son[q]); len[sp]=len[p]+1,fa[sp]=fa[q],fa[q]=fa[ne]=sp; while(p&amp;&amp;son(p,c)==q)son(p,c)=sp,p=fa[p]; } } } inline void up(int x){ if(!x)return; all+=(c[x]++); } inline void down(int x){ if(!x)return; all-=(--c[x]); } int main(){ trans[&#39;z&#39;]=1,trans[&#39;o&#39;]=2,trans[&#39;u&#39;]=3,trans[&#39;t&#39;]=4,trans[&#39;s&#39;]=5,trans[&#39;y&#39;]=6; int n=read(),m=read(),sq=n/sqrt(m),l,r;k=read(); scanf(&quot;%s&quot;,s+1); for(register int i=1;i&lt;=n&gt;&gt;1;++i)swap(s[i]=trans[s[i]],s[n-i+1]=trans[s[n-i+1]]); for(register int i=1;i&lt;=n;++i)insert(s[i]); for(register int i=1;i&lt;=n;++i)w[i]=son(w[i-1],s[i]); for(register int i=2;i&lt;=cnt;++i)add(fa[i],i); dfs(); for(register int i=1;i&lt;=n;++i)w[i]=top[w[i]]; for(register int i=1;i&lt;=m;++i)l=read(),r=read(),q[i].l=n-r+1,q[i].r=n-l+1,q[i].num=i,q[i].be=l/sq+1;//原串翻转了，询问区间也要翻转 sort(q+1,q+1+m); l=1,r=0; for(register int i=1;i&lt;=m;++i){ while(l&lt;q[i].l)down(w[l++]); while(l&gt;q[i].l)up(w[--l]); while(r&gt;q[i].r)down(w[r--]); while(r&lt;q[i].r)up(w[++r]); ans[q[i].num]=all; } for(register int i=1;i&lt;=m;++i)printf(&quot;%lld\\n&quot;,ans[i]); } $P.S$：欢迎$dalao$提出蒟蒻哪里写假了，虽然当最劣解也挺好的","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://ctz45562.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"莫队","slug":"莫队","permalink":"https://ctz45562.github.io/tags/%E8%8E%AB%E9%98%9F/"},{"name":"后缀自动机","slug":"后缀自动机","permalink":"https://ctz45562.github.io/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"}]},{"title":"洛谷 P4770 [NOI2018]你的名字","slug":"洛谷-P4770-NOI2018-你的名字","date":"2019-05-11T03:14:26.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/05/11/洛谷-P4770-NOI2018-你的名字/","link":"","permalink":"https://ctz45562.github.io/2019/05/11/%E6%B4%9B%E8%B0%B7-P4770-NOI2018-%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97/","excerpt":"传送门 抄题解的时候其实感觉都还挺套路的。 然而我还是抄了三天。","text":"传送门 抄题解的时候其实感觉都还挺套路的。 然而我还是抄了三天。 造$SAM$，线段树合并得到$endpos$集合。倍增定位到$[l,r]$代表的节点，对于某一个长度$L$，有$endpos\\in [l+L,r]$的节点在$[l,r]$出现过。$T$的子串都是前缀的后缀，找一下$T$每个前缀最长的在$[l,r]$出现过的后缀，记它的长度为$L$。 到这儿都比较套路了。 一开始想倍增找，然而是$\\log^2$的，而且并不能确定$L$也无法保证跳到的节点是否正确。 出门右转题解区，其实直接暴力跳就好。不断缩减$L$检验是否满足条件，若$L$不满足当前节点就跳$fa$。复杂度$O(|T|\\log)$。 然后是去重的问题。 $SAM$本身就能解决本质不同的子串数量，对$T$造$SAM$，不考虑$L$就有$\\sum len[i]-len[fa[i]]$。考虑上就给每个节点限制一个$ma$，表示该节点的串最小长度为$ma$，前面求的$L$求的是每个前缀的限制，就把$L$限制在含有前缀的节点上，复制点也要把$ma$复制过去。答案就为$\\sum \\max\\{len[i]-\\max(len[fa[i]],ma[i]),0\\}$（可能有负数对$0$取$\\max$） 代码： //以下所有比普通SAM多了个t的都是T的SAM #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 1000005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } #define ls(x) ls[x] #define rs(x) rs[x] #define son(x,y) son[x][y] #define sont(x,y) sont[x][y] int ls[maxn*25],rs[maxn*25],h[maxn],num,all,n; int son[maxn][26],fa[maxn],len[maxn],root[maxn],w[maxn]={1},last=1,cnt=1; int sont[maxn][26],fat[maxn],lent[maxn],ma[maxn],lastt,cntt; char s[maxn]; struct edge{ int pre,to; }e[maxn]; inline void add(int from,int to){ e[++num].pre=h[from],h[from]=num,e[num].to=to; } void modify(int poi,int l,int r,int &amp;node){ node=++all; if(l==r)return; int mid=l+r&gt;&gt;1; if(poi&lt;=mid)modify(poi,l,mid,ls(node)); else modify(poi,mid+1,r,rs(node)); } int ask(int L,int R,int l,int r,int node){ if(!node)return 0; if(L&lt;=l&amp;&amp;R&gt;=r)return 1; int mid=l+r&gt;&gt;1; if(L&lt;=mid&amp;&amp;ask(L,R,l,mid,ls(node)))return 1; if(R&gt;mid&amp;&amp;ask(L,R,mid+1,r,rs(node)))return 1; return 0; } int merge(int x,int y){ if(!x||!y)return x|y; int ne=++all; ls(ne)=merge(ls(x),ls(y)); rs(ne)=merge(rs(x),rs(y)); return ne; } void insert(int c){ int p=last,ne=last=++cnt; modify(len[ne]=len[p]+1,1,n,root[ne]); while(p&amp;&amp;!son(p,c))son(p,c)=ne,p=fa[p]; if(!p)fa[ne]=1; else { int q=son(p,c); if(len[q]==len[p]+1)fa[ne]=q; else { int sp=++cnt; memcpy(son[sp],son[q],sizeof son[q]); len[sp]=len[p]+1,fa[sp]=fa[q],fa[q]=fa[ne]=sp; while(p&amp;&amp;son(p,c)==q)son(p,c)=sp,p=fa[p]; } } } void dfs(int node=1){ int x; for(register int i=h[node];i;i=e[i].pre) x=e[i].to,dfs(x),root[node]=merge(root[node],root[x]); } inline void init(){ memset(sont[1],0,sizeof sont[1]); lastt=1,cntt=1; } long long calc(){ long long ans=0; for(register int i=2;i&lt;=cntt;++i) ans+=max(0,lent[i]-max(lent[fat[i]],ma[i])); return ans; } void insertt(int c,int d){ int p=lastt,ne=lastt=++cntt; memset(sont[ne],0,sizeof sont[ne]); lent[ne]=lent[p]+1,ma[ne]=d; while(p&amp;&amp;!sont(p,c))sont(p,c)=ne,p=fat[p]; if(!p)fat[ne]=1; else { int q=sont(p,c); if(lent[q]==lent[p]+1)fat[ne]=q; else { int sp=++cntt; memcpy(sont[sp],sont[q],sizeof sont[q]); ma[sp]=ma[q],lent[sp]=lent[p]+1,fat[sp]=fat[q],fat[q]=fat[ne]=sp; while(p&amp;&amp;sont(p,c)==q)sont(p,c)=sp,p=fat[p]; } } } int main(){ scanf(&quot;%s&quot;,s+1),n=strlen(s+1); int m,l,r,node,N,L; for(register int i=1;i&lt;=n;++i)insert(s[i]-&#39;a&#39;); for(register int i=1;i&lt;=n;++i)w[i]=son(w[i-1],s[i]-&#39;a&#39;); for(register int i=2;i&lt;=cnt;++i)add(fa[i],i); dfs(); m=read(); while(m--){ scanf(&quot;%s&quot;,s+1),N=strlen(s+1),l=read(),r=read(); init(),node=1,L=0; for(register int i=1;i&lt;=N;++i){ if(son(node,s[i]-&#39;a&#39;)&amp;&amp;ask(l+L,r,1,n,root[son(node,s[i]-&#39;a&#39;)]))node=son(node,s[i]-&#39;a&#39;),++L; else { while(L&amp;&amp;(!son(node,s[i]-&#39;a&#39;)||!ask(l+L,r,1,n,root[son(node,s[i]-&#39;a&#39;)]))){ --L; if(L==len[fa[node]])node=fa[node]; } if(!son(node,s[i]-&#39;a&#39;)||!ask(l+L,r,1,n,root[son(node,s[i]-&#39;a&#39;)]))node=1,L=0; else node=son(node,s[i]-&#39;a&#39;),++L; } insertt(s[i]-&#39;a&#39;,L); } printf(&quot;%lld\\n&quot;,calc()); } } 一些闲扯： 关于这道题 它让我写了一个星期，在看了题解后依然抄了三天 让我在二轮后不想去机房，因为一去机房就要继续写这屑题 让我丧失学OI的信心 让我决定立刻结束字符串的学习 让我对曾经认为一辈子都不会学的计算几何产生了兴趣 不过其实这道题对$SAM$的能有更深入的认识吧，也涨了不少姿势。 而且在$loj$上交的时候出现了一个神奇的问题：因为编译出的$exe$过大（$9MB$，我也不知道为啥会这么大啊$QAQ$）不支持运行导致$CE$？ 喵喵喵？","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://ctz45562.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"后缀自动机","slug":"后缀自动机","permalink":"https://ctz45562.github.io/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"线段树合并","slug":"线段树合并","permalink":"https://ctz45562.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/"}]},{"title":"SDOI2019R2 养生游记","slug":"SDOI2019R2养生游记","date":"2019-05-09T04:27:51.000Z","updated":"2021-07-19T09:14:32.237Z","comments":true,"path":"2019/05/09/SDOI2019R2养生游记/","link":"","permalink":"https://ctz45562.github.io/2019/05/09/SDOI2019R2%E5%85%BB%E7%94%9F%E6%B8%B8%E8%AE%B0/","excerpt":"$R1$后都$rank\\ 76$了真的没救了，于是$R2$前学了$SA$和$SAM$，做好了爆零的准备，就当是来旅游了$QwQ$","text":"$R1$后都$rank\\ 76$了真的没救了，于是$R2$前学了$SA$和$SAM$，做好了爆零的准备，就当是来旅游了$QwQ$ Day -1打算出发之前把「你的名字」切掉。 诶你们怎么都要跑啊？问了一圈发现就我和$A$哥（学长）晚上留在机房。 $asuldb$：还有$A$哥晚上陪着你，和你共度春宵 于是我也跟着溜了，也没有切掉你的名字。 （后来听说$A$哥孤身一人坚守机房面对$loli$，壮士啊） Day 0在家颓废了一上午。 总结一下收获： 我TM吹爆「约定的梦幻岛」！ 下午继续在车上颓废，得知了$JF$上午做了些大涨$RP$的事情。（滑稽） 大概$5$个小时才到，跟$challestend$住一块。接着去报道试机，从宾馆到考场徒步走要二十分钟而且大部分都是上坡，原来学OI对体育有要求。 记录对话一则： $ctz$：你看我就是来旅游的，到时候我要是坐在$rqy$、$ckw$等人旁边，一开考十分钟我就开始玩扫雷故意让他们看到，他们就会很方。 $asuldb$：然后一小时后你去上个厕所，回来发现他们已经三个对拍挂上玩着扫雷、蜘蛛纸牌，你就会更方 感觉考场环境还不错，$win\\ 7$好评，但是$delete$、$home$、$end$几个键的布局很诡异老摁不着，而且按键海拔比较低很难受。 先敲了个$SA$，然而它挂了。。。 感觉很方，半个月前刚学的怎么就挂了？查了大概十分钟发现n-k+i写成了n-i+k，终于过了。 又听从了$JF$建议敲了个最大流和费用流，并没有检验正确性，打算晚上再看看网络流板子。 最后打了个$SAM$就出来了。 $loli$带着去某饭店吃饭，让我们自己点菜就走了。 然后学长带着$asuldb$溜回去叫外卖了，还剩我、$JF$、$challestend$和杜爷。过了一会$challestend$也坐不住跑路了。 最后三个人很尬地点了$5$碗面条和$3$个菜。 晚上回宾馆继续颓废。$challestend$拿出了笔记本和很酷很炫的机械键盘，大概是写代码吧。 他疯狂敲击键盘的声音让在一旁玩手机的我自叹不如，真是努力啊 凑过去一看写的是——原来是在打东方。。。 宾馆的插座很松，插头老掉下来，十分担心晚上手机充不上电直接影响第二天的颓废 由于知道往年$SDOI\\ R2$的毒瘤，暗自打算一定要比赛中玩扫雷。 最后十点半睡了。因为没啥压力（旅游有什么压力）没有像$R1$一样睡不着。 Day 1还好手机充上电了。。。 吃了一个豆沙包和俩油条。油条很凉很硬感觉是昨天剩的不过还是吃下去了。 终于知道$loli$宾馆选址的良苦用心了，经过长途跋涉后精神了许多。 这次居然不仅有$Dev$，还提供了$Vim$、$sublime$、$VS\\ code$和没听说过的$code\\ block$（有$Vim$没有$Emacs$2333），但是都没有配置，本来打算用$Vim$的然而编译函数都没配出来还是回归了$Dev$。 开考先扫了遍题，哇$T1$居然是水数据结构！$T2$是个$DP$？$T3$题目有点长先没看。 决定先从$T1$下手。 单点改、全局加、全局赋值、全局乘、全局求和、单点求值，然而序列长度$1e9$，操作次数$1e7$，显然要线性时间。 想了几种数据结构做法发现都带$\\log$并不可行，先打了个$50$分的线段树拍着。 此时过了不到一小时，$T2$想了个$O(nc^2)$的$DP$，能收获一个大零蛋没往上写；重新读了遍$T3$，原来是个区间$MST$，打了个$10$分的暴力上去。 还是回去肝$T1$吧。 只有单点和全局操作，而且标准操作只有$1e5$个，也就是说真正要维护的位置不超过$1e5$个，其他位置的值都是统一的。 先离散化一下。再把每个$a_i$、$b_i$的$q$个操作搬下来。由于有单点赋值，可以维护一下每个点最后一次赋值的时间，所以现在要解决的就是给一个值$v$和操作区间$[l,r]$，$O(1)$得到$v$在经过$[l,r]$的操作后得到的值。 在纸上推了推发现珂以用前缀和、前缀积解决。还涉及到模意义下的除法，得预处理一下逆元（怪不得模数是$1e7+19$），还好背过了线性预处理逆元 原来并没有用到数据结构。。。 二十分钟写出来$RE$了，发现前缀积有负数逆元挂了，模成正数，过了样例 把线段树和它拍着，没啥问题。加大数据后$WA$了一组。 线段树挂了？换成暴力还是不对。爆$int$了？#define int long long依然不行。 数据规模在$1e3$只能硬调。大概输出调试了一小时，发现有一个操作全局乘$0$导致后面前缀积全为$0$，于是强行把乘$0$改为赋值为$0$就$A$了。 又拍了一会没啥问题测速度。上来蹦出个$8800ms$瞬间方了。 查了一下原来数据开成$5e7$次操作了。 改了后稳定在$1000ms$。 我居然在$SDOI\\ R2$里切题了！这事儿我能吹一年 就剩半个小时了，无心再写题，拍上暴力和速度玩起了扫雷。（一局没赢嘤嘤嘤） 出来后发现好像都会$T1$，$challestend$逆元用的$exgcd$带个$\\log$，一口一个“我凉了”“我爆零了”“你们都好强啊”。由于$R1$见识过$challestend$的假，我清楚$challestend\\ T1$稳过。 $T3$还有个$n=1$的$10$分，当时我在玩扫雷没注意，难受。 $loli$又带我们去昨天的饭店，他提前点好了两桌菜，哈哈哈这回你们一个也别想跑 因为后面两道题比较毒瘤所以咕了下午的讲题。 得分$110$，$rank24$，一分没挂很开心。$challestend$也是$110$，果然带$\\log$稳过$T1$。大众分$120$。 下午和$challestend$继续颓废。期间$loli$来奶，收获了金句名言$loli$原话： $\\text{zyc}$（$challestend$）比较稳。 永七神明坠落线打残了（以为烟花的任务给两天时间不慌把赛姐攻略了），皇室各种被虐一路掉分，大概是上午把$RP$耗光了 晚上$loli$说要带我们去吃$KFC$，五点半在大厅集合。下去后发现只有$asuldb$、宽嫂和$fuge$，甚至$loli$都不在，决定一起咕掉。回来的时候看到准备下去的$JF$和杜爷又跟了下去。 一楼大厅，$loli$，$JF$，$challestend$，杜爷，我。 鼓起勇气把他们咕了的事告诉$loli$，就又变成了我们四个出去吃。$challestend$见状头也不回地跑了。（似曾相识） 回宾馆继续颓废。 因为更加担心插头掉下来进行了如下处理： Day 2从$R1$到现在没有一道网络流，认为今天必定有一道。于是开考前先把最大流、费用流敲了。 浏览一遍题发现凉了。 写了个$T3\\ 20$分的$SAM$想钻研一下$T3$。 打个表发现数列在$0110$和$1001$之间不断循环，于是把$0110$看作$0$，$1001$看作$1$再打一遍，发现又是$0110$和$1001$不断循环。 无限循环打了五个小时的表 这好像是道神仙题。。。$T2$博弈论秒弃，开始看$T1$ 你看它长得多像网络流啊！（然而并不是） 发现$p$和$q$是独立的而且都要尽可能大。突然傻了，认为$p$最大就是所有人都去第一场聚会，$p$就是最小度数。接下来四小时一直认定这个死理。 $q$最大就是一般图的最大独立集？不会有什么带花树吧？而且二分图的定理在一般图上适用吗？ 本来我也不会带花树。打了个爆搜上去，这是要爆零的节奏啊。 是不是补图的边双？然而我连边双都不会，魔改了一下缩点，大概能求边双，又发现不是边双，应当是为完全图的子图（后来我才知道那玩意叫团） 彻底懵了，想写个贪心又无从下手。 拍了拍爆搜的速度还写了个checker，又$WA$又$T$。改了改后，无解的数据我能跑满指数复杂度，中间有说过数据保证有解，但是$T$了我也不知道是因为无解还是真的跑不过。 算了把爆搜交上去吧。$20$分退役预定。 又一次在扫雷中结束了。（终于赢了一局） 中午$loli$给叫的$KFC$外卖。。。 你们欺负我不会随机化算法嘤嘤嘤 下午出成绩。容我先笑会： 哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈我的错误结论和爆搜能跑出来80分 总分$100$，又是$rank24$。 魏老师高一进队$NB$！asuldb最终没抢过魏老师女队名额2333 后记本来是打算当旅游的，不过结果还算满意。 没啥可说的，既然$RP$在这里耗光了 那么就预祝我CSP2019初赛退役","categories":[{"name":"日常","slug":"日常","permalink":"https://ctz45562.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://ctz45562.github.io/tags/OI/"},{"name":"游记","slug":"游记","permalink":"https://ctz45562.github.io/tags/%E6%B8%B8%E8%AE%B0/"}]},{"title":"Codeforces700E Cool Slogans","slug":"洛谷-CF700E-CoolSlogans","date":"2019-05-02T13:53:29.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/05/02/洛谷-CF700E-CoolSlogans/","link":"","permalink":"https://ctz45562.github.io/2019/05/02/%E6%B4%9B%E8%B0%B7-CF700E-CoolSlogans/","excerpt":"传送门 洛咕的翻译简洁明了清晰易懂，我只用了半小时就明白了题意。","text":"传送门 洛咕的翻译简洁明了清晰易懂，我只用了半小时就明白了题意。 概括一下题意： 给定一个字符串$S$，构造一个字符串数组$str$，满足任意$str[i]$为$S$的一个子串，且$str[i]$在$str[i-1]$中出现至少$2$次。求$str$数组最大大小。 如果$SAM$的节点$A$的某个串在节点$B$的某个串中出现了至少两次，则任意一个$B$的$endpos$，$A$在$[endpos-len[B]+len[A],endpos]$都有至少$2$个$endpos$ 所以没必要每个$endpos$都检验一遍，任取一个查询即可，线段树合并实现。 我们把$str$数组倒过来，满足条件为$str[i]$在$str[i+1]$中出现至少$2$次，答案不会变。 设$f(i)$为以点$i$的串为最后一个串，数组最大大小。显然如果它在某个点的串出现过至少$2$次就可以$+1$转移过去。然而待检验的点是$O(n)$的，肯定是不行的。 举个栗子：ab可以向ababa转移，但是这个转移是不优的。明显转移到abab会更好（它比ababa短，就更容易转移向其他的点）。那么一个点转移它的子孙是最优的。 转移的时候记录$str$数组最后一个串是哪个点，判断的时候要用该点的$endpos$。 妙啊！ 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 500005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } #define ls(x) ls[x] #define rs(x) rs[x] #define son(x,y) son[x][y] int ls[maxn&lt;&lt;5],rs[maxn&lt;&lt;5],root[maxn],all; int son[maxn][26],fa[maxn],len[maxn],pos[maxn],f[maxn],tax[maxn],cur[maxn],top[maxn],last=1,cnt=1,n; char s[maxn]; void modify(int poi,int l,int r,int &amp;node){ node=++all; if(l==r)return; int mid=l+r&gt;&gt;1; if(poi&lt;=mid)modify(poi,l,mid,ls(node)); else modify(poi,mid+1,r,rs(node)); } int ask(int L,int R,int l,int r,int node){ if(!node)return 0; if(L&lt;=l&amp;&amp;R&gt;=r)return 1; int mid=l+r&gt;&gt;1; if(L&lt;=mid&amp;&amp;ask(L,R,l,mid,ls(node)))return 1; if(R&gt;mid&amp;&amp;ask(L,R,mid+1,r,rs(node)))return 1; return 0; } int merge(int x,int y,int l,int r){ if(!x||!y)return x|y; int mid=l+r&gt;&gt;1,ne=++all; ls(ne)=merge(ls(x),ls(y),l,mid); rs(ne)=merge(rs(x),rs(y),mid+1,r); return ne; } void insert(int c){ int p=last,ne=last=++cnt; modify(pos[ne]=len[ne]=len[p]+1,1,n,root[ne]); while(p&amp;&amp;!son(p,c))son(p,c)=ne,p=fa[p]; if(!p)fa[ne]=1; else { int q=son(p,c); if(len[q]==len[p]+1)fa[ne]=q; else { int sp=++cnt; memcpy(son[sp],son[q],sizeof son[q]); fa[sp]=fa[q],len[sp]=len[p]+1,fa[q]=fa[ne]=sp; while(p&amp;&amp;son(p,c)==q)son(p,c)=sp,p=fa[p]; } } } int main(){ int x,y,ans=1; n=read(),scanf(&quot;%s&quot;,s+1); for(register int i=1;i&lt;=n;++i)insert(s[i]-&#39;a&#39;); for(register int i=1;i&lt;=cnt;++i)++tax[len[i]]; for(register int i=1;i&lt;=n;++i)tax[i]+=tax[i-1]; for(register int i=1;i&lt;=cnt;++i)cur[tax[len[i]]--]=i; for(register int i=cnt;i;--i)if(y=fa[x=cur[i]])root[y]=merge(root[y],root[x],1,n),pos[y]=pos[x]; for(register int i=2;i&lt;=cnt;++i){ y=top[fa[x=cur[i]]]; if(!y){f[x]=1,top[x]=x;continue;} if(ask(pos[x]-len[x]+len[fa[y]],pos[x]-1,1,n,root[y]))ans=max(ans,f[x]=f[y]+1),top[x]=x; else top[x]=y; } printf(&quot;%d\\n&quot;,ans); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"字符串","slug":"字符串","permalink":"https://ctz45562.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"后缀自动机","slug":"后缀自动机","permalink":"https://ctz45562.github.io/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"线段树合并","slug":"线段树合并","permalink":"https://ctz45562.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/"}]},{"title":"Codeforces271D Good Substrings","slug":"洛谷-CF271D-Good-Substrings","date":"2019-04-30T00:28:06.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/04/30/洛谷-CF271D-Good-Substrings/","link":"","permalink":"https://ctz45562.github.io/2019/04/30/%E6%B4%9B%E8%B0%B7-CF271D-Good-Substrings/","excerpt":"传送门 十分板子的$SAM$题了。 没有$SAM$题解赶紧水一发。","text":"传送门 十分板子的$SAM$题了。 没有$SAM$题解赶紧水一发。 把不好的字母的转移边权值视为$1$，好的字母权值视为$0$，这个题就是求$SAM$上从根节点出发，有多少条路径长度$\\le k$。 设$f(i,j)$表示从节点$i$出发，有多少条路径长度为$j$。 方程：$f(i,j)=\\sum f(son(i,c),j-ba[c])$（$ba[c]$表示$c$是否为不好的字母） 还有一种路径是直接从$i$到它的儿子的，对于$i$的每一条存在的转移边，$++f(i,ba[c])$即可。 答案为$\\sum\\limits_{i=0}^{k}f(1,i)$。因为$SAM$包含的子串不重不漏，所以求出来的也就本质不同。 复杂度看起来有点假，实际上分析一波就会发现转移次数不超过边数，单次转移是$O(n)$的，总复杂度$O(n^2)$ 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 5005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } #define son(x,y) son[x][y] int son[maxn][26],fa[maxn],len[maxn],f[maxn][1505],n,m,k,last=1,cnt=1; bool vis[maxn],ba[26]; char s[maxn]; void insert(int c){ int p=last,ne=last=++cnt; len[ne]=len[p]+1; while(p&amp;&amp;!son(p,c))son(p,c)=ne,p=fa[p]; if(!p)fa[ne]=1; else { int q=son(p,c); if(len[q]==len[p]+1)fa[ne]=q; else { int sp=++cnt; memcpy(son[sp],son[q],sizeof son[q]); fa[sp]=fa[q],len[sp]=len[p]+1,fa[q]=fa[ne]=sp; while(p&amp;&amp;son(p,c)==q)son(p,c)=sp,p=fa[p]; } } } void dp(int node=1){ vis[node]=1; int x; for(register int i=0;i&lt;26;++i){ x=son(node,i); if(!x)continue; if(!vis[x])dp(x); ++f[node][ba[i]]; for(register int j=0;j&lt;=k;++j) if(j-ba[i]&gt;=0)f[node][j]+=f[x][j-ba[i]]; } } int main(){ scanf(&quot;%s&quot;,s+1),n=strlen(s+1); for(register int i=1;i&lt;=n;++i)insert(s[i]-&#39;a&#39;); scanf(&quot;%s&quot;,s+1); for(register int i=0;i&lt;26;++i)ba[i]=(s[i+1]==&#39;0&#39;); k=read(),dp(); int ans=0; for(register int i=0;i&lt;=k;++i)ans+=f[1][i]; printf(&quot;%d\\n&quot;,ans); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"字符串","slug":"字符串","permalink":"https://ctz45562.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"后缀自动机","slug":"后缀自动机","permalink":"https://ctz45562.github.io/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"}]},{"title":"bzoj 3218 a+b Problem","slug":"bzoj-3218-a+b-Problem","date":"2019-04-28T13:37:34.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/04/28/bzoj-3218-a+b-Problem/","link":"","permalink":"https://ctz45562.github.io/2019/04/28/bzoj-3218-a+b-Problem/","excerpt":"通往bzojの传送门 通往51nodの传送门 在比赛上见到这个题，发现我根本就不会网络流，连经典模型都不会。嘤嘤嘤 不过厚颜无耻地在zhuoer和题解的帮助下A掉了","text":"通往bzojの传送门 通往51nodの传送门 在比赛上见到这个题，发现我根本就不会网络流，连经典模型都不会。嘤嘤嘤 不过厚颜无耻地在zhuoer和题解的帮助下A掉了 首先进行小学生都会的移项变换： $\\ \\sum\\limits_{i\\in white} w_i+\\sum\\limits_{i\\in black}b_i-\\sum\\limits_{i\\in bad}p_i\\\\=\\sum(w_i+b_i)-\\sum\\limits_{i\\in black}w_i-\\sum\\limits_{i\\in white}b_i-\\sum\\limits_{i\\in bad}p_i$ 建模： 每个点$i$分出来一个$i’$。 源点向$i$连流量为$b_i$的边 $i$向汇点连流量为$w_i$的边 $i$向$i’$连流量为$p_i$的边 $i’$向所有能使$i$变坏的点$j$连流量为$inf$的边 就是酱紫： 答案就是$\\sum(w_i+b_i)$减去最小割。 对于点$i$，为了使源汇不连通，首先要么割掉$b_i$，要么割掉$w_i$。前者代表它为白点，后者代表它为黑点。 如果割$b_i$，已经满足不联通了，就不用考虑$p_i$。 如果割$w_i$，若$j$割了$b_j$（即$j$为白点），则还有一条路径$S\\rightarrow i\\rightarrow i’\\rightarrow j\\rightarrow T$。 在$p_i$、$b_i$、$w_j$里割一条边。割掉它们有啥意义呢？ 若割掉$p_i$，就是付出坏点的代价 若割掉$b_i$，把$i$点由黑点改为白点 若割掉$w_j$，把$j$点由白点改为黑点 为啥要开一个$i’$连$inf$边呢？ $i$可能有好几个$j$要连，但是多个满足条件的$j$只有会产生一次$p_i$，所以拆点限制。 Q：为啥这种沙雕题要写这么详细？ A：因为我太蒻了，看了题解搞了很久才明白。。。 边数是$n^2$的，主席树优化建图达到$n\\log n$ 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 50005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } #define ls(x) ls[x] #define rs(x) rs[x] int line[maxn&lt;&lt;5],st,en,h[maxn&lt;&lt;5],fl[maxn&lt;&lt;5],ls[maxn&lt;&lt;5],rs[maxn&lt;&lt;5],id[maxn],root[maxn],head,tail,num=1,cnt; int a[maxn],b[maxn],ll[maxn],rr[maxn],p[maxn],w[maxn],dis[maxn&lt;&lt;2],len; struct edge{ int pre,to,flow; }e[maxn&lt;&lt;6]; inline void add(int from,int to,int l){ if(!from||!to)return; e[++num].pre=h[from],h[from]=num,e[num].to=to,e[num].flow=l; e[++num].pre=h[to],h[to]=num,e[num].to=from,e[num].flow=0; } bool bfs(){ memset(fl,0,sizeof fl); fl[st]=tail=1,head=0; while(head&lt;tail){ int node=line[++head],x; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; if(!fl[x]&amp;&amp;e[i].flow){ fl[x]=fl[node]+1; if(x==en)return 1; line[++tail]=x; } } } return 0; } int dfs(int node=st,int qu=inf){ if(node==en)return qu; int rest=qu,x,k; for(register int i=h[node];i&amp;&amp;rest;i=e[i].pre){ x=e[i].to; if(fl[x]==fl[node]+1&amp;&amp;e[i].flow){ k=dfs(x,min(e[i].flow,rest)); if(!k)fl[x]=0; else rest-=k,e[i].flow-=k,e[i^1].flow+=k; } } return qu-rest; } void build(int poi,int l,int r,int &amp;node,int ol){ node=++cnt,add(node,ol,inf); if(l==r){ add(node,poi,inf); return; } int mid=l+r&gt;&gt;1,ans; if(a[poi]&lt;=mid)rs(node)=rs(ol),build(poi,l,mid,ls(node),ls(ol)); else ls(node)=ls(ol),build(poi,mid+1,r,rs(node),rs(ol)); add(node,ls(node),inf),add(node,rs(node),inf); } void modify(int L,int R,int l,int r,int node,int poi){ if(!node)return; if(L&lt;=l&amp;&amp;R&gt;=r){add(poi,node,inf);return;} int mid=l+r&gt;&gt;1; if(L&lt;=mid)modify(L,R,l,mid,ls(node),poi); if(R&gt;mid)modify(L,R,mid+1,r,rs(node),poi); } int main(){ int n=read(),ans=0; cnt=(n&lt;&lt;1)+2; for(register int i=1;i&lt;=n;++i) dis[++len]=a[i]=read(),b[i]=read(),w[i]=read(),dis[++len]=ll[i]=read(),dis[++len]=rr[i]=read(),p[i]=read(); sort(dis+1,dis+1+len); len=unique(dis+1,dis+1+len)-dis-1; for(register int i=1;i&lt;=n;++i){ a[i]=lower_bound(dis+1,dis+1+len,a[i])-dis; ll[i]=lower_bound(dis+1,dis+1+len,ll[i])-dis; rr[i]=lower_bound(dis+1,dis+1+len,rr[i])-dis; build(i,1,len,root[i],root[i-1]); } line[1]=st=cnt+n+n+1,en=st+1; for(register int i=1;i&lt;=n;++i){ add(st,i,b[i]),add(i,i+n,p[i]),add(i,en,w[i]); modify(ll[i],rr[i],1,len,root[i-1],i+n),ans+=b[i]+w[i]; } while(bfs())ans-=dfs(); printf(&quot;%d\\n&quot;,ans); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://ctz45562.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"网络流","slug":"网络流","permalink":"https://ctz45562.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"最小割","slug":"最小割","permalink":"https://ctz45562.github.io/tags/%E6%9C%80%E5%B0%8F%E5%89%B2/"},{"name":"主席树","slug":"主席树","permalink":"https://ctz45562.github.io/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"}]},{"title":"Codeforces1037H Security","slug":"洛谷-CF1037H-Security","date":"2019-04-28T12:50:20.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/04/28/洛谷-CF1037H-Security/","link":"","permalink":"https://ctz45562.github.io/2019/04/28/%E6%B4%9B%E8%B0%B7-CF1037H-Security/","excerpt":"传送门 说实话做这个题之前我都不知道CF有H题","text":"传送门 说实话做这个题之前我都不知道CF有H题 字典序尽量小又要严格大于模式串，记模式串为$S$，则贪心让前面最多的字符和$S$相同，在后面再补一个比$S$大且最小的字符。 则最优的方案一定是在$S$后面补一个尽可能小的字符。如果补不了，就倒着枚举位置，如果当前位置$i$能替换为一个比$S_i$大的字符，找到最小的可替换字符$c$换掉它。答案就是$S(1\\sim i-1)+’c’$。 以下用“好点”表示包含$[L,R]$子串的节点。 先把母串的$SAM$造出来。 对每个模式串，找出仅走“好点”，能匹配的最大长度$max\\underline{}len$。同时找出每个位置$i$最小的字符$nex$，满足$c&gt;S_i$且从$i-1$匹配的节点走$nex$边的儿子为“好点”（没有为$-1$）。 从$max\\underline{}len$倒着枚举，找到第一个不为$-1$的位置$i$，$S(1\\sim i-1)+nex_i$即为答案。 至于怎么判断一个节点是否为“好点”，用线段树合并获取每个节点$endpos$的所有元素。假设当前走到的长度为$i$，$endpos$中存在$pos$满足$pos\\in [L,R]$且$pos-i+1\\in [L,R]$的节点为“好点”。合起来就是$pos\\in [L+i-1,R]$。 空间$O(n\\log n)$，时间$O(26n\\log n)$（实际情况远跑不满） 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 400005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } #define son(x,y) son[x][y] #define ls(x) ls[x] #define rs(x) rs[x] int h[maxn],root[maxn],ls[maxn&lt;&lt;5],rs[maxn&lt;&lt;5],all,num; int son[maxn][26],len[maxn],fa[maxn],nex[maxn],last=1,cnt=1,n,N; char s[maxn]; struct edge{ int pre,to; }e[maxn]; inline void add(int from,int to){ e[++num].pre=h[from],h[from]=num,e[num].to=to; } void modify(int poi,int l,int r,int &amp;node){ node=++all; if(l==r)return; int mid=l+r&gt;&gt;1; if(poi&lt;=mid)modify(poi,l,mid,ls(node)); else modify(poi,mid+1,r,rs(node)); } int merge(int x,int y,int l,int r){ if(!x||!y||l==r)return x|y; int ne=++all,mid=l+r&gt;&gt;1; ls(ne)=merge(ls(x),ls(y),l,mid); rs(ne)=merge(rs(x),rs(y),mid+1,r); return ne; } bool ask(int L,int R,int l,int r,int node){ if(!node)return 0; if(L&lt;=l&amp;&amp;R&gt;=r)return 1; int mid=l+r&gt;&gt;1; if(L&lt;=mid&amp;&amp;ask(L,R,l,mid,ls(node)))return 1; if(R&gt;mid&amp;&amp;ask(L,R,mid+1,r,rs(node)))return 1; return 0; }//询问endpos在[L,R]中是否有元素 void insert(int c){ int p=last,ne=last=++cnt; modify(len[ne]=len[p]+1,1,N,root[ne]); while(p&amp;&amp;!son(p,c))son(p,c)=ne,p=fa[p]; if(!p)fa[ne]=1; else { int q=son(p,c); if(len[q]==len[p]+1)fa[ne]=q; else { int sp=++cnt; memcpy(son[sp],son[q],sizeof son[q]); fa[sp]=fa[q],len[sp]=len[p]+1,fa[q]=fa[ne]=sp; while(p&amp;&amp;son(p,c)==q)son(p,c)=sp,p=fa[p]; } } } void dfs(int node=1){ int x; for(register int i=h[node];i;i=e[i].pre) x=e[i].to,dfs(x),root[node]=merge(root[node],root[x],1,N); }//求endpos集合 int main(){ scanf(&quot;%s&quot;,s+1),N=strlen(s+1); for(register int i=1;i&lt;=N;++i)insert(s[i]-&#39;a&#39;); for(register int i=2;i&lt;=cnt;++i)add(fa[i],i); dfs(); int m=read(),l,r,node,x,i; while(m--){ l=read(),r=read(),node=1; scanf(&quot;%s&quot;,s+1),n=strlen(s+1); for(i=1;;++i){ nex[i]=-1; for(register int j=max(s[i]-&#39;a&#39;+1,0);j&lt;26;++j){ x=son(node,j); if(x&amp;&amp;ask(l+i-1,r,1,N,root[x])){ nex[i]=j; break; } } x=son(node,s[i]-&#39;a&#39;); if(!x||i==n+1||!ask(l+i-1,r,1,N,root[x]))break; node=x; } while(i&amp;&amp;nex[i]==-1)--i; if(!i)puts(&quot;-1&quot;);//找不到，无解 else { for(register int j=1;j&lt;i;++j)px(s[j]); px(nex[i]+&#39;a&#39;); pn; } } }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://ctz45562.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"后缀自动机","slug":"后缀自动机","permalink":"https://ctz45562.github.io/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"线段树合并","slug":"线段树合并","permalink":"https://ctz45562.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/"}]},{"title":"USACO-17DEC Standing Out from the Herd","slug":"洛谷-P4081-USACO17DECStanding-Out-from-the-Herd","date":"2019-04-26T23:45:50.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/04/27/洛谷-P4081-USACO17DECStanding-Out-from-the-Herd/","link":"","permalink":"https://ctz45562.github.io/2019/04/27/%E6%B4%9B%E8%B0%B7-P4081-USACO17DECStanding-Out-from-the-Herd/","excerpt":"传送门 感觉我的做法好鬼畜啊。。。是不是错了啊 不过可爱的$asuldb$跟我做法一样诶$QwQ$","text":"传送门 感觉我的做法好鬼畜啊。。。是不是错了啊 不过可爱的$asuldb$跟我做法一样诶$QwQ$ 把所有串用特殊字符隔开，拼一块造$SAM$。 $endpos$集合就是子串出现位置，如果一个节点的$endpos$只在一个串里出现过，它就可以算进独特值里。 造$SAM$的时候可以给节点染个色，然后在$parent\\ tree$上向上合并，如果某个节点只有一种颜色$x$，就可以给$x$产生贡献。 因为把所有串拼了起来，会有不是$x$的子串出现，就要记录一下最大的$endpos$值$ma$，显然$ma[i]=\\max\\{ma[j]\\}(fa[j]=i)$，再记录一下每个串左端点的位置$ll[x]$，贡献就是$(ma[i]-len[fa[i]])-\\max\\{ma[i]-len[i]+1,ll[x]\\}+1$ 有可能该节点没有一个子串属于$x$，就会有负数，对$0$取个$\\max$就好啦。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 200005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } #define son(x,y) son[x][y] int h[maxn],col[maxn],ll[maxn],ma[maxn],son[maxn][27],fa[maxn],len[maxn],ans[maxn],last=1,cnt=1,all,num,n; char s[maxn]; struct edge{ int pre,to; }e[maxn]; inline void add(int from,int to){ e[++num].pre=h[from],h[from]=num,e[num].to=to; } inline void merge(int &amp;x,int y){ if(x==y)return; if(x==-1||y==-1||x&amp;&amp;y)x=-1; else x=x|y; }//合并颜色 void insert(int c,int i=0){ int p=last,ne=last=++cnt; len[ne]=len[p]+1,ma[ne]=len[ne],col[ne]=i;//染色 while(p&amp;&amp;!son(p,c))son(p,c)=ne,p=fa[p]; if(!p)fa[ne]=1; else { int q=son(p,c); if(len[q]==len[p]+1)fa[ne]=q; else { int sp=++cnt; memcpy(son[sp],son[q],sizeof son[q]); fa[sp]=fa[q],len[sp]=len[p]+1,fa[q]=fa[ne]=sp; while(p&amp;&amp;son(p,c)==q)son(p,c)=sp,p=fa[p]; } } } void dfs(int node=1){ int x; for(register int i=h[node];i;i=e[i].pre) x=e[i].to,dfs(x),merge(col[node],col[x]),ma[node]=max(ma[node],ma[x]); x=col[node]; if(~x)ans[x]+=max((ma[node]-len[fa[node]])-max(ma[node]-len[node]+1,ll[x])+1,0); } int main(){ n=read(); int m,N=0; for(register int i=1;i&lt;=n;++i){ scanf(&quot;%s&quot;,s+1),m=strlen(s+1); for(register int j=1;j&lt;=m;++j)insert(s[j]-&#39;a&#39;,i); ll[i]=N+1,N+=m+1;//记录左端点 if(i!=n)insert(26);//特殊字符 } for(register int i=2;i&lt;=cnt;++i)add(fa[i],i); dfs(); for(register int i=1;i&lt;=n;++i)printf(&quot;%d\\n&quot;,ans[i]); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://ctz45562.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"后缀自动机","slug":"后缀自动机","permalink":"https://ctz45562.github.io/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"}]},{"title":"洛谷 P4022 [CTSC2012]熟悉的文章","slug":"洛谷-P4022-CTSC2012熟悉的文章","date":"2019-04-26T07:46:44.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/04/26/洛谷-P4022-CTSC2012熟悉的文章/","link":"","permalink":"https://ctz45562.github.io/2019/04/26/%E6%B4%9B%E8%B0%B7-P4022-CTSC2012%E7%86%9F%E6%82%89%E7%9A%84%E6%96%87%E7%AB%A0/","excerpt":"传送门 妈妈我能独立切CTSC黑题啦！（虽然我承认这题不算难）","text":"传送门 妈妈我能独立切CTSC黑题啦！（虽然我承认这题不算难） 以下，用$S(l,r)$表示字符串$S$从$l$位置开始到$r$的子串，$n$表示待考察作文串的长度。 答案很明显有单调性。因为若长度$i$可行的话，则存在和长度$i$相同的方案使所有$j(&lt;i)$也可行。 考虑二分答案。设$rr[i]$表示最大的满足$S(i,rr[i])$为作文库子串的位置。 把所有作文库的串用特殊字符隔开造$SAM$，枚举每个位置匹配预处理$rr[i]$。 容易发现$rr[i]$的一个性质：$rr[i]\\ge rr[i-1]$。这样处理$rr[i]$时就可以用上$rr[i-1]$和它结束的节点继续匹配。 这里就有一个问题：以匹配$S(i-1,rr[i-1])$和$S(i,rr[i-1])$到达的节点可能不同，但若不同则一定是$parent\\ tree$上的父子关系。记$node$为$i-1$匹配结束的节点，处理第$i$位时，就需要判断一下$S(i,rr[i-1])$的长度和$len[fa[node]]$的关系，选择是否向上跳。$rr[i]$就能$O(n)$预处理了。 对于当前答案$mid$是否可行，可以用$DP$求解。设$f(i)$表示对串$S(i,n)$进行分段，最少有多少个字符是“不熟悉”的。 方程：$f(i)=\\min\\{f(i+1)+1,f(j)\\}(i+mid\\le j\\le rr[i]+1)$ 也就是把第$i$个字符归为“不熟悉”的子串里，或者以第$i$个字符开头划分一段子串。$f(j)$可以用单调队列优化，复杂度为$O(n)$，总复杂度$O(n\\log n)$ 若$f(1)\\le \\frac{n}{10}$则答案可行。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 1100005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } #define son(x,y) son[x][y] int son[maxn][3],fa[maxn],len[maxn],rr[maxn],f[maxn],last=1,cnt=1,n; char s[maxn]; struct MonoQueue{ int line[maxn],head,tail; inline void push(int x){ while(head&lt;=tail&amp;&amp;f[line[tail]]&gt;=f[x])--tail; line[++tail]=x; } inline void check(int x){ while(head&lt;=tail&amp;&amp;line[head]&gt;x)++head; } inline void clear(){ head=1,tail=0; } inline int front(){ if(head&lt;=tail)return f[line[head]]; return inf; } }q;//手写单调队列 void insert(int c){ int p=last,ne=last=++cnt; while(p&amp;&amp;!son(p,c))son(p,c)=ne,p=fa[p]; if(!p)fa[ne]=1; else { int q=son(p,c); if(len[q]==len[p]+1)fa[ne]=q; else { int sp=++cnt; son(sp,0)=son(q,0),son(sp,1)=son(q,1),son(sp,2)=son(q,2); fa[sp]=fa[q],len[sp]=len[p]+1; fa[q]=fa[ne]=sp; while(p&amp;&amp;son(p,c)==q)son(p,c)=sp,p=fa[p]; } } } void work_rr(){ int node=1,l=0; for(register int i=1;i&lt;=n;++i){ if(l)--l; if(node!=1&amp;&amp;len[fa[node]]&gt;=l)node=fa[node]; while(i+l&lt;=n&amp;&amp;son(node,s[i+l]-&#39;0&#39;))node=son(node,s[i+l]-&#39;0&#39;),++l; rr[i]=i+l-1; } } bool check(int l){ q.clear(),f[n+1]=0; for(register int i=n;i;--i){ if(i+l&lt;=n+1)q.push(i+l); q.check(rr[i]+1); f[i]=min(f[i+1]+1,q.front()); } return f[1]&lt;=n/10; } int main(){ int N=read(),M=read(),l,r,mid; for(register int i=1;i&lt;=M;++i){ scanf(&quot;%s&quot;,s+1),n=strlen(s+1); for(register int j=1;j&lt;=n;++j)insert(s[j]-&#39;0&#39;); if(i!=M)insert(2);//特殊字符 } while(N--){ scanf(&quot;%s&quot;,s+1),n=strlen(s+1); work_rr(); l=0,r=n; while(l&lt;r){ mid=l+r+1&gt;&gt;1; if(check(mid))l=mid; else r=mid-1; } printf(&quot;%d\\n&quot;,l); } }","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"字符串","slug":"字符串","permalink":"https://ctz45562.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"二分","slug":"二分","permalink":"https://ctz45562.github.io/tags/%E4%BA%8C%E5%88%86/"},{"name":"后缀自动机","slug":"后缀自动机","permalink":"https://ctz45562.github.io/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"单调队列","slug":"单调队列","permalink":"https://ctz45562.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"}]},{"title":"洛谷 P5212 SubString","slug":"洛谷-P5212-SubString","date":"2019-04-26T02:41:35.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/04/26/洛谷-P5212-SubString/","link":"","permalink":"https://ctz45562.github.io/2019/04/26/%E6%B4%9B%E8%B0%B7-P5212-SubString/","excerpt":"传送门 我的第一篇$SAM$题解$QwQ$","text":"传送门 我的第一篇$SAM$题解$QwQ$ 看到动态加字符就能想到$SAM$上去。 对于查询答案就是跑一遍串，到达点的$endpos$集合大小。 动态维护$endpos$集合大小。最朴素的求法就是在$parent\\ tree$上$DP$。那就维护一下子树大小，添加字符的过程中会涉及到改$fa$，直接上$LCT$维护子树大小。 @asuldb：为啥LCT​不方便维护子树啊。。。就一个子树和多好维护，比链加好写还跑得快 半小时一遍$A$美滋滋$QwQ$ 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 1200005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } struct Link_Cut_Tree{ #define son(x,y) son[x][y] #define ls(x) son(x,0) #define rs(x) son(x,1) #define root(x) (son[fa[x]][0]==x||son[fa[x]][1]==x) #define whson(x) (son[fa[x]][1]==x) int son[maxn][2],fa[maxn],dat[maxn],sum[maxn],_sum[maxn],rev[maxn],st[maxn]; //_sum是虚子树大小 inline void update(int node){ sum[node]=sum[ls(node)]+sum[rs(node)]+_sum[node]+dat[node]; } inline void addedge(int s,int f,int wh){ if(s)fa[s]=f; son(f,wh)=s; } inline void reverdown(int x){ swap(son(x,0),son(x,1)),rev[x]^=1; } inline void pushdown(int x){ if(rev[x]){ if(ls(x))reverdown(ls(x)); if(rs(x))reverdown(rs(x)); rev[x]=0; } } inline void zhuan(int x){ int f=fa[x],gf=fa[f],wh=whson(x); fa[x]=gf; if(root(f))son(gf,whson(f))=x; addedge(son(x,wh^1),f,wh); addedge(f,x,wh^1); update(f),update(x); } void splay(int x){ int y=x,top=1; st[1]=x; while(root(y))st[++top]=y=fa[y]; while(top)pushdown(st[top--]); while(root(x)){ y=fa[x]; if(root(y))zhuan(whson(x)^whson(y)?x:y); zhuan(x); } } void access(int x){ for(int y=0;x;y=x,x=fa[x]) splay(x),_sum[x]+=sum[son(x,1)]-sum[y],son(x,1)=y,update(x); } void makeroot(int x){ access(x),splay(x),reverdown(x); } void cut(int x,int y){ makeroot(x),access(y),splay(y); fa[x]=son(y,0)=0,update(y); } void link(int x,int y){ access(x),splay(x),makeroot(y),fa[x]=y,_sum[y]+=sum[x],update(y); } int ask(int x){ makeroot(1),access(x),splay(x); return sum[son(x,1)]+_sum[x]+dat[x]; } inline void init(int x){ dat[x]=sum[x]=1; } }lct; int son[maxn][26],fa[maxn],len[maxn],last=1,cnt=1,n,mask; char s[3000005]; inline void change_father(int x,int y){ if(fa[x])lct.cut(x,fa[x]); lct.link(x,fa[x]=y); } void insert(int c){ int p=last,ne=last=++cnt; len[ne]=len[p]+1,lct.init(ne); while(p&amp;&amp;!son(p,c))son(p,c)=ne,p=fa[p]; if(!p)change_father(ne,1); else { int q=son(p,c); if(len[q]==len[p]+1)change_father(ne,q); else { int sp=++cnt; memcpy(son[sp],son[q],sizeof son[q]); change_father(sp,fa[q]),len[sp]=len[p]+1; change_father(q,sp),change_father(ne,sp); while(p&amp;&amp;son(p,c)==q)son(p,c)=sp,p=fa[p]; } } } void work(){ scanf(&quot;%s&quot;,s),n=strlen(s); return; int rec=mask; for(register int i=0;i&lt;n;++i){ rec=(rec*131+i)%n; swap(s[rec],s[i]); } } void ask(){ int node=1,ans=0; work(); for(register int i=0;i&lt;n&amp;&amp;node;++i)node=son(node,s[i]-&#39;A&#39;); if(!node)puts(&quot;0&quot;); else printf(&quot;%d\\n&quot;,ans=lct.ask(node)); mask^=ans; } void add(){ work(); for(register int i=0;i&lt;n;++i)insert(s[i]-&#39;A&#39;); } int main(){ int t=read(); char op[10]; scanf(&quot;%s&quot;,s+1),n=strlen(s+1); for(register int i=1;i&lt;=n;++i)insert(s[i]-&#39;A&#39;); while(t--){ scanf(&quot;%s&quot;,op); if(op[0]==&#39;Q&#39;)ask(); else add(); } }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://ctz45562.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"后缀自动机","slug":"后缀自动机","permalink":"https://ctz45562.github.io/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"LCT","slug":"LCT","permalink":"https://ctz45562.github.io/tags/LCT/"}]},{"title":"后缀自动机学习笔记","slug":"后缀自动机学习笔记","date":"2019-04-23T03:24:47.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/04/23/后缀自动机学习笔记/","link":"","permalink":"https://ctz45562.github.io/2019/04/23/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"“后缀数组好$NB$啊！” “那我们来学学更$NB$的后缀自动机吧！”","text":"“后缀数组好$NB$啊！” “那我们来学学更$NB$的后缀自动机吧！” 前言先考虑一个问题：如何用一棵树表示出某个串的所有子串？ 一个串的子串由它每个后缀的所有前缀组成。那么把它的每个后缀插到一棵$trie$树里，就能用根节点到任意节点表示出一个子串了。 然而这样时间空间都是$O(n^2)$的。于是就有了后缀自动机。 后缀自动机（$Suffix\\ AutoMaton$）又称子串自动机，是一张$DAG$，可以用最少的点线性时间与空间表示出每个后缀（最小性）。 如果说后缀数组是用来练习单调栈、二分和$ST$表的话，后缀自动机大概就是用来练习树形$DP$、图的$DP$和线段树合并吧（光速逃 抄袭来源 https://www.luogu.org/blog/Kesdiael3/hou-zhui-zi-dong-ji-yang-xie （讲的很用心，大部分是抄他的） https://wavwing.top/2019/03/03/SAM%20Note （通过一些$PY$交♂易得到了密码） https://0x131cc05.github.io/2019/03/21/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/ https://oi-wiki.org/string/sam/ https://wenku.baidu.com/view/fa02d3fff111f18582d05a81.html （$clj$的讲稿还是比较专业的，免费的$ppt$这里可以下载） https://www.cnblogs.com/asuldb/tag/SAM/ （题单主要来源） #define基本$A[i,j]$：串$A$从第$i$个到第$j$个字符的组成的串 $length(A)$：串$A$的长度 $k$：字符集大小 $n$：一般情况下指母串长度 状态与转移： $SAM$中每个点都有一个状态，记点$i$的状态为$T(i)$，根节点的状态为$T(0)$。每条边都是一个转移，一个状态可以通过转移成为一个新的状态。 很抽象。。。简单理解的话就是状态$T(i)$相当于从根节点走到$i$得到的字符串，转移相当于给当前字符串添加一个字符。 SAM​$cnt$：$SAM$节点总数 $last$：当前串最长前缀的节点 $son[x][y]$（个人习惯$define$成$son(x,y)$）：$SAM$中节点$x$走字符$’y’$到达的节点（类比于$trie$的边） $fa[x]$：节点$x$在$SAM$中的父亲 $len[x]$：节点$x$代表的$endpos$等价类中，最长串的长度 $siz[x]$：节点$x$代表的$endpos$集合大小 $L(x)$：节点$x$代表的$endpos$等价类中的最长串 endpos定义对于字符串$S$任意一个子串$A$，$A$可能在$S$中出现多次，它的$endpos$为其所有结束位置的集合，记为$endpos(A)$。 举个栗子：在串aaabaabab中，$endpos(“aab”)=\\{4,7\\}$，$endpos(“ab”)=\\{4,7,9\\}$ 若$endpos(A)=endpos(B)$，称$A$与$B$属于同一个$endpos$等价类。 对于一个串，就能把它划分成若干个$endpos$等价类。 并不想证明的引理1.当且仅当串$B$以串$A$一个后缀的形式出现在$S$中时，则$endpos(A)=endpos(B)$ 这个比较明显了吧。。。直观理解就好了。 2.对于串$A$与串$B$，假设$length(B)&lt;length(A)$，要么$endpos(A)\\subseteq endpos(B)$(当$B$是$A$的后缀时)；要么$endpos(A)\\cap endpos(B)=\\varnothing$（当$B$不是$A$的后缀时） 当$B$不是$A$的后缀时，它们肯定不会有公共的结束位置。 当$B$是$A$的后缀时。显然若$length(A)&gt;length(B)$，$siz[A]\\le siz[B]$，再结合引理$1$，就有$endpos(A)\\subseteq endpos(B)$ 3.在同一个$endpos$等价类中，假设最长的串为$A$，则其余的串都是$A$的后缀，且它们长度是连续的。换句话说，设最长长度为$r$，最短为$l$，所有串的长度恰好覆盖了$[l,r]$ 由引理$1$可得“其余的串都是$A$的后缀”。 若长度不是连续的，在$endpos$等价类$E$中，存在$A$的后缀$A’,A’’$满足$length(A’’)&lt;length(A’)&lt;length(A)$，$A,A’’\\in E$，$A’\\notin E$。则$siz[A’’]\\ge siz[A’]\\ge siz[A]$，且$siz[A’’]=siz[A]$，矛盾，所以引理成立。 （我在瞎扯） 其实上面的引理都很明显，证明了反而更晕。。。 4.$endpos$等价类的个数级别为$O(n)$（重点） 这是证明后缀自动机复杂度的重要引理。 对于一个$endpos$等价类$E$，在其中最长的串前添加一个字符，根据引理$2$，得到的串所属的$endpos$等价类一定是$E$的一个真子集，并且添加不同的字符得到的$endpos$等价类互不相交。所以在最长串前添加字符（保证新串还是母串子串），相当于将$E$分割成若干个不相交的子集，子集的个数不超过$E$的大小。 那么一切$endpos$等价类都是由$\\{1,2,3…n\\}$不断分割而来的，类比于线段树，总大小不超过$O(n)$ 后缀链接定义对于一个$endpos$等价类$E$，记其中长度最大的串为$A_{max}$，最小的为$A_{min}$，由上面引理$3$可知其余所有串为$A_{max}$的后缀，且长度连续。取串$A’$为$A_{max}$最长且不属于$E$的后缀，把$A_{min}$链接上$A’$，就是后缀链接。 性质1.$length(A_{min})=length(A’)+1$，$endpos(A_{min})\\subseteq endpos(A’)$ 2.所有的后缀链接构成一棵以$T(0)$为根的树 从任意一个$endpos$等价类出发，沿后缀链接走长度是严格递减的，最后一定走到$T(0)$ 3.以$endpos$等价类建树，由一个类的子集向自己连边，得到的树和后缀链接树结构相同。每个节点是包含某一前缀若干长度单调递减的后缀，并由后缀链接成长度从1到前缀长度的后缀的并集。 我们称这棵树为$parent\\ tree$。 比如说串$aababa$的$parent\\ tree$长这样（图片来源，节点右边是这个类中最长的串）： 根据引理$4$，$parent\\ tree$的边数是$O(n)$级别的。 $SAM$跟这个有啥关系？ $SAM$的节点和$parent\\ tree$的节点是相同的，只是边不一样。 SAM的构造SAM​长啥样？$SAM$的构造是在线的。通过逐个加入字符维护当前$SAM$。 先放一张$SAM$的图（以串$aaabaab$为例，图片绘自SAM Drawer）： 好丑啊 黑边指向儿子，红边指向父亲，$Max$就是$len$，$size1$是$siz$ 可以发现对于任意非根节点，从根节点到其所有黑色路径构成的串组成了其$endpos$等价类。红边构成了$parent\\ tree$。 实现#define son(x,y) son[x][y] int len[maxn],fa[maxn],son[maxn][26],last=1,cnt=1,n; char s[maxn]; void insert(int c){ int p=last,ne=last=++cnt; len[ne]=len[p]+1; while(p&amp;&amp;!son(p,c))son(p,c)=ne,p=fa[p]; if(!p)fa[ne]=1;//#case 1 else { int q=son(p,c); if(len[q]==len[p]+1)fa[ne]=q;//#case 2 else { int sp=++cnt; memcpy(son[sp],son[q],sizeof son[sp]); fa[sp]=fa[q],len[sp]=len[p]+1; fa[ne]=fa[q]=sp; while(p&amp;&amp;son(p,c)==q)son(p,c)=sp,p=fa[p]; }//#case 3 } } int main(){ scanf(&quot;%s&quot;,s+1),n=strlen(s+1); for(register int i=1;i&lt;=n;++i)insert(s[i]-&#39;a&#39;); } 每次添加一个字符$c$后，受影响的是新最长前缀的所有后缀，也就是原串最长前缀的所有后缀$+\\ ‘c’$。 一句句来看： int p=last,ne=last=++cnt; $p$存了当前最长前缀所在的节点，$ne(new)$是新建节点，状态为当前最长前缀，更新一下$last$。 len[ne]=len[p]+1; $ne$存有当前串的前缀，$len$即为上一个串的前缀($last$)长度$+1$。 while(p&amp;&amp;!son(p,c))son(p,c)=ne,p=fa[p]; 从$p$开始往上跳，因为$p$是原串最长前缀，往上跳就是从长到短枚举它每一个后缀。!son(p,c)就说明还未出现过该状态$+\\ ‘c’$这个子串，现在加上了就会出现在最后，向$ne$连边。 case 1 if(!p)fa[ne]=1; 遍历完所有后缀都没有son(p,c)!=0的点，说明$’c’$就没有出现过，就把它向根节点连父亲。 case 2 else { int q=son(p,c); if(len[q]==len[p]+1)fa[ne]=q; 现在跳到了第一个有$’c’$这条边的点。 用$q$记录$p$走$’c’$到的点。 len[q]==len[p]+1说明$q$代表的$endpos$等价类中只有$L(p)+’c’$，为$ne$的后缀，连$p$的父亲到$q$。同时这是第一个满足条件的点，再往上跳的点$len$只会更小，那就向最长的点连父亲。 case 3现在$len[q]!=len[p]+1$了，也就是$len[q]&gt;len[p]+1$。在点$q$的$endpos$等价类中，不止有$L(p)+’c’$，还有其他更长的串，并且这些更长的串都不是$ne$的后缀。如果是的话，由于它更长，在点$p$之前一定还有一个节点的$’c’$边指向它，也就跳不到$p$点。 这样$q$就被分成了$2$类：$length==len[p]+1$和$length&gt;len[p]+1$ 前者满足$ne$向它连父亲，但后者不满足，所以就要新建节点分开它们。 int sp=++cnt; 新建节点$sp(split)$，包含$length==len[p]+1$的串。 memcpy(son[sp],son[q],sizeof son[sp]); 复制儿子。 本来就都是同一类的，分裂只是因为有的串$endpos$多了一位，儿子没变。 len[sp]=len[p]+1,fa[sp]=fa[q]; $sp$中只有$length==len[p]+1$的串，$len[sp]$自然是$len[p]+1$，父亲也是原父亲。 fa[ne]=fa[q]=sp; $ne$的父亲肯定指向只有$length==len[p]+1$的$sp$点，而$sp$的$endpos$比$q$多了一位（也就是新加进来的位置），$q$的父亲连向它。 while(p&amp;&amp;son(p,c)==q)son(p,c)=sp,p=fa[p]; 再往上跳更新儿子。因为$p$往上跳$L(p)+’c’$一定有最后一位，而$q$的$endpos$，真正有的是$sp$，所有连向$q$的点都要移情别恋到$sp$上。如果跳到儿子不是$q$的$p$，那么$son(p,c)$就是$q$的祖先。$q$的父亲是$sp$，$son(p,c)$就是$sp$的祖先了，满足$endpos$的关系，不需要修改了。 复杂度空间显然一个字符最多新建两个节点，每个节点存有$k$个儿子，复杂度为$O(nk)$。 当然可以以时间换空间，数组改为$map$，空间就是$O(n)$的。 时间复杂度是$O(n)$的，如果开$map$的话是$O(n\\log k)$的。当$k$较小时可以视为常数，还是$O(n)$的。 复杂度肯定只关心两个$while$和$memcpy$。 while(p&amp;&amp;!son(p,c))son(p,c)=ne,p=fa[p]; 这个$while$就是加边的，它的均摊复杂度就是边数级别。 下面证明$SAM$边数级别是$O(n)$的： 为了能存下所有子串，$SAM$中一定要能遍历到每一个后缀。 任意求出$SAM$的一个生成树，边数级别是$O(n)$。 找到一条路径：根节点$\\rightarrow$状态$A\\rightarrow edge(A,B)\\rightarrow$状态$B\\rightarrow$结束状态（某个叶子节点） 其中$edge(A,B)$不一定存在，就加上这条边。这是我们会发现：这条路径恰好是遍历了一个后缀。 那么对于每个后缀我们都找出来一条这样的路径，每条路径最多加$1$条边，也保证了每个后缀都能遍历到，总边数级别就是$O(n)$的。 所以第一个$while$均摊是$O(n)$的。 memcpy(son[sp],son[p],sizeof son[sp]); 如果$k$是常数大小的话，这个就是常数级别的。 如果$k$很大开了$map$的话，首先根据引理$4$，$SAM$节点个数是$O(n)$的。如果使一次复制达到$O(n)$级别，就必须至少有$O(n)$的节点，也就是插入了$O(n)$的字符。而一个点最多被复制一次，复杂度还是$O(n)$的。 while(p&amp;&amp;son(p,c)==q)son(p,c)=sp,p=fa[p]; 一个点同一个儿子最多被改变一次。换句话说，每条边最多被修改一次。 点$q$分裂出了点$sp$，把所有$son(p,c)==q$都转移到$sp$上。而$sp$本身由于赋值它的长度len[sp]=len[p]+1，所以当访问到点$sp$时，会按照$case\\ 2$处理，连向它的边也不会再改变。总复杂度就是$O(n)$的。 PS：网上证明我太蒻了都没看懂，只能自己$yy$出这个证明。$wavwing$说这个证明的复杂度上界是不严格的，我证明的复杂度是和边数同级的，但据说应该是和点数同级。虽然都是$O(n)$的，但实际上效率会更好（通俗点说常数会更小）。反正能证出来就行 广义SAM这部分可以先跳过去。 栗子现在我们来$yy$一道题： 给多个模式串。多次询问，每次给定一个串，求在所有模式串中一共出现了几次。 根据后缀数组的经验，可以在每个模式串中间插入一个特殊字符$造$SAM$，出现次数就是到达节点的$siz$。 然而这里就有一个问题，比如给的串长度为$3$，走到的节点有一个串为：SAM$NB 这时候就出现问题了，因为是把串拼在一起的，就会受长度、特殊字符的影响，处理起来比较麻烦。（我太蒻了找不到很便捷的处理方式） 于是这时我们需要一只广义$SAM$。它可以存储每个串的所有子串，同时不会出现多余的像上面栗子那样的串。 广义$SAM$网上找不到很详细的资料，一些原理和性质也没有系统的说明，所以我是纯粹背过的。 构造其实构造贼简单，每插入一个串就把$last$赋值为$1$，其他和普通$SAM$一样。（至于为啥我也不知道啊） 可以用几个短串模拟一下构造。 以串$aab,bb,ab$为例，它长这个样子（还是$SAM\\ Drawer$）： 比普通$SAM$更丑了。。。 我们会发现里面有的点永远走不到，比如说点$5,8,9$。 至于怎么用。。。其实和普通$SAM$一样用就行。但是要注意的是广义$SAM$不能通过拓扑序求$siz$。 复杂度未知。。。 应用以下用$edge(i,j)$表示$fa[j]=i$ 求出每个点的siz​$endpos$集合大小就相当于子串出现次数，求出这个就能乱搞干很多事情了。 $DP$求解。$fa$建出$parent\\ tree$，按拓扑序或$dfsDP$。 方程：若点$i$不包含原串前缀，$siz[i]=\\sum\\limits_{edge(i,j)}siz[j]$；否则$siz[i]=1+\\sum\\limits_{edge(i,j)}siz[j]$ 什么意思呢？首先对于不包含前缀的点我们分割它的$endpos$集合有了$parent\\ tree$，它的儿子的并集就是它自己。 看到$parent\\ tree$，可以发现集合$\\{1,2,4,6\\}$分割成了$\\{2\\}$和$\\{4,6\\}$，$\\{1\\}$去哪儿了？ 分割集合相当于给集合里的每个串前添加字符得到新子串，产生了新的$endpos$等价类，分割下去。但是前缀不能在前面添加字符（它已经到头了），就不会分割出新的$endpos$等价类。显然一个类中最多只有一个前缀，就有上面的方程。 实现：只需要在$insert$函数第二行加一句：siz[ne]=1，建好$SAM$，$DP$就行啦。 关于拓扑序有个有点意思的求法： int tax[maxn],cur[maxn]; for(register int i=1;i&lt;=cnt;++i)++tax[len[i]]; for(register int i=1;i&lt;=n;++i)tax[i]+=tax[i-1]; for(register int i=1;i&lt;=cnt;++i)cur[tax[len[i]]--]=i; 很像后缀排序里的基数排序，搞完这些之后$cur$里就是拓扑序啦。 如果想求出$endpos$集合里具体元素，珂以用线段树合并或$Splay$启发式合并，貌似主席树也行。 广义$SAM$不能通过拓扑序求$siz$ 定位子串给定一个字符串$S$，多次询问，给定$l,r$，求$S[l,r]$对应节点。 $parent\\ tree$上父子都是后缀关系。预处理出所有前缀$r$对应的节点，倍增跳到$len$合适的地方。 判断子串给一个模式串判断是否是母串的子串。 直接扔到$SAM$上跑一遍没到空节点上就是子串。 不同子串个数由于$SAM$的最小性，同一个子串不会对应两条路径。所以就是求$SAM$上的路径数。 $DP$求解。$f(i)$表示点$i$出发的子串个数，方程$f(i)=\\sum f(son(i,j))+1$，答案为$f(1)$。 也可以直接求$\\sum len(i)-len(fa[i])$ 不去重字典序第k小子串后缀自动机经典应用。 先把$siz$求出来。 设$f(i)$表示从点$i$出发能得到的子串数量（可以重复）。 方程$f(i)=\\sum\\limits_{son(i,j)}siz(j)+f(j)$ 然后从根节点开始，从小到大枚举字符，如果$k&gt;f(son(i,j))+siz[son(i,j)]$就减去，否则走这条边并让$k-=siz[son(i,j)]$，$k$小于$0$就结束。 最长公共子串给定2个模式串，求它们的最长公共子串。 当然用SA啊 对第一个串造$SAM$，用第二个串在$SAM$上跑，维护一下当前长度。依次匹配每一个字符，能走就走，长度++；不能走就不断向上跳$fa$，直到有边能走，长度置为该节点的$len$。中间过程所有到达的长度最大值为答案。 扩展到多个串上： 对第一个串造$SAM$，每个节点维护已匹配过的串走到该节点的最小长度$mi$和当前串走到该节点最大匹配长度$ma$。让每个串往上面跑并记录匹配长度，每次走到某个节点都把$ma$对匹配长度取$\\max$，跑完更新每个节点，根据定义，$mi_i=\\min\\{mi_i,ma_i\\}$，而如果存在$ma_i$，$fa[i]$必定能完全匹配，则$mi_{fa[i]}=len[fa[i]]$。答案为$\\max\\{mi_i\\}$。 最长公共后缀给定母串，求两个前缀的最长公共后缀。 它们的$LCA$的$len$。 至于为啥。。。刚从$R2$回来好累啊懒得想了。 后缀的最长公共前缀倒过来就行了。 最小表示法给定一个串，可以任意把最后面的字符移到开头，求能得到的字典序最小的串。 这不最小表示法、后缀数组SB题吗 把串复制一遍接在后边造$SAM$，就要找一条长度为$n$的字典序最小的路径。设$f(i)$为以节点$i$为起点，沿着$son$走能走的最长路的长度，$DP$求解，方程：$f(i)=\\max\\{f(son(i,j))+1\\}$。 从根节点开始$dfs$，记录当前剩余未填字符数为$m$，从小到大枚举字符，如果$f[son(i,j)]+1\\ge m$就走，直到$m$为$0$。 $A$了后看了看$asuldb$的题解发现我在瞎扯。。。 因为我们是把串循环同构了，所以从根节点出发一定有长度为$n$的路径，其他点同样有满足条件的路径。所以没必要$DP$，贪心走最小的儿子走$n$遍就完了。 水题一些题在学后缀数组时已经做过啦，所以有的我是在口胡。。。 好多题目都是从asuldb那里偷过来的$QwQ$ 【模板】后缀自动机求出$endpos$集合大小，答案就是$max\\{siz[i]len[i]\\}(siz[i]&gt;1)$ 玄武密码很裸的判断子串。。。 （我把这个题放上来好像显得很low） 弦论填上我后缀数组的坑。$t=0$，后缀数组随便做所有点的$siz$都是$1$，（同一个状态只出现一次），和上面应用一样跑就行啦。 $t=1$，还是上面那个。 生成魔咒有了$SAM$这个题就很板子了，毕竟$SAM$就是在线的。 直接用式子$ans=\\sum len(i)-len(fa(i))$，连$fa$时算上贡献就完了。 字符集太大了得上$map$。 SubString询问答案就是在$SAM$上跑一遍到达的节点的$siz$，所以就是动态维护$siz$。 $siz$和$parent\\ tree$有关，加字符有可能改变$fa$关系，$LCT$维护子树大小就好啦。 题解 熟悉的文章关于怎么做。。。这里空太小了写不开 题解 Standing Out from the Herd题解 碱基序列动态规划。设$f(i,j)$表示前$i$组序列，有多少种方案走到节点$j$。 定义函数$walk(j,S)$表示从节点$j$出发走串$S$到达的节点。 刷表法，把母串$SAM$造出来。对于第$i$组序列的每个模式串$S$，都有转移$f(i+1,walk(j,S))+=f(i,j)$ 答案为$\\sum\\limits_{i=1}^{cnt}siz[i]*f(k,i)$ 复杂度$O(n\\sum|S|)$ （题目数据范围不给清楚。。。模式串的长度总和应该不大，反正能过） DNA一开始想到了$dfs$、$bfs$和$DP$做法，不过十分怀疑复杂度。 对于$DP$，对$S_0$造$SAM$，设$f(i,j,k)=0/1$为匹配了$S$的前$i$位，已经有$k$位不同，是否能到达节点$j$。答案为$\\sum siz[j] (f(n,j,0/1/2/3)=1)$ 这时发现我们只关心最终是否能到达某个节点，状态就为$f(i,j)$表示匹配了$S$的前$i$位，到达节点$j$最少有多少位不同。 转移时枚举当前节点的下一位为$A,C,G,T$，和$i+1$位不同就加$1$。复杂度是$O(n^2)$的。 然后会发现实际上能转移的状态并不多，中间$f$值大于$3$的都可以舍弃掉了。可以结合一下$bfs$，开一个队列把有用状态装进去更新$f$。 因为有用的状态数不多好像$dfs$效率也不错。 Security题解 Cool Slogans题解 事情的相似度简单概括：$[l,r]$中的前缀两两之间最长公共后缀的最大值。 先转成$LCA$。 平衡树维护$endpos$，启发式合并，把$siz$小的平衡树中每个$endpos$查一下大树里的前驱后继，也就是最可能有贡献的点对，它们的$LCA$为当前点，就有$n\\log n$个三元组$(endpos_1,endpos_2,len[i])$，然后就是数点问题了。 你的名字题解 下面是一些广义$SAM$的题。 前面熟悉的文章、Standing Out from the Herd也是可以用广义$SAM$做的，而且应该比普通$SAM$更方便（不过当时没学） Forensic Examination比较裸的题了。 对母串和所有串造广义$SAM$，在上面跑一下母串，求出每个位置到达的节点（也就是$S[1,r]$到的节点） 然后线段树合并求出每个节点包含了哪些模式串及出现次数。 对于每个询问，从节点$S[1,p_r]$倍增向上跳到节点$S[p_l,p_r]$，求线段树中$[l,r]$的最大值就好啦。 串把广义$SAM$造出来，统计一下每个节点属于多少个模式串（就是统计个颜色），这个线段树合并、$dsu\\ on\\ tree$都行。 对于每个串，我们统计其每个前缀的后缀的答案。前缀到达的节点容易找到，然后倍增跳到第一个颜色数$\\ge k$的节点，$len$就是该前缀的贡献。 诸神眷顾的幻想乡以每个叶子节点为根$dfs$一遍，相当于把这棵树看作以该节点为根的$trie$树，把这棵$trie$树上的串插到广义$SAM$里（广义$SAM$有一种标准的造法是以$trie$树造$SAM$，然而我懒得学了）。我们对每个节点存一下它的$last$，某个节点就根据它父亲的$last$插入进$SAM$。最后和普通$SAM$一样统计本质不同的子串就行了。因为叶子数不超过$20$，复杂度是$OK$的。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ctz45562.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://ctz45562.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"后缀自动机","slug":"后缀自动机","permalink":"https://ctz45562.github.io/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"}]},{"title":"洛谷 P5284 [十二省联考2019]字符串问题","slug":"洛谷-P5284-十二省联考2019字符串问题","date":"2019-04-23T02:02:07.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/04/23/洛谷-P5284-十二省联考2019字符串问题/","link":"","permalink":"https://ctz45562.github.io/2019/04/23/%E6%B4%9B%E8%B0%B7-P5284-%E5%8D%81%E4%BA%8C%E7%9C%81%E8%81%94%E8%80%832019%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98/","excerpt":"传送门 以此题结束我后缀数组的学习 然而我可能这辈子都结束不了后缀数组了$QAQ$","text":"传送门 以此题结束我后缀数组的学习 然而我可能这辈子都结束不了后缀数组了$QAQ$ 用$SA$处理出来每个$B$串是那些$A$串的前缀，连边；再把有支配关系的串连边。问题就成了有向图的最长链，拓扑排序顺便判个环，$DP$就完了。 这样边数是$O(n_an_b)$的，能过前$4$个点。 若某个$B$串属于后缀$S(i)$，后缀$S(j)$满足$B$串匹配的条件是$LCP(S(i),S(j))\\ge len(B)$，所以在$SA$里可以二分出来每个$B$串能连边的区间，线段树优化建图，边数就能降到$O(n\\log n)$。 然后就能拿到$80$分的好成绩。 最后$2$个点中$len(B)$可能大于$len(A)$，而$2$个串连边还有条件为$len(A)\\ge len(B)$，以长度造出来主席树，主席树优化建图，边数还是$O(n\\log n)$，可以通过此题。 本地$lemon$原数据不吸氧$AC$，然后在洛咕上吸氧拿到了$90$分的好成绩。 于是开始优化常数。。。 通过诸如舍弃$STL$、$fread$、$O_3$等等负优化： 难受，继续去卡常了，代码就咕了$QAQ$ $update$： 哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈我刚写完哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈这篇blog哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈就卡过去了哈哈哈哈哈哈哈 （请无视掉上面） 拓扑排序完了之后$DP\\rightarrow$ 一边拓扑排序一边$DP$ $40000ms+\\rightarrow 32000ms+$ $emm…$ 不管了过了就行 咕了的代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 200010 #define inf 0x3f3f3f3f const int N = maxn &lt;&lt; 6; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } #define ls(x) ls[x] #define rs(x) rs[x] /*==============variable==============*/ int cur[N],f[maxn][22],root[maxn],hl[maxn],h[N],ls[N],rs[N],a[maxn][2],b[maxn][2],deg[N],num,numl,len; int sa[maxn],rk[maxn],tp[maxn],tax[maxn],hei[maxn],lg[maxn],id[maxn],na,nb,n,m,cnt,L,R,poi; long long g[N]; struct edge{ int pre,to,l; }e[N&lt;&lt;1]; struct length{ int pre,to; }le[maxn]; /*==============End==============*/ /*==============Chairman Tree==============*/ inline void add(int from,int to,int l=0){ if(!from||!to)return; e[++num].pre=h[from],h[from]=num,e[num].to=to,e[num].l=l,++deg[to]; } inline void add_l(int from,int to){ le[++numl].pre=hl[from],hl[from]=numl,le[numl].to=to; } void build(int l,int r,int &amp;node,int ol){ node=++cnt,add(ol,node); if(l==r){id[poi]=node,g[node]=a[poi][1]-a[poi][0]+1;return;} int mid=l+r&gt;&gt;1; if(rk[a[poi][0]]&lt;=mid)rs(node)=rs(ol),build(l,mid,ls(node),ls(ol)); else ls(node)=ls(ol),build(mid+1,r,rs(node),rs(ol)); add(ls(node),node),add(rs(node),node); } void modify(int l,int r,int node){ if(!node)return; if(L&lt;=l&amp;&amp;R&gt;=r){add(node,poi);return;} int mid=l+r&gt;&gt;1; if(L&lt;=mid)modify(l,mid,ls(node)); if(R&gt;mid)modify(mid+1,r,rs(node)); } /*==============End==============*/ /*==============Suffix Array===========*/ void Rsort(){ for(register int i=0;i&lt;=m;++i)tax[i]=0; for(register int i=1;i&lt;=n;++i)++tax[rk[i]]; for(register int i=1;i&lt;=m;++i)tax[i]+=tax[i-1]; for(register int i=n;i;--i)sa[tax[rk[tp[i]]]--]=tp[i]; } void Ssort(){ for(register int i=1;i&lt;=n;++i)rk[i]=s[i],tp[i]=i; m=225,Rsort(); for(register int k=1,p=0;p&lt;n;m=p,k&lt;&lt;=1){ p=0; for(register int i=1;i&lt;=k;++i)tp[++p]=n-k+i; for(register int i=1;i&lt;=n;++i)if(sa[i]&gt;k)tp[++p]=sa[i]-k; Rsort(); for(register int i=1;i&lt;=n;++i)tp[i]=rk[i]; rk[sa[1]]=p=1; for(register int i=2;i&lt;=n;++i) rk[sa[i]]=tp[sa[i]]==tp[sa[i-1]]&amp;&amp;tp[sa[i]+k]==tp[sa[i-1]+k]?p:++p; } } void get_height(){ int k=0,x; for(register int i=1;i&lt;=n;++i){ if(rk[i]==1)continue; if(k)--k; x=sa[rk[i]-1]; while(i+k&lt;=n&amp;&amp;x+k&lt;=n&amp;&amp;s[i+k]==s[x+k])++k; hei[rk[i]]=f[rk[i]][0]=k; } } void ST(){ for(register int i=2;i&lt;=n;++i)lg[i]=lg[i&gt;&gt;1]+1; for(register int j=1;j&lt;=lg[n];++j) for(register int i=1;i+(1&lt;&lt;j)-1&lt;=n;++i) f[i][j]=min(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]); } inline int query(int l,int r){ if(l&gt;r)return inf; int len=lg[r-l+1]; return min(f[l][len],f[r-(1&lt;&lt;len)+1][len]); } void Prefix_Initialization(){ int l,r,mid,x,len; for(register int i=1;i&lt;=nb;++i){ x=rk[b[i][0]],len=b[i][1]-b[i][0]+1; l=1,r=x; while(l&lt;r){ mid=l+r&gt;&gt;1; if(query(mid+1,x)&gt;=len)r=mid; else l=mid+1; } L=l,l=x,r=n; while(l&lt;r){ mid=l+r+1&gt;&gt;1; if(query(x+1,mid)&gt;=len)l=mid; else r=mid-1; } R=l,poi=i+cnt; modify(1,n,root[len]); } } /*===============End===============*/ /*===============DP================*/ void topo(){ int node,x,res=0,head=0; long long ans=0; for(register int i=1;i&lt;=cnt;++i)if(!deg[i])cur[++len]=i; while(head&lt;len){ node=cur[++head],ans=max(ans,g[node]); for(register int i=h[node];i;i=e[i].pre){ x=e[i].to,--deg[x],g[x]=max(g[x],g[node]+e[i].l); if(!deg[x])cur[++len]=x; } } for(register int i=1;i&lt;=cnt;++i)if(deg[i])ans=-1,deg[i]=0; printf(&quot;%lld\\n&quot;,ans); } /*==================End==================*/ int main(){ int t=read(); while(1){ scanf(&quot;%s&quot;,s+1),n=strlen(s+1),na=read(); Ssort(),get_height(),ST(); root[n+1]=0; for(register int i=1;i&lt;=na;++i)a[i][0]=read(),a[i][1]=read(),add_l(a[i][1]-a[i][0]+1,i); for(register int i=n;i;--i){ int last=root[i+1],node; for(register int j=hl[i];j;j=le[j].pre)poi=le[j].to,build(1,n,node,last),last=node; root[i]=last,hl[i]=0; } nb=read(); for(register int i=1;i&lt;=nb;++i)b[i][0]=read(),b[i][1]=read(); int m=read(),x,y; while(m--){ x=read(),y=read(); add(y+cnt,id[x],a[x][1]-a[x][0]+1); } Prefix_Initialization(); cnt+=nb; topo(); if(!--t)break; for(register int i=1;i&lt;=cnt;++i)h[i]=g[i]=0; cnt=num=numl=len=0; memset(tp,0,sizeof tp); } }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"字符串","slug":"字符串","permalink":"https://ctz45562.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"后缀数组","slug":"后缀数组","permalink":"https://ctz45562.github.io/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"主席树","slug":"主席树","permalink":"https://ctz45562.github.io/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"}]},{"title":"洛谷 P1117 [NOI2016]优秀的拆分","slug":"洛谷-P1117-NOI2016优秀的拆分","date":"2019-04-21T08:48:42.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/04/21/洛谷-P1117-NOI2016优秀的拆分/","link":"","permalink":"https://ctz45562.github.io/2019/04/21/%E6%B4%9B%E8%B0%B7-P1117-NOI2016%E4%BC%98%E7%A7%80%E7%9A%84%E6%8B%86%E5%88%86/","excerpt":"传送门 「优秀的拆分」可以说是非常优秀了","text":"传送门 「优秀的拆分」可以说是非常优秀了 温馨提示：后缀数组多测要清空$tp$数组！！！！ 设$st[i]$为以第$i$个字符为开头，能有多少个$AA$串；$en[i]$即以第$i$个字符为结尾，有多少个$AA$串。 答案就是$\\sum\\limits_{i=1}^{n-1}en[i]*st[i+1]$。我们就能用哈希（蒟蒻不会哈希只能强上$SA$）$O(n^2)$得到$95$分的好成绩。 （如果蒟蒻比赛写到这就懒得继续写了，散了散了） 枚举每个$A$串长度$len$，对母串每$len$个字符打一个标记，显然一个$AA$串一定覆盖两个标记。那么对于每两个相邻的标记，若它们的$LCS+LCP\\ge len$就能产生$AA$串。（$LCS$是前缀的最长公共后缀，$LCP$是后缀的最长公共前缀） 并且这个$AA$串左右端点可以移动，移动范围为$LCS+LCP-len$，给这段区间$+1$，上差分。 时间复杂度$O(\\sum\\limits_{i=1}^{n}\\frac{n}{i})=O(n\\log n)$ 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 30005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int lg[maxn],n,m; long long st[maxn],en[maxn]; struct Suffix_Array{ int sa[maxn],rk[maxn],tp[maxn],tax[maxn],hei[maxn],f[maxn][25]; char s[maxn]; void Rsort(){ for(register int i=0;i&lt;=m;++i)tax[i]=0; for(register int i=1;i&lt;=n;++i)++tax[rk[i]]; for(register int i=1;i&lt;=m;++i)tax[i]+=tax[i-1]; for(register int i=n;i;--i)sa[tax[rk[tp[i]]]--]=tp[i]; } void Ssort(){ for(register int i=1;i&lt;=n;++i)rk[i]=s[i],tp[i]=i; m=225,Rsort(); for(register int k=1,p=0;p&lt;n;m=p,k&lt;&lt;=1){ p=0; for(register int i=1;i&lt;=k;++i)tp[++p]=n-k+i; for(register int i=1;i&lt;=n;++i)if(sa[i]&gt;k)tp[++p]=sa[i]-k; Rsort(); for(register int i=1;i&lt;=n;++i)tp[i]=rk[i]; rk[sa[1]]=p=1; for(register int i=2;i&lt;=n;++i) rk[sa[i]]=tp[sa[i]]==tp[sa[i-1]]&amp;&amp;tp[sa[i]+k]==tp[sa[i-1]+k]?p:++p; } } void get_height(){ int k=0,x; for(register int i=1;i&lt;=n;++i){ if(rk[i]==1)continue; if(k)--k; x=sa[rk[i]-1]; while(i+k&lt;=n&amp;&amp;x+k&lt;=n&amp;&amp;s[i+k]==s[x+k])++k; hei[rk[i]]=k; } } void ST(){ for(register int i=1;i&lt;=n;++i)f[i][0]=hei[i]; for(register int j=1;j&lt;lg[n];++j) for(register int i=1;i+(1&lt;&lt;j)-1&lt;=n;++i) f[i][j]=min(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]); } inline int query(int l,int r){ int len=lg[r-l+1]-1; return min(f[l][len],f[r-(1&lt;&lt;len)+1][len]); } inline int lcp(int i,int j){ return query(min(rk[i],rk[j])+1,max(rk[i],rk[j])); } void init(){ memset(tp,0,sizeof tp); Ssort(),get_height(),ST(); } }pre,suf; inline void add(int l,int r,long long *a){ if(r&lt;1)return; if(l&lt;=n)++a[max(l,1)]; if(r&lt;n)--a[r+1]; } inline int LCS(int x,int y){ if(!x||!y)return 0; return pre.lcp(n-x+1,n-y+1); } inline int LCP(int x,int y){ return suf.lcp(x,y); } int main(){ int t=read(); long long ans; for(register int i=1;i&lt;maxn;++i) lg[i]=lg[i-1]+(1&lt;&lt;lg[i-1]==i); while(t--){ scanf(&quot;%s&quot;,suf.s+1),n=strlen(suf.s+1),ans=0; memset(st,0,sizeof st),memset(en,0,sizeof en); for(register int i=1,j=n;i&lt;=n;--j,++i)pre.s[i]=suf.s[j]; pre.init(),suf.init(); for(register int i=1;i&lt;=(n&gt;&gt;1);++i){ for(register int j=i+i;j&lt;=n;j+=i){ int lcs=min(LCS(j-1,j-i-1),i-1),lcp=min(LCP(j,j-i),i),delta=lcs+lcp-i; if(lcs+lcp&lt;i)continue; add(j-i-lcs,j-i-lcs+delta,st),add(j+lcp-1-delta,j+lcp-1,en); } } for(register int i=2;i&lt;=n;++i) st[i]+=st[i-1],en[i]+=en[i-1]; for(register int i=1;i&lt;n;++i) ans+=en[i]*st[i+1]; printf(&quot;%lld\\n&quot;,ans); } } 后记： 数据千万条，清空第一条。 多测不清空，爆零两行泪。 $SA$要清空$tp$数组。。。蒟蒻调了一小时才发现的$QAQ$ 还有蒟蒻想知道$LCS$有没有简便一点的$O(1)$求法。翻转字符串造$SA$感觉太暴力了。。。","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://ctz45562.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"后缀数组","slug":"后缀数组","permalink":"https://ctz45562.github.io/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"}]},{"title":"洛谷 P3181 [HAOI2016]找相同字符","slug":"洛谷-P3181-HAOI2016-找相同字符","date":"2019-04-21T00:52:53.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/04/21/洛谷-P3181-HAOI2016-找相同字符/","link":"","permalink":"https://ctz45562.github.io/2019/04/21/%E6%B4%9B%E8%B0%B7-P3181-HAOI2016-%E6%89%BE%E7%9B%B8%E5%90%8C%E5%AD%97%E7%AC%A6/","excerpt":"传送门 调了两天终于调出来啦$qwqwqwqwqwq$","text":"传送门 调了两天终于调出来啦$qwqwqwqwqwq$ 把两个串拼一块染个色造$SA​$。 对于它们的子串$S_A,S_B$，设它们分别属于后缀$suffix_i,suffix_j$，则只要$LCP(suffix_i,suffix_j)\\ge len(S_A)$两个子串就是相同的。 又有$LCP(suffix_i,suffix_j)=\\min\\{height[k]\\}(i&lt;k\\le j)$ 那么对于任意一个区间$[l,r]$它会产生$\\min\\{height[k]\\}(k\\in (l,r])​$的贡献。 然后就可以用单调栈了。显然选取的两个区间端点颜色要不同，做个前缀和就好了。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 400005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } template&lt;typename T&gt; inline T read(){ T x=0; int y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int sa[maxn],rk[maxn],hei[maxn],tp[maxn],tax[maxn],ll[maxn],rr[maxn],col[maxn],sum[maxn][2],n,m; char a[maxn],s[maxn]; struct MonoStack{ int sta[maxn],top; inline void push1(int x){ while(top&gt;1&amp;&amp;hei[sta[top]]&gt;=hei[x])--top; sta[++top]=x; } inline void push2(int x){ while(top&gt;1&amp;&amp;hei[sta[top]]&gt;hei[x])--top; sta[++top]=x; } inline void clear(){ top=0; } inline int back(){ return sta[top-1]; } }st;//单调栈 void Rsort(){ for(register int i=0;i&lt;=m;++i)tax[i]=0; for(register int i=1;i&lt;=n;++i)++tax[rk[i]]; for(register int i=1;i&lt;=m;++i)tax[i]+=tax[i-1]; for(register int i=n;i;--i)sa[tax[rk[tp[i]]]--]=tp[i]; } void Ssort(){ for(register int i=1;i&lt;=n;++i)rk[i]=s[i],tp[i]=i; m=225,Rsort(); for(register int k=1,p=0;p&lt;n;m=p,k&lt;&lt;=1){ p=0; for(register int i=1;i&lt;=k;++i)tp[++p]=n-k+i; for(register int i=1;i&lt;=n;++i)if(sa[i]&gt;k)tp[++p]=sa[i]-k; Rsort(); for(register int i=1;i&lt;=n;++i)tp[i]=rk[i]; rk[sa[1]]=p=1; for(register int i=2;i&lt;=n;++i) rk[sa[i]]=tp[sa[i]]==tp[sa[i-1]]&amp;&amp;tp[sa[i]+k]==tp[sa[i-1]+k]?p:++p; } } void get_height(){ int k=0,x; for(register int i=1;i&lt;=n;++i){ if(rk[i]==1)continue; if(k)--k; x=sa[rk[i]-1]; while(i+k&lt;=n&amp;&amp;x+k&lt;=n&amp;&amp;s[i+k]==s[x+k])++k; hei[rk[i]]=k; } } void solve(){ long long ans=0; st.push1(1); for(register int i=1;i&lt;=n;++i)st.push1(i),ll[i]=st.back(); st.clear(),st.push2(n+1); for(register int i=n;i;--i)st.push2(i),rr[i]=st.back()-1; for(register int i=1;i&lt;=n;++i) sum[i][0]=sum[i-1][0]+(col[sa[i]]==1),sum[i][1]=sum[i-1][1]+(col[sa[i]]==2);//前缀和 for(register int i=1;i&lt;=n;++i){ ans+=1ll*hei[i]*((sum[rr[i]][0]-sum[i-1][0])*(sum[i-1][1]-sum[ll[i]-1][1])+(sum[rr[i]][1]-sum[i-1][1])*(sum[i-1][0]-sum[ll[i]-1][0])); } printf(&quot;%lld\\n&quot;,ans); } int main(){ scanf(&quot;%s&quot;,s+1),m=strlen(s+1)+1; for(register int i=1;i&lt;m;++i)col[i]=1; s[m]=&#39;$&#39;; scanf(&quot;%s&quot;,a+1),n=strlen(a+1); for(register int i=1;i&lt;=n;++i) s[i+m]=a[i],col[i+m]=2; n+=m; Ssort(),get_height(),solve(); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://ctz45562.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"后缀数组","slug":"后缀数组","permalink":"https://ctz45562.github.io/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"},{"name":"单调栈","slug":"单调栈","permalink":"https://ctz45562.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}]},{"title":"SPOJ8222 NSUBSTR - Substrings","slug":"洛谷-SP8222-NSUBSTRSubstrings","date":"2019-04-16T23:24:07.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/04/17/洛谷-SP8222-NSUBSTRSubstrings/","link":"","permalink":"https://ctz45562.github.io/2019/04/17/%E6%B4%9B%E8%B0%B7-SP8222-NSUBSTRSubstrings/","excerpt":"传送门 $SAM$是啥？来一发朴素的$SA$解法。","text":"传送门 $SAM$是啥？来一发朴素的$SA$解法。 先把$SA$建出来。如果某两个子串$S_1,S_2$相同的话，它们所属的后缀的$LCP$要大于等于$len(S_1)$。 $LCP$是$\\min\\{height[k]\\}(i&lt;k\\le j)$，然后就变成了对每个长度$L$，求出最长的一段区间$[l,r]$使$height[i]\\ge L(i\\in[l,r])$。单调栈扫两遍就行了。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 250005 #define inf 0x3f3f3f3f #define pn putchar(&#39;\\n&#39;) #define px(x) putchar(x) #define ps putchar(&#39; &#39;) #define pd puts(&quot;======================&quot;) #define pj puts(&quot;++++++++++++++++++++++&quot;) using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int sa[maxn],rk[maxn],hei[maxn],tp[maxn],tax[maxn],ll[maxn],rr[maxn],ans[maxn],n,m; char s[maxn]; struct MonoStack{ int sta[maxn],top; inline void push(int x){ while(top&gt;1&amp;&amp;hei[sta[top]]&gt;=hei[x])--top; sta[++top]=x; } inline int back(){ return sta[top-1]; } inline void clear(){ top=0; } }st;//单调栈 void Rsort(){ for(register int i=0;i&lt;=m;++i)tax[i]=0; for(register int i=1;i&lt;=n;++i)++tax[rk[i]]; for(register int i=1;i&lt;=m;++i)tax[i]+=tax[i-1]; for(register int i=n;i;--i)sa[tax[rk[tp[i]]]--]=tp[i]; } void Ssort(){ for(register int i=1;i&lt;=n;++i)rk[i]=s[i],tp[i]=i; m=225,Rsort(); for(register int k=1,p=0;p&lt;n;m=p,k&lt;&lt;=1){ p=0; for(register int i=1;i&lt;=k;++i)tp[++p]=n-k+i; for(register int i=1;i&lt;=n;++i)if(sa[i]&gt;k)tp[++p]=sa[i]-k; Rsort(); for(register int i=1;i&lt;=n;++i)tp[i]=rk[i]; rk[sa[1]]=p=1; for(register int i=2;i&lt;=n;++i) rk[sa[i]]=tp[sa[i]]==tp[sa[i-1]]&amp;&amp;tp[sa[i]+k]==tp[sa[i-1]+k]?p:++p; } } void get_height(){ int k=0,x; for(register int i=1;i&lt;=n;++i){ if(rk[i]==1)continue; if(k)--k; x=sa[rk[i]-1]; while(i+k&lt;=n&amp;&amp;x+k&lt;=n&amp;&amp;s[i+k]==s[x+k])++k; hei[rk[i]]=k; } } void solve(){ st.push(0); for(register int i=1;i&lt;=n;++i) st.push(i),ll[i]=st.back()+1; st.clear(),st.push(n+1); for(register int i=n;i;--i) st.push(i),rr[i]=st.back()-1; for(register int i=1;i&lt;=n;++i) ans[hei[i]]=max(ans[hei[i]],rr[i]-ll[i]+2);//先只更新当前答案 ，比hei[i]小的下面做一个后缀最大值取到 ans[n+1]=1;//答案最少为1 for(register int i=n;i;--i) ans[i]=max(ans[i],ans[i+1]); for(register int i=1;i&lt;=n;++i) printf(&quot;%d\\n&quot;,ans[i]); } int main(){ scanf(&quot;%s&quot;,s+1),n=strlen(s+1); Ssort(),get_height(),solve(); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://ctz45562.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"后缀数组","slug":"后缀数组","permalink":"https://ctz45562.github.io/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"},{"name":"单调栈","slug":"单调栈","permalink":"https://ctz45562.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}]},{"title":"洛谷 P2336 [SCOI2012]喵星球上的点名","slug":"洛谷-P2336-SCOI2012-喵星球上的点名","date":"2019-04-16T13:13:33.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/04/16/洛谷-P2336-SCOI2012-喵星球上的点名/","link":"","permalink":"https://ctz45562.github.io/2019/04/16/%E6%B4%9B%E8%B0%B7-P2336-SCOI2012-%E5%96%B5%E6%98%9F%E7%90%83%E4%B8%8A%E7%9A%84%E7%82%B9%E5%90%8D/","excerpt":"传送门 不知道为啥写这题时的感觉跟以前写「阿狸的打字机」很像。。。","text":"传送门 不知道为啥写这题时的感觉跟以前写「阿狸的打字机」很像。。。 第一问后缀数组常规操作，给定模式串和母串，求每个模式串在多少个母串出现过。 把所有串染色后拼起来（姓和名之间也要加上特殊字符），建出$SA$，$ST$表+二分出匹配区间后就成了HH的项链。这里选择莫队解决。 关键是第二问，询问每种颜色被多少个询问区间覆盖。 这里就是莫队的一个小技巧了：如果一种颜色在询问$q_L$里出现，又在$q_R$里消失，那么在$q_{L\\sim R-1}$这种颜色都出现了，答案就加上$R-L$，一波作差就好了。 然而蒟蒻莫队并没怎么练过（板子都打不对）。。。然后死在了第二问的莫队常规操作上$QAQ​$ 这也太技巧了。——摘自《潮语·潮讽》 代码：（如果蒟蒻写了个假了的莫队、$SA$或$ST$表请各位$dalao$指正。。。） #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 500005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int pos[maxn],col[maxn],tax[maxn],tp[maxn],rk[maxn],sa[maxn],s[maxn],hei[maxn],lg[maxn],f[maxn][25],ans1[maxn],ans2[maxn],len[maxn],cnt[maxn],all,n,m,N,M; struct Question{ int b,l,r,num; bool operator &lt; (const Question &amp;x)const{ if(b!=x.b)return b&lt;x.b; if(b&amp;1)return r&lt;x.r; return r&gt;x.r; } }q[maxn]; void Rsort(){ for(register int i=0;i&lt;=m;++i)tax[i]=0; for(register int i=1;i&lt;=n;++i)++tax[rk[i]]; for(register int i=1;i&lt;=m;++i)tax[i]+=tax[i-1]; for(register int i=n;i;--i)sa[tax[rk[tp[i]]]--]=tp[i]; } void Ssort(){ for(register int i=1;i&lt;=n;++i)rk[i]=s[i]+1,m=max(m,s[i]+1),tp[i]=i; Rsort(); for(register int k=1,p=0;p&lt;n;m=p,k&lt;&lt;=1){ p=0; for(register int i=1;i&lt;=k;++i)tp[++p]=n-k+i; for(register int i=1;i&lt;=n;++i)if(sa[i]&gt;k)tp[++p]=sa[i]-k; Rsort(); for(register int i=1;i&lt;=n;++i)tp[i]=rk[i]; rk[sa[1]]=p=1; for(register int i=2;i&lt;=n;++i) rk[sa[i]]=tp[sa[i]]==tp[sa[i-1]]&amp;&amp;tp[sa[i]+k]==tp[sa[i-1]+k]?p:++p; } } void get_height(){ int k=0,x; for(register int i=1;i&lt;=n;++i){ if(rk[i]==1)continue; if(k)--k; x=sa[rk[i]-1]; while(i+k&lt;=n&amp;&amp;x+k&lt;=n&amp;&amp;s[i+k]==s[x+k])++k; f[rk[i]][0]=hei[rk[i]]=k; } } void ST(){ for(register int i=1;i&lt;=n;++i)lg[i]=lg[i-1]+(1&lt;&lt;lg[i-1]==i); for(register int j=1;j&lt;lg[n];++j) for(register int i=1;i+(1&lt;&lt;(j-1))&lt;=n;++i) f[i][j]=min(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]); }//st表预处理 inline int query(int l,int r){ int len=lg[r-l+1]-1; return min(f[l][len],f[r-(1&lt;&lt;len)+1][len]); }//st表查询 inline int lcp(int i,int j){ if(i==j)return n-sa[i]+1; return query(min(i,j)+1,max(i,j)); } void work(int x){ int ra=rk[pos[x]],l=1,r=ra,mid,ans=ra; while(l&lt;r){ mid=l+r&gt;&gt;1; if(lcp(mid,ra)&gt;=len[x])r=mid; else l=mid+1; }//二分左端点 q[x].l=l; l=ra,r=n; while(l&lt;=r){ mid=l+r&gt;&gt;1; if(lcp(mid,ra)&gt;=len[x])l=mid+1,ans=mid; else r=mid-1; }//二分右端点 q[x].r=ans,q[x].num=x; } inline void Get(int &amp;l,int x=0){ l=read(); for(register int i=1;i&lt;=l;++i) s[i+n]=read()+1,col[i+n]=x; s[n+l+1]=0; n+=l+1; }//读入 int p,k;//k是当前询问编号 inline void add(int x){ p=col[sa[x]]; if(p){ if(!cnt[p])++all,ans2[p]-=k; ++cnt[p]; } } inline void del(int x){ p=col[sa[x]]; if(p){ --cnt[p]; if(!cnt[p])--all,ans2[p]+=k; } } int main(){ N=read(),M=read(); int l=1,r=0,sq=sqrt(M); for(register int i=1;i&lt;=N;++i) Get(len[0],i),Get(len[0],i); for(register int i=1;i&lt;=M;++i) pos[i]=n+1,Get(len[i]); Ssort(),get_height(),ST(); for(register int i=1;i&lt;=M;++i) work(i); for(register int i=1;i&lt;=M;++i) q[i].b=q[i].l/sq+1; sort(q+1,q+1+M); while(++k&lt;=M){ while(l&lt;q[k].l)del(l++); while(l&gt;q[k].l)add(--l); while(r&lt;q[k].r)add(++r); while(r&gt;q[k].r)del(r--); ans1[q[k].num]=all; } while(l&lt;=r)del(l++); for(register int i=1;i&lt;=M;++i) printf(&quot;%d\\n&quot;,ans1[i]); for(register int i=1;i&lt;=N;++i) printf(&quot;%d &quot;,ans2[i]); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://ctz45562.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"后缀数组","slug":"后缀数组","permalink":"https://ctz45562.github.io/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"},{"name":"ST表","slug":"ST表","permalink":"https://ctz45562.github.io/tags/ST%E8%A1%A8/"},{"name":"莫队","slug":"莫队","permalink":"https://ctz45562.github.io/tags/%E8%8E%AB%E9%98%9F/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"后缀数组学习笔记","slug":"后缀数组学习笔记","date":"2019-04-14T11:28:10.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/04/14/后缀数组学习笔记/","link":"","permalink":"https://ctz45562.github.io/2019/04/14/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"终于正式开新算法啦！ 发现学过的东西至今只会打板子很方赶紧学点很酷很炫的新算法安抚一下自己QAQ","text":"终于正式开新算法啦！ 发现学过的东西至今只会打板子很方赶紧学点很酷很炫的新算法安抚一下自己QAQ 前言（瞎扯）后缀很好理解，就是一个字符串从某个位置到结尾连成的子串。 后缀数组（$Suffix\\ Array$）就是把这些后缀按字典序排序后的数组。功能十分强大。 后缀数组主要是用来练习单调栈、二分和$ST$表的（雾 抄袭来源 http://www.cnblogs.com/zwfymqz/p/8413523.html https://blog.csdn.net/a1035719430/article/details/80217267 https://www.cnblogs.com/victorique/p/8480093.html https://challestend.github.io/suffix-array-learning-notes/ https://wavwing.top/2019/01/18/2019.1.18/ #define基本$S(i)$：从位置$i$开始的后缀 $s[l,r]$：截取字符串$s$第$l$到第$r$个字符得到的子串 $n$：字符串长度 $len(p)$：字符串$p$的长度 后缀数组$sa[i]$：（字典序）排第$i$名的后缀的下标 $rk[i]$：$S(i)$的排名 （显然$rk[sa[i]]=i$，$sa[rk[i]]=i$，知道一个就能求出另一个） 基数排序$tax[i]$：第一关键字的桶（在基数排序中会处理成前缀和） $tp[i]$：第二关键字排名第$i$名的下标 $m$：第一关键字有多少种排名（一开始为字符集大小） height数组$LCP(i,j)$：$S(i)$和$S(j)$的最长公共前缀 $lcp(i,j)$：$LCP(sa[i],sa[j])$（注意区分$LCP$） $height[i]$：$lcp(i-1,i)$ $h[i]$：$height[rk[i]]$ 后缀排序先不管后缀数组干啥，得先能造出来后缀数组，就要对后缀排序。 $sort$显然不行。 于是有了倍增$O(n\\log n)$、$DC3\\ O(n)$、$SA-IS\\ O(n)$、潮爷几个数组随便模拟$O(1)$的后缀排序。 不要学很酷很炫的算法，学了你就失败。——某金牌教练 所以我就学了最好懂(?)最好写(?)的倍增。 倍增前置芝士 基数排序：说实话现在还没搞懂。概括一下就是逐位比较，先比较个位，再比较十位。。。复杂度$O(n\\lg n)$。不过在后缀排序中只有两个关键字，所以复杂度是$O(n)$的。 原理$S(i)$的前$k$位就是$S(i-k)$的$k+1\\sim 2k$位，两者的字典序排名也是一样的。那么我们就可以通过$S(i)$的前$k$位排名获取$S(i-k)$的$k+1\\sim 2k$位的排名了。 设倍增跳到了第$k$层，我们要以每个后缀前$k$位的排名为第一关键字，$k+1\\sim 2k$位的排名为第二关键字排序。结合上面那个原理转移，进行双关键字基数排序。 最多跳$\\log n$层，每次基数排序是$O(n)$的，总复杂度$O(n\\log n)$。 实现int tax[maxn],tp[maxn],sa[maxn],rk[maxn],m,n; char s[maxn]; void rsort(){ for(register int i=0;i&lt;=m;++i)tax[i]=0; for(register int i=1;i&lt;=n;++i)++tax[rk[i]]; for(register int i=1;i&lt;=m;++i)tax[i]+=tax[i-1]; for(register int i=n;i;--i)sa[tax[rk[tp[i]]]--]=tp[i]; }//基数排序 void ssort(){ m=75; for(register int i=1;i&lt;=n;++i)rk[i]=s[i]-&#39;0&#39;,tp[i]=i; rsort(); for(register int k=1,p=0;p&lt;n;m=p,k&lt;&lt;=1){ p=0; for(register int i=1;i&lt;=k;++i)tp[++p]=n-k+i; for(register int i=1;i&lt;=n;++i) if(sa[i]&gt;k)tp[++p]=sa[i]-k; rsort(); for(register int i=1;i&lt;=n;++i)tp[i]=rk[i]; rk[sa[1]]=p=1; for(register int i=2;i&lt;=n;++i) rk[sa[i]]=tp[sa[i]]==tp[sa[i-1]]&amp;&amp;tp[sa[i]+k]==tp[sa[i-1]+k]?p:++p; } }//后缀排序 后缀排序ssort先不看基数排序，现在先理解为一次rsort后，$sa$数组会更新为依据$rk$（第一关键字的排名）和$tp$（第二关键字的位置）排序后的结果。 m=75;是初始化字符集大小。 首先以第$1$位为第一关键字、位置为第二关键字排序： for(register int i=1;i&lt;=n;++i)rk[i]=s[i]-&#39;0&#39;,tp[i]=i; rsort();基数排序。 排序的变量： for(register int k=1,p=0;p&lt;n;m=p,k&lt;&lt;=1) $k$是当前倍增长度，也就是这次排序要对前$2k$个字母排序。 $p$是一个计数器，下面要用到。 循环条件先不用管最后说，m=p是一个小优化也先不管，k&lt;&lt;=1每次$k$延展一倍。 现在我们有每个后缀前$k$个字符的排名情况，要扩展到$2k$上，也就是以每个后缀的前$k$位为第一关键字，$k+1\\sim 2k$位为第二关键字进行基数排序。那么要先获取第二关键字的排名。 首先有的后缀长度达不到$k$个，排序时后$k$个字符是空的，认为它们排名最靠前，先加进$tp$数组里： for(register int i=1;i&lt;=k;++i)tp[++p]=n-k+i; 然后是重点： for(register int i=1;i&lt;=n;++i)if(sa[i]&gt;k)tp[++p]=sa[i]-k; 原理中“通过$S(i)$的前$k$位排名获取$S(i-k)$的$k+1\\sim 2k$位的排名”。当前$sa$存的是$S(sa[i])$的前$k$位排名，就用它更新$S(sa[i]-k)$第二关键字的排名。 rsort();基数排序。 接下来更新$rk$数组以进行新一轮的排序，需要一个新数组存一下原$rk$数组，$tp$排完序后就没用了，正好用上（$memcpy$也行）： for(register int i=1;i&lt;=n;++i)tp[i]=rk[i]; （最好还是不要直接$swap$两个数组，有的地方会$CE$） 初始化第一名和计数器： rk[sa[1]]=p=1; 按$sa$依次更新$rk$，更新$rk$时要注意可能有重复的排名。 for(register int i=2;i&lt;=n;++i) rk[sa[i]]=(tp[sa[i]]==tp[sa[i-1]]&amp;&amp;tp[sa[i]+k]==tp[sa[i-1]+k])?p:++p; 注意$tp$数组已经赋值为原$rk$数组！ 比较一下原$S(sa[i])$和$S(sa[i-1])$的前$k$个字符的$tp$，再比较一下$k+1\\sim 2k$的$tp$，两个都相等说明这一轮排名相等，$p$不变；否则$++p$。 我们回过头来看循环条件：p&lt;n。 更新完$rk$后，$p$作为计数器，意义是有多少个不同的排名。所以只要p==n即每个后缀排名都不同就排完了。 基数排序rsort$m$为第一关键字有多少种的排名，也就是$tax$桶的上界。一开始初始化m=75即字符集大小。 前面提到的m=p即更新桶的上界。注意桶的下标是从$0\\sim m$的。 先清空第一关键字的桶（$memset$也行）： for(register int i=0;i&lt;=m;++i)tax[i]=0; 把每个后缀的第一关键字排名加进对应的桶里： for(register int i=1;i&lt;=n;++i)++tax[rk[i]]; 对桶做一个前缀和： for(register int i=1;i&lt;=m;++i)tax[i]+=tax[i-1]; 做完前缀和后，每个桶的意义就变为：第一关键字排名为$i$，前面就有$tax[i]$个比它小的 最难理解的一步： for(register int i=n;i;--i)sa[tax[rk[tp[i]]]--]=tp[i]; 先复习一下定义： $tp[i]$：第二关键字排名第$i$名的下标 一层一层看： $i$从大到小循环：优先处理第二关键字排名靠后的 $tp[i]$：找到第二关键字排名为$i$的下标 $rk[tp[i]]$：找到它第一关键字的排名 $tax[rk[tp[i]]]$：找到对应的桶 $tax[rk[tp[i]]]—$：现在我们从这个桶里拿走它的排名。对于第一关键字比它小的，已经通过前缀和处理出来；因为是倒序循环，保证了第二关键字比它小的在它后面取到，实现了优先第一关键字排序，再以第二关键字排序。 $sa[tax[rk[tp[i]]]—]=tp[i]$：更新$sa$数组。 （模拟一下对理解很有帮助） 最后偷放一张图理解一下（来源）： height数组后缀数组的精髓。 性质及XJB证明：1.$lcp(i,j)=\\min\\{lcp(i,k),lcp(k,j)\\}(i&lt;k&lt;j)$ 放个图会直观一些（以$aaaaabaaab$为例，下面的数组是$sa$） 抄来的证明： 设$I=S(i),J=S(j),K=S(k),p=\\min\\{lcp(i,k),lcp(k,j)\\}$ 则$I$与$K$前$p$个字符相同，$K$与$J$前$p$个字符相同。$I$与$J$最少有前$p$个字符相同。 由$p=\\min\\{lcp(i,k),lcp(k,j)\\}$可知$I$与$K$第$p+1$个字符不相同或$K$与$J$第$p+1$个字符不相同。即$I$与$J$第$p+1$个字符不相同。 所以$I$与$J$最长公共前缀为$p$。 2.$h[i]\\ge h[i-1]-1$（重点） 对于$h[i-1]\\le 1$时显然成立。 考虑$h[i-1]&gt;1$的情况： 设$k$为$sa[rk[i-1]-1]$。 则$h[i-1]=LCP(i-1,k)$ 把$S(i-1)$和$S(k)$去掉首字母，得到$S(i)$和$S(k+1)$，可知$LCP(i,k+1)=LCP(i-1,k)-1=h[i-1]-1$ 同时$k+1$在$sa$中一定排在$i$的前面。 上面这句话卡了我一天$QAQ$，所以详细写一下原因。 放一张图： $S(k)$之所以排在$S(i-1)$的前面，就是在第$LCP(i-1,k)+1$的字符差异导致的。如上图灰框圈出的部分。 当去掉首字母后，因为$h[i-1]&gt;1$，所以$S(i)$与$S(k+1)$还是会在同样的地方有差异，$rk[k+1]$还是小于$rk[i]$，$k+1$在$sa$中一定排在$i$前面。 那么所有比$i$排名靠前的里谁和$i$最像（$LCP$最大）呢？一定是和它相邻的，也就是$sa[rk[i]-1]$。 则$lcp(rk[i],rk[i-1])\\ge LCP(i,k+1)$ $height[rk[i]]\\ge h[i-1]-1$ $h[i]\\ge h[i-1]-1$ （阳阳$2$分钟讲明白了我看了一天的证明，$TQL$！） 3.$lcp(i,j)=\\min\\{height[k]\\}(i&lt; k\\le j)$ 根据性质$1$，有： $lcp(i,j)=\\min\\{lcp(i,i+1),lcp(i+1,j)\\}\\\\ \\qquad\\quad\\ =\\min\\{lcp(i,i+1),lcp(i+1,i+2),lcp(i+2,j)\\}\\\\ \\qquad\\quad\\ =\\min\\{lcp(k,k-1)\\}(i&lt;k\\le j)\\\\ \\qquad\\quad\\ =\\min\\{height[k]\\}(i&lt;k\\le j)$ （还是抄的） 实现说了那么多，怎么求$height$数组呢？ 根据上面的性质$2$，就有线性时间复杂度推出$h$数组的方法，进而求出$height$数组。 当然并不需要真的开$h$数组，直接按位置循环求$height$即可。 int height[maxn]; void get_height(){ int k=0,x;//k是h[i-1] for(register int i=1;i&lt;=n;++i){ if(rk[i]==1)continue; if(k)--k;//h[i]&gt;=h[i-1]-1 x=sa[rk[i]-1];//获取待匹配的串 while(i+k&lt;=n&amp;&amp;x+k&lt;=n&amp;&amp;s[i+k]==s[x+k])++k;//匹配 height[rk[i]]=k;//更新height } } 这样就能$O(n)$求$height$啦！ 应用任意两个后缀的LCP​由性质$3$可知： $LCP(i,j)=\\min\\{height[k]\\}(\\min\\{rk[i],rk[j]\\}+1&lt;k\\le \\max\\{rk[i],rk[j]\\})$ 用$ST$表$O(n\\log n)$预处理，$O(1)$回答。 不同子串个数求一个字符串本质不同的子串个数。 总子串个数为$\\dfrac{n(n+1)}{2}$ 每个后缀的所有前缀构成了所有子串。对于某一个后缀$S(i)$的前缀，与前面重复的个数为$height[rk[i]]$。 答案即为$\\dfrac{n(n+1)}{2}-\\sum\\limits_{i=1}^{n}height[i]$ 最长公共子串求多个字符串的最长公共子串。 把每个字符串依次连接起来，每个串之间用一个特殊字符隔开。再给每个串的字符染上颜色。构建后缀数组。 扫一遍$sa$数组，用尺取法获取尽可能小的区间$[l,r]$使$sa[i]$$(i\\in [l,r])$能覆盖所有颜色，所有的$\\min\\{hei[i]\\}(i\\in (l,r])$的最大值即为答案。用单调队列维护达到$O(\\sum len(S))$。 模式串出现次数给定一些模式串和一些母串，求每个模式串在所有母串中出现过多少次。 把所有串拼到一起建出$SA$，找到每个模式串$p$的“匹配区间”，也就是最大的区间$[l,r]$使所有的$LCP(i,p)\\ge len(p)(i\\in[l,r])$。答案具有单调性可以$ST$表+二分。由于模式串之间可能有子串关系，统计时染个色，模式串不加入答案，做一个前缀和就好了。 模式串出现次数（去重）给定一些模式串和母串，求每个模式串在多少个母串里出现过。 和上面一样，二分出来区间，数颜色种数。 额。。。$HH$的项链？主席树？离线+树状数组？莫队？有那么麻烦？ 好吧真的这么做。。。 可重叠最长重复子串$\\max\\{height[i]\\}$ 不可重叠最长重复子串二分答案。找到所有满足$\\min\\{height[i]\\}\\ge mid(i\\in[l,r])$的区间（区间尽可能大），若$\\max\\{sa[i]\\}-\\min\\{sa[i]\\}\\ge mid$则答案可行。 最长回文子串并不会manacher和哈希所以在这里写写。 枚举一下回文中心$p$，求出翻转过来的前缀$p$与后缀$p$的$LCP$更新答案。把串翻转过来接在后面用$ST$表维护。 最小表示法给定一个串，可以任意把最后面的字符移到开头，求能得到的字典序最小的串。 把原串复制一遍接在后面（不加特殊字符），两边染个色。找到染前半段颜色的$rk$最小的后缀就是答案。 水题不同子串个数就是上面应用第二个。 LCS - Longest Common Substring两个串的$LCS$，应用第三个求解即可。 不过这个题就两个串也可以直接取$\\max\\{height[i]\\}(col[i-1]\\neq col[i])$ 字符加密把字符串复制一遍接到后面，直接后缀排序，按$sa$的顺序输出。 Sandy的卡片多个串的$LCS$。显然两个串相同时相邻两项之间的差是相等的。 差分一下上板子就完了。 差异$asuldb$强推此题，他说有六成$SA$的题都能转到这个题上。 求$\\sum\\limits_{1\\le i&lt;j\\le n} len(S(i))+len(S(j))-2LCP(i,j)$ 前面的$len(S(i)),len(S(j))$和系数$2$提出来，就成了求： $\\sum\\limits_{1\\le i&lt;j\\le n}LCP(i,j)=\\sum\\limits_{1\\le i&lt;j\\le n}\\min\\{height[k]\\}(i&lt;k\\le j)$ 也就是$sa$里每个子区间的$min\\{height[i]\\}$之和。 枚举一下每个$height[i]$在哪个区间为最小值，找到左右第一个比它小的$height$，单调栈扫两遍乘起来就行了。注意处理好$height$值相同的数。 喵星球上的点名题意概述：给一堆母串和模式串，求出每个模式串在多少个母串中出现过，每个母串包含了多少个模式串。 第一问应用里讲过了，为了处理第二问得用莫队。 第二问就是每种颜色在多少询问区间里出现过。 莫队移动指针时如果某种颜色没了，那么它就会在它上次出现的那个询问$\\sim$当前询问之间的区间里出现过，然后作差加起来就完了。。。 更详细的题解 后记：调了一晚上，蒟蒻命要没了 仰望半月的夜空对每个长度$L$，找到它在$sa$数组里最靠前且最大的可行区间，然后$ST$表查询这个区间的$\\min\\{sa[i]\\}$即可。 这里可行区间就是对区间内每个后缀，截取的长度为$L$的子串相同的区间。最靠前保证了字典序最小。容易想到区间$[l,r]$满足$\\min\\{height[i]\\}\\ge len(i\\in[l,r])$就是可行区间。 左端点好确定，$O(n)$扫一遍。右端点$ST$表维护$\\min\\{height[i]\\}$+二分。 字符串显然是要从$S(a\\sim b)$和$S(c)$取$LCP$。则$S(i)$与$S(c)$的$LCP$为$\\min\\{LCP(i,c),b-i+1,d-c+1\\}$ 这个$b-i+1$是变化的，很麻烦，那么二分答案。 对于当前答案$mid$，$S(a\\sim b-mid+1)$不受影响，求出这个区间内最大$LCP$值确定二分边界。 显然$sa$里离得越近$LCP$越大（废话），问题就成了求$S(a\\sim b-mid+1)$谁的$rk$和$S(c)$的$rk$离得最近。 静态区间前驱后继，上主席树就是了。 复杂度$O(n\\log^2 n)$，有点卡常。。。 弦论$t=0$时造出$SA$求出$height$数组。枚举答案所在的后缀，$S(sa[i])$前有$\\sum\\limits_{j=1}^{i-1} len(S(sa[j]))-height[j]$个子串比$S(sa[i])$的子串小。 $t=1$，$emm…$学了$SAM$再做，先咕了。 $update$：填坑","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ctz45562.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://ctz45562.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"后缀数组","slug":"后缀数组","permalink":"https://ctz45562.github.io/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"}]},{"title":"洛谷 P3558 [POI2013]BAJ-Bytecomputer","slug":"洛谷-P3558-POI2013-BAJ-Bytecomputer","date":"2019-04-13T00:34:17.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/04/13/洛谷-P3558-POI2013-BAJ-Bytecomputer/","link":"","permalink":"https://ctz45562.github.io/2019/04/13/%E6%B4%9B%E8%B0%B7-P3558-POI2013-BAJ-Bytecomputer/","excerpt":"传送门 其实没必要分类讨论。","text":"传送门 其实没必要分类讨论。 很容易想到设$f(i,j)$表示前$i$个数满足单调不降、第$i$个数为$j$的最少操作次数。 再定义一个函数$calc(x,y,state)$表示：把$a[i-1]$可以取到的值压进$state$里（二进制下每一位依次表示能取到$-1,0,1$），$a[i]$从$x$修改为$y$的最小代价。 预处理$calc$，转移方程就能直接写成： $f(i,j)=\\min\\{f(i-1,k)+calc(a[i],j,state)\\}(k\\le j)$（把$\\min(a[i-1],k)$到$\\max(a[i-1],k)$每个值加入$state$） 解释一下：枚举$a[i-1]$修改为了$k$，那么在$a[i-1]$修改的过程中会取到$\\min(a[i-1],k)$到$\\max(a[i-1],k)$的每个值，想用哪个值，就在它修改到这个值的时候去更新$a[i]$。 然后就是预处理$calc$了： 若$x=y$，$calc(x,y,state)=0$ 若$x&lt; y$，只要$state$能取到$1$，就有$calc(x,y,state)=y-x$ 若$x&gt;y$，只要$state$能取到$-1$，就有$calc(x,y,state)=x-y$ 其他情况均为$inf$ 初始状态$f(1,a[1])=0$，答案为$\\min\\{f(n,-1),f(n,0),f(n,1)\\}$，复杂度$O(9n)$。 题面没有给范围，大概是$1e6$，无解还要输出”$BRAK$” 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 1000005 const long long inf = 4557430888798830399ll; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } const int S = 7; int a[maxn]={1}; long long f[maxn][3],s[3][3][S+2]; //s是calc函数的值 void init(){ memset(f,0x3f,sizeof f); memset(s,0x3f,sizeof s); for(register int s0=0;s0&lt;=S;++s0) for(register int i=0;i&lt;3;++i) s[i][i][s0]=0;//x=y for(register int s0=0;s0&lt;=S;++s0) if(s0&amp;1)s[2][1][s0]=s[1][0][s0]=1,s[2][0][s0]=2;//state能取到-1 for(register int s0=0;s0&lt;=S;++s0) if(s0&amp;4)s[0][1][s0]=s[1][2][s0]=1,s[0][2][s0]=2;//state能取到1 //预处理s } int main(){ int n=read(),state; long long ans=inf; for(register int i=1;i&lt;=n;++i) a[i]=read()+1; //防止负数下标全部+1 init(); f[1][a[1]]=0; for(register int i=2;i&lt;=n;++i) for(register int j=0;j&lt;3;++j) for(register int k=0;k&lt;=j;++k){ state=0; for(register int p=min(a[i-1],k);p&lt;=max(a[i-1],k);++p) state|=1&lt;&lt;p; f[i][j]=min(f[i][j],f[i-1][k]+s[a[i]][j][state]); } ans=min(f[n][0],min(f[n][1],f[n][2])); if(ans==inf)puts(&quot;BRAK&quot;); else printf(&quot;%lld\\n&quot;,ans); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"洛谷 AT2567 RGB Sequence","slug":"洛谷-AT2567-RGB-Sequence","date":"2019-04-12T12:14:52.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/04/12/洛谷-AT2567-RGB-Sequence/","link":"","permalink":"https://ctz45562.github.io/2019/04/12/%E6%B4%9B%E8%B0%B7-AT2567-RGB-Sequence/","excerpt":"传送门 一道神仙$DP$题$QwQ$。继续抄题解","text":"传送门 一道神仙$DP$题$QwQ$。继续抄题解 设$f(i,j,k)$表示已经处理前$i$个元素、最后一次出现的位置第二靠前的颜色位置为$j$、第三靠前的位置为$k$时的方案数。显然第一靠前的是$i$，所以不用设出来。 对于每个限制条件，把它限制在右端点。（右端点是临界情况，右端点之前没达到条件可以在后面补足） 用刷表法转移。枚举第$i+1$个元素的颜色并检验每个限制$i+1$的条件是否满足，满足就转移。 具体来说分$3$种情况： 颜色和$i$一样：$f(i+1,j,k)+=f(i,j,k)$ 颜色和$j$一样：$f(i+1,i,k)+=f(i,j,k)$ 颜色和$k$一样：$f(i+1,i,j)+=f(i,j,k)$ 初始状态：$f(1,0,0)=1$ 最后答案为$3*\\sum\\limits_{i=0}^{n-1}\\sum\\limits_{j=0}^{\\max(i-1,0)}f(n,i,j)$ 为啥要乘$3$呢？这里$i,j,k$只是个位置关系，并不是具体某种颜色，所以任意给$i,j,k$选颜色，有$3$种排列。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #define maxn 305 #define inf 0x3f3f3f3f const int mod = 1e9+7; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } #define in(l,r,x) (l&lt;=x&amp;&amp;x&lt;=r) vector&lt;int&gt;limit[maxn];//限制条件 int l[maxn],c[maxn],f[maxn][maxn][maxn]; inline int count(int l,int r,int c1,int c2,int c3){ return in(l,r,c1)+in(l,r,c2)+in(l,r,c3); }//计算区间为l,r、颜色位置为c1,c2,c3时，有多少种颜色出现在区间内 int main(){ int n=read(),m=read(),k1,k2,k3,x,ans=0; for(register int i=1;i&lt;=m;++i) l[i]=read(),limit[read()].push_back(i),c[i]=read(); if(n==1){ ans=3; for(register int i=1;i&lt;=m;++i) if(c[i]==1)ans=min(ans,1); else ans=0; printf(&quot;%d\\n&quot;,ans); return 0; }//要特判n=1，刷表法刷不到1 f[1][0][0]=1; for(register int c1=1;c1&lt;n;++c1) for(register int c2=0;c2&lt;c1;++c2) for(register int c3=0;c3&lt;=max(c2-1,0);++c3){ bool ok1=1,ok2=1,ok3=1;//选1、2、3颜色是否可行 for(register int j=0;j&lt;limit[c1+1].size();++j){ x=limit[c1+1][j]; k1=count(l[x],c1+1,c1+1,c2,c3),k2=count(l[x],c1+1,c1,c1+1,c3),k3=count(l[x],c1+1,c1,c2,c1+1); ok1&amp;=(k1==c[x]),ok2&amp;=(k2==c[x]),ok3&amp;=(k3==c[x]); }//依次检验每个区间 if(ok1)(f[c1+1][c2][c3]+=f[c1][c2][c3])%=mod; if(ok2)(f[c1+1][c1][c3]+=f[c1][c2][c3])%=mod; if(ok3)(f[c1+1][c1][c2]+=f[c1][c2][c3])%=mod; } for(register int j=0;j&lt;n;++j) for(register int k=0;k&lt;=max(j-1,0);++k) (ans+=f[n][j][k])%=mod; printf(&quot;%d\\n&quot;,((ans&lt;&lt;1)%mod+ans)%mod);//我就不开long long QwQ }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"洛谷 P3953 NOIP2017 逛公园","slug":"洛谷-P3953-NOIP2017-逛公园","date":"2019-04-12T00:22:59.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/04/12/洛谷-P3953-NOIP2017-逛公园/","link":"","permalink":"https://ctz45562.github.io/2019/04/12/%E6%B4%9B%E8%B0%B7-P3953-NOIP2017-%E9%80%9B%E5%85%AC%E5%9B%AD/","excerpt":"传送门 翻了翻往年的$NOIP$题，终于找到一道可做的了$QwQ$","text":"传送门 翻了翻往年的$NOIP$题，终于找到一道可做的了$QwQ$ 肯定要先跑个最短路。 先不管无解。第一反应是记忆化搜索，搜索状态为当前节点和已经走的距离。 显然是不行的，已经走的距离上界太大，数组开不下。 注意到$K$贼小，可以把$K$当做状态。 于是状态就改为当前节点和与最短路的差距。 显然，根据最短路的性质，走边$edge(x,y)$会导致差距增大$dis_x+edge(x,y).len-dis_y$（$dis$是最短路） 依此记忆化搜索即可。同时要注意，搜到点$n$不能停止，可能通过往回走绕几圈回来也是合法的。（蒟蒻因为这个取得了30分的好成绩） 再来处理无解。满足无解的条件： 存在$0$环 从起点经过$0$环到终点存在一条长度小于等于$dis_n+K$的路径 判环我只会Tarjan 反向建图跑最短路，然后依次对位于$0$环的点判断$dis(1,x)+dis(n,x)$是否小于等于$dis(1,n)+K$。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define maxn 100005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int dis[maxn],disn[maxn],H[maxn],h[maxn],f[maxn][51],sta[maxn],seg[maxn],low[maxn],top,n,m,k,mod,num,all; bool vis[maxn],zero[maxn]; priority_queue&lt;pair&lt;int,int&gt; &gt;q; struct edge{ int pre,to,l; }e[maxn&lt;&lt;1],E[maxn&lt;&lt;1]; //大写的都是反向建的边 inline void add(int from,int to,int l){ e[++num].pre=h[from],h[from]=num,e[num].to=to,e[num].l=l; E[num].pre=H[to],H[to]=num,E[num].to=from; } void DJ(){ memset(dis,0x3f,sizeof dis); dis[1]=0,q.push(make_pair(0,1)); while(!q.empty()){ int x=q.top().second; q.pop(); if(vis[x])continue; vis[x]=1; for(register int i=h[x];i;i=e[i].pre) if(dis[e[i].to]&gt;dis[x]+e[i].l)q.push(make_pair(-(dis[e[i].to]=dis[x]+e[i].l),e[i].to)); } } void reDJ(){ memset(disn,0x3f,sizeof disn); disn[n]=0,q.push(make_pair(0,n)); while(!q.empty()){ int x=q.top().second; q.pop(); if(vis[x])continue; vis[x]=1; for(register int i=H[x];i;i=E[i].pre) if(disn[E[i].to]&gt;disn[x]+E[i].l)q.push(make_pair(-(disn[E[i].to]=disn[x]+E[i].l),E[i].to)); } }//反向最短路 void TJ(int node){ vis[node]=1,sta[++top]=node; seg[node]=low[node]=++all; int x; for(register int i=h[node];i;i=e[i].pre){ if(e[i].l)continue;//只跑0边判0环 x=e[i].to; if(!seg[x])TJ(x),low[node]=min(low[node],low[x]); else if(vis[x])low[node]=min(low[node],seg[x]); } if(seg[node]==low[node]){ if(sta[top]!=node)zero[node]=1; while(sta[top]!=node)vis[sta[top]]=0,zero[sta[top--]]=1; --top,vis[node]=0; } } int dfs(int node,int delta){ if(delta&gt;k)return 0;//差距超出限制不合法 if(~f[node][delta])return f[node][delta]; f[node][delta]=(node==n);//到了终点就有1种方案 int x; for(register int i=h[node];i;i=e[i].pre){ x=e[i].to; f[node][delta]+=dfs(x,delta+dis[node]+e[i].l-dis[x]); if(f[node][delta]&gt;=mod)f[node][delta]%=mod; } return f[node][delta]; } int main(){ int t=read(),x,y; while(t--){ n=read(),m=read(),k=read(),mod=read(); memset(seg,0,sizeof seg); memset(zero,0,sizeof zero); memset(h,0,sizeof h); memset(H,0,sizeof H),num=0,all=0; memset(vis,0,sizeof vis); while(m--)x=read(),y=read(),add(x,y,read()); for(register int i=1;i&lt;=n;++i) if(!seg[i])TJ(i); reDJ(); memset(vis,0,sizeof vis); DJ(); for(register int i=1;i&lt;=n;++i) if(zero[i]&amp;&amp;dis[i]+disn[i]&lt;=dis[n]+k)goto Bad_Option; memset(f,-1,sizeof f); printf(&quot;%d\\n&quot;,dfs(1,0));//初始的差距为0 continue; Bad_Option: puts(&quot;-1&quot;); } }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"https://ctz45562.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"图论","slug":"图论","permalink":"https://ctz45562.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"tarjan","slug":"tarjan","permalink":"https://ctz45562.github.io/tags/tarjan/"},{"name":"最短路","slug":"最短路","permalink":"https://ctz45562.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"USACO-08FEB 修路Making the Grade","slug":"洛谷-P2893-USACO08FEB-修路Making-the-Grade","date":"2019-04-11T09:15:20.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/04/11/洛谷-P2893-USACO08FEB-修路Making-the-Grade/","link":"","permalink":"https://ctz45562.github.io/2019/04/11/%E6%B4%9B%E8%B0%B7-P2893-USACO08FEB-%E4%BF%AE%E8%B7%AFMaking-the-Grade/","excerpt":"传送门 这是一篇研究潮学、用于颓废的题解。 其实这题并不难，但是思维很巧妙。","text":"传送门 这是一篇研究潮学、用于颓废的题解。 其实这题并不难，但是思维很巧妙。 一个显而易见的思路就是设$f(i,j)​$为前$i​$个数都满足递增且第$i​$个数为$j​$的最小代价。就有转移方程$f(i,j)=min\\{f(i-1,k)+abs(a_i-j) \\}(k\\le j)​$。不过值域$1e9​$，无论空间还是时间都受不了。 把这个做法写出来并记录方案，用瞪眼法就会发现修改后的数一定是原数列的某个数。 重新设$f(i,j)​$为前$i​$个数都满足递增且第$i​$个数是原数列中第$j​$大的数的最小代价。先离散化，和原来一样转移，时间复杂度为$O(n^3)​$。然后这玩意可以直接前缀最小值优化成$O(n^2)​$。 写完后一交。。。过了。 A了再来证明 数（X）学（J）归（B）纳（扯）法： 只有一个数时显然保留原值是最优的。 假设前$k$个值已经满足递增了，考虑第$k+1$个值的处理方案： 这里假设$k=3$： 如上图，潮爷用第一种方案，一定是把自己变得和最强的一样强代价最小；用第二种方案，一定是把比他强的人变得和潮爷一样代价最小。 因为第一个数是原数列的数，所以后面的都还是原数列的数。 证完了！ （$wavwing$说这个结论显而易见，看来是我太蒻了） （其实这个题还有$O(n\\log n)$的做法，也是基于这个结论，懒得写了） （顺便说一句洛咕数据未免太水我忘了写递减的情况结果过了？） （所以我并不打算把递减的补上 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 2005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int f[maxn][maxn],a[maxn],dis[maxn]; int main(){ int n=read(),len; for(register int i=1;i&lt;=n;++i) dis[i]=a[i]=read(); sort(dis+1,dis+1+n); len=unique(dis+1,dis+1+n)-dis-1;//离散化 memset(f,0x3f,sizeof f); for(register int i=1;i&lt;=len;++i) f[0][i]=0; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=len;++j) f[i][j]=min(f[i-1][j]+abs(a[i]-dis[j]),f[i][j-1]);//前缀最小值 printf(&quot;%d\\n&quot;,f[n][len]); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"潮学","slug":"潮学","permalink":"https://ctz45562.github.io/tags/%E6%BD%AE%E5%AD%A6/"}]},{"title":"USACO-13OPEN 照片Photo","slug":"洛谷-P3084-USACO13OPEN-照片Photo","date":"2019-04-10T02:35:31.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/04/10/洛谷-P3084-USACO13OPEN-照片Photo/","link":"","permalink":"https://ctz45562.github.io/2019/04/10/%E6%B4%9B%E8%B0%B7-P3084-USACO13OPEN-%E7%85%A7%E7%89%87Photo/","excerpt":"传送门 思路甚妙的$DP$（蒟蒻并不会差分约束$QwQ$）","text":"传送门 思路甚妙的$DP$（蒟蒻并不会差分约束$QwQ$） 设$f(i)$为只考虑前$i$个，且第$i$头牛为斑点牛的最大值。 初始状态显然为$f(0)=0$。 转移： 每个区间只有一头斑点牛，第$i$头为斑点牛，则所有覆盖$i$的区间都不能转移，记$rr[i]$为覆盖点$i$的所有区间中最靠左的左端点。 每个区间必须有一头斑点牛，所有不覆盖$i$的区间必须有斑点牛，记$ll[i]$为不覆盖点$i$的区间中最靠右的左端点。 就有转移方程$f(i)=\\max \\{f(j)+1\\}(ll[i]\\le j \\le rr[i])$ 记所有区间中最靠右的左端点为$ml$，答案即为$\\max \\{f(i)\\}(ml\\le i \\le n)$。（最靠右的区间必须有斑点牛） 可以用单调队列优化，时间复杂度$O(n)​$。 对于预处理$ll[i],rr[i]​$同样可以$O(n)​$实现。对于每个区间$[L,R]​$，将$rr[L]​$与$L​$取$min​$；将$ll[R+1]​$与$L​$取$max​$，然后$ll​$正着扫一遍取前缀最大值，$rr​$倒着扫一遍取后缀最小值。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 200005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int ll[maxn],rr[maxn],f[maxn],line[maxn],head,tail; inline void push(int p){ if(f[p]==-1)return; while(head&lt;=tail&amp;&amp;f[line[tail]]&lt;=f[p])--tail; line[++tail]=p; } int main(){ int n=read(),m=read(),l,r,ml=1,poi=-1,ans=-1; for(register int i=1;i&lt;=n;++i) rr[i]=i; for(register int i=1;i&lt;=m;++i) l=read(),r=read(),ll[r+1]=max(ll[r+1],l),rr[r]=min(rr[r],l),ml=max(ml,l); for(register int i=1;i&lt;=n;++i) ll[i]=max(ll[i],ll[i-1]); for(register int i=n-1;i;--i) rr[i]=min(rr[i],rr[i+1]); memset(f,-1,sizeof f); f[0]=0,head=1; for(register int i=1;i&lt;=n;++i){ while(poi&lt;rr[i]-1)++poi,push(poi); while(head&lt;=tail&amp;&amp;line[head]&lt;ll[i])++head; if(head&lt;=tail)f[i]=f[line[head]]+1; } for(register int i=ml;i&lt;=n;++i) ans=max(ans,f[i]); printf(&quot;%d\\n&quot;,ans); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"单调队列","slug":"单调队列","permalink":"https://ctz45562.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"}]},{"title":"洛谷 P2157 [SDOI2009]学校食堂","slug":"洛谷-P2157-SDOI2009学校食堂","date":"2019-04-10T00:07:30.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/04/10/洛谷-P2157-SDOI2009学校食堂/","link":"","permalink":"https://ctz45562.github.io/2019/04/10/%E6%B4%9B%E8%B0%B7-P2157-SDOI2009%E5%AD%A6%E6%A0%A1%E9%A3%9F%E5%A0%82/","excerpt":"传送门 自从开始复习DP，我就天天抄题解","text":"传送门 自从开始复习DP，我就天天抄题解 第一眼看到题目：我是谁？我在哪？我要干什么？ 注意到$B​$的范围十分友好，明显要状压。我要状压啥？ 于是愉悦地抄起了题解 $f(i,st,k)$表示前$i-1$个人已经吃完，第$i$个人到第$i+7$个人的状态为$st$（$0$为没吃，$1$为吃了）最短时间。因为做一道菜的时间和上一道有关系，所以用$k$表示上一个吃的人为第$i+k$个人$(k\\in [-8,7])$。 Q：为啥k的意义这么奇怪？不能直接用k表示上一个吃的人为k？ A：可以发现上一个吃的人范围一定在$[i-8,i+7]$内，超出这个范围这个状态就是不合法的，就能直接省掉空间与时间。 初始状态：$f(1,0,-1)=0$（没有人吃饭，第$1$个人到第$8$个人都没吃饭，上一道菜为第$0$道，即还没有做菜） 考虑转移： 如果$st$第一位为$1$（第$i$个人吃了），那就直接向$f(i+1,st&gt;&gt;1,k-1)$转移。这两个状态其实是一样的，不用枚举下一个谁吃饭。 如果$st$第一位为$0$，枚举下一个谁吃了，转移到$f(i,st|(1&lt;&lt;j),j)$，还要注意满足每个人的容忍度，记录当前最大能吃饭的人的范围，一但超出就停止。 答案即为$\\min \\{f(n+1,0, -8)\\sim f(n+1,0,0)\\}$ Q：为什么不考虑不合法的状态呢？ ​ 比如说$st$中第3个人没吃，第6个人吃了，而第3个人容忍度为2，这样转移不就错了吗？ A：转移时都是向合法的状态转移，不合法的都被过滤掉了。所以当遇到不合法状态时，它从未被转移过，值也就为$inf$。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 1005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int t[maxn],b[maxn],F[maxn][1&lt;&lt;9][20],*f[maxn][1&lt;&lt;9]; inline int calc(int i,int j){ if(!i)return 0; return t[i]^t[j]; } //t[i]|t[j]-t[i]&amp;t[j]就相当于t[i]^t[j] int main(){ int c=read(); for(register int i=0;i&lt;maxn;++i) for(register int j=0;j&lt;(1&lt;&lt;9);++j) f[i][j]=&amp;F[i][j][10]; //小技巧：用指针处理可以使数组访问负数下表 while(c--){ int n=read(); for(register int i=1;i&lt;=n;++i) t[i]=read(),b[i]=read(); memset(F,0x3f,sizeof F); f[1][0][-1]=0; for(register int i=1;i&lt;=n;++i){ for(register int st=0;st&lt;(1&lt;&lt;8);++st) for(register int k=-8;k&lt;=7;++k){ if(f[i][st][k]==inf)continue; if(1&amp;st) f[i+1][st&gt;&gt;1][k-1]=min(f[i+1][st&gt;&gt;1][k-1],f[i][st][k]); else { for(register int j=0,li=7;j&lt;=li;++j)//li是最大容忍范围 if(!((1&lt;&lt;j)&amp;st)){ f[i][st|(1&lt;&lt;j)][j]=min(f[i][st|(1&lt;&lt;j)][j],f[i][st][k]+calc(i+k,i+j)); li=min(li,j+b[i+j]); } } } } int ans=inf; for(register int i=-8;i&lt;=0;++i) ans=min(ans,f[n+1][0][i]); printf(&quot;%d\\n&quot;,ans); } }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"状态压缩","slug":"状态压缩","permalink":"https://ctz45562.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"}]},{"title":"十二省联考2019R1 自闭游记","slug":"十二省联考2019R1-自闭游记","date":"2019-04-07T23:43:06.000Z","updated":"2021-07-19T09:14:05.460Z","comments":true,"path":"2019/04/08/十二省联考2019R1-自闭游记/","link":"","permalink":"https://ctz45562.github.io/2019/04/08/%E5%8D%81%E4%BA%8C%E7%9C%81%E8%81%94%E8%80%832019R1-%E8%87%AA%E9%97%AD%E6%B8%B8%E8%AE%B0/","excerpt":"希望能苟进二轮吧。。。","text":"希望能苟进二轮吧。。。 Day -2写了两道数据结构水题，没心情做题了。下午把板子都敲了一遍，才发现会的东西倍儿少。然后去敲维护数列和树套树彻底暴毙。 最后和$JF$颓了一晚上。 Day -1请了一天假在家休息。 颓废一时爽，一直颓废一直爽 Day 0总结一下会的： 练了半年的至今只会打板子的数据结构 板子都不一定打对的网络流 刚起步的数论 得出结论：凉透了。 和$JF$坐到一块，看着他用$1G$流量更新炉石。潮味相投的潮爷和曹爷坐一块，各种秀恩爱。颓了一路游戏。 和$wavwing$住一块，潮爷和曹爷不出意料住在一起。$challestend$和$mhr$住一块，根据$asuldb$所说，$challestend$是不是要凉啊… 下午帮$wavwing$调出了$LCT$，奶一口wavwing今天学LCT明天就爆切。 （然而一轮并没有LCT​ 晚上$loli$带着去一家比较大的饭店吃饭。潮爷俨然一副大老板模样，旁边有$asuldb$。潮爷一有不满意的地方，$asuldb$就立马赔♂罪。 潮爷：你（asuldb）稳到明天12点。你明天进考场稳了，出考场上厕所稳了，打对文件名稳了，不爆long long稳了，不爆int稳了… 晚上$wavwing$继续肝题，我在一边继续颓废。感觉wavwing稳了。 10点睡觉，然而$wavwing$和我都睡不着。 好不容易睡着了，做梦梦见自己$Day\\ 1\\ 185$分，我怕不是要凉凉$QAQ$。 Day 1一起床感觉精神一般，据wavwing所说他就没睡着，还听到了我打呼噜。 早餐吃的油条，咬了口面包感觉不对劲又放了回去。 进考场看到$XP$机和奇小无比的显示器真是令人愉悦。 先把三个题都浏览了一遍，感觉$T2$、$T3$令人自闭，先做$T1$。 暴力分$60$分真不少。正解显然要用$trie$树，顺便$yy$了一下$trie$树异或第$k$大。开个堆。。。对每个前缀异或和依次取出第$1$大、第$2$大。。。去更新堆，直到不能更新。。。 然而复杂度是错的，会被卡到$O(n^2\\log n)$。已经过了半个小时，本来暴力分还不少，觉得再想正解不如先看看其他题（失误$1$）。 $T2$再看看，每个$A$串对应的$B$串是固定的，这样每个$A$串下一个能接的$A$串也是固定的，预处理好就能造一张图，然后$Tarjan$判一下环，拓扑排序$+DP$就行了吧。。。（考完我才知道拓扑排序也能判环） 至于判前缀关系，给$B$串造棵$trie$树，让每个$A$串在上面跑。 试着写了一下直接过样例，我肥肠兴奋地以为写出了正解。结果最大的样例直接爆空间。。。算了一下时间复杂度也不对。。。 看了看数据，大概能拿$30-40$分吧。 再去看$T3$。前三个看出来是$19^n$，第一个打了个快速幂，第二个指数巨大套个欧拉定理，第三个要高精取模？懒得打了一会再说。 第四、五个猜模数？猜不出来，也没想着暴力去试。（失误2） 第六个wa了还有负数明显爆了$int$了。结果试了带取模爆$int$、不带取模爆$int$、不带取模爆$long\\ long$，又看到提示，试了转$unsigned\\ int$各种方案最后都没试出来，于是自闭了。 最后几个输出一堆$p$、$+$、$-$、$.$、$g$、$u$，一脸懵逼。字符串有循环节然后可以打表？写了个$kmp$还写挂了，改对后发现根本没有。彻底自闭。 回去搞$T2$，$trie$树空间开销太大而且多测$memset$太费时间，然后我突然智商下线换成了$O(n^2|S|)$的暴力匹配。（失误3） 其实本来只能拿部分分，完全可以把$trie$树数组开小的。 最后半小时回去把$T3$高精打了（没想着可以边读边取模）。 期望得分：$60+40+12=112$ asuldb半小时爆切$T1$，差点又切掉$T2$。潮爷$T1$以为是不相交的区间凉凉了。challestend展示出他高超的假技术，一直说自己爆零垫底。 asuldb说了$T1$的做法，其实真的是个沙雕题。。。然而我却没有投入过多时间。杜爷推出$T3$的$p$是质数，我当时是想找出题人好好交♂流一番的。 中午吃完饭听完讲解等成绩。和$asuldb$、$mhr$、$wavwing$、$challestend$一众大佬在山师大附中里闲逛。 出了成绩得知$T2$成功因为我的$zz$操作少了$30$分。$112\\rightarrow 82$。初四的杜爷$T1$爆零结果仍然$100+$吊打我，潮爷喜获$18$分的好成绩。（坐等潮爷$Day\\ 2\\ 318$分翻盘） 下午在宾馆颓。$loli$到各个房间奶，然后。。。 潮爷：KAO！我考了个大零蛋！ loli（推门而入）：知道自己考了多少分了？ 晚上一块叫的外卖。吃完和wavwing一起自闭。他玩吃鸡我玩手游。 loli敲门。 wavwing（以为是他妈）：去去！我这还没完呢，还有10个人。 loli：你们人都在吗？ wavwing：。。。 好在他现在还活着 睡前补了集天使和点兔。因为怕像昨天一样睡不着快$11$点睡的（其实是自闭了）。 然而还是没睡好 Day 2精神状态还是一般。。。 早餐又吃的油条。 都在奶今天一道$DP$一道网络流一道$LCT$。 浏览了一遍题目。$emm…$ 网络流呢？$T1$、$T3$求方案数显然不是，$T2\\ 2e5$的数据也跑不了。先去肝了$1$小时$T2$无果，再玩了一下$T1$，感觉像背包然而不会写啊。。。又用$1$小时把暴力打了出来，得分$20+45+8=73$。感觉要凉赶紧再看看有没有部分分。$T3$几个特殊数据想了一会感觉并不会，又去看$T2$一条链的情况。 这个可以贪心吧。。。把两条链提出来，取两边最大的合并。又不放心和暴力拍了一下，没啥问题扔了上去，能捞个$15$分。 还剩一个多小时，$T1$其他部分分也不会拿，自闭了半个多小时。（失误4） 最后还剩半小时，绝望地看了看$T2$，发现子树可以合并成一条链处理！这样就能用之前的贪心了。极限地用了十来分钟去写，幸亏之前对拍还留在那，拍了一下没问题。然而时间紧张，没想着可以堆+启发式合并稳定$O(n\\ log^2 n)$，所以可以被深度大一点的树卡死。赶紧写了个树的直径特判链数据，把之前的链处理放上。$2000$的数据没啥问题了，又捞到$15$分。 写完还有$5$分钟，真的惊险刺激。。。 出了成绩$T1$没挂，$20$分；$T2$最大数据一个点都不给过，幸亏没挂，$75$分（明明拍的时候随机数据下跑的还挺快的说$QAQ$）；$T3$暴力莫名挂了考了个大零蛋，得亏就$8$分。 全省$rank\\ 76$，不知道能不能苟进二轮。。。（虽然苟进去也注定进不了省队） 后记总结一下失误真的太大了。 如果能多投些时间在$D1T1$就能切掉了… 如果没有脑子一抽把$trie$树换成暴力$D1T2$就能多$30$分了… 如果没有懒得打暴力$D1T3$就能多拿几分了… 如果再多想想$D2T2$也能切掉了… 然而并没有那么多如果。 同时也深感自己缺乏比赛经验，基础算法也太烂了，总之慢慢补吧…","categories":[{"name":"日常","slug":"日常","permalink":"https://ctz45562.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://ctz45562.github.io/tags/OI/"},{"name":"游记","slug":"游记","permalink":"https://ctz45562.github.io/tags/%E6%B8%B8%E8%AE%B0/"}]},{"title":"洛谷 P4247 [清华集训]序列操作","slug":"洛谷-P4247-清华集训-序列操作","date":"2019-04-01T06:29:53.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/04/01/洛谷-P4247-清华集训-序列操作/","link":"","permalink":"https://ctz45562.github.io/2019/04/01/%E6%B4%9B%E8%B0%B7-P4247-%E6%B8%85%E5%8D%8E%E9%9B%86%E8%AE%AD-%E5%BA%8F%E5%88%97%E6%93%8D%E4%BD%9C/","excerpt":"传送门 快省选了从数论回来练练数据结构，然后被安利去做了这道毒瘤题。","text":"传送门 快省选了从数论回来练练数据结构，然后被安利去做了这道毒瘤题。 看到$3​$操作。 之后看到$c$的范围只有$20$，明显是暴力维护$20$种答案。 又到了欢乐的推式子时间： 设$f_p(i)​$为线段树$p​$节点代表区间选$i​$个数相乘所有方案得到的和，$ls(p)、rs(p)​$为$p​$的左右儿子。 合并 对于一个$f_p(i)$，$ls(p)$和$rs(p)$都可以提供各自的$f_{ls(p)}(i)$和$f_{rs(p)}(i)$。 然后就是两个儿子交起来的贡献，可以理解为把两个儿子拼起来，为$\\sum\\limits_{j=1}^{i-1}f_{ls(p)}(j)f_{rs(p)}(i-j)​$。 总复杂度为$O(20^2)​$ 相反数区间加太麻烦了先说取反。 容易想到，$i​$为奇数，取反会使$f_p(i)​$也取反；$i​$为偶数则不变。 复杂度为$O(20)​$ 区间加比如说$p$有四个数$a,b,c,d$，$f_p(3)$就有$a*b*c,a*b*d,a*c*d,b*c*d$ 然后统一加上$k$，再手推一下新的答案，为$4k^3+3k^2(a+b+c)+2k(ab+ac+bc)+abc$ 我们可以猜想更新后答案变为$\\sum\\limits_{j=0}^{i}a_jk^{i-j}f_p(j)​$，$a_j​$为系数。 问题就变成了求$a_j$。以$a_2$为例，因为$f_p(2)$包含的每种组合的系数都是$a_2$的，所以只要知道任意一项的系数就行了，于是来推一下$a*b$的系数。 $a_2$实际上就是$f_p(3)$所有组合中，可以提取出$a*b$的数量。我们可以用组合数来推： $p$有$4$个数，选了$2$个数$a,b$后还有$4-2$个数可以选，现在要凑成$3$个数还需要$3-2$个数，即$C^{3-2}_{4-2}$ 推广到所有情况，设$siz​$为区间长度。$a_j=C_{siz-j}^{i-j}​$ 式子就变成了$\\sum\\limits_{j=0}^{i}C_{siz-j}^{i-j}k^{i-j}f_p(j)​$ 组合数可以杨辉三角预处理。这个式子的复杂度就是$O(20^2*\\log 20)$。 取反标记优先，取反时把加法标记一起取反。 总复杂度为$O(n\\log n20^2\\log 20)=O(大常数*n\\log^3 n)$ $emm…$ 然后按这个思路写就$A​$了。 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 50005 const int N = 20; const long long mod = 19940417; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int n,a[maxn]; long long c[maxn][21],ans[21]; long long quickpow(long long x,long long y){ long long an=1; while(y){ if(y&amp;1)an=an*x%mod; x=x*x%mod; y&gt;&gt;=1; } return an; } struct Segment_Tree{ long long sum[maxn&lt;&lt;2][21],tag[maxn&lt;&lt;2]; int siz[maxn&lt;&lt;2],li[maxn&lt;&lt;2]; //siz为区间长度，li为min(siz,N)，在build是处理出来 bool rev[maxn&lt;&lt;2]; //取反标记 #define ls(x) x&lt;&lt;1 #define rs(x) x&lt;&lt;1|1 inline void update(int node){ for(register int i=1;i&lt;=li[node];++i){ sum[node][i]=(sum[ls(node)][i]+sum[rs(node)][i])%mod; for(register int j=1;j&lt;i;++j) sum[node][i]=(sum[node][i]+sum[ls(node)][j]*sum[rs(node)][i-j])%mod; } } inline void datadown(int node,long long d){ for(register int i=li[node];i;--i) for(register int j=0;j&lt;i;++j) sum[node][i]=(sum[node][i]+sum[node][j]*c[siz[node]-j][i-j]%mod*quickpow(d,i-j))%mod; tag[node]=(tag[node]+d)%mod; }//区间加 inline void reverdown(int node){ for(register int i=1;i&lt;=li[node];i+=2) sum[node][i]=-sum[node][i];//奇数取反 rev[node]^=1,tag[node]=-tag[node];//加法标记一并取反 }//取反 inline void pushdown(int node){ if(rev[node]){ reverdown(ls(node)),reverdown(rs(node)); rev[node]=false; } if(tag[node]){ datadown(ls(node),tag[node]); datadown(rs(node),tag[node]); tag[node]=0; } } void build(int l,int r,int node){ siz[node]=r-l+1,li[node]=min(r-l+1,N),sum[node][0]=1; if(l==r){ sum[node][1]=a[l]; return; } int mid=l+r&gt;&gt;1; build(l,mid,ls(node)); build(mid+1,r,rs(node)); update(node); } void add(int L,int R,int l,int r,int node,long long d){ if(L&lt;=l&amp;&amp;R&gt;=r){ datadown(node,d); return; } pushdown(node); int mid=l+r&gt;&gt;1; if(L&lt;=mid)add(L,R,l,mid,ls(node),d); if(R&gt;mid)add(L,R,mid+1,r,rs(node),d); update(node); } void reverse(int L,int R,int l,int r,int node){ if(L&lt;=l&amp;&amp;R&gt;=r){ reverdown(node); return; } pushdown(node); int mid=l+r&gt;&gt;1; if(L&lt;=mid)reverse(L,R,l,mid,ls(node)); if(R&gt;mid)reverse(L,R,mid+1,r,rs(node)); update(node); } void ask(int L,int R,int l,int r,int node,int c){ if(L&lt;=l&amp;&amp;R&gt;=r){ for(register int i=c;i;--i){ ans[i]=(ans[i]+sum[node][i])%mod; for(register int j=1;j&lt;i;++j) ans[i]=(ans[i]+ans[j]*sum[node][i-j])%mod; } return; } pushdown(node); int mid=l+r&gt;&gt;1; if(L&lt;=mid)ask(L,R,l,mid,ls(node),c); if(R&gt;mid)ask(L,R,mid+1,r,rs(node),c); } }st; void Get_C(){ c[0][0]=1; for(register int i=1;i&lt;=n;++i){ c[i][0]=1; for(register int j=1;j&lt;=N;++j) c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod; } }//预处理组合数 int main(){ n=read(); int m=read(); Get_C(); for(register int i=1;i&lt;=n;++i) a[i]=read(); st.build(1,n,1); char s[2]; int l,r,d; while(m--){ scanf(&quot;%s&quot;,s); l=read(),r=read(); if(s[0]==&#39;R&#39;)st.reverse(l,r,1,n,1); else { d=read(); if(s[0]==&#39;I&#39;)st.add(l,r,1,n,1,d); else { memset(ans,0,sizeof ans); st.ask(l,r,1,n,1,d); printf(&quot;%lld\\n&quot;,(ans[d]%mod+mod)%mod); //负数要模成正数输出 } } } }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线段树","slug":"线段树","permalink":"https://ctz45562.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"洛谷 P4735 最大异或和","slug":"洛谷-P4735-最大异或和","date":"2019-03-31T00:45:44.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/03/31/洛谷-P4735-最大异或和/","link":"","permalink":"https://ctz45562.github.io/2019/03/31/%E6%B4%9B%E8%B0%B7-P4735-%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C/","excerpt":"传送门 翻了翻题解，只有我这么蒻不会把后缀异或和转成前缀异或和吗$QAQ$","text":"传送门 翻了翻题解，只有我这么蒻不会把后缀异或和转成前缀异或和吗$QAQ$ 没有想到转前缀所以蒟蒻暴力维护了后缀异或和。 首先操作离线下来，处理出添加完所有数后数列的状态，直接把所有后缀异或和插入进可持久化$trie$树里。然后倒着处理操作，这样添加就变成了删除。 删除结尾的一个数，剩下的所有后缀异或和都会异或上删掉的数。在全局维护一个$tag$，删一个数就把$tag$异或上它。在查询时只要$tag$这一位上为$1$就要反着走。 不过这题卡常，恰好我这个做法常数比较大，吸氧才能过$QAQ$。 非常神奇的一点：读入字符串用scanf$T$得飞起，换成cin就$A$了。数据有锅？ #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 300005 using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int siz[maxn&lt;&lt;6],trie[maxn&lt;&lt;6][2],a[maxn&lt;&lt;1],sum[maxn&lt;&lt;1],root[maxn&lt;&lt;1],ans[maxn],top,tag,cnt=1; #define ls(x) trie[x][0] #define rs(x) trie[x][1] struct ORDER{ int s,l,r,x; }o[maxn]; inline void update(int node){ siz[node]=siz[ls(node)]+siz[rs(node)]; } void insert(int &amp;node,int ol,int d,int now=25){ node=++cnt; if(now==-1){ siz[node]=siz[ol]+1; return; } bool k=d&amp;(1&lt;&lt;now); trie[node][k^1]=trie[ol][k^1]; insert(trie[node][k],trie[ol][k],d,now-1); update(node); } int ask(int node,int ol,int d,int now=25){ if(now==-1)return 0; bool k=(d&amp;(1&lt;&lt;now))^(tag&amp;(1&lt;&lt;now)); //异或上tag的这一位就相当于：tag这一位上为1方向改变 if(siz[trie[node][k^1]]-siz[trie[ol][k^1]]&gt;0)return ask(trie[node][k^1],trie[ol][k^1],d,now-1)+(1&lt;&lt;now); else return ask(trie[node][k],trie[ol][k],d,now-1); } int main(){ int n=read(),m=read(); char ss[2]; for(register int i=1;i&lt;=n;++i) a[i]=read(); for(register int i=1;i&lt;=m;++i){ cin&gt;&gt;ss; o[i].s=(ss[0]==&#39;Q&#39;)+1,o[i].l=read(); if(o[i].s==1)a[++n]=o[i].l; else o[i].r=read(),o[i].x=read(); } for(register int i=n;i;--i) sum[i]=sum[i+1]^a[i]; for(register int i=1;i&lt;=n;++i) insert(root[i],root[i-1],sum[i]); for(register int i=m;i;--i){ if(o[i].s==1)tag^=o[i].l;//标记处理 else ans[++top]=ask(root[o[i].r],root[o[i].l-1],o[i].x); } while(top)printf(&quot;%d\\n&quot;,ans[top--]); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"trie树","slug":"trie树","permalink":"https://ctz45562.github.io/tags/trie%E6%A0%91/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"可持久化","slug":"可持久化","permalink":"https://ctz45562.github.io/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"}]},{"title":"洛谷 P3164 [CQOI2014]和谐矩阵","slug":"洛谷-P3164-CQOI2014-和谐矩阵","date":"2019-03-29T08:33:10.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/03/29/洛谷-P3164-CQOI2014-和谐矩阵/","link":"","permalink":"https://ctz45562.github.io/2019/03/29/%E6%B4%9B%E8%B0%B7-P3164-CQOI2014-%E5%92%8C%E8%B0%90%E7%9F%A9%E9%98%B5/","excerpt":"传送门 每个元素都有偶数个相邻的$1$，就是每个元素和相邻元素异或起来为$0$。 显然可以高斯消元。","text":"传送门 每个元素都有偶数个相邻的$1$，就是每个元素和相邻元素异或起来为$0$。 显然可以高斯消元。 把$(i,j)$元素的值设为$x_{i,j}$，就有方程： $(x_{i,j})\\ xor\\ (x_{i-1,j})\\ xor\\ (x_{i+1,j})\\ xor\\ (x_{i,j-1})\\ xor\\ (x_{i,j+1})=0 $ 当然这个方程组解集不是唯一的。题目中要求不允许答案全$0$矩阵，就把高斯消元中遇到的自由元的值定为$1$，再把剩余方程中含有该自由元的常数$xor$上$1$。异或方程组还可以用$bitset$优化。 时间复杂度：$O(n^3/32)$ 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;bitset&gt; #define poi(x,y) ((x-1)*m+y) //poi(x,y)将二维坐标转成一个整数 const int dx[5]={0,0,0,1,-1},dy[5]={0,1,-1,0,0}; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } template&lt;typename T&gt; inline T read(){ T x=0; int y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int n,N,ans[1605]; //N是总元素个数(n*m) bitset&lt;1601&gt;a[1605],rec[1605]; void Gauss(){ for(register int i=1;i&lt;=N;++i){ int now=i; while(!a[now][i]&amp;&amp;now&lt;N)++now; if(now!=i)swap(a[now],a[i]); if(!a[i][i]){ //遇到自由元 a[i][N+1]=1; for(register int j=i+1;j&lt;=N;++j) a[i][j]=0; //常数赋值为1，系数赋值为0，也就是解为1 for(register int j=i+1;j&lt;=N;++j) if(a[j][i])a[j].flip(N+1); //该元素的解对其他方程的影响 continue; } for(register int j=i+1;j&lt;=N;++j) if(a[j][i])a[j]^=a[i]; } for(register int i=N;i;--i){ ans[i]=a[i][N+1]; for(register int j=i+1;j&lt;=N;++j) if(a[i][j])ans[i]^=ans[j]; } } int main(){ int n=read(),m=read(); N=n*m; for(register int i=1;i&lt;=n;++i){ for(register int j=1;j&lt;=m;++j){ for(register int k=0;k&lt;5;++k){ int x=i+dx[k],y=j+dy[k]; if(x&lt;1||x&gt;n||y&lt;1||y&gt;m)continue; a[poi(i,j)][poi(x,y)]=1; } } } Gauss(); for(register int i=1;i&lt;=n;++i,pn) for(register int j=1;j&lt;=m;++j) printf(&quot;%d &quot;,ans[poi(i,j)]); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"高斯消元","slug":"高斯消元","permalink":"https://ctz45562.github.io/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"}]},{"title":"洛谷 P3193 [HNOI2008]GT考试","slug":"洛谷-P3193-HNOI2008-GT考试","date":"2019-03-27T06:53:38.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/03/27/洛谷-P3193-HNOI2008-GT考试/","link":"","permalink":"https://ctz45562.github.io/2019/03/27/%E6%B4%9B%E8%B0%B7-P3193-HNOI2008-GT%E8%80%83%E8%AF%95/","excerpt":"传送门 求方案数，显然这个题得动态规划。。。","text":"传送门 求方案数，显然这个题得动态规划。。。 设$f(i,j)$为母串长为$i$位，子串当前匹配到了第$j$位的方案数。考虑$f(i,j)$向$i+1$转移： 枚举$i+1$的数字，然后就会发现这玩意可以用$kmp$转移。预处理出$next$数组后，转移时和普通的$kmp$匹配一样跳$next$数组，直到匹配到最长前缀转移过去。 初值$f(0,0)=1$，答案$ans=\\sum\\limits_{i=0}^{i&lt;m}f(n,i)$ 伪代码： f[0][0]=1; for(int i=0;i&lt;n;++i) for(int j=0;j&lt;m;++j) for(int k=&#39;0&#39;;k&lt;=&#39;9&#39;;++k){//枚举下一位 int l=j; while(l&amp;&amp;a[l+1]!=k)l=next[l]; if(a[l+1]==k)++l; //和kmp一样以k为i+1位的数字匹配 (f[i+1][l]+=f[i][j])%=mod; } int ans=0; for(int i=0;i&lt;m;++i) (ans+=f[n][i])%=mod; 复杂度不会证，反正不低于$O(10nm)$。这个式子可以用矩阵快速幂优化。把$f(i-1,0$ ~ $m-1)$和$f(i,0$ ~ $m-1)$扔进去，枚举每一个$j$和第$i+1$位的数字，在矩阵上对应的位置$+1$。 显然$f(1,0)=9,f(1,1)=1$，然后直接矩乘就好了。 矩阵大小：$(2m)*(2m)$，复杂度$O(40^3\\log n)$ 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } template&lt;typename T&gt; inline T read(){ T x=0; int y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int n,m,mod; int next[50]; char a[22]; struct Matrix{ int a[50][50],l,c; Matrix operator * (const Matrix x){ Matrix ans; ans.l=l,ans.c=x.c; for(register int k=0;k&lt;c;++k) for(register int i=0;i&lt;l;++i) for(register int j=0;j&lt;x.c;++j) (ans.a[i][j]+=a[i][k]*x.a[k][j])%=mod; return ans; } Matrix(){ memset(a,0,sizeof a); } }start,origin; //start为初始矩阵，origin为转移矩阵 Matrix quickpow(Matrix x,int y){ Matrix ans; ans.l=ans.c=x.l; for(register int i=0;i&lt;ans.l;++i) ans.a[i][i]=1; while(y){ if(y&amp;1)ans=ans*x; x=x*x; y&gt;&gt;=1; } return ans; } void kmp(){ int j=0; for(register int i=2;i&lt;=m;++i){ while(j&amp;&amp;a[j+1]!=a[i])j=next[j]; if(a[j+1]==a[i])++j; next[i]=j; } } void build(){ for(register int i=m,j=0;i&lt;(m&lt;&lt;1);++i,++j) origin.a[i][j]=1; for(register int i=0;i&lt;m;++i){ for(register int j=&#39;0&#39;;j&lt;=&#39;9&#39;;++j){ int k=i; while(k&amp;&amp;a[k+1]!=j)k=next[k]; if(a[k+1]==j)++k; if(k&lt;m)++origin.a[i+m][k+m]; //m=i、下一位为j时会对第k位产生影响 } } origin.l=origin.c=m&lt;&lt;1; start.l=1,start.c=m&lt;&lt;1; start.a[0][0]=start.a[0][m+1]=1,start.a[0][m]=9; } int main(){ n=read(),m=read(),mod=read(); scanf(&quot;%s&quot;,a+1); kmp(); build(); start=start*quickpow(origin,n); int ans=0; for(register int i=0;i&lt;m;++i) (ans+=start.a[0][i])%=mod; printf(&quot;%d\\n&quot;,ans); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"字符串","slug":"字符串","permalink":"https://ctz45562.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"矩阵乘法","slug":"矩阵乘法","permalink":"https://ctz45562.github.io/tags/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"},{"name":"KMP","slug":"KMP","permalink":"https://ctz45562.github.io/tags/KMP/"}]},{"title":"洛谷 P2303 [SDOi2012]Longge的问题","slug":"洛谷-P2303-【-SDOi2012-Longge的问题】","date":"2019-03-26T11:11:50.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/03/26/洛谷-P2303-【-SDOi2012-Longge的问题】/","link":"","permalink":"https://ctz45562.github.io/2019/03/26/%E6%B4%9B%E8%B0%B7-P2303-%E3%80%90-SDOi2012-Longge%E7%9A%84%E9%97%AE%E9%A2%98%E3%80%91/","excerpt":"传送门 写篇题解纪念一下我想了一天的沙雕题。","text":"传送门 写篇题解纪念一下我想了一天的沙雕题。 显然，$gcd(i,n)$一定等于$n$的某个因子。 $O(\\sqrt n)$筛出$n$的因子，假设有$cnt$个，分别为$a_1,a_2…a_{cnt}$。 对于任意一个因子$a_i$，若有$gcd(ka_i,n)=a_i$，则$gcd(k,n/a_i)=1$。 即$k$与$n/a_i$互质。所以$a_i$的贡献为$\\varphi(n/a_i)*a_i$。 答案即为$\\sum\\limits_{i=1}^{cnt}\\varphi(n/a_i)*a_i$ 嘤嘤嘤我居然想了一天？ 复杂度：$O(cnt\\sqrt n)$ 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } template&lt;typename T&gt; inline T read(){ T x=0; int y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } long long n; long long phi(long long x){ long long ans=x; for(long long i=2;i*i&lt;=x;++i){ if(x%i==0){ ans=ans/i*(i-1); while(x%i==0)x/=i; } } if(x&gt;1)ans=ans/x*(x-1); return ans; } void Get_Factor(){ long long ans=0; for(long long i=1;i*i&lt;=n;++i) if(n%i==0){ ans+=phi(n/i)*i; if(i*i!=n)ans+=phi(i)*n/i; } printf(&quot;%lld\\n&quot;,ans); } int main(){ n=read&lt;long long&gt;(); Get_Factor(); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"欧拉函数","slug":"欧拉函数","permalink":"https://ctz45562.github.io/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"}]},{"title":"洛谷 P2568 GCD","slug":"题解-洛谷-P2568-【GCD】","date":"2019-03-25T06:00:13.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/03/25/题解-洛谷-P2568-【GCD】/","link":"","permalink":"https://ctz45562.github.io/2019/03/25/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7-P2568-%E3%80%90GCD%E3%80%91/","excerpt":"传送门 以此题题解纪念我第一道独立思考出的数论题$QwQ$。","text":"传送门 以此题题解纪念我第一道独立思考出的数论题$QwQ$。 首先质数肯定是要筛的。 考虑对于某一个质数$p$，满足$gcd(i,j)=p$的$(i,j)$有多少对： 显然$p|i$且 $p|j$，则设$i=ap$，$j=bp$。 即$gcd(ap,bp)=p$ 把$p$提出来：$gcd(a,b)*p=p$ 约去$p$：$gcd(a,b)=1$，也就是$a$、$b$互质 假设$a&gt;b$，问题就变成了求$a$所有取值的欧拉函数的和。$ap$不能超过$n$，则$1\\le a\\le \\left\\lfloor\\dfrac{n}{p}\\right\\rfloor$。直接预处理出欧拉函数和前缀和。其中$a,b$可互换，答案乘$2$。当$a=1,b=1$时互换是同一种情况，答案减去$cnt$（$cnt$为质数个数）。 综上，$ans=\\left(\\sum\\limits_{i=1}^{cnt}\\sum\\limits_{j=1}^{\\left\\lfloor\\frac{n}{prime[i]}\\right\\rfloor}\\varphi(j)\\right)-cnt$ 用的欧拉筛，时间复杂度$O(n)$。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 10000005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } long long sum[maxn],ans; int phi[maxn],prime[maxn&gt;&gt;2],cnt; bool is[maxn]; int main(){ int n=read(); sum[1]=phi[1]=1; for(register int i=2;i&lt;=n;++i){ if(!is[i])prime[++cnt]=i,phi[i]=i-1; sum[i]=sum[i-1]+(long long)phi[i]; for(register int j=1;j&lt;=cnt&amp;&amp;prime[j]*i&lt;=n;++j){ is[prime[j]*i]=1; if(i%prime[j]==0){ phi[i*prime[j]]=phi[i]*prime[j]; break; } phi[i*prime[j]]=phi[i]*(prime[j]-1); } } for(register int i=1;i&lt;=cnt;++i) ans+=sum[n/prime[i]]; printf(&quot;%lld\\n&quot;,ans*2-(long long)cnt); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"欧拉函数","slug":"欧拉函数","permalink":"https://ctz45562.github.io/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"}]},{"title":"blogの搭建之next","slug":"blogの搭建","date":"2019-03-21T11:54:59.000Z","updated":"2021-07-01T04:33:23.255Z","comments":true,"path":"2019/03/21/blogの搭建/","link":"","permalink":"https://ctz45562.github.io/2019/03/21/blog%E3%81%AE%E6%90%AD%E5%BB%BA/","excerpt":"可以说这是份指南，也算是如果某天blog炸了后的重构指导书。（其实我只是今晚想颓）","text":"可以说这是份指南，也算是如果某天blog炸了后的重构指导书。（其实我只是今晚想颓） 前言首先来一句：next吼啊！（破音 不得不说next主题提供的配置还是非常全面的，几乎800行的配置文件看着就爽啊。本文记录我对next-Gemini主题的修改。其中大部分也适用于其他hexo主题。 目前我已换成了sakura主题，本文不再更新。sakura修改内容全部写在blogの搭建之sakura里。 常见配置什么Latex、鼠标点击特效、动态背景、访客计数器等等网上关于next的全是，就不再说了。主要说一些不好找的。 live2d看板娘普通的git bash中执行： npm install hexo-helper-live2d --save 在站点配置文件中添加： live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-wanko # 模型名称 display: position: right # 位置 width: 285 # 宽 height: 570 # 高 hOffset: -20 # 水平向左偏移量 vOffset: -50 # 垂直向上偏移量 mobile: show: true react: opacity: 1 # 透明度 更多的设置可以参考官方说明。 更换模型： 这个地方里有模型名称和预览。找到想要的（以live2d-widget-model-z16为例），执行： npm install live2d-widget-model-z16 --save 在上面加的文本中，模型名称一栏改为live2d-widget-model-z16。 高级的添加可以换装、说话、换看板娘、玩游戏、拍照。 首先把这个仓库的压缩包下载，解压到一个文件夹里。或者在git bash中克隆到一个文件夹里： git clone https://github.com/stevenjoezhang/live2d-widget 然后整个文件夹扔进\\themes\\next\\source​里，记住这个文件夹的名字（名字可以改）。 打开文件夹里的$autoload.js$，把第一行的： const live2d_path = &quot;...&quot;; $…$改成 /你刚才记的名字/ 打开\\themes\\next\\layout\\_layout.swig文件，把下面一句话扔到最后的&lt;/body&gt;上面： &lt;script src=&quot;/你刚才记的名字/autoload.js&quot;&gt;&lt;/script&gt; （不知道为啥网上的教程都把$autoload.js$写成了$autolload.js$，结果捣鼓了好久。。。） 如果玩过了普通版本，两个看板娘可能会冲突，把配置普通live2d时在主站配置文件添加的东西里enable底下的删掉（注释掉），然后把enable改为false。 调整懂一点css、js、html可能会更好一些。。。（当然不会也行，蒟蒻就不会） 主要是在live2d文件夹里的$waifu.css$、$waifu-tips.js$、$waifu-tips.json$。 位置$waifu.css$文件中第一个大括号里： #waifu{ ... } 里面的bottom改后面的数值可以调整上下位置；把left改为right能直接变到右边去（没试过，应该是可以的），后面的数值可以微调左右位置。 大小因为我没想调所以暂时不会（咕咕咕 言论$waifu-tips.json$和$waifu-tips.js$都有，前者好像更多。 就按里面的格式直接添加或删除就行了。 在$waifu-tips.js$里还能改某句话停留的时间。showmessage(文字,数字,数字)里第一个数字就是了（改炸了我不负责。。。） 一些小bug1.把鼠标放上去和鼠标点击说话会冲突，我就直接把$waifu-tips.json$里鼠标放上去那一段删掉，里面的话都移到点击事件里了。 2.第一个看板娘Pio眼睛偶尔会短暂消失。。。好像是开发者的bug吧。。。 参考： https://www.jianshu.com/p/89440678ee3c https://blog.csdn.net/dataiyangu/article/details/83021854?utm_source=blogxgwz3 https://imjad.cn/archives/lab/add-dynamic-poster-girl-with-live2d-to-your-blog-02 一言Hitokoto先说一句我只会把一言放到侧栏上。。。 提供两种方法： Ⅰ一直在找能不能添加随机一言在blog上，然而并没有找到什么教程，我也不会写js和html就搁置了很长时间。 后来偶然在某位大佬的博客里找到了一种比较粗糙的方法（好像仅适用next-Gemini主题？）：附上链接 这里再感谢大佬，了却我一个心愿QwQ。 里面最后写了一言的添加方法，还是可行的。如果自定义格式的话可以到第一段添加的文字里魔改，font-size、color、font-family啥的应该看的懂吧。。。（改炸了我也不负责。。。） 不过还是有一些bug： 1.页面向下滚动时一言会突然消失，向上滚动又会突然出现。。。 2.一言过长时侧边栏遮不住，就会多出一块来。。。我是直接暴力延长侧边栏解决的。。。 因为现在换了挂个预览图： Ⅱ写完上面的第二天我又找到新方案了。。。上谷歌一搜就出来一篇。。。就是我现在的这种，主要是没啥bug，而且和下面个人信息合并了。 如果您用过上面那个想换的话，得先照着上面那篇再删掉。一定要注意别删多了。 链接 按里面说的配好hitokoto.js和_layout.swig后，在\\themes\\next\\layout_macro\\sidebar.swig里这段下面： {% if theme.sidebar.onmobile %} {% endif %} &lt;div class=&quot;sidebar-inner&quot;&gt; 添加： &lt;div&gt; &lt;p class=&quot;hitokoto&quot;&gt;&lt;/p&gt; &lt;p class=&quot;from&quot;&gt;&lt;/p&gt; &lt;/div&gt; 然后预览一下就会看到一言了！（如果想放到底下我猜的大概放到底下吧。。。可以试验一下） 当然这个很丑，需要自己改里面的格式（需要html语言，好像有大佬说这是swig语言。。。蒟蒻不太懂）。我费了2个小时现学html改成现在这样子。放上丑陋的配置： &lt;div style=&quot;margin:1px auto;font-family:&#39;微软雅黑&#39;;font-weight:bold; font-size: 19px; color: #100ae0&quot;&gt;「 一言 」&lt;/div&gt; &lt;p class=&quot;hitokoto&quot; style=&quot;font-family:&#39;楷体&#39;; text-indent:2em; margin-top:8px;margin-bottom:5px;text-align:left; font-size:17px;font-weight:bold&quot;&gt;&lt;/p&gt; &lt;p class=&quot;from&quot; style=&quot;font-size:15px;text-align:right; margin:0;color:grey&quot;&gt;&lt;/p&gt; &lt;hr style=&quot;height:2px; margin:10px auto;color:blue&quot;&gt; 仅供参考，可以自己魔改。如果您是html大佬轻喷蒟蒻的半吊子html写法。。。 加载条调整加载条的话在next主题配置文件中的pace改为true，下面的pace_theme可以选列出来的主题。 主要说一下个性化样式。（同机房大佬CLT教的） 在\\themes\\next\\source\\lib\\pace里找到你选的主题，改里面的color、font-size之类的。一个主题可能会有多个要改的地方注意一下。 如果你玩Stylus(会css)…在\\themes\\next\\source\\css\\_custom\\custom.styl​文件中可以自由编辑css代码！ $update$： 这里写一个next的小bug： （以下皆为闲扯） 很久之前wavwing想把blog换成绿色背景，我帮他写了个css。结果发现在侧栏个人信息出现前（它有动画效果延迟出现），下方会有白底，表示有强迫症，看着很难受： 后来试了试其他背景同样会出现这个bug。于是尝试写css消掉它，不过我都不知道这个叫啥。。。 一开始傻了，拼手速在侧栏出现前F12抓取，然而时间太短抓不出来。。。 又试着写了关于侧栏sidebar模块的调整，对白底并没有影响。 很久之后的某天写了个margin-left​，发现侧栏和白底脱离了！ 这样F12就能随便抓取了。 于是有了解决方案： 在custom.styl里加上： aside#sidebar.sidebar{ background:#fff0; } 成功解决！ 评论来必力界面非常美观，登录方式多，管理快捷，功能全。之前是想一直用来必力的。 然而我没用它是因为它是外国的，加载比较慢甚至有时候加载不出来。。。（我的blog上放的东西太多很卡。。。） 当然还是稍微说一下： 网上还是有不少教程的，大概是申请个账号、安装一下、获取uid、扔到next主题配置文件里的livere_uid里就行了。还可以在来必力网站上设置邮件提醒、管理评论什么的。 Valine添加访问速度快，支持markdown（不过不支持latex)，界面十分简洁，不需要登陆。 当然美观性还是比来必力差很多。。。 网上也是有不少教程的，在leancloud上注册个账号照着配就行了。 如果用的github博客，评论里可能会提示 code 403：api访问白名单拒绝bulabula（差不多这个意思） （在localhost:4000预览时出现是正常的）可能是配置域名时（新建的应用-&gt;设置-&gt;安全中心-&gt;Web安全域名）只添加了http或https开头的域名，把另一个换行补上就好了。 邮件提醒很麻烦。。。网上有教程。（这个就不错） 这里说一下添加各种自定义环境变量这一步： 先搞一下SMTP授权码（我用的163邮箱，qq啥的从网上查一下吧应该有。。。） 添加的变量网上有好多版本，有的变量我都不知道干啥的。。。 如下图添加这些就能用： 保存后要在云引擎-&gt;实例-&gt;设置图标-&gt;重启之后才会生效 管理评论： 在存储-&gt;数据-&gt;Comment里可以看到评论并删除 和看板娘的互动： 上面说的高级的看板娘会在Valine评论里时有互动，和来必力就没有QwQ 定时器： leancloud有这么个休眠策略： 每天必须休眠 6 个小时 30 分钟内没有外部请求，则休眠。 休眠后如果有新的外部请求实例则马上启动（但激活时此次发送邮件会失败）。 在云引擎-&gt;定时任务-&gt;创建定时器里，一共有三栏： 名称随便填；函数选self-wake；下面选Cron表达式，里面填： 0 0/20 7-23 * * ? 别忘了启用定时器。（不知道要不要重启实例。。。） 这样就可以在每天7点到23点，每20分钟唤醒一次。在云引擎-&gt;应用日志可以看到它被唤醒的记录。 教程上说要设置什么Web主机域名，然而要实名认证很麻烦。。。结果不设置也能用？ 参考：https://github.98.tn/hexo-valine-admin/ gitalk/gitment外观都还行，速度也不错。但是必须使用github登录才能评论。 好像gitment是原生的，最稳定。但是据说作者弃了一堆bug没人修。。。 加快博客访问速度先放一个很有意思的网站：https://developers.google.com/speed/pagespeed/insights/ （可能需要翻墙？） 可以测试网站速度，给出评分、详细加载信息和优化建议。 改域名blog里东西太多，加载起来很卡甚至有时候出不来东西，毕竟github是外国网站。网上说关联上coding能快很多，然而coding好像升级成了腾讯云开发者平台好像很麻烦的样子。。。 按教程搞了一遍后发现coding的访问速度和github差不了多少。。。所以还是我blog上东西太多了 慢慢找解决方案吧。。。（cry大佬说过买个域名会快？然而我太穷了） 2019/3/25：又试了一下发现了神奇的问题：晚上在家上github博客极慢甚至加载不出来，coding就很快；在机房正好反过来。。。（没有文明上网） 我也不知道该咋弄了。。。。 静态资源压缩无意间看到的，什么html文件空行很多之类的原因会拖慢blog加载速度。 看到有很多gulp压缩的。但是配置起来比较麻烦，搞了半天还失败了。 又看到了hexo-neat插件，安装简洁，效果也不错。 安装： npm install hexo-neat --save 在站点配置文件中添加： # 文件压缩，在exclude设置一些需要跳过的文件 # hexo-neat neat_enable: true # 压缩 html neat_html: enable: true exclude: # 压缩 css neat_css: enable: true exclude: - &#39;**/*.min.css&#39; # 压缩 js neat_js: enable: true mangle: true output: compress: exclude: - &#39;**/*.min.js&#39; - &#39;**/jquery.fancybox.pack.js&#39; - &#39;**/index.js&#39; 然后。。。就完了 执行hexo g部署时这个插件就会压缩资源（hexo s预览时也会压缩），会稍微慢一点。 在火狐下右键查看页面源代码就会发现很多东西都被压成了一行。。。 所以这证明了压行能提高程序效率 还有一个坑点： 刚用上就发现看板娘和鼠标点击特效不见了。。。 调了调发现它成功把我的看板娘$js,css$和鼠标特效的$js$压缩了，然后莫名出了BUG（不过一言的$js$压缩了没事？） 在站点配置文件中，neat_css的exclude里添加： - &#39;**/waifu.css&#39; neat_js的exclude里添加： - &#39;**/waifu-tips.js&#39; - &#39;**/autoload.js&#39; - &#39;**/love.js&#39; 参考：https://www.playpi.org/2018112101.html 懒加载懒加载就是不一次性完全加载图片，需要的时候再加载。 网上说可以安个插件： npm install hexo-lazyload --save 在站点配置文件中添加： lazyload: enable: true # className: #可选 e.g. .J-lazyload-img # loadingImg: #可选 eg. ./images/loading.png 然而。。。它报错了，没找到解决方法。 还有一种麻烦一点的方法：懒得写了挂个链接吧：https://mmmmmm.me/hexo_er_lazy.html 然而。。。它又报错了。。。 $update$：发现为啥报错了，他的第一步里的$js$代码第一行use strict&#39;少了个引号，应该是&#39;use strict&#39; cdn加速js加速把国外的$cdn$源换成国内的大概会快一点 在主题配置文件中找到vendors一栏，把下面对应地方修改为： vendors: # Internal path prefix. Please do not edit it. _internal: vendors # Internal version: 2.1.3 jquery: https://cdn.bootcss.com/jquery/2.1.3/jquery.min.js # Internal version: 2.1.5 # See: http://fancyapps.com/fancybox/ fancybox: https://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js fancybox_css: https://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css # Internal version: 1.0.6 # See: https://github.com/ftlabs/fastclick fastclick: https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js # Internal version: 1.9.7 # See: https://github.com/tuupola/jquery_lazyload lazyload: https://cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js # Internal version: 1.2.1 # See: http://VelocityJS.org velocity: https://cdn.bootcss.com/velocity/1.2.1/velocity.min.js # Internal version: 1.2.1 # See: http://VelocityJS.org velocity_ui: https://cdn.bootcss.com/velocity/1.2.1/velocity.ui.min.js # Internal version: 0.7.9 # See: https://faisalman.github.io/ua-parser-js/ ua_parser: https://cdn.bootcss.com/UAParser.js/0.7.9/ua-parser.min.js # Internal version: 4.6.2 # See: http://fontawesome.io/ fontawesome: https://cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css # Internal version: 1 # https://www.algolia.com algolia_instant_js: algolia_instant_css: # Internal version: 1.0.2 # See: https://github.com/HubSpot/pace # Or use direct links below: # pace: //cdn.bootcss.com/pace/1.0.2/pace.min.js # pace_css: //cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css pace: pace_css: # Internal version: 1.0.0 # https://github.com/hustcc/canvas-nest.js canvas_nest: https://cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js # three three: https://cdn.bootcss.com/three.js/r83/three.min.js jsdelivr懒得写了这篇讲的就挺详细的：https://www.hojun.cn/2019/01/18/jsDeliver-github%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%8C%E5%85%8D%E8%B4%B9%E5%A5%BD%E7%94%A8%E7%9A%84cdn/ 这个东西我刚用的时候还是很快的，不过不知道为啥速度越来越慢。。。 全局cdn正在研究。。。 参考：https://www.itcto.cn/blog/hexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96/ 图片压缩Tinypng jpeg.io 这俩网站都可以压缩图片，在几乎不损失清晰度情况下，平均能压缩$70\\%$的大小。 然后png图片可以用格式工厂之类的软件改成jpg(jpeg)，大小也会减小。 $Tinypng$压缩效果更好，$jpeg.io$会自动转换成jpg格式。 自定义404页面首先在根目录下的\\souce里新建一个404.html文件，用html语言写。。。 $emm…$ 我好像不会html… 方案：新建页面404$\\rightarrow$在404页面里的index.md里用markdown语法写$\\rightarrow$hexo g部署$\\rightarrow$在根目录下的\\public\\404\\index.html里的内容就是markdown转变成的html语言啦，粘过去就好了。 在站点配置文件中找到“skip_render”一项，改为： skip_render: 404.html 如果有多项的话： skip_render: - README.md - 404.html （注意空格） 这样在访问了不存在的网页时就会跳到404页面上去了。 （404在本地预览时是看不到效果的，必须上传上去。。。） 附上我个人丑陋的404.html： &lt;body&gt; &lt;div&gt; &lt;p&gt;&lt;center&gt;&lt;img src=&quot;https://i.loli.net/2019/04/09/5cac36216530c.jpg&quot; width=&quot;340&quot; height=&quot;350&quot;&gt;&lt;/center&gt;&lt;/p&gt; &lt;p style=&quot;text-align: center;font-size:30px&quot;&gt;&lt;strong&gt;啊嘞？网页丢了？&lt;/strong&gt;&lt;/p&gt; &lt;p style=&quot;text-align: center;font-size:20px&quot;&gt;&lt;a href=&quot;https://ctz45562.github.io&quot;&gt;&lt;strong&gt;回到主页&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt; &lt;p style=&quot;text-align: center;font-size:20px&quot;&gt;&lt;a href=&quot;javascript:history.go(-1);&quot;&gt;&lt;strong&gt;返回上一页&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;/html&gt; 效果 抄袭参考来源（没错和一言那个是同一篇）","categories":[{"name":"杂物","slug":"杂物","permalink":"https://ctz45562.github.io/categories/%E6%9D%82%E7%89%A9/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://ctz45562.github.io/tags/blog/"}]},{"title":"洛谷 P1903 [国家集训队] 数颜色 / 维护队列","slug":"题解-洛谷-P1903-【-国家集训队-数颜色-维护队列】","date":"2019-03-20T07:17:40.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/03/20/题解-洛谷-P1903-【-国家集训队-数颜色-维护队列】/","link":"","permalink":"https://ctz45562.github.io/2019/03/20/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7-P1903-%E3%80%90-%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F-%E6%95%B0%E9%A2%9C%E8%89%B2-%E7%BB%B4%E6%8A%A4%E9%98%9F%E5%88%97%E3%80%91/","excerpt":"传送门 安利一下既好写又美观的树套树（大雾","text":"传送门 安利一下既好写又美观的树套树（大雾 思路和HH的项链一样，维护每个位置下一个和它相同颜色的位置$nex[i]$，查询时就找$nex[i]&gt;R$且$L\\le i\\le R$的个数（$[L,R]$为待查询区间，下同）。 两个限制条件自然想到树套树。外层用线段树或树状数组维护$nex[i]$，每个节点内部开一个平衡树或动态开点线段树维护位置。查询时直接查外层$[R+1,n+1]$（这里提前把$nex[i]$为$0$的都改为$n+1$）中，内层位于$[L,R]$的数量。 不过修改比较麻烦： 记$i$为修改点，$last$为上一个和$i$颜色相同的位置（可以开数组记下来，想偷懒的话直接开平衡树查也行），$j$为$i$前面第一个颜色为要修改的颜色的位置，二元组$(x,y)$为外层为$x$，内层为$y$。修改操作就为： 删除$(i,last)$ 插入$(nex[i],last)$ 赋值$nex[last]=nex[i]$ 删除$(nex[i],i)$ 插入$(nex[j],i)$ 删除$(nex[j],j)$ 插入$(i,j)$ 赋值$nex[i]=nex[j],nex[j]=i$ 不理解的话可以画个图，观察一下一次修改操作会对$last,nex[i],j,nex[j]$产生的影响。 因为有可能$j$或$last$为$0$，需要记一下每种颜色当前第一次出现的位置，判断修改。 线段树套线段树$2900ms$（$O_2$），树状数组套线段树$1300ms$（$O_2$） 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 50005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } template&lt;typename T&gt; inline T read(){ T x=0; int y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } inline int ran(){ static int seed=45562; return seed=(seed*48271LL%2147483647); } int n; #define ls(x) ls[x] #define rs(x) rs[x] struct Treap{ int dat[maxn&lt;&lt;2],ls[maxn&lt;&lt;2],rs[maxn&lt;&lt;2],siz[maxn&lt;&lt;2],ra[maxn&lt;&lt;2],cnt; inline void update(int node){ siz[node]=siz[ls(node)]+siz[rs(node)]+1; } void right(int &amp;node){ int rec=ls(node); ls(node)=rs(rec); rs(rec)=node; node=rec; update(rs(node)),update(node); } void left(int &amp;node){ int rec=rs(node); rs(node)=ls(rec); ls(rec)=node; node=rec; update(ls(node)),update(node); } void insert(int &amp;node,int d){ if(!node){ node=++cnt; ra[node]=ran(),dat[node]=d,siz[node]=1; return; } if(dat[node]&lt;d){ insert(rs(node),d); if(ra[rs(node)]&gt;ra[node])left(node); } else { insert(ls(node),d); if(ra[ls(node)]&gt;ra[node])right(node); } ++siz[node]; } void del(int &amp;node,int d){ if(dat[node]==d){ if(ls(node)&amp;&amp;rs(node)){ if(ra[ls(node)]&gt;ra[rs(node)])right(node),del(rs(node),d); else left(node),del(ls(node),d); --siz[node]; } else node=ls(node)|rs(node); return; } if(dat[node]&lt;d)del(rs(node),d); else del(ls(node),d); --siz[node]; } int getpre(int node,int d){ int ans=0; while(node){ if(dat[node]&lt;d)ans=max(ans,dat[node]),node=rs(node); else node=ls(node); } return ans; } }tr; struct Data_Segment_Tree{ int ls[maxn&lt;&lt;5],rs[maxn&lt;&lt;5],sum[maxn&lt;&lt;5],cnt; void add(int poi,int l,int r,int &amp;node,int d){ if(!node)node=++cnt; sum[node]+=d; if(l==r)return; int mid=l+r&gt;&gt;1; if(poi&lt;=mid)add(poi,l,mid,ls(node),d); else add(poi,mid+1,r,rs(node),d); } int ask(int L,int R,int l,int r,int node){ if(!node)return 0; if(L&lt;=l&amp;&amp;R&gt;=r)return sum[node]; int mid=l+r&gt;&gt;1,ans=0; if(L&lt;=mid)ans=ask(L,R,l,mid,ls(node)); if(R&gt;mid)ans+=ask(L,R,mid+1,r,rs(node)); return ans; } }dst; #undef ls #undef rs /*==============树状数组套线段树===============*/ struct Binary_Indexed_Tree{ int root[maxn]; #define lowb(x) (x&amp;-x) inline void add(int x,int pl,int d){ while(x&lt;=n+1)dst.add(pl,1,n,root[x],d),x+=lowb(x); } inline int ask(int x,int l,int r){ int ans=0; while(x)ans+=dst.ask(l,r,1,n,root[x]),x-=lowb(x); return ans; } }bit; int root[1000005],fir[1000005],nex[maxn],pre[1000005],a[maxn]; inline void change(int i,int d){ if(a[i]==d)return; int last=tr.getpre(root[a[i]],i),j=tr.getpre(root[d],i); if(fir[a[i]]==i)fir[a[i]]=nex[i]; if(last){ bit.add(i,last,-1); bit.add(nex[i],last,1); nex[last]=nex[i]; } bit.add(nex[i],i,-1); if(j){ bit.add(nex[j],i,1); bit.add(nex[j],j,-1); bit.add(i,j,1); nex[i]=nex[j]; nex[j]=i; } else { bit.add(fir[d],i,1); nex[i]=fir[d],fir[d]=i; } tr.del(root[a[i]],i),tr.insert(root[d],i); a[i]=d; } /*==================End====================*/ /*=========================================*/ /*==============线段树套线段树===============*/ #define ls(x) x&lt;&lt;1 #define rs(x) x&lt;&lt;1|1 struct Next_Segment_Tree{ int root[maxn&lt;&lt;2]; void add(int poi,int l,int r,int node,int pl,int d){ dst.add(pl,1,n,root[node],d); if(l==r)return; int mid=l+r&gt;&gt;1; if(poi&lt;=mid)add(poi,l,mid,ls(node),pl,d); else add(poi,mid+1,r,rs(node),pl,d); } int ask(int L,int l,int r,int node,int ll,int rr){ if(L&lt;=l)return dst.ask(ll,rr,1,n,root[node]); int mid=l+r&gt;&gt;1; return (L&lt;=mid?ask(L,l,mid,ls(node),ll,rr):0)+ask(L,mid+1,r,rs(node),ll,rr); } }nst; int root[1000005],fir[1000005],nex[maxn],pre[1000005],a[maxn]; inline void change(int i,int d){ if(a[i]==d)return; int last=tr.getpre(root[a[i]],i),j=tr.getpre(root[d],i); if(fir[a[i]]==i)fir[a[i]]=nex[i]; if(last){ nst.add(i,1,n+1,1,last,-1); nst.add(nex[i],1,n+1,1,last,1); nex[last]=nex[i]; } nst.add(nex[i],1,n+1,1,i,-1); if(j){ nst.add(nex[j],1,n+1,1,i,1); nst.add(nex[j],1,n+1,1,j,-1); nst.add(i,1,n+1,1,j,1); nex[i]=nex[j]; nex[j]=i; } else { nst.add(fir[d],1,n+1,1,i,1); nex[i]=fir[d],fir[d]=i; } tr.del(root[a[i]],i),tr.insert(root[d],i); a[i]=d; } /*==============End===============*/ int main(){ n=read(); int m=read(); for(register int i=1;i&lt;=n;++i){ a[i]=read(),nex[pre[a[i]]]=i,pre[a[i]]=i; if(!fir[a[i]])fir[a[i]]=i; tr.insert(root[a[i]],i); } for(register int i=1;i&lt;=n;++i){ if(!nex[i])nex[i]=n+1; bit.add(nex[i],i,1); } for(register int i=1;i&lt;=1000000;++i) if(!fir[i])fir[i]=n+1; char s[2]; int l,r; while(m--){ scanf(&quot;%s&quot;,s); if(s[0]==&#39;Q&#39;)l=read(),r=read(),printf(&quot;%d\\n&quot;,bit.ask(n+1,l,r)-bit.ask(r,l,r)); else l=read(),r=read(),change(l,r); } }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线段树","slug":"线段树","permalink":"https://ctz45562.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"平衡树","slug":"平衡树","permalink":"https://ctz45562.github.io/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"},{"name":"树状数组","slug":"树状数组","permalink":"https://ctz45562.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"树套树","slug":"树套树","permalink":"https://ctz45562.github.io/tags/%E6%A0%91%E5%A5%97%E6%A0%91/"}]},{"title":"洛谷 P4919 Marisa采蘑菇","slug":"题解-洛谷-P4919-【Marisa采蘑菇】","date":"2019-03-18T12:44:14.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/03/18/题解-洛谷-P4919-【Marisa采蘑菇】/","link":"","permalink":"https://ctz45562.github.io/2019/03/18/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7-P4919-%E3%80%90Marisa%E9%87%87%E8%98%91%E8%8F%87%E3%80%91/","excerpt":"传送门 壮哉我大线段树！","text":"传送门 壮哉我大线段树！ 这种毒瘤查询肯定不能在线用数据结构维护，考虑把询问离线下来处理。 假设在某个询问$[L,R]$中某种蘑菇的数量为$x$，这种蘑菇在整个序列中的数量为$all$，则区间$[L,R]$之外的蘑菇数量为$all-x$。 当$|x-(all-x)|\\le k$时该种蘑菇会有$1$贡献。分类讨论解方程就有 $\\dfrac{all-k}{2}\\le x\\le \\dfrac{all+k}{2}$（由于整形精度问题，代码中的解应为$\\dfrac{all-k+1}{2}\\le x\\le \\dfrac{all+k}{2}$） 也就是说如果固定$R$，左端点只要在某个区间内就能获得这种蘑菇的贡献。 献上一张图助于理解： 记$next[i]$为下一个和位置$i$同种的蘑菇的位置。注意到右端点移动到$next[R]$，则对应的 绿色区间$[l,r]$也会移动到$[next[l],next[r]]$上。 而一种蘑菇当前能产生贡献的的区间为 $[$ 从$R$往前数第$\\dfrac{all-k+1}{2}$个同种蘑菇的位置，从$R$往前数第$\\dfrac{all+k}{2}$个同种蘑菇的位置 $]$ 这样把每个位置开一个$vector$，每个询问插进它右端点的$vector$中。扫一遍序列，存一下每种蘑菇当前能产生贡献的区间，每次扫到这种蘑菇就删去旧区间的贡献（区间$-1$），并更新新区间的贡献（区间$+1$）。遇到询问右端点单点查询左端点的值作为答案。 区间加减$+$单点查询，树状数组差分可以做。然而线段树作为蒟蒻的信仰，肯定要写一发线段树。既然只有单点查，所有非叶子节点也不需要维护总和，直接维护$tag$，查询时把经过的$tag$加起来就好了，不吸氧最后一个点$2100ms+$（树状数组$1500ms+$）。 代码（可能肥肠乱，因为维护的东西比较复杂。。。）： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #define maxn 1000005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int n,k,a[maxn]; struct Question{ int l,ans; }q[maxn];//每个询问 struct Segment_Tree{ #define ls(x) x&lt;&lt;1 #define rs(x) x&lt;&lt;1|1 int tag[maxn&lt;&lt;2]; void add(int L,int R,int l,int r,int node,int d){ if(L&lt;=l&amp;&amp;R&gt;=r){ tag[node]+=d; return; } int mid=l+r&gt;&gt;1; if(L&lt;=mid)add(L,R,l,mid,ls(node),d); if(R&gt;mid)add(L,R,mid+1,r,rs(node),d); } int ask(int poi,int l,int r,int node){ if(l==r)return tag[node]; int mid=l+r&gt;&gt;1; if(poi&lt;=mid)return ask(poi,l,mid,ls(node))+tag[node]; else return ask(poi,mid+1,r,rs(node))+tag[node]; } }st;//线段树 int ll[maxn],rr[maxn],fir[maxn],nex[maxn],last[maxn],all[maxn],cnt[maxn],li[maxn]; //ll、rr就是每种蘑菇当前能产生贡献的区间 //fir是每种蘑菇第一次出现的位置，nex是前面说的next，last是每种蘑菇上一次出现的位置，用于更新nex数组 //all是每种蘑菇总出现次数，cnt是当前已经出现过了几次，li是它的区间限制 bool vis[maxn]; vector&lt;int&gt;Q[maxn]; inline int limit(int i){ return max(0,(all[i]-k+1)&gt;&gt;1); } //计算区间 //其实不难发现，(all+k)/2=all-(all-k+1)/2，所以知道一边另一边直接减一下就行了 int main(){ n=read(); int m=read(); k=read(); for(register int i=1;i&lt;=n;++i){ a[i]=read(),++all[a[i]]; nex[last[a[i]]]=i,last[a[i]]=i,ll[a[i]]=1; if(!fir[a[i]])fir[a[i]]=i; } for(register int i=n;i;--i) if(!nex[i])nex[i]=n+1,li[a[i]]=limit(a[i]); nex[n+1]=n+1; for(register int i=1;i&lt;=m;++i) q[i].l=read(),Q[read()].push_back(i); int co,p,l; for(register int i=1;i&lt;=n;++i){ co=a[i],p=++cnt[co],l=li[co]; if(rr[co])st.add(ll[co],rr[co],1,n,1,-1); if(p&gt;=l){ if(!rr[co])rr[co]=fir[co]; else rr[co]=nex[rr[co]]; } if(p&gt;=all[co]-l+1){ if(!vis[co])ll[co]=fir[co]+1,vis[co]=1; else ll[co]=nex[ll[co]-1]+1; } if(rr[co])st.add(ll[co],rr[co],1,n,1,1); //上面四个if都是用来维护这个区间的，蒟蒻也不好解释清楚了。。。感性理解一下吧。。。 for(register int j=0;j&lt;Q[i].size();++j) q[Q[i][j]].ans=st.ask(q[Q[i][j]].l,1,n,1); } for(register int i=1;i&lt;=m;++i) printf(&quot;%d\\n&quot;,q[i].ans); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线段树","slug":"线段树","permalink":"https://ctz45562.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"洛谷 P4602 [CTSC2018]混合果汁","slug":"题解-洛谷-P4602-【-CTSC2018-混合果汁】","date":"2019-03-17T02:29:46.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/03/17/题解-洛谷-P4602-【-CTSC2018-混合果汁】/","link":"","permalink":"https://ctz45562.github.io/2019/03/17/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7-P4602-%E3%80%90-CTSC2018-%E6%B7%B7%E5%90%88%E6%9E%9C%E6%B1%81%E3%80%91/","excerpt":"传送门 都说是$CTSC2018$最水的题。。。还是太蒻了想了很长时间。。。$QAQ$","text":"传送门 都说是$CTSC2018$最水的题。。。还是太蒻了想了很长时间。。。$QAQ$ 考虑一下朴素的解法： 对$d_i$排序，对$d_i$二分答案。因为答案取的是最小值，所以比它大的随便加。$d_i$越小能加的范围就越大，答案具有单调性，因此可以二分。然后尽可能把所有较小的$p_i$加上，看看加到最大后$\\sum l_i$是否满足，以此判断二分范围。 复杂度$O(n^2logn)$ 瓶颈在于选取尽可能多得选取较小的$p_i$。可以发现它能用主席树维护。首先按$p_i$排序，获取每种果汁$p_i$的排名；再按$d_i$排序，依次按照$p_i$的排名插入主席树，每个节点维护一下$\\sum p_i*l_i$（把这些果汁全加上的价格）和$\\sum l_i$（这些果汁的总容量）。 查询时，尽可能把左儿子选上，也就是只要$\\sum p_i*l_i \\le g_j$就把总容量加上$\\sum l_i$，$g_j$减去$\\sum p_i*l_i$，走右儿子。当然可能出现递归到叶子节点，剩余的$g_j$不足以全加上这种果汁，尽可能多加，即返回$min\\{g_j/p_i,l_i\\}$。 总之都是基于贪心思想。其他过程还是和开始的做法一样。时间复杂度$O(nlog^2n)$ 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 100005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } template&lt;typename T&gt; inline T read(){ T x=0; int y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int root[maxn]; struct Drink{ int d,l,num; long long p; }d[maxn]; struct Chairman_Tree{ int ls[maxn&lt;&lt;5],rs[maxn&lt;&lt;5],cnt; long long sum[maxn&lt;&lt;5],con[maxn&lt;&lt;5],p[maxn&lt;&lt;5]; //sum是li*pi的和，con是li的和，p是叶子节点的pi #define ls(x) ls[x] #define rs(x) rs[x] void build(int poi,int l,int r,int &amp;node,int ol,long long L,long long P){ node=++cnt; sum[node]=sum[ol]+L*P; con[node]=con[ol]+L; if(l==r){ p[node]=P; return; } int mid=l+r&gt;&gt;1; if(poi&lt;=mid)rs(node)=rs(ol),build(poi,l,mid,ls(node),ls(ol),L,P); else ls(node)=ls(ol),build(poi,mid+1,r,rs(node),rs(ol),L,P); } long long ask(int l,int r,int node,long long g){ if(l==r)return node?min((g/p[node]),con[node]):0; //空节点注意判断一下，否则会出现除以0的情况 int mid=l+r&gt;&gt;1; if(sum[ls(node)]&gt;g)return ask(l,mid,ls(node),g); //剩下的钱不足以全加上，走左儿子 else return ask(mid+1,r,rs(node),g-sum[ls(node)])+con[ls(node)]; //付得起，贪心全加上，走右儿子 } }ct; inline bool cmp1(Drink x,Drink y){ return x.p&lt;y.p; } inline bool cmp2(Drink x,Drink y){ return x.d&gt;y.d; } int main(){ int n=read(),m=read(); for(register int i=1;i&lt;=n;++i) d[i].d=read(),d[i].p=read&lt;long long&gt;(),d[i].l=read(); sort(d+1,d+1+n,cmp1);//按pi排序 for(register int i=1;i&lt;=n;++i) d[i].num=i;//获取排名 sort(d+1,d+1+n,cmp2);//按di排序 for(register int i=1;i&lt;=n;++i) ct.build(d[i].num,1,n,root[i],root[i-1],d[i].l,d[i].p); //以pi的排名建树 int l,r; while(m--){ long long g=read&lt;long long&gt;(),L=read&lt;long long&gt;(); int ans=-1; l=1,r=n; while(l&lt;=r){ int mid=l+r&gt;&gt;1; long long k=ct.ask(1,n,root[mid],g); if(k&gt;=L)ans=d[mid].d,r=mid-1; else l=mid+1; } printf(&quot;%d\\n&quot;,ans); } }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://ctz45562.github.io/tags/%E4%BA%8C%E5%88%86/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"主席树","slug":"主席树","permalink":"https://ctz45562.github.io/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"}]},{"title":"洛谷 P3273 [SCOI2011]棘手的操作","slug":"题解-洛谷-P3273-【-SCOI2011-棘手的操作】","date":"2019-03-16T12:44:24.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/03/16/题解-洛谷-P3273-【-SCOI2011-棘手的操作】/","link":"","permalink":"https://ctz45562.github.io/2019/03/16/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7-P3273-%E3%80%90-SCOI2011-%E6%A3%98%E6%89%8B%E7%9A%84%E6%93%8D%E4%BD%9C%E3%80%91/","excerpt":"传送门 长得一点也不像线段树的线段树思维题。。。","text":"传送门 长得一点也不像线段树的线段树思维题。。。 看到连边首先想到了$LCT$。但是。。。$LCT$不能对一群不在同一条链上的节点修改和查询。 换个思路想：如果同一联通块节点编号连续的话，是不是就好维护了呢？这样问题就变成了保证每次连边后形成的联通块编号连续，然后就可以并查集$+$线段树维护了。 题目没有强制在线，自然可以把操作离线下来。 一开始每个点都是联通块，拥有一个编号序列（这里编号序列是一个相对位置，两个不同的联通块编号靠前靠后不会互相影响的）。当连接两个联通块时，把它们两个的编号序列拼接起来。蒟蒻用的朴素的链表，可以$O(1)$地将两个块编号序列连接起来。 然后用并查集维护联通块大小，线段树区间加维护最大值就好了$QwQ$。 注意！数据有不合法连边，要特判。 具体实现还是看代码清晰一些：（蒟蒻没写过链表，自己$yy$用数组写的的可能比较丑陋。。。） #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 300005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } template&lt;typename T&gt; inline T read(){ T x=0; int y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int nex[maxn],tail[maxn],a[maxn],pos[maxn],seg[maxn],fa[maxn],siz[maxn],cnt,n; //nex指向链表节点的下一项，tail是链表尾指针 //seg是重新编的号，pos是每个seg对应的实际位置 //fa是并查集 int find(int x){ if(fa[x]==x)return x; return fa[x]=find(fa[x]); } struct Order{ int s,x,d;//s是操作类型 }o[maxn];//存储操作 struct Segment_Tree{ int ma[maxn&lt;&lt;2],tag[maxn&lt;&lt;2]; #define ls(x) (x&lt;&lt;1) #define rs(x) (x&lt;&lt;1|1) inline void update(int node){ ma[node]=max(ma[ls(node)],ma[rs(node)]); } inline void datadown(int node,int d){ ma[node]+=d,tag[node]+=d; } inline void pushdown(int node){ datadown(ls(node),tag[node]); datadown(rs(node),tag[node]); tag[node]=0; } void build(int l=1,int r=cnt,int node=1){ if(l==r){ ma[node]=a[pos[l]]; fa[l]=l,siz[l]=1; //重置并查集和siz return; } int mid=l+r&gt;&gt;1; build(l,mid,ls(node)); build(mid+1,r,rs(node)); update(node); } void add(int L,int R,int l,int r,int node,int d){ if(L&lt;=l&amp;&amp;R&gt;=r){ datadown(node,d); return; } if(tag[node])pushdown(node); int mid=l+r&gt;&gt;1; if(L&lt;=mid)add(L,R,l,mid,ls(node),d); if(R&gt;mid)add(L,R,mid+1,r,rs(node),d); update(node); } int ask(int L,int R,int l,int r,int node){ if(L&lt;=l&amp;&amp;R&gt;=r)return ma[node]; if(tag[node])pushdown(node); int mid=l+r&gt;&gt;1,ans=-inf; if(L&lt;=mid)ans=ask(L,R,l,mid,ls(node)); if(R&gt;mid)ans=max(ans,ask(L,R,mid+1,r,rs(node))); return ans; } }st;//线段树常规操作 int main(){ n=read(); for(register int i=1;i&lt;=n;++i) a[i]=read(),tail[i]=fa[i]=i; int m=read(); for(register int i=1;i&lt;=m;++i){ char s[5]; scanf(&quot;%s&quot;,s); if(s[0]==&#39;A&#39;){ o[i].s=-s[1]+&#39;0&#39;; if(s[1]&lt;&#39;3&#39;)o[i].x=read(); o[i].d=read(); } else if(s[0]==&#39;F&#39;){ o[i].s=s[1]-&#39;0&#39;; if(s[1]&lt;&#39;3&#39;)o[i].x=read(); } else { o[i].s=45562; int x=read(),y=read(),u=find(x),v=find(y); o[i].x=x,o[i].d=y; if(u==v)continue;//特判 nex[tail[u]]=v,tail[u]=tail[v],fa[v]=u; //把两段链表连起来 } } //s&lt;0为A操作，|s|为其后跟的编号 //s==45562连边操作 //s&gt;0为F操作，s为其后跟的编号 for(register int i=1;i&lt;=n;++i) if(fa[i]==i){ //如果一个点在并查集里是根的话，它也是所在链表的头 for(register int j=i;j;j=nex[j])seg[j]=++cnt,pos[cnt]=j; //遍历每一个链表，直接按链表顺序编号 } st.build();//初始建树 for(register int i=1;i&lt;=m;++i){ int s=o[i].s; if(s==45562){ int u=find(o[i].x),v=find(o[i].d); if(u==v)continue; siz[u]+=siz[v],fa[v]=u; //维护一下siz便于获取联通块的区间 } else if(s&lt;0){ if(s==-1)st.add(seg[o[i].x],seg[o[i].x],1,cnt,1,o[i].d); else if(s==-2){ int u=find(o[i].x); st.add(seg[u],seg[u]+siz[u]-1,1,cnt,1,o[i].d); //并查集根的编号+siz-1就是该联通块当前所代表的区间 } else st.add(1,cnt,1,cnt,1,o[i].d); } else { if(s==1)printf(&quot;%d\\n&quot;,st.ask(seg[o[i].x],seg[o[i].x],1,cnt,1)); else if(s==2){ int u=find(o[i].x); printf(&quot;%d\\n&quot;,st.ask(seg[u],seg[u]+siz[u]-1,1,cnt,1)); } else printf(&quot;%d\\n&quot;,st.ma[1]); } } }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"并查集","slug":"并查集","permalink":"https://ctz45562.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"线段树","slug":"线段树","permalink":"https://ctz45562.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"洛谷 P2154 [SDOI2009]虔诚的墓主人","slug":"题解-洛谷-P2154-【-SDOI2009-虔诚的墓主人】","date":"2019-03-15T03:26:38.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/03/15/题解-洛谷-P2154-【-SDOI2009-虔诚的墓主人】/","link":"","permalink":"https://ctz45562.github.io/2019/03/15/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7-P2154-%E3%80%90-SDOI2009-%E8%99%94%E8%AF%9A%E7%9A%84%E5%A2%93%E4%B8%BB%E4%BA%BA%E3%80%91/","excerpt":"传送门 来一发优美的线段树版题解$QwQ$。","text":"传送门 来一发优美的线段树版题解$QwQ$。 对于一块墓碑，它的贡献是上方取$k$棵树、下方取$k$棵树、左边取$k$棵树、右边取$k$棵树方案数的乘积。 即：假设一块墓碑上、下、左、右分别有$u,d,l,r$棵树（下同），其贡献为$C(u,k)*C(d,k)*C(l,k)*C(r,k)$。 预处理出组合数，离散化后扫描线扫$x$轴，注意到$y$轴上的两棵树之间的点它们的$u$和$d$是相同的 就像这样： 也就是说它们的$C(u,k)*C(d,k)$是可以$O(1)$算出来的。那么就能维护一下$\\sum C(l_i,k)*C(r_i,k)$乘起来算进答案里。 首先算出$y$轴每列有多少棵树，以此为初始$r$值，$l$为$0$，从左到右扫。遇到一棵树就把这一列的$r$减$1$，$l$加$1$，并更新这个点的$C(l,k)*C(r,k)$。对同一排上的两棵树查询中间的$\\sum C(l_i,k)*C(r_i,k)$即可。 树状数组蒟蒻不会更新$QAQ$，都放在了线段树上搞。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #define maxn 100005 #define inf 0x3f3f3f3f const long long mod = 2147483648ll; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } template&lt;typename T&gt; inline T read(){ T x=0; int y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } long long C[11][maxn],c[maxn]; int disx[maxn],disy[maxn],init[maxn],lenx,leny; vector&lt;int&gt;X[maxn]; struct Segment_Tree{ long long dat[maxn&lt;&lt;2]; int ll[maxn&lt;&lt;2],rr[maxn&lt;&lt;2]; #define ls(x) (x&lt;&lt;1) #define rs(x) (x&lt;&lt;1|1) inline void update(int node){ dat[node]=(dat[ls(node)]+dat[rs(node)])%mod; } void build(int l,int r,int node){ if(l==r){ rr[node]=init[l]; return; } int mid=l+r&gt;&gt;1; build(l,mid,ls(node)); build(mid+1,r,rs(node)); } void add(int poi,int l,int r,int node){ if(l==r){ --rr[node],++ll[node]; dat[node]=c[rr[node]]*c[ll[node]]%mod; //更新组合数 return; } int mid=l+r&gt;&gt;1; if(poi&lt;=mid)add(poi,l,mid,ls(node)); else add(poi,mid+1,r,rs(node)); update(node); } long long ask(int L,int R,int l,int r,int node){ if(L&lt;=l&amp;&amp;R&gt;=r)return dat[node]; int mid=l+r&gt;&gt;1; long long ans=0; if(L&lt;=mid)ans=ask(L,R,l,mid,ls(node)); if(R&gt;mid)ans+=ask(L,R,mid+1,r,rs(node)); return ans%mod; } }st; struct tree{ int x,y; }t[maxn]; int main(){ C[0][0]=1; read(),read(); int n=read(); for(register int i=1;i&lt;=n;++i) disx[++lenx]=t[i].x=read(),disy[++leny]=t[i].y=read(); sort(disx+1,disx+lenx+1); sort(disy+1,disy+leny+1); lenx=unique(disx+1,disx+1+lenx)-disx-1; leny=unique(disy+1,disy+1+leny)-disy-1; //离散化 int k=read(); for(register int i=1;i&lt;=n;++i){ ++init[t[i].y=lower_bound(disy+1,disy+1+leny,t[i].y)-disy];//初始的r值 X[lower_bound(disx+1,disx+1+lenx,t[i].x)-disx].push_back(t[i].y); C[0][i]=1; for(register int j=1;j&lt;=k;++j) C[j][i]=(C[j][i-1]+C[j-1][i-1])%mod; c[i]=C[k][i]; //预处理组合数。因为都是关于k的就压进了一个数组 } st.build(1,leny,1); long long ans=0; for(register int i=1;i&lt;=lenx;++i){ sort(X[i].begin(),X[i].end());//一定要排序 if(!X[i].empty())st.add(X[i][0],1,leny,1); for(register int j=1;j&lt;X[i].size();++j){ if(X[i][j-1]+1&lt;X[i][j]&amp;&amp;j&gt;=k&amp;&amp;X[i].size()-j&gt;=k)(ans+=st.ask(X[i][j-1]+1,X[i][j]-1,1,leny,1)*c[j]%mod*c[X[i].size()-j]%mod)%=mod; st.add(X[i][j],1,leny,1); } } printf(&quot;%lld\\n&quot;,ans); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线段树","slug":"线段树","permalink":"https://ctz45562.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"扫描线","slug":"扫描线","permalink":"https://ctz45562.github.io/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF/"}]},{"title":"洛谷 P4137 Rmq Problem / mex","slug":"题解-洛谷-P4137-【Rmq-Problem-mex】","date":"2019-03-14T23:51:15.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/03/15/题解-洛谷-P4137-【Rmq-Problem-mex】/","link":"","permalink":"https://ctz45562.github.io/2019/03/15/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7-P4137-%E3%80%90Rmq-Problem-mex%E3%80%91/","excerpt":"传送门 一道水题想了半天。。。","text":"传送门 一道水题想了半天。。。 可以想到造棵权值线段树，查询时如果左儿子有这个区间内没有出现的数就走左儿子，否则走右儿子。如果用普通的主席树维护每个数出现的次数，就会发现这玩意不具有区间可减性，不是基于前缀和的主席树能维护的。 换个思路：对于第$i$棵权值线段树，维护一下数列前$i$项中每个权值出现的最靠右的位置。然后向上更新一下最小值。这样如果某个权值最靠右的位置都比查询区间左端点小的话，那它一定没有在这个区间里出现。维护最小值目的就是看最小的是否比左端点大，根据这个在线段树上二分。 权值范围是$10^9$的。题解里有说答案最大为$n$，直接把$&gt;n$的$a[i]$处理为$n+1$就行。蒟蒻没有想到$QAQ$，说一下蒟蒻的处理： 用离散化，但是一个权值没有在数列里出现过的话就不会在离散化数组中，也不会出现在线段树中，查询会出锅。注意到一个询问的答案要么是$0$，要么是数列中某个数的值$+1$。这样离散化时把$0$和每个出现过的权值$+1$都丢进去就行了$QwQ$。 当然这道题不强制在线也不修改，可以把询问离线下来一边扫一边加，遇到询问右端点就查询左端点，不需要主席树（可持久化线段树），一棵权值线段树就可以了。 时间复杂度：$O(nlogn)$ 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #define maxn 400005 #define inf 0x3f3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } template&lt;typename T&gt; inline T read(){ T x=0; int y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int dis[maxn],ll[maxn],ans[maxn],len,a[maxn],n,m; //dis是离散化数组，ll是每个询问的左端点，ans是答案 vector&lt;int&gt;line[maxn]; //line用来离线存每个询问 struct Segment_Tree{ #define ls(x) (x&lt;&lt;1) #define rs(x) (x&lt;&lt;1|1) int dat[maxn&lt;&lt;2]; inline void update(int node){ dat[node]=min(dat[ls(node)],dat[rs(node)]); } void add(int poi,int l,int r,int node,int d){ if(l==r){ dat[node]=d; //因为是离线边扫边加，当前更新的位置一定是最靠右的，所以直接覆盖掉就行 return; } int mid=l+r&gt;&gt;1; if(poi&lt;=mid)add(poi,l,mid,ls(node),d); else add(poi,mid+1,r,rs(node),d); update(node); } int ask(int d){ int l=1,r=len,node=1; while(l&lt;r){ int mid=l+r&gt;&gt;1; if(dat[ls(node)]&lt;d)r=mid,node=ls(node); //左区间有最靠右的位置都比左端点小的，一定没出现过，向左走 else l=mid+1,node=rs(node); //否则向右走 } return dis[l]; } }st; int main(){ n=read(),m=read(); for(register int i=1;i&lt;=n;++i) dis[++len]=a[i]=read(),dis[++len]=a[i]+1; //把每个值+1添进去 dis[++len]=0; //把0添进去 sort(dis+1,dis+1+len); len=unique(dis+1,dis+1+len)-dis-1; for(register int i=1;i&lt;=m;++i){ ll[i]=read(); line[read()].push_back(i); } for(register int i=1;i&lt;=n;++i){ a[i]=lower_bound(dis+1,dis+1+len,a[i])-dis; st.add(a[i],1,len,1,i); for(int j=0;j&lt;line[i].size();++j){ int k=line[i][j]; ans[k]=st.ask(ll[k]); } } for(register int i=1;i&lt;=m;++i) printf(&quot;%d\\n&quot;,ans[i]); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线段树","slug":"线段树","permalink":"https://ctz45562.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"洛谷 P4340 [SHOI2016]随机序列","slug":"题解-洛谷-P4340-【-SHOI2016-随机序列】","date":"2019-03-12T13:46:48.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/03/12/题解-洛谷-P4340-【-SHOI2016-随机序列】/","link":"","permalink":"https://ctz45562.github.io/2019/03/12/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7-P4340-%E3%80%90-SHOI2016-%E9%9A%8F%E6%9C%BA%E5%BA%8F%E5%88%97%E3%80%91/","excerpt":"传送门 这种题一般就慢慢推式子吧。。。","text":"传送门 这种题一般就慢慢推式子吧。。。 对一个数列，在任意添加符号时候你会发现，某个数字前面有多少种情况添加加号，就有多少种情况添加减号，就会相互抵消。而第一个数字前面加不了东西，不受这个规律影响。 所以经过一系列合并最后剩下的一定是若干个前缀乘（类比于前缀和）的和。 所以前缀乘组合情况是怎么样的呢？令$g(i)=\\prod\\limits_{i=1}^{n}a[i]$，即前缀乘。 假设数列有$5$个数字，为$a,b,c,d,e$。$g(5)=a*b*c*d*e$。显然$g(5)$只会出现$1$次。 把最后一个乘号替换为加号和减号，$a*b*c*d+e$和$a*b*c*d-e$就会相加相互抵消，得到$2$个$g(4)$。 再把$g(5)$和$g(4)$的每种情况的倒数第二个乘号替换为加号和减号，相加后就会得到$6$个$g(3)$。以此类推，有$18$个$g(2)$，$54$个$g(1)$。这样规律就比较明显了：每个$g(i)$都珂以由$g(k)(i&lt;k\\le n)$修改对应位置的乘号，得到$2$个$g(i)$。 定义函数$f(i)=\\begin{cases}1&amp;i=1\\\\\\\\\\sum\\limits_{j=1}^{i-1}f(j)*2&amp;i&gt;1\\end{cases}$ 答案就是 $ans=\\sum\\limits_{i=1}^{ n}g(i)*f(n-i+1)$ （其实这个规律完全可以爆搜用瞪眼法得出来） $f(i)$和$g(i)$珂以直接预处理出来，然后直接上线段树维护，每个节点维护所代表区间的$\\sum\\limits_{i=l}^{r}g(i)*f(n-i+1)$。 对于修改：比如还是那五个数，要修改第三个数$c$为$k$。类似于前缀和，单点修改影响的是$g(3),g(4),g(5)$，也就是要把 $f(3)*a*b*c+f(2)*a*b*c*d+f(1)*a*b*c*d*e$ 修改为 $f(3)*a*b*k+f(2)*a*b*k*d+f(1)*a*b*k*d*e$ 就珂以把原式乘上$\\frac{k}{c}$。有除法还要取模显然要用到乘法逆元，即为把带修点到$n$的区间乘上$k*inv(c)$，就是个线段树区间乘。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 100005 #define inf 0x3f3f3f3f const long long mod = 1000000007; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } template&lt;typename T&gt; inline T read(){ T x=0; int y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int n,a[maxn]; long long f[maxn],g[maxn],inv[maxn]={0,1}; struct Segment_Tree{ long long dat[maxn&lt;&lt;2],tag[maxn&lt;&lt;2]; #define ls(x) (x&lt;&lt;1) #define rs(x) (x&lt;&lt;1|1) inline void update(int node){ dat[node]=(dat[ls(node)]+dat[rs(node)])%mod; } inline void datadown(int node,long long d){ (dat[node]*=d)%=mod; (tag[node]*=d)%=mod; } inline void pushdown(int node){ datadown(ls(node),tag[node]); datadown(rs(node),tag[node]); tag[node]=1; } void build(int l,int r,int node){ tag[node]=1; if(l==r){ dat[node]=g[l]*f[n-l+1]%mod; return; } int mid=l+r&gt;&gt;1; build(l,mid,ls(node)); build(mid+1,r,rs(node)); update(node); } void add(int L,int R,int l,int r,int node,long long d){ if(L&lt;=l&amp;&amp;R&gt;=r){ datadown(node,d); return; } if(tag[node]!=1)pushdown(node); int mid=l+r&gt;&gt;1; if(L&lt;=mid)add(L,R,l,mid,ls(node),d); if(R&gt;mid)add(L,R,mid+1,r,rs(node),d); update(node); } }st; int main(){ for(register int i=2;i&lt;=10000;++i) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;//数据范围是允许预处理出逆元的 n=read(); int m=read(); long long sum=1; f[1]=1,g[0]=1; for(register int i=2;i&lt;=n;++i) f[i]=(sum&lt;&lt;1)%mod,(sum+=f[i])%=mod;//预处理f数组 for(register int i=1;i&lt;=n;++i) a[i]=read(),g[i]=g[i-1]*a[i]%mod;//预处理前缀乘 st.build(1,n,1); while(m--){ int x=read(),d=read(); st.add(x,n,1,n,1,1ll*d*inv[a[x]]%mod); printf(&quot;%lld\\n&quot;,st.dat[1]); a[x]=d; } }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线段树","slug":"线段树","permalink":"https://ctz45562.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"洛谷 P1502 窗口的星星","slug":"题解-洛谷-P1502-【窗口的星星】","date":"2019-03-10T06:39:45.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/03/10/题解-洛谷-P1502-【窗口的星星】/","link":"","permalink":"https://ctz45562.github.io/2019/03/10/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7-P1502-%E3%80%90%E7%AA%97%E5%8F%A3%E7%9A%84%E6%98%9F%E6%98%9F%E3%80%91/","excerpt":"传送门 提供一个神奇的思路。","text":"传送门 提供一个神奇的思路。 首先二维数点能想到扫描线+线段树。 边框不能取，珂以把长、宽都减$1$，因为你可以这么框： 也就是说边界不取整数。 然后将坐标系上每个点扩展为一个矩形： 大概就是这种感觉：把每个点向左下角扩展得到它代表的矩形。 对于每颗星星，把它能影响到的矩形加上它的贡献。 不考虑横坐标，它能影响到的矩形为:$y$到$y+h$的点所代表的所有矩形。 考虑上横坐标，用扫描线，及时删除不在当前横坐标能覆盖的星星。 这样把每个可能的矩形缩成一个点，用线段树维护最大值，边扫边取最大值就行了。 时间复杂度：$O(t·nlogn)$ （说着轻快其实蒟蒻调了好长时间，边界的处理太麻烦了，具体细节还是看代码吧$QAQ$） #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 10005 #define inf 0x3f3f3f3f #define pn putchar(&#39;\\n&#39;) #define px(x) putchar(x) #define ps putchar(&#39; &#39;) #define pd puts(&quot;======================&quot;) #define pj puts(&quot;++++++++++++++++++++++&quot;) using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } template&lt;typename T&gt; inline T read(){ T x=0; int y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } struct Segment_Tree{ long long dat[maxn&lt;&lt;2],tag[maxn&lt;&lt;2]; #define ls(x) (x&lt;&lt;1) #define rs(x) (x&lt;&lt;1|1) inline void update(int node){ dat[node]=max(dat[ls(node)],dat[rs(node)]); } inline void datadown(int node,long long d){ dat[node]+=d; tag[node]+=d; } inline void pushdown(int node){ datadown(ls(node),tag[node]); datadown(rs(node),tag[node]); tag[node]=0; } void add(int L,int R,int l,int r,int node,long long d){ if(L&lt;=l&amp;&amp;R&gt;=r){ datadown(node,d); return; } if(tag[node])pushdown(node); int mid=l+r&gt;&gt;1; if(L&lt;=mid)add(L,R,l,mid,ls(node),d); if(R&gt;mid)add(L,R,mid+1,r,rs(node),d); update(node); } inline void clear(){ memset(dat,0,sizeof dat); memset(tag,0,sizeof tag); } }st; int dis[maxn]; //离散化数组 struct POINT{ int x,y,ll,rr; long long d; }p[maxn]; //星星：x、y是坐标，ll、rr是它能覆盖的矩形范围，d是亮度 inline bool cmp(POINT x,POINT y){ return x.x&lt;y.x; } int main(){ int t=read(); while(t--){ int n=read(),w=read()-1,h=read()-1,len=0,head=1; //长宽各-1 for(register int i=1;i&lt;=n;++i) p[i].x=read(),dis[++len]=p[i].y=read(),p[i].d=read&lt;long long&gt;(); dis[++len]=(1ll&lt;&lt;31)-1; //加了一个无穷大的边界 sort(dis+1,dis+1+len); sort(p+1,p+1+n,cmp);//把星星按横坐标排序 len=unique(dis+1,dis+1+len)-dis-1; long long ans=0; for(register int i=1;i&lt;=n;++i){ p[i].ll=upper_bound(dis+1,dis+1+len,p[i].y)-dis,p[i].rr=upper_bound(dis+1,dis+1+len,p[i].y+h)-dis; //要用upper_bound，两边是可以等于的 st.add(p[i].ll,p[i].rr,1,len,1,p[i].d); while(p[i].x-w&gt;p[head].x)st.add(p[head].ll,p[head].rr,1,len,1,-p[head].d),++head; //通过head头指针删除点 ans=max(ans,st.dat[1]); } printf(&quot;%lld\\n&quot;,ans); st.clear(); } }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线段树","slug":"线段树","permalink":"https://ctz45562.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"扫描线","slug":"扫描线","permalink":"https://ctz45562.github.io/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF/"}]},{"title":"bzoj 2212[POI2011]ROT-Tree Rotations","slug":"题解-bzoj-2212-【-POI2011-ROT-Tree-Rotations】","date":"2019-03-07T13:48:14.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/03/07/题解-bzoj-2212-【-POI2011-ROT-Tree-Rotations】/","link":"","permalink":"https://ctz45562.github.io/2019/03/07/%E9%A2%98%E8%A7%A3-bzoj-2212-%E3%80%90-POI2011-ROT-Tree-Rotations%E3%80%91/","excerpt":"传送门 能看得懂题面的传送门 前序遍历叶子节点，可以理解为把叶子节点从左到右输出。","text":"传送门 能看得懂题面的传送门 前序遍历叶子节点，可以理解为把叶子节点从左到右输出。 那么首先考虑一个性质：交换某个节点的左右儿子，仅会对这两棵子树之间的逆序对造成影响，而对某棵子树内部、它祖宗十八代之间的逆序对没有影响。 某个节点的左子树和右子树有哪些数换完之后还是有哪些数，交换后相对位置变化的只有这两棵子树，所以仅对这两棵子树有影响。 这样就有一个贪心的思路：如果某个节点交换左右儿子更优则交换。 怎么叫更优？交换后左、右子树之间逆序对小于交换前的就算更优。（注意这里的逆序对就针对于这两棵子树之间的值，不算上子树内部产生的逆序对） 现在问题转化成了：计算每个节点左、右子树之间的逆序对数。首先可以想到合并。其实平衡树启发式合并和线段树合并都珂以，不过平衡树$O(nlog^2n)$太慢了，这里选择线段树合并。 对树进行$dfs$，使用动态开点权值线段树，从底部将叶子节点的权值一步步合并上来，在任意节点就能得到其左右儿子的线段树。对于求两棵子树间的逆序对，珂以在合并时求出。放图举个栗子： 比如现在合并到了蓝色节点，就让计数变量加上左儿子线段树中该节点的右儿子的值 x 右儿子线段树上该节点的左儿子的值，也就是上图中红色节点的值乘绿色节点的值。然后在递归的每个节点都执行这个操作。 这个操作可以理解为：不考虑某个节点内部的逆序对情况，红色节点中的每个值都能与绿色节点中的每个值产生逆序对，于是有两值相乘为答案。至于节点内部就可以继续递归求出。 交换后的逆序对数：记$sizl$为左子树权值（叶子节点）的个数，$sizr$为右子树权值的个数，交换前有$x$对逆序对。则交换后就有$sizl*sizr-x$对逆序对。 这个容易理解：共有$sizl*sizr$种组合，每个之前不符合逆序对的组合，交换后就符合了。同理之前符合的交换后就不符合了。 答案的统计：珂以$dfs$完之后直接前序遍历用归并排序或树状数组求出。但是在$dfs$中已经求出每个节点左右儿子间逆序对数，就可以把这个值加起来作为答案，效率高很多。 还有注意开$long\\ long$ 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 200005 #define inf 0x3f3f3f3f #define pn putchar(&#39;\\n&#39;) #define px(x) putchar(x) #define ps putchar(&#39; &#39;) #define pd puts(&quot;======================&quot;) #define pj puts(&quot;++++++++++++++++++++++&quot;) using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } template&lt;typename T&gt; inline T read(){ T x=0; int y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } struct Tree{ int ls,rs,root,d; //左儿子、右儿子、线段树的根、权值 }t[maxn&lt;&lt;1]; //节点数要开两倍 int num=1,n; long long ans,all; //all是最终答案，ans是中间统计左右子树间逆序对的计数器 struct Segment_Tree{ int dat[maxn&lt;&lt;5],ls[maxn&lt;&lt;5],rs[maxn&lt;&lt;5],cnt; #define ls(x) ls[x] #define rs(x) rs[x] void add(int poi,int l,int r,int &amp;node){ node=++cnt; dat[node]=1; if(l==r)return; int mid=l+r&gt;&gt;1; if(poi&lt;=mid)add(poi,l,mid,ls(node)); else add(poi,mid+1,r,rs(node)); } int merge(int l,int r,int x,int y){ if(!x||!y)return x|y;//有空节点返回另一个 dat[x]+=dat[y];//合并两个节点信息 if(l==r)return x;//递归到底层返回 int mid=l+r&gt;&gt;1; ans+=1ll*dat[rs(x)]*dat[ls(y)]; //这里x为左儿子的节点，y为右儿子的节点，就有上面提到的统计方法 ls(x)=merge(l,mid,ls(x),ls(y)); rs(x)=merge(mid+1,r,rs(x),rs(y)); return x; }//线段树合并 }st; void dfs(int node=1){ if(!t[node].ls)return; dfs(t[node].ls); dfs(t[node].rs); //先处理左右儿子，得到左右儿子的情况 ans=0; //计数器清零 long long siz=1ll*st.dat[t[t[node].ls].root]*st.dat[t[t[node].rs].root]; t[node].root=st.merge(1,n,t[t[node].ls].root,t[t[node].rs].root); if(ans&gt;siz-ans)swap(t[node].ls,t[node].rs),all+=siz-ans; else all+=ans; //直接用中间过程求的值统计最终答案 } void Get(int node=1){ t[node].d=read(); if(!t[node].d)Get(t[node].ls=++num),Get(t[node].rs=++num); else st.add(t[node].d,1,n,t[node].root); }//递归读入 int main(){ n=read(); Get(); dfs(); printf(&quot;%lld\\n&quot;,all); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://ctz45562.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线段树合并","slug":"线段树合并","permalink":"https://ctz45562.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/"},{"name":"线段树","slug":"线段树","permalink":"https://ctz45562.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"洛谷 P3582 [POI2015]KIN","slug":"题解-洛谷-P3582-【-POI2015-KIN】","date":"2019-03-04T13:47:20.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/03/04/题解-洛谷-P3582-【-POI2015-KIN】/","link":"","permalink":"https://ctz45562.github.io/2019/03/04/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7-P3582-%E3%80%90-POI2015-KIN%E3%80%91/","excerpt":"传送门 这篇题解的思路其实是因机房某位王姓神仙指点而来$QwQ$","text":"传送门 这篇题解的思路其实是因机房某位王姓神仙指点而来$QwQ$ 首先要会线段树维护最大子段和，不会的可以做做这个 把题目简化一下： 任取一段闭区间，使区间贡献最大 有没有种最大子段和的感觉？但是要求数字重复的不能算。那么如果有两个相同的元素，一个贡献置为正，另一个置为负，互相抵消就能去重了。于是扫一遍依次加入每个点的贡献，每次都取一下当前最大值。 放个图来看： 红色的是相同的元素。 在第一个红点会有正的贡献$a$。 然后加到第二个： 把第一个置为$-a$，这时如果同时选$1$、$2$点就会正好抵消。而如果只选中第一个点虽然贡献不正确，但是因为是一边扫一遍取最大值，所以这种情况在之前已经被取到了。 再来第三个： 注意要把第一个清零，否则这时如果三个点都选的话贡献就为负了。 记录一下每种颜色上一个出现的位置就能做了$QwQ$。 细节：注意判断该颜色是否为第一次出现。还有要开$long\\ long$ 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 1000005 #define inf 0x3f3f3f3f #define pn putchar(&#39;\\n&#39;) #define px(x) putchar(x) #define ps putchar(&#39; &#39;) #define pd puts(&quot;======================&quot;) #define pj puts(&quot;++++++++++++++++++++++&quot;) using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } template&lt;typename T&gt; inline T read(){ T x=0; int y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int f[maxn],pre[maxn],last[maxn]; //f是电影，pre[i]是上一个和f[i]相同的位置，last是某种颜色最后一次出现的位置 long long a[maxn]; //a记录电影贡献 struct Segment_Tree{ long long ll[maxn&lt;&lt;2],rr[maxn&lt;&lt;2],ma[maxn&lt;&lt;2],sum[maxn&lt;&lt;2]; #define ls(x) (x&lt;&lt;1) #define rs(x) (x&lt;&lt;1|1) inline void update(int node){ sum[node]=sum[ls(node)]+sum[rs(node)]; ll[node]=max(ll[ls(node)],sum[ls(node)]+ll[rs(node)]); rr[node]=max(rr[rs(node)],sum[rs(node)]+rr[ls(node)]); ma[node]=max(max(ma[ls(node)],ma[rs(node)]),rr[ls(node)]+ll[rs(node)]); } void add(int poi,int l,int r,int node,long long d){ //把点poi的值改为d if(l==r){ sum[node]=ll[node]=rr[node]=ma[node]=d; return; } int mid=l+r&gt;&gt;1; if(poi&lt;=mid)add(poi,l,mid,ls(node),d); else add(poi,mid+1,r,rs(node),d); update(node); } }st; int main(){ int n=read(),m=read(); for(register int i=1;i&lt;=n;++i) f[i]=read(); for(register int i=1;i&lt;=m;++i) a[i]=read&lt;long long&gt;(); long long ans=0; for(register int i=1;i&lt;=n;++i){ pre[i]=last[f[i]],last[f[i]]=i; if(pre[i])st.add(pre[i],1,n,1,-a[f[i]]); //把上一个该颜色的位置贡献置为负 if(pre[pre[i]])st.add(pre[pre[i]],1,n,1,0); //把上上个贡献置为0 st.add(i,1,n,1,a[f[i]]); //加上该点的贡献 ans=max(ans,st.ma[1]); //一边跑一边取最大值 } printf(&quot;%lld\\n&quot;,ans); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线段树","slug":"线段树","permalink":"https://ctz45562.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"洛谷 P4556 [Vani有约会]雨天的尾巴","slug":"题解-洛谷-P4556-【-Vani有约会-雨天的尾巴】","date":"2019-03-03T07:32:34.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/03/03/题解-洛谷-P4556-【-Vani有约会-雨天的尾巴】/","link":"","permalink":"https://ctz45562.github.io/2019/03/03/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7-P4556-%E3%80%90-Vani%E6%9C%89%E7%BA%A6%E4%BC%9A-%E9%9B%A8%E5%A4%A9%E7%9A%84%E5%B0%BE%E5%B7%B4%E3%80%91/","excerpt":"传送门 题解没有树剖转化序列做的？来水一发题解。","text":"传送门 题解没有树剖转化序列做的？来水一发题解。 首先简化一下，如果把问题改成序列上做，即： 每个操作在一段区间上加一种颜色，求每个点数量最多的颜色。 用一下差分的思想：记操作区间为$[L,R]$，扫描整个序列。如果扫到某个操作的$L$,就把它的颜色$+1$；如果扫过某个操作的$R$就把它的颜色$-1$。每个点的答案就是扫到这个点时颜色数量最多的一个。这些可以用线段树来维护。 现在放到树上了，为链操作。就能使用树剖。树剖珂以把一条链剖成$logn$个编号连续的链。这样就能把每个操作剖成$logn$个新操作，用上面的方法放到序列上做就行了$QwQ$。 时间复杂度：每个操作会被分成$logn$个新操作，每个新操作会执行一次$O(logn)$的线段树操作。总复杂度$O(nlog^2n)$ 空间复杂度：$O(nlogn)$ 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #define maxn 100005 #define inf 0x3f3f3f3f #define pn putchar(&#39;\\n&#39;) #define px(x) putchar(x) #define ps putchar(&#39; &#39;) #define pd puts(&quot;======================&quot;) #define pj puts(&quot;++++++++++++++++++++++&quot;) using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } template&lt;typename T&gt; inline T read(){ T x=0; int y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int h[maxn],num; struct edge{ int pre,to; }e[maxn&lt;&lt;1]; struct Question{ int d,s; }; vector&lt;Question&gt;q[maxn]; //Question用来存操作 int seg[maxn],pos[maxn],son[maxn],siz[maxn],deep[maxn],fa[maxn],top[maxn],cnt[maxn],ans[maxn],all; inline void add(int from,int to){ e[++num].pre=h[from],h[from]=num,e[num].to=to; } struct Segment_Tree{ int dat[maxn&lt;&lt;2],wh[maxn&lt;&lt;2]; #define ls(x) (x&lt;&lt;1) #define rs(x) (x&lt;&lt;1|1) inline void update(int node){ if(!dat[ls(node)]&amp;&amp;!dat[rs(node)])dat[node]=wh[node]=0; else if(dat[ls(node)]&gt;dat[rs(node)]||(dat[ls(node)]==dat[rs(node)]&amp;&amp;wh[ls(node)]&lt;wh[rs(node)]))dat[node]=dat[ls(node)],wh[node]=wh[ls(node)]; else dat[node]=dat[rs(node)],wh[node]=wh[rs(node)]; } //wh表示最大值的编号 void build(int l,int r,int node){ if(l==r){ wh[node]=l; return; } int mid=l+r&gt;&gt;1; build(l,mid,ls(node)); build(mid+1,r,rs(node)); } void add(int poi,int l,int r,int node,int d){ if(l==r){ dat[node]+=d; return; } int mid=l+r&gt;&gt;1; if(poi&lt;=mid)add(poi,l,mid,ls(node),d); else add(poi,mid+1,r,rs(node),d); update(node); } }st; struct Tree_Chain_split{ void dfs1(int node=1){ siz[node]=1; for(register int i=h[node];i;i=e[i].pre){ int x=e[i].to; if(!siz[x]){ fa[x]=node,deep[x]=deep[node]+1; dfs1(x); if(siz[x]&gt;siz[son[node]])son[node]=x; siz[node]+=siz[x]; } } } void dfs2(int node=1){ seg[node]=++all; pos[all]=node; if(son[node]){ top[son[node]]=top[node]; dfs2(son[node]); for(register int i=h[node];i;i=e[i].pre){ int x=e[i].to; if(!seg[x])top[x]=x,dfs2(x); } } } void ask(int x,int y,int d){ Question add,minus; add.s=minus.s=d,add.d=1,minus.d=-1; while(top[x]!=top[y]){ if(deep[top[x]]&lt;deep[top[y]])swap(x,y); q[seg[top[x]]].push_back(add),q[seg[x]+1].push_back(minus); //注意减去的要加1 x=fa[top[x]]; } if(deep[x]&lt;deep[y])swap(x,y); q[seg[y]].push_back(add),q[seg[x]+1].push_back(minus); }//拆分操作函数 }tcs; int main(){ int n=read(),m=read(),tp=0; for(register int i=1;i&lt;n;++i){ int a=read(),b=read(); add(a,b),add(b,a); } tcs.dfs1(),tcs.dfs2(); while(m--){ int a=read(),b=read(),d=read(); tp=max(tp,d); tcs.ask(a,b,d); } st.build(1,tp,1); for(register int i=1;i&lt;=n;++i){ for(register int j=0;j&lt;q[i].size();++j) st.add(q[i][j].s,1,tp,1,q[i][j].d); ans[pos[i]]=st.wh[1]; } for(register int i=1;i&lt;=n;++i) printf(&quot;%d\\n&quot;,ans[i]); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://ctz45562.github.io/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"线段树","slug":"线段树","permalink":"https://ctz45562.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"洛谷 P3302 [SDOI2013]森林","slug":"题解-洛谷-P3302-【-SDOI2013-森林】","date":"2019-03-01T09:32:05.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/03/01/题解-洛谷-P3302-【-SDOI2013-森林】/","link":"","permalink":"https://ctz45562.github.io/2019/03/01/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7-P3302-%E3%80%90-SDOI2013-%E6%A3%AE%E6%9E%97%E3%80%91/","excerpt":"传送门 强制在线资瓷连边的树上$K$大（小）值。","text":"传送门 强制在线资瓷连边的树上$K$大（小）值。 静态树上$K$大值可以用主席树，结合$LCA$加加减减就行。 要求连边，可以启发式合并主席树。其实也可以说重构主席树。维护一下每个点所在的树的$size$，连接两点，选择$size$较小的连到较大的上去，即重新$dfs$一遍。 由于每个点合并一次后$size$至少翻倍，所以最多被合并$logn$次。重构一个点主席树复杂度为$O(logn)$，总复杂度$O(nlog^2n)$。 维护$size$珂以用并查集。因为要改变树的形态，树剖$LCA$不能用了，珂以用倍增$LCA$或者$LCT$求$LCA$。（蒟蒻以前一直用的树剖$LCA$，结果倍增写假了调了两天$QAQ$） 空间上可以重复利用之前的点，不过蒟蒻懒得写想省时间所以没有，所以单点重构主席树要开$O(logn)$个节点，空间复杂度$O(nlog^2n)$。 细节：值域很大，需要离散化 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 80005 #define inf 0x3f3f3f3f #define pn putchar(&#39;\\n&#39;) #define px(x) putchar(x) #define ps putchar(&#39; &#39;) #define pd puts(&quot;======================&quot;) #define pj puts(&quot;++++++++++++++++++++++&quot;) using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } template&lt;typename T&gt; inline T read(){ T x=0; int y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int h[maxn],num,F[maxn],siz[maxn]; //F是并查集 struct edge{ int pre,to; }e[maxn&lt;&lt;1]; inline void add(int from,int to){ e[++num].pre=h[from],h[from]=num,e[num].to=to; } int find(int x){ if(F[x]==x)return x; return F[x]=find(F[x]); } int n,len,dis[maxn],a[maxn],root[maxn],fa[maxn][32],lg[maxn],deep[maxn]; //dis是离散化数组 struct Chairman_Tree{ int dat[maxn*400],ls[maxn*400],rs[maxn*400],cnt; #define ls(x) ls[x] #define rs(x) rs[x] void build(int poi,int ne,int ol){ int l=1,r=len; while(l&lt;r){ dat[ne]=dat[ol]+1; int mid=l+r&gt;&gt;1; if(poi&lt;=mid)rs(ne)=rs(ol),ol=ls(ol),ne=ls(ne)=++cnt,r=mid; else ls(ne)=ls(ol),ol=rs(ol),ne=rs(ne)=++cnt,l=mid+1; } dat[ne]=dat[ol]+1; }//主席树重构 int ask(int x,int y,int lc,int fl,int k){ //lc是lca，fl为lca的父亲 int l=1,r=len; while(l&lt;r){ int mid=l+r&gt;&gt;1,sum=dat[ls(x)]+dat[ls(y)]-dat[ls(lc)]-dat[ls(fl)]; if(sum&gt;=k)x=ls(x),y=ls(y),lc=ls(lc),fl=ls(fl),r=mid; else x=rs(x),y=rs(y),lc=rs(lc),fl=rs(fl),l=mid+1,k-=sum; } return dis[l]; }//查询 }ct; int lca(int x,int y){ if(deep[x]&lt;deep[y])swap(x,y); while(deep[x]&gt;deep[y])x=fa[x][lg[deep[x]-deep[y]]-1]; if(x==y)return x; for(register int i=lg[deep[x]];i&gt;=0;--i) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0]; }//倍增lca void dfs(int node,int f){ deep[node]=deep[f]+1; root[node]=++ct.cnt; ct.build(a[node],root[node],root[f]); fa[node][0]=f; int top=lg[deep[node]]; for(register int i=1;i&lt;=top;++i) fa[node][i]=fa[fa[node][i-1]][i-1]; for(register int i=h[node];i;i=e[i].pre){ int x=e[i].to; if(x!=f)siz[node]+=siz[x],dfs(x,node); } } void merge(int x,int y){ add(x,y),add(y,x); int u=find(x),v=find(y); if(siz[u]&gt;siz[v])swap(x,y),swap(u,v); siz[v]+=siz[u]; dfs(x,y); } int spget(){ char ch=getchar(); while(ch!=&#39;Q&#39;&amp;&amp;ch!=&#39;L&#39;)ch=getchar(); return ch==&#39;Q&#39;; }//获取字符的 int main(){ read(); n=read(); int m=read(),t=read(); for(register int i=1;i&lt;=n;++i) F[i]=i,a[i]=dis[i]=read(),lg[i]=lg[i-1]+(1&lt;&lt;lg[i-1]==i); sort(dis+1,dis+1+n); len=unique(dis+1,dis+1+n)-dis-1; for(register int i=1;i&lt;=n;++i) a[i]=lower_bound(dis+1,dis+1+len,a[i])-dis; //离散化 for(register int i=1;i&lt;=m;++i){ int a=read(),b=read(); add(a,b),add(b,a); } for(register int i=1;i&lt;=n;++i) if(!deep[i])dfs(i,0); for(register int i=1;i&lt;=n;++i) if(fa[i][0])F[i]=fa[i][0]; //初始化并查集 for(register int i=1;i&lt;=n;++i) ++siz[find(i)]; //初始化size int ans=0; for(register int i=1;i&lt;=t;++i){ int s=spget(),x=read()^ans,y=read()^ans; if(s){ int k=read()^ans,l=lca(x,y); printf(&quot;%d\\n&quot;,ans=ct.ask(root[x],root[y],root[l],root[fa[l][0]],k)); } else merge(x,y); } }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"主席树","slug":"主席树","permalink":"https://ctz45562.github.io/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"name":"并查集","slug":"并查集","permalink":"https://ctz45562.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"LCA","slug":"LCA","permalink":"https://ctz45562.github.io/tags/LCA/"},{"name":"启发式合并","slug":"启发式合并","permalink":"https://ctz45562.github.io/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"}]},{"title":"洛谷 P4234 最小差值生成树","slug":"题解-洛谷-P4234-【最小差值生成树】","date":"2019-02-28T12:37:10.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/02/28/题解-洛谷-P4234-【最小差值生成树】/","link":"","permalink":"https://ctz45562.github.io/2019/02/28/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7-P4234-%E3%80%90%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%80%BC%E7%94%9F%E6%88%90%E6%A0%91%E3%80%91/","excerpt":"传送门 首先将边排序，依次尝试加边。两个点不连通就连，否则把这条边取代两点之间权值最小的边。可以用$LCT$拆边为点维护。","text":"传送门 首先将边排序，依次尝试加边。两个点不连通就连，否则把这条边取代两点之间权值最小的边。可以用$LCT$拆边为点维护。 考虑这种做法的正确性： 从小到大排序可以理解为枚举答案生成树的最大值（比它大的都在后面还没有加）。同时最小值也要尽量大，因此用较大的边替换较小的边一定更优。同时之前枚举的边也是用较大的边替换较小的边，也就最大化了最小值。 这样只要当前已经构成了生成树，就可以开始更新答案了。最大边就是当前枚举的边，最小边可以用平衡树维护。（一开始用的$multiset$，啥都没想直接$erase$，没想到会把所有的元素都清除掉，调了半小时。。。后来还是写的$treap$） 细节上注意数据中有自环，要判断一下。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 300005 #define inf 0x3f3f3f3f #define pn putchar(&#39;\\n&#39;) #define px(x) putchar(x) #define ps putchar(&#39; &#39;) #define pd puts(&quot;======================&quot;) #define pj puts(&quot;++++++++++++++++++++++&quot;) using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } template&lt;typename T&gt; inline T read(){ T x=0; int y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } inline int ran(){ static int seed=45562; return seed=(seed*48271LL%2147483647); }//优化常数的随机数函数 int n,m; struct edge{ int from,to,l; }e[maxn]; struct Link_Cut_Tree{ int mi[maxn],dat[maxn],son[maxn][2],fa[maxn],rev[maxn],st[maxn]; //dat是这个点（边）的权值，mi是权值最小的点的序号 //边的序号+n为它拆成的点 #define son(x,y) son[x][y] #define whson(x) (son[fa[x]][1]==x) #define root(x) (son[fa[x]][0]!=x&amp;&amp;son[fa[x]][1]!=x) inline int MIN(int x,int y){ return dat[x]&lt;dat[y]?x:y; } inline void update(int node){ mi[node]=MIN(node,MIN(mi[son(node,0)],mi[son(node,1)])); } inline void addedge(int s,int f,int wh){ if(s)fa[s]=f; son(f,wh)=s; } inline void reverdown(int node){ swap(son(node,0),son(node,1)); rev[node]^=1; } inline void pushdown(int node){ if(rev[node]){ if(son(node,0))reverdown(son(node,0)); if(son(node,1))reverdown(son(node,1)); rev[node]=0; } } inline void zhuan(int x){ int f=fa[x],gf=fa[f],wh=whson(x); fa[x]=gf; if(!root(f))son(gf,whson(f))=x; addedge(son(x,wh^1),f,wh); addedge(f,x,wh^1); update(f),update(x); } inline void splay(int x){ int top=1,y=x; st[1]=x; while(!root(y))st[++top]=y=fa[y]; while(top)pushdown(st[top--]); while(!root(x)){ y=fa[x]; if(!root(y)) zhuan(whson(x)^whson(y)?x:y); zhuan(x); } } void access(int x){ for(int y=0;x;y=x,x=fa[x]) splay(x),son(x,1)=y,update(x); } void makeroot(int x){ access(x),splay(x),reverdown(x); } void link(int x,int y){ makeroot(x); fa[x]=y; } void cut(int x,int y){ makeroot(x),access(y),splay(y); son(y,0)=fa[x]=0; update(y); } int findroot(int x){ access(x),splay(x); while(son(x,0))pushdown(x),x=son(x,0); return x; } int Get(int x,int y){ makeroot(x),access(y),splay(y); return mi[y]; } Link_Cut_Tree(){ memset(dat,0x3f,sizeof dat); } }lct; struct Treap{ int dat[maxn],ls[maxn],rs[maxn],ra[maxn],root,cnt; #define ls(x) ls[x] #define rs(x) rs[x] void right(int &amp;node){ int rec=ls(node); ls(node)=rs(rec); rs(rec)=node; node=rec; } void left(int &amp;node){ int rec=rs(node); rs(node)=ls(rec); ls(rec)=node; node=rec; } void insert(int &amp;node,int d){ if(!node){ node=++cnt; ra[node]=ran(); dat[node]=d; return; } if(dat[node]&lt;d){ insert(rs(node),d); if(ra[rs(node)]&gt;ra[node])left(node); } else { insert(ls(node),d); if(ra[ls(node)]&gt;ra[node])right(node); } } void del(int &amp;node,int d){ if(dat[node]==d){ if(ls(node)&amp;&amp;rs(node)){ if(ra[ls(node)]&gt;ra[rs(node)])right(node),del(rs(node),d); else left(node),del(ls(node),d); } else node=ls(node)+rs(node); return; } if(dat[node]&lt;d)del(rs(node),d); else del(ls(node),d); } int getmin(){ int node=root; while(ls(node))node=ls(node); return dat[node]; } }tr; inline bool cmp(edge x,edge y){ return x.l&lt;y.l; } void solve(){ int ans=inf,cnt=1; for(register int i=1;i&lt;=n;++i) lct.mi[i]=i; for(register int i=n+1;i&lt;=n+m;++i) lct.dat[i]=e[i-n].l,lct.mi[i]=i; //lct初始化 for(register int i=1;i&lt;=m;++i){ int x=e[i].from,y=e[i].to; if(x==y)continue;//自环判断 tr.insert(tr.root,e[i].l); if(lct.findroot(x)==lct.findroot(y)){ int k=lct.Get(x,y); lct.cut(x,k),lct.cut(y,k); tr.del(tr.root,e[k-n].l); } else ++cnt; lct.link(x,i+n),lct.link(i+n,y); if(cnt==n)ans=min(ans,e[i].l-tr.getmin()); //已经构成树，统计答案 } printf(&quot;%d\\n&quot;,ans); } int main(){ n=read(),m=read(); for(register int i=1;i&lt;=m;++i) e[i].from=read(),e[i].to=read(),e[i].l=read(); sort(e+1,e+1+m,cmp); solve(); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"LCT","slug":"LCT","permalink":"https://ctz45562.github.io/tags/LCT/"}]},{"title":"洛谷 P3703 [SDOI2017]树点涂色","slug":"题解-洛谷-P3703-【-SDOI2017-树点涂色】","date":"2019-02-27T13:24:55.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/02/27/题解-洛谷-P3703-【-SDOI2017-树点涂色】/","link":"","permalink":"https://ctz45562.github.io/2019/02/27/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7-P3703-%E3%80%90-SDOI2017-%E6%A0%91%E7%82%B9%E6%B6%82%E8%89%B2%E3%80%91/","excerpt":"传送门 $LCT$维护树上联通块。","text":"传送门 $LCT$维护树上联通块。 首先看$1$操作，起点为根的链染色，而且是chuan全新的颜色。可以自己画个图看看。 是不是有种$LCT$里的$access$的感觉？那就可以考虑用$LCT$维护树的形态，把相同颜色的点放在同一棵$splay$里。因为一定是从根开始的染色，染的是不同的颜色，初始颜色又不同，就能保证一棵$splay$一定维护一条链，符合$LCT$的性质，是可行的。（事实上这也是$LCT$维护树上联通块的常见姿势） 于是对于操作$1$，就是$access$一下。对于一个点的权值也就是从该点到根节点的路径会经过几个$splay$。因为在$access$时，每向上跳一次虚边就相当于跨过了一个$splay$，所以可以用这个性质来统计。 伪代码： int fake_access(int x){ int ans=0; for(;x;x=fa[x],++ans) splay(x); //统计答案不能真的access改变树的形态，所以不连儿子 //这也是为啥叫fAKe_access——它没有真的access return ans; } 于是操作$2$就是$fakeaccess(x)+fakeaccess(y)-2*fakeaccess(lca(x,y))+1$ （一定要$+1$，因为减去了$2*fakeaccess(lca(x,y))$后，$lca(x,y)$自己的$splay$就被减没了） 麻烦的是操作$3$。 根据上面，一个点的权值，也就相当于一个点到根节点路径上有几条虚边。 那么有一条虚边变重了，它对应的子树权值就会都$-1$；有一条实边变轻了，它对应的子树权值都会$+1$。 初始权值好求，就是点的深度。子树加加减减，还要求子树权值$max$，可以用$dfs$序+线段树来维护。 能改变虚实边的就是$access$操作了。这里还要在$LCT$中要维护一下每个$splay$中深度最小的点（记为$ma[x]$，原因看下面伪代码解释）。 伪代码： //seg为dfs序，siz为子树大小 void access(int x){ for(int y=0;x;y=x,x=fa[x]){ splay(x); if(son(x,1))st.add(seg[ma[son(x,1)]],seg[ma[son(x,1)]]+siz[ma[son(x,1)]]-1,1,cnt,1,1); //son(x,1)变轻，子树+1 //变轻的一定是这棵splay中深度最小的点（毕竟是一条链），但是本身在splay中可能会出现它的根不是深度最小的点，所以要维护一下 if(y)st.add(seg[ma[y]],seg[ma[y]]+siz[ma[y]]-1,1,cnt,1,-1); //y变重，子树-1 //同理，变重的也是深度最小的点 son(x,1)=y; update(x); } } 这样就实现了用$LCT$维护形态，在线段树上维护信息。其实这样操作$2$也可以用线段树来查了。 时间复杂度：$O(nlog^2n)$ 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;set&gt; #define maxn 100005 #define inf 0x3f3f3f #define pn putchar(&#39;\\n&#39;) #define px(x) putchar(x) #define ps putchar(&#39; &#39;) #define pd puts(&quot;======================&quot;) #define pj puts(&quot;++++++++++++++++++++++&quot;) using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } template&lt;typename T&gt; inline T read(){ T x=0; int y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } inline int ran(){ static int seed=45562; return seed=(seed*48271LL%2147483647); } int h[maxn],num; struct edge{ int to,pre; }e[maxn&lt;&lt;1]; inline void add(int from,int to){ e[++num].pre=h[from],h[from]=num,e[num].to=to; } int pos[maxn],seg[maxn],top[maxn],deep[maxn],fa[maxn],son[maxn],siz[maxn],cnt; struct Segment_Tree{ int ma[maxn&lt;&lt;2],tag[maxn&lt;&lt;2]; #define ls(x) (x&lt;&lt;1) #define rs(x) (x&lt;&lt;1|1) inline void update(int node){ ma[node]=max(ma[ls(node)],ma[rs(node)]); } inline void datadown(int node,int d){ ma[node]+=d; tag[node]+=d; } inline void pushdown(int node){ datadown(ls(node),tag[node]); datadown(rs(node),tag[node]); tag[node]=0; } void build(int l,int r,int node){ if(l==r){ ma[node]=deep[pos[l]]+1; //因为深度是从0开始的，所以要+1 return; } int mid=l+r&gt;&gt;1; build(l,mid,ls(node)); build(mid+1,r,rs(node)); update(node); } void add(int L,int R,int l,int r,int node,int d){ if(L&lt;=l&amp;&amp;R&gt;=r){ datadown(node,d); return; } if(tag[node])pushdown(node); int mid=l+r&gt;&gt;1; if(L&lt;=mid)add(L,R,l,mid,ls(node),d); if(R&gt;mid)add(L,R,mid+1,r,rs(node),d); update(node); } int ask(int L,int R,int l,int r,int node){ if(L&lt;=l&amp;&amp;R&gt;=r)return ma[node]; if(tag[node])pushdown(node); int mid=l+r&gt;&gt;1,ans=0; if(L&lt;=mid)ans=ask(L,R,l,mid,ls(node)); if(R&gt;mid)ans=max(ans,ask(L,R,mid+1,r,rs(node))); return ans; } }st;//线段树 struct Link_Cut_Tree{ int son[maxn][2],fa[maxn],ma[maxn]; #define son(x,y) son[x][y] #define whson(x) (son[fa[x]][1]==x) #define root(x) (son[fa[x]][0]!=x&amp;&amp;son[fa[x]][1]!=x) inline void update(int node){ if(son(node,0))ma[node]=ma[son(node,0)]; else ma[node]=node; } inline void addedge(int s,int f,int wh){ son(f,wh)=s; if(s)fa[s]=f; } inline void zhuan(int x){ int f=fa[x],gf=fa[f],wh=whson(x); fa[x]=gf; if(!root(f))son(gf,whson(f))=x; addedge(son(x,wh^1),f,wh); addedge(f,x,wh^1); update(f),update(x); } void splay(int x){ int y=fa[x]; while(!root(x)){ if(!root(y)) zhuan(whson(x)^whson(y)?x:y); zhuan(x); y=fa[x]; } } void access(int x){ for(int y=0;x;y=x,x=fa[x]){ splay(x); if(son(x,1))st.add(seg[ma[son(x,1)]],seg[ma[son(x,1)]]+siz[ma[son(x,1)]]-1,1,cnt,1,1); if(y)st.add(seg[ma[y]],seg[ma[y]]+siz[ma[y]]-1,1,cnt,1,-1); son(x,1)=y; update(x); } } int fake_access(int x){ int ans=0; for(;x;x=fa[x],++ans) splay(x); return ans; } }lct;//lct struct Tree_Chain_Split{ void dfs1(int node=1){ siz[node]=1; lct.ma[node]=node; for(register int i=h[node];i;i=e[i].pre){ int x=e[i].to; if(!siz[x]){ lct.fa[x]=fa[x]=node; deep[x]=deep[node]+1; dfs1(x); if(siz[x]&gt;siz[son[node]])son[node]=x; siz[node]+=siz[x]; } } } void dfs2(int node=1){ seg[node]=++cnt; pos[cnt]=node; if(son[node]){ top[son[node]]=top[node]; dfs2(son[node]); for(register int i=h[node];i;i=e[i].pre){ int x=e[i].to; if(!seg[x])top[x]=x,dfs2(x); } } } int lca(int x,int y){ while(top[x]!=top[y]){ if(deep[top[x]]&lt;deep[top[y]])swap(x,y); x=fa[top[x]]; } return deep[x]&lt;deep[y]?x:y; }//用的树剖求lca }tcs; int main(){ int n=read(),m=read(); for(register int i=1;i&lt;n;++i){ int a=read(),b=read(); add(a,b),add(b,a); } tcs.dfs1(),tcs.dfs2(); st.build(1,cnt,1); while(m--){ int s=read(),x=read(); if(s==1)lct.access(x); else if(s==2){ int y=read(); printf(&quot;%d\\n&quot;,lct.fake_access(x)+lct.fake_access(y)-(lct.fake_access(tcs.lca(x,y))&lt;&lt;1)+1); } else printf(&quot;%d\\n&quot;,st.ask(seg[x],seg[x]+siz[x]-1,1,cnt,1)); } }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线段树","slug":"线段树","permalink":"https://ctz45562.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"LCT","slug":"LCT","permalink":"https://ctz45562.github.io/tags/LCT/"}]},{"title":"洛谷 P1600 天天爱跑步","slug":"题解-洛谷-P1600-【天天爱跑步】","date":"2019-02-26T07:58:25.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/02/26/题解-洛谷-P1600-【天天爱跑步】/","link":"","permalink":"https://ctz45562.github.io/2019/02/26/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7-P1600-%E3%80%90%E5%A4%A9%E5%A4%A9%E7%88%B1%E8%B7%91%E6%AD%A5%E3%80%91/","excerpt":"传送门 来一种$O(nlogn)$的毒瘤做法。","text":"传送门 来一种$O(nlogn)$的毒瘤做法。 首先介绍一下主角：$dsu\\ on\\ tree$ 。其原理是树上启发式合并。它支持$O(nlogn)$无修改子树信息统计。 实现：树剖划分出轻重儿子。对于某个节点，先递归处理轻儿子，并清除轻子树的影响。然后处理重儿子，保留重子树的影响。再次统计轻子树的影响，就能得到该点整个子树的信息。 伪代码： void dfs(int x,bool remain){ //remain表示是否保留该点子树的信息 int f=fa[x],s=son[x];//s为重儿子 for(int i=h[x];i;i=e[i].pre){ int y=e[i].to; if(x!=f&amp;&amp;x!=s)dfs(y,0);//递归处理轻儿子，删除信息 } if(s)dfs(s,1);//递归处理重儿子并保留信息 count(x);//这里的count是统计x的轻子树的信息 ans[x]=...;//记录答案 if(!remain)clear(x);//清除x整个子树的影响 } 复杂度：每个点到根节点的路径被剖成了最多$logn$条重链，而其中每个轻边都会使该点被用至多$O(n)$的时间统计一次，只要单点的信息统计与删除是$O(1)$的，总复杂度就为$O(nlogn)$ 参考： http://www.cnblogs.com/zzqsblog/p/6146916.html https://www.cnblogs.com/zcysky/p/6822395.html 回到这个题上。对于每一个玩家$(x-&gt;y)$，我们可以把它分成两半：$(x-&gt;lca(x,y))+(lca(x,y)-&gt;y)$，因为前者是往上跑，后者是往下跑，分开好处理。 放个图： 红色的数字是跑到该点的时间。 （以下用$deep$代表点的深度） 先处理$(x-&gt;lca(x,y))$ 对于往上跑的路径来说，只要满足$deep[x]-deep[i]=w[i]$，且该路径能覆盖到$i$，$i$就能观测到该名玩家。 即$deep[i]+w[i]=deep[x]$ 再处理$(lca(x,y)-&gt;y)$ 如图容易发现：从点$y$往上跳，每跳一步，时间就会$-1$，而一开始时间为$dis(x,y)$。 则一个点$i$能观测到$y$的条件是： $deep[y]-deep[i]=dis(x,y)-w[i]$且该路径也要覆盖$i$。 其中$dis(x,y)=deep[x]+deep[y]-2*deep[lca(x,y)]$ 移项整理得： $deep[x]-2*deep[lca(x,y)]=w[i]-deep[i]$ 综上，运用树上差分的思想，对于每个玩家$(x-&gt;y)$，用两个数组$up$和$down$： 将点$x$的$up$插入一个$deep[x]$。 将点$y$的$down$插入一个$deep[x]-2*deep[lca(x,y)]$。 $lca(x,y)$会统计两遍该路径，在$up$中打上删除$deep[x]$的标记 为了保证路径不覆盖的点不会统计，将$fa[lca(x,y)$]打上删除$deep[x]-2*deep[lca(x,y)]$的标记。 对于一个点$i$，统计其子树的$up$、$down$所有插入过的数，答案即为$up$中$(deep[i]+w[i])$的数量加上$down$中$(w[i]-deep[i])$的数量。 怎么统计呢？$dsu\\ on\\ tree$就出场了！直接统计就好了。 时间复杂度：每位玩家最多影响四个点，均摊下来单点统计还是$O(1)$的，总复杂度$O(nlogn)$。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #define maxn 300005 #define inf 0x3f3f3f #define pn putchar(&#39;\\n&#39;) #define px(x) putchar(x) #define ps putchar(&#39; &#39;) #define pd puts(&quot;======================&quot;) #define pj puts(&quot;++++++++++++++++++++++&quot;) using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } template&lt;typename T&gt; inline T read(){ T x=0; int y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int h[maxn],w[maxn],top[maxn],deep[maxn],fa[maxn],siz[maxn],son[maxn],num,n,m,ans[maxn]; bool vis[maxn]; int upi[maxn]; vector&lt;int&gt;doi[maxn],dod[maxn],upd[maxn]; //upi：up insert，向上路径的插入。因为该插入只会插入某个点的deep，所以压成了普通的数组 //upd：up delete，向上路径的删除 //doi、dod同理 struct edge{ int pre,to; }e[maxn&lt;&lt;1]; inline void add(int from,int to){ e[++num].pre=h[from],h[from]=num,e[num].to=to; } struct Tree_Chain_Split{ void dfs1(int node=1){ siz[node]=1; for(register int i=h[node];i;i=e[i].pre){ int x=e[i].to; if(!siz[x]){ fa[x]=node,deep[x]=deep[node]+1; dfs1(x); if(siz[x]&gt;siz[son[node]])son[node]=x; siz[node]+=siz[x]; } } } void dfs2(int node=1){ vis[node]=1; if(son[node]){ top[son[node]]=top[node]; dfs2(son[node]); for(register int i=h[node];i;i=e[i].pre){ int x=e[i].to; if(!vis[x]){ top[x]=x; dfs2(x); } } } } int lca(int x,int y){ while(top[x]!=top[y]){ if(deep[top[x]]&lt;deep[top[y]])swap(x,y); x=fa[top[x]]; } return deep[x]&lt;deep[y]?x:y; } }tcs; //树链剖分，顺便用的树剖的lca int upcnt[maxn],CNT[maxn&lt;&lt;1],*downcnt=&amp;CNT[maxn]; //upcnt是向上路径统计数组，downcnt反之。两种路径统计依据不同，所以分开 //因为w[i]-deep[i]可能为负数，所以用了指针小技巧使downcnt能使用负数下标 bool in[maxn]; //用于dsu on tree的数组。标记上的点在统计子树信息时不会访问该点的子树（见count函数） void count(int node){ int f=fa[node]; for(register int i=h[node];i;i=e[i].pre){ int x=e[i].to; if(x!=f&amp;&amp;!in[x])count(x); } upcnt[deep[node]]+=upi[node]; for(register int i=0;i&lt;upd[node].size();++i) --upcnt[upd[node][i]]; for(register int i=0;i&lt;doi[node].size();++i) ++downcnt[doi[node][i]]; for(register int i=0;i&lt;dod[node].size();++i) --downcnt[dod[node][i]]; }//统计信息 void clear(int node){ int f=fa[node]; for(register int i=h[node];i;i=e[i].pre){ int x=e[i].to; if(x!=f)clear(x); } upcnt[deep[node]]-=upi[node]; for(register int i=0;i&lt;upd[node].size();++i) ++upcnt[upd[node][i]]; for(register int i=0;i&lt;doi[node].size();++i) --downcnt[doi[node][i]]; for(register int i=0;i&lt;dod[node].size();++i) ++downcnt[dod[node][i]]; } void dfs(int node=1,bool remain=0){ int s=son[node],f=fa[node]; if(s){ for(register int i=h[node];i;i=e[i].pre){ int x=e[i].to; if(x!=s&amp;&amp;x!=f)dfs(x,0); } dfs(s,1); in[s]=1;//count时不会统计上它的重子树 } count(node);//统计轻儿子的信息 if(deep[node]+w[node]&lt;=n)ans[node]=upcnt[deep[node]+w[node]]; //判一下不能越界 ans[node]+=downcnt[w[node]-deep[node]]; //获取答案 in[s]=0;//一定要清掉标记 if(!remain)clear(node);//清除整个子树的信息 } void init(){ while(m--){ int a=read(),b=read(),l=tcs.lca(a,b); ++upi[a]; doi[b].push_back(deep[a]-(deep[l]&lt;&lt;1)); upd[l].push_back(deep[a]); dod[fa[l]].push_back(deep[a]-(deep[l]&lt;&lt;1)); } }//读入每名玩家并处理 int main(){ n=read(),m=read(); for(register int i=1;i&lt;n;++i){ int a=read(),b=read(); add(a,b),add(b,a); } for(register int i=1;i&lt;=n;++i) w[i]=read(); tcs.dfs1(),tcs.dfs2(); init(),dfs(); for(register int i=1;i&lt;=n;++i) printf(&quot;%d &quot;,ans[i]); } 码量确实有点大。不过$dsu\\ on\\ tree$在某些题中还是很高效的$QwQ$。","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"dsu on tree","slug":"dsu-on-tree","permalink":"https://ctz45562.github.io/tags/dsu-on-tree/"},{"name":"启发式合并","slug":"启发式合并","permalink":"https://ctz45562.github.io/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"}]},{"title":"USACO-19JAN Redistricting","slug":"题解-洛谷-P5202-【-USACO19JAN-Redistricting】","date":"2019-02-25T04:37:51.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/02/25/题解-洛谷-P5202-【-USACO19JAN-Redistricting】/","link":"","permalink":"https://ctz45562.github.io/2019/02/25/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7-P5202-%E3%80%90-USACO19JAN-Redistricting%E3%80%91/","excerpt":"传送门 正解好像是$O(n)$的单调队列优化贪心？这里提供一种好想点的$O(nlogn)$思路。","text":"传送门 正解好像是$O(n)$的单调队列优化贪心？这里提供一种好想点的$O(nlogn)$思路。 首先把 $H$ 看作 $1$ ， $G$ 看作 $-1$ ，处理一下前缀和 $sum$ ，这样就能快速判断一段区间两种牛数量关系了。 用 $f(i)$ 表示把前 $i$ 块牧草地分完最少能有几段更赛牛区域。转移时枚举一下最后一段区域的长度，就有： $f(i)=min\\{f(i-j)+[sum[i]-sum[i-j]\\le 0]\\}(1\\le j\\le k)$ 初值$f[0]=0$，答案为$f[n]$。 $[sum[i]-sum[i-j]\\le 0]$意为区域$[i-j+1,i]$是否为更赛牛区域。 时间复杂度：$O(nk)$，显然过不了。 把$sum[i]-sum[i-j]\\le 0$移项得$sum[i]\\le sum[i-j]$ 这样就可以造一棵存两个值$sum[i]$和$f[i]$的平衡树，以$sum[i]$排序，每个节点取一下子树中的$min(f[i])$。查询时遍历一遍平衡树，大于等于当前$sum[i]$的要$+1$，取一下$min$，就能用$logn$的时间更新，然后再插入。同时为了保证取到前面的$k$个值要及时删除$QwQ$ 时间复杂度：$O(nlogn)$ 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 300005 #define inf 0x3f3f3f3f #define pn putchar(&#39;\\n&#39;) #define px(x) putchar(x) #define ps putchar(&#39; &#39;) #define pd puts(&quot;======================&quot;) #define pj puts(&quot;++++++++++++++++++++++&quot;) using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } template&lt;typename T&gt; inline T read(){ T x=0; int y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; }//快读 inline int ran(){ static int seed=45562; return seed=(seed*48271LL%2147483647); }//rand函数，好像能优化一下常数？ struct Treap{ int dat[maxn],num[maxn],ls[maxn],rs[maxn],ra[maxn],mi[maxn],cnt,root; //dat为用于比较的关键值（sum[i])，num为存起来的f[i]，mi为子树最小f[i] #define ls(x) ls[x] #define rs(x) rs[x] inline void update(int node){ mi[node]=min(min(mi[ls(node)],mi[rs(node)]),num[node]); } void right(int &amp;node){ int rec=ls(node); ls(node)=rs(rec); rs(rec)=node; node=rec; update(rs(node)); update(node); } void left(int &amp;node){ int rec=rs(node); rs(node)=ls(rec); ls(rec)=node; node=rec; update(ls(node)); update(node); } void insert(int &amp;node,int d1,int d2){ if(!node){ node=++cnt; dat[node]=d1; mi[node]=num[node]=d2; ra[node]=ran(); return; } if(dat[node]&lt;d1||(dat[node]==d1&amp;&amp;num[node]&lt;d2)){ insert(rs(node),d1,d2); if(ra[rs(node)]&gt;ra[node])left(node); } else { insert(ls(node),d1,d2); if(ra[ls(node)]&gt;ra[node])right(node); } update(node); } void del(int &amp;node,int d1,int d2){ if(dat[node]==d1&amp;&amp;num[node]==d2){ if(ls(node)&amp;&amp;rs(node)){ if(ra[ls(node)]&gt;ra[rs(node)])right(node),del(rs(node),d1,d2); else left(node),del(ls(node),d1,d2); update(node); } else node=ls(node)+rs(node); return; } if(dat[node]&lt;d1||(dat[node]==d1&amp;&amp;num[node]&lt;d2))del(rs(node),d1,d2); else del(ls(node),d1,d2); update(node); } int Get(int d){ int node=root,ans=inf; while(node){ if(d&lt;=dat[node])ans=min(ans,min(num[node],mi[rs(node)])+1),node=ls(node); //当前节点大于等于待查询值，则它的右子树都大于等于，答案+1 else ans=min(ans,min(num[node],mi[ls(node)])),node=rs(node); //否则左子树都比它小，不+1 } return ans; }//查询函数 Treap(){ num[0]=mi[0]=inf; } }tr; int f[maxn],sum[maxn],n,k; char a[maxn]; int main(){ n=read(),k=read(); scanf(&quot;%s&quot;,a+1); for(register int i=1;i&lt;=n;++i) if(a[i]==&#39;H&#39;)sum[i]=sum[i-1]+1; else sum[i]=sum[i-1]-1; tr.insert(tr.root,0,0);//插入初值 for(register int i=1;i&lt;=n;++i){ if(i&gt;k)tr.del(tr.root,sum[i-k-1],f[i-k-1]);//删除不在当前区间的值 f[i]=tr.Get(sum[i]); tr.insert(tr.root,sum[i],f[i]); } printf(&quot;%d\\n&quot;,f[n]); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"平衡树","slug":"平衡树","permalink":"https://ctz45562.github.io/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"}]},{"title":"SPOJ8791 DYNALCA - Dynamic LCA","slug":"题解-洛谷-SP8791-【DYNALCA-Dynamic-LCA】","date":"2019-02-24T03:12:46.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/02/24/题解-洛谷-SP8791-【DYNALCA-Dynamic-LCA】/","link":"","permalink":"https://ctz45562.github.io/2019/02/24/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7-SP8791-%E3%80%90DYNALCA-Dynamic-LCA%E3%80%91/","excerpt":"传送门 只要会用$LCT$求$LCA$，这个题就很简单了$QwQ$（虽然因为之前一直写的假的$splay$和$LCT$调了一上午）","text":"传送门 只要会用$LCT$求$LCA$，这个题就很简单了$QwQ$（虽然因为之前一直写的假的$splay$和$LCT$调了一上午） 看到连边删边自然会去想$LCT$，那怎么用$LCT$求$LCA$？ 放图来看： 我要查$LCA(6,7)$，如果打通根到$6$的实链： 再打通到$7$的实链： 就会发现这两条实链在点$2$处分开了，也可以说这两条链一起在点$2$汇入进去。点$2$就是它们的$LCA$。 怎么找呢？在$access$时，每次改右儿子都相当于把两棵$splay$的链汇入进这个点。那最后一次汇入的点就是答案了。 实现： int access(int x){ int y=0; for(;x;y=x,x=fa[x]) splay(x),son(x,1)=y; return y; } int lca(int x,int y){ access(x);//一定要先打通到x的实链才能保证y汇入了x的链 return access(y); } 注意一下换根的影响。$link$可以换根，因为连上爹后他自己就不是根了；而$cut$不能换根。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 100005 #define inf 0x3f3f3f #define pn putchar(&#39;\\n&#39;) #define px(x) putchar(x) #define ps putchar(&#39; &#39;) #define pd puts(&quot;======================&quot;) #define pj puts(&quot;++++++++++++++++++++++&quot;) using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } template&lt;typename T&gt; inline T read(){ T x=0; int y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; }//快读 int n; struct Link_Cut_Tree{ int son[maxn][2],fa[maxn],rev[maxn],st[maxn]; #define whson(x) (son[fa[x]][1]==x) #define root(x) (son[fa[x]][0]!=x&amp;&amp;son[fa[x]][1]!=x) #define son(x,y) son[x][y] inline void addedge(int s,int f,int wh){ if(s)fa[s]=f; son(f,wh)=s; } inline void reverdown(int x){ rev[x]^=1; swap(son(x,0),son(x,1)); } inline void pushdown(int node){ if(rev[node]){ if(son(node,0))reverdown(son(node,0)); if(son(node,1))reverdown(son(node,1)); rev[node]=0; } } inline void zhuan(int x){ int f=fa[x],gf=fa[f],wh=whson(x); fa[x]=gf; if(!root(f))son(gf,whson(f))=x; addedge(son(x,wh^1),f,wh); addedge(f,x,wh^1); } inline void splay(int x){ int top=1,y=x; st[1]=x; while(!root(y))st[++top]=y=fa[y]; while(top)pushdown(st[top--]); while(!root(x)){ if(!root(fa[x])) zhuan(whson(fa[x])^whson(x)?x:fa[x]); zhuan(x); } } inline int access(int x){ int y=0; for(;x;y=x,x=fa[x]) splay(x),son(x,1)=y; return y; } inline void makeroot(int x){ access(x),splay(x),reverdown(x); } inline void link(int x,int y){ makeroot(x); fa[x]=y; } inline void cut(int x){ access(x),splay(x); fa[son(x,0)]=0,son(x,0)=0; } inline int ask(int x,int y){ access(x); return access(y); } }lct; int main(){ n=read(); int m=read(); while(m--){ char s[5]; scanf(&quot;%s&quot;,s); if(s[0]==&#39;c&#39;){ int x=read(); lct.cut(x); } else { int x=read(),y=read(); if(s[1]==&#39;i&#39;)lct.link(x,y); else printf(&quot;%d\\n&quot;,lct.ask(x,y)); } } }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"LCA","slug":"LCA","permalink":"https://ctz45562.github.io/tags/LCA/"},{"name":"LCT","slug":"LCT","permalink":"https://ctz45562.github.io/tags/LCT/"}]},{"title":"SPOJ11470 TTM - To the moon","slug":"题解-SP11470-【TTM-To-the-moon】","date":"2019-02-18T08:59:39.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/02/18/题解-SP11470-【TTM-To-the-moon】/","link":"","permalink":"https://ctz45562.github.io/2019/02/18/%E9%A2%98%E8%A7%A3-SP11470-%E3%80%90TTM-To-the-moon%E3%80%91/","excerpt":"传送门 题意概括一下就是区间修改的可持久化线段树。","text":"传送门 题意概括一下就是区间修改的可持久化线段树。 一般的可持久化线段树都是单点改的，这道题肯定不能一个一个改。想想普通线段树的区间修改，是找到最多 $logn$ 个节点并打上懒标记。这样我们当然可以也找到这 $logn$ 个节点并继承。但是标记一下传就会出问题：某两个版本的线段树共用的节点不能修改值。 于是用标记永久化。标记永久化既不需要下传标记，也不需要通过子节点更新自己。 具体来说：对被修改区间覆盖的节点打上标记，其左右子节点继承上个版本的左右子节点 放图来看： 就会发现，查询时红色线段树有标记，查询时 $tag$ 会对答案产生影响， $tag$ 不下放就不会影响到两棵线段树的公共节点，就能保证不会互相影响了 $QwQ$ 。 时间复杂度：$O(nlogn)$ 空间复杂度：每个区间最多被分成 $2logn$ 个节点，所以为 $O(nlogn)$ 细节上注意好时间戳与版本之间的关系（尤其是 $B$ 操作） 上代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 100005 #define inf 0x3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } template&lt;typename T&gt; inline T read(){ T x=0; int y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; }//快读 int root[maxn&lt;&lt;1],wh[maxn]; //wh记录每个时间戳对应哪个版本 int a[maxn]; struct Chairman_Tree{ long long dat[maxn&lt;&lt;6],tag[maxn&lt;&lt;6]; int ls[maxn&lt;&lt;6],rs[maxn&lt;&lt;6],cnt; #define ls(x) ls[x] #define rs(x) rs[x] inline void update(int node){ dat[node]=dat[ls(node)]+dat[rs(node)]; } void build(int l,int r,int &amp;node){ node=++cnt; if(l==r){ dat[node]=a[l]; return; } int mid=l+r&gt;&gt;1; build(l,mid,ls(node)); build(mid+1,r,rs(node)); update(node); }//初始建树 void add(int L,int R,int l,int r,int &amp;ne,int ol,int d){ ne=++cnt; dat[ne]=dat[ol]+1ll*(min(R,r)-max(L,l)+1)*d; tag[ne]=tag[ol]; if(L&lt;=l&amp;&amp;R&gt;=r){ tag[ne]+=(long long)d; ls[ne]=ls[ol],rs[ne]=rs[ol];//继承子节点 return; } int mid=l+r&gt;&gt;1; if(L&lt;=mid)add(L,R,l,mid,ls(ne),ls(ol),d); else ls(ne)=ls(ol);//不包含在这个区间内节点，直接继承过来 if(R&gt;mid)add(L,R,mid+1,r,rs(ne),rs(ol),d); else rs(ne)=rs(ol); } long long ask(int L,int R,int l,int r,int node){ if(L&lt;=l&amp;&amp;R&gt;=r)return dat[node]; int mid=l+r&gt;&gt;1; long long ans=0; if(L&lt;=mid)ans=ask(L,R,l,mid,ls(node)); if(R&gt;mid)ans+=ask(L,R,mid+1,r,rs(node)); return ans+1ll*(min(R,r)-max(L,l)+1)*tag[node]; } }ct; int main(){ int n=read(),m=read(),t=0,now=0; //now是当前的时间戳，t是当前的版本 for(register int i=1;i&lt;=n;++i) a[i]=read(); ct.build(1,n,root[0]); while(m--){ char s[2]; scanf(&quot;%s&quot;,s); if(s[0]==&#39;C&#39;){ wh[++now]=++t; int l=read(),r=read(),d=read(); ct.add(l,r,1,n,root[t],root[t-1],d); } else if(s[0]==&#39;Q&#39;){ int l=read(),r=read(); printf(&quot;%lld\\n&quot;,ct.ask(l,r,1,n,root[t])); } else if(s[0]==&#39;H&#39;){ int l=read(),r=read(),k=read(); printf(&quot;%lld\\n&quot;,ct.ask(l,r,1,n,root[wh[k]])); } else now=read(),root[++t]=root[wh[now]]; } return 0; } 标记永久化大法好！ $QwQ$","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线段树","slug":"线段树","permalink":"https://ctz45562.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"可持久化","slug":"可持久化","permalink":"https://ctz45562.github.io/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"标记永久化","slug":"标记永久化","permalink":"https://ctz45562.github.io/tags/%E6%A0%87%E8%AE%B0%E6%B0%B8%E4%B9%85%E5%8C%96/"}]},{"title":"洛谷 P3722 [AH2017/HNOI2017]影魔","slug":"题解-P3722-【-AH2017-HNOI2017-影魔】","date":"2019-02-17T12:09:05.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/02/17/题解-P3722-【-AH2017-HNOI2017-影魔】/","link":"","permalink":"https://ctz45562.github.io/2019/02/17/%E9%A2%98%E8%A7%A3-P3722-%E3%80%90-AH2017-HNOI2017-%E5%BD%B1%E9%AD%94%E3%80%91/","excerpt":"传送门 感觉还是挺有思维难度的一道题。蒟蒻想了不短时间才从暴力$O(n^3)$优化到$O(nlogn)$","text":"传送门 感觉还是挺有思维难度的一道题。蒟蒻想了不短时间才从暴力$O(n^3)$优化到$O(nlogn)$ 纯暴力$O(n^3)$ 暴力枚举区间内的点对，暴力扫描区间最大值。 稍微好点的暴力最大值可以用线段树维护，优化到 $O(n^2logn)$。 （其实$st$表能达到 $O(n^2)$ ，不过蒟蒻早忘了咋写了。。。总之最大值可以用数据结构优化) （重点！）高端的优化似乎到上面就不是很好想了。瓶颈就在于枚举点对的 $n^2$。可不可以少枚举点东西？ 一个点对 $(i,j)$ 的贡献与三个值有关：$a[i],a[j],max(a[k])(i&lt;k&lt;j)$ 不枚举$i,j$，那就枚举中间的 $a[k]$。这里引入两个值：定义 $ll[i]$ 为从点 $i$ 向左走，直到遇到第一个大于它的数的位置（没有则为0）；同理，$rr[i]$就是向右走（没有则为n+1)。 也就是说，点 $i$ 是区间$[ll[i]+1,rr[i]-1]$的最大值，且满足这个区间长度最小。 这样，枚举这个点（记为 $i$ )的时候：（区间记为$[L,R]$） 如果 $ll[i]$ 与 $rr[i]$ 都在区间中，就会有一点对 $(ll[i],rr[i])$满足条件 $1$。 如果 $ll[i]$ 在区间中，那么每个点对 $(ll[i],k)(i&lt;k&lt;min(rr[i],R))$ 满足条件 $2$。（因为 $a[k]&lt;a[i]$ ，$a[i]&lt;a[ll[i]]$ ， $a[i]$ 为区间 $[ll[i]+1,k-1]$的最大值。注意不能走出去所以取min） 如果 $rr[i]$ 在区间中，那么每个点对 $(k,rr[i])(max(ll[i],L)&lt;k&lt;i)$ 满足条件 $2$。（原因同上） 这样就能得到 $O(n^2)$ 的做法。 顶级的优化前面铺垫这么多，终于轮到正解出场了！ 根据上面，我们需要一种方法，能快速得知： 每个 $ll[i]$ 在区间内的数的 $min(rr[i],R)-i$ 每个 $rr[i]$ 在区间内的数的 $i-max(ll[i],L)$ $ll[i]$，$rr[i]$都在区间内数的个数。 虽然有点麻烦，不过本题只有询问，是不是可以离线下来搞一搞呢？ 先处理第一种。从右往左扫描数列，遇到某个数的 $ll[i]$ 再把这个数产生的贡献用某种数据结构维护起来，遇到某个询问的左端点就直接查询，这样保证了只有 $ll[i]$ 在区间内的数才会产生贡献。 具体来说：用线段树维护。遇到 $ll[i]$ 就把 $[i+1,rr[i]-1]$（注意不能取两端）加 $1$，遇到询问左端点就查询 $[L,R]$ 的和。仔细想想就会发现，这样也会在查询时相当于取了$min(rr[i],R)$。 第二种倒过来扫就好了。 第三种正着扫倒着扫皆可。以倒着扫为例：遇到 $ll[i]$ 把$[rr[i],n]$加 $1$（意为询问右端点落在$[rr[i],n]$都会覆盖到$rr[i]$，就有 1 贡献），这样查询时单点查 $R$ 即可。 时间复杂度：$O(nlogn)$（常数有点大最慢$1100ms+$。。。） 细节：1.关于预处理$ll$、$rr$：蒟蒻好像想复杂了，没有什么好方法，只能记录下位置，按权值排序后造棵平衡树倒着扫数列，插入每个点的位置，$ll$、$rr$分别查前驱后继。。。 2.统计的答案要开long long！ $update:$ 3.有一点忘了说了：对于情况1，满足$i+1=j​$同样会有贡献，而该方法统计不上，所以输出时直接加上就好。 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #define maxn 200005 #define inf 0x3f3f3f using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } template&lt;typename T&gt; inline T read(){ T x=0; int y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; }//快读 inline int ran(){ static int seed=45562; return seed=seed*48271LL%2147483647; }//一个优化常数的随机数函数 int a[maxn],pos[maxn],ll[maxn],rr[maxn],n; vector&lt;int&gt;lq[maxn],rq[maxn],li[maxn],ri[maxn]; //分别用来存询问左端点、右端点和ll、rr的位置情况 //vector可以用链式前向星代替，常数小。不过我懒了。。。 struct Question{ int l,r; long long ans; }q[maxn]; struct Treap{ #define ls(x) ls[x] #define rs(x) rs[x] int dat[maxn],ls[maxn],rs[maxn],ra[maxn],root,cnt; void right(int &amp;node){ int rec=ls(node); ls(node)=rs(rec); rs(rec)=node; node=rec; } void left(int &amp;node){ int rec=rs(node); rs(node)=ls(rec); ls(rec)=node; node=rec; } void insert(int &amp;node,int d){ if(！node){ node=++cnt; dat[node]=d; ra[node]=ran(); return; } if(dat[node]&lt;d){ insert(rs(node),d); if(ra[rs(node)]&gt;ra[node])left(node); } else { insert(ls(node),d); if(ra[ls(node)]&gt;ra[node])right(node); } } int getpre(int d){ int ans=0,node=root; while(node){ if(dat[node]&lt;d)ans=max(ans,dat[node]),node=rs(node); else node=ls(node); } return ans; } int getnex(int d){ int ans=n+1,node=root; while(node){ if(dat[node]&lt;d)node=rs(node); else ans=min(ans,dat[node]),node=ls(node); } return ans; } }tr;//平衡树 #undef ls #undef rs #define ls(x) (x&lt;&lt;1) #define rs(x) (x&lt;&lt;1|1) struct Segment_Tree{ int dat[maxn&lt;&lt;2],tag[maxn&lt;&lt;2]; inline void update(int node){ dat[node]=dat[ls(node)]+dat[rs(node)]; } inline void datadown(int l,int r,int node,int d){ dat[node]+=(r-l+1)*d; tag[node]+=d; } inline void pushdown(int l,int r,int node){ int mid=l+r&gt;&gt;1; datadown(l,mid,ls(node),tag[node]); datadown(mid+1,r,rs(node),tag[node]); tag[node]=0; } void add(int L,int R,int l,int r,int node){ if(L&lt;=l&amp;&amp;R&gt;=r){ dat[node]+=r-l+1; ++tag[node]; return; } if(tag[node])pushdown(l,r,node); int mid=l+r&gt;&gt;1; if(L&lt;=mid)add(L,R,l,mid,ls(node)); if(R&gt;mid)add(L,R,mid+1,r,rs(node)); update(node); } long long ask(int L,int R,int l,int r,int node){ if(L&lt;=l&amp;&amp;R&gt;=r)return (long long)dat[node]; if(tag[node])pushdown(l,r,node); int mid=l+r&gt;&gt;1; long long ans=0; if(L&lt;=mid)ans=ask(L,R,l,mid,ls(node)); if(R&gt;mid)ans+=ask(L,R,mid+1,r,rs(node)); return ans; } }st1,st2,st3;//空间够大开三棵线段树QwQ int main(){ n=read(); int m=read(); long long p1=read&lt;long long&gt;(),p2=read&lt;long long&gt;(); for(register int i=1;i&lt;=n;++i){ a[i]=read(); pos[a[i]]=i; } sort(a+1,a+1+n); for(register int i=n;i;--i){ int L=tr.getpre(pos[a[i]]),R=tr.getnex(pos[a[i]]); ll[pos[a[i]]]=L; rr[pos[a[i]]]=R; if(L!=-inf)li[L].push_back(pos[a[i]]); if(R!=inf)ri[R].push_back(pos[a[i]]); tr.insert(tr.root,pos[a[i]]); } for(register int i=1;i&lt;=m;++i) q[i].l=read(),q[i].r=read(),lq[q[i].l].push_back(i),rq[q[i].r].push_back(i); for(register int i=n;i;--i){ for(register int j=0;j&lt;li[i].size();++j){ if(li[i][j]+1&lt;rr[li[i][j]])st1.add(li[i][j]+1,rr[li[i][j]]-1,0,n+1,1); st3.add(rr[li[i][j]],n+1,0,n+1,1); } for(register int j=0;j&lt;lq[i].size();++j) q[lq[i][j]].ans+=st1.ask(i,q[lq[i][j]].r,0,n+1,1)*p2+st3.ask(q[lq[i][j]].r,q[lq[i][j]].r,0,n+1,1)*p1; } for(register int i=1;i&lt;=n;++i){ for(register int j=0;j&lt;ri[i].size();++j) if(ll[ri[i][j]]+1&lt;ri[i][j])st2.add(ll[ri[i][j]]+1,ri[i][j]-1,0,n+1,1); for(register int j=0;j&lt;rq[i].size();++j) q[rq[i][j]].ans+=st2.ask(q[rq[i][j]].l,i,0,n+1,1)*p2; } for(register int i=1;i&lt;=m;++i) printf(&quot;%d\\n&quot;,q[i].ans+(long long)(q[i].r-q[i].l)*p1); }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线段树","slug":"线段树","permalink":"https://ctz45562.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"洛谷 P3332 [ZJOI2013]K大数查询","slug":"题解-洛谷-P3332-【-ZJOI2013-K大数查询】","date":"2019-02-17T02:46:46.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/02/17/题解-洛谷-P3332-【-ZJOI2013-K大数查询】/","link":"","permalink":"https://ctz45562.github.io/2019/02/17/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7-P3332-%E3%80%90-ZJOI2013-K%E5%A4%A7%E6%95%B0%E6%9F%A5%E8%AF%A2%E3%80%91/","excerpt":"传送门 好像整体二分跑得飞快，不过蒟蒻是来练树套树的。才不是我不会任何离线算法","text":"传送门 好像整体二分跑得飞快，不过蒟蒻是来练树套树的。才不是我不会任何离线算法 操作涉及区间插入、区间查询k小值。先想到了权值线段树套平衡树，平衡树存储位置。 查询时（假设查询区间 $[l,r]$ 的第k名）从权值线段树根节点出发，查询右儿子平衡树的$r$的排名-（$l-1$）的排名，也就是右边区间中在区间 $[l,r]$的数的个数，比$k$小，就让$k$减去它，跳到左儿子上；反之跳到右儿子上。（比较像主席树区间$k$大值） 插入暴力将每个位置挨个插到平衡树中。 复杂度 $O(nlog^{2}n+len*log^{2}n)$ $\\text{（len为总插入数字的个数）}$ $T$了$10$个点。$len$非常大。瓶颈就在于插入。一个个插入确实太慢了，有没有什么能快速把一段连续区间加进去？ 线段树可以。权值线段树里套一个维护位置的线段树。插入直接区间加 $1$，查询区间求和，时间都是$logn$的。为了保证空间，还要动态开点。 时间复杂度：每次插入查询都要访问权值线段树的$logn$个节点，每个节点要访问内部的线段树的$logn$个节点。总复杂度$O(nlog^{2}n)$。 空间复杂度：每次插入都要访问权值线段树的$logn$个节点，每个节点内部的线段树最多会新开$logn$个节点，总复杂度$O(nlog^{2}n)$。 不过毕竟树套树常数大，容易 $T$ 。搞个标记永久化能优化不少。不过蒟蒻并不会卡常，程序自带大常数（比如AC自动机永远跑不进 $9000ms$），标记永久化还是 $T$ 了一个点。加了$fread$、快输才能不开$O2$过。 上代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 50005 #define inf 0x3f3f3f #define pn putchar(&#39;\\n&#39;) #define px(x) putchar(x) #define ps putchar(&#39; &#39;) #define pd puts(&quot;======================&quot;) #define pj puts(&quot;++++++++++++++++++++++&quot;) #define getchar() (*head++) using namespace std; char buf[1&lt;&lt;23],*head=buf;//fread优化 inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } template&lt;typename T&gt; inline T read(){ T x=0; int y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; }//快读 void put(int x){ if(x&lt;0)px(&#39;-&#39;)，x=-x; if(x&gt;9)put(x/10); px(x%10+48); }//快输 int n; #define ls(x) ls[x] #define rs(x) rs[x] struct Position_Segment_Tree{ long long dat[maxn*400]; int tag[maxn*400],ls[maxn*400],rs[maxn*400],cnt; void add(int L,int R,int l,int r,int &amp;node){ if(!node)node=++cnt;//动态开点 dat[node]+=(long long)(min(R,r)-max(L,l)+1);//标记永久化 if(L&lt;=l&amp;&amp;R&gt;=r){ ++tag[node]; return; } int mid=l+r&gt;&gt;1; if(L&lt;=mid)add(L,R,l,mid,ls(node)); if(R&gt;mid)add(L,R,mid+1,r,rs(node)); } long long ask(int L,int R,int l,int r,int node,long long t=0){ if(!node)return (long long)(min(R,r)-max(L,l)+1)*t; if(L&lt;=l&amp;&amp;R&gt;=r)return dat[node]+1ll*(min(R,r)-max(L,l)+1)*t; int mid=l+r&gt;&gt;1; long long ans=0; if(L&lt;=mid)ans=ask(L,R,l,mid,ls(node),t+tag[node]); if(R&gt;mid)ans+=ask(L,R,mid+1,r,rs(node),t+tag[node]); return ans; } }pst; #undef ls #undef rs #define ls(x) (x&lt;&lt;1) #define rs(x) (x&lt;&lt;1|1) struct Data_Segment_Tree{ int root[maxn&lt;&lt;3]; void insert(int poi,int L,int R){ int l=-n,r=n,node=1; while(1){ pst.add(L,R,1,n,root[node]); if(l==r)return; int mid=l+r&gt;&gt;1; if(poi&lt;=mid)node=ls(node),r=mid; else node=rs(node),l=mid+1; } }//为了卡常把递归改成了非递归的。不过好像没什么效果。。。 void ask(int L,int R,long long k){ int l=-n,r=n,node=1; while(l&lt;r){ int mid=l+r&gt;&gt;1; long long sum=pst.ask(L,R,1,n,root[rs(node)]); if(sum&gt;=k)node=rs(node),l=mid+1; else k-=sum,node=ls(node),r=mid; } put(l),pn; } }dst; int main(){ fread(buf,1,1&lt;&lt;23,stdin); n=read(); int m=read(); while(m--){ int s=read(),l=read(),r=read(); if(s==1){ int d=read(); dst.insert(d,l,r); } else { long long k=read&lt;long long&gt;(); dst.ask(l,r,k); } } }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线段树","slug":"线段树","permalink":"https://ctz45562.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"标记永久化","slug":"标记永久化","permalink":"https://ctz45562.github.io/tags/%E6%A0%87%E8%AE%B0%E6%B0%B8%E4%B9%85%E5%8C%96/"},{"name":"树套树","slug":"树套树","permalink":"https://ctz45562.github.io/tags/%E6%A0%91%E5%A5%97%E6%A0%91/"}]},{"title":"SPOJ6779 GSS7 - Can you answer these queries VII","slug":"题解-洛谷-SP6779-【GSS7-Can-you-answer-these-queries-VII】","date":"2019-02-17T02:45:26.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/02/17/题解-洛谷-SP6779-【GSS7-Can-you-answer-these-queries-VII】/","link":"","permalink":"https://ctz45562.github.io/2019/02/17/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7-SP6779-%E3%80%90GSS7-Can-you-answer-these-queries-VII%E3%80%91/","excerpt":"传送门 题解都是树剖，没有LCT？","text":"传送门 题解都是树剖，没有LCT？ 裸的树上链查询最大子段和+链赋值。一开始想的树剖，不过树剖查询时会在两个点之间来回跳，两边信息的合并是有一定思维量的。因为懒得想就写的LCT。（毕竟LCT能直接把整个链完整的提取出来真的方便啊） 最大子段和这一系列题都是，维护一下以这个区间总和sum，覆盖左端点的最大和ll，覆盖右端点的最大和rr，最大子段和ma。 $\\text{ll=max(左儿子ll，左儿子sum+自己的点权+右儿子ll)}$ $\\text{rr=max(右儿子rr，右儿子sum+自己的点权+左儿子rr)}$ $\\text{ma=max(左儿子ma，右儿子ma，左儿子rr+自己的点权+右儿子ll)}$ 链赋值，若赋值为正，ll、rr、ma就改为sum（所有点都选）；为负，则改为0（可以不选） 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;map&gt; #define maxn 100005 #define inf 0x3f3f3f3f #define pn putchar(&#39;\\n&#39;) #define px(x) putchar(x) #define ps putchar(&#39; &#39;) #define pd puts(&quot;======================&quot;) #define pj puts(&quot;++++++++++++++++++++++&quot;) using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } template&lt;typename T&gt; inline T read(){ T x=0; int y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; }//快读 int n; struct Link_Cut_Tree{ int ll[maxn],rr[maxn],ma[maxn],sum[maxn],siz[maxn],son[maxn][2],fa[maxn],rev[maxn],tag[maxn],st[maxn],dat[maxn]; #define son(x,y) son[x][y] #define whson(x) (son[fa[x]][1]==x) #define root(x) (son[fa[x]][0]!=x&amp;&amp;son[fa[x]][1]!=x) inline void update(int node){ siz[node]=siz[son(node,0)]+siz[son(node,1)]+1;//维护siz用于更新sum ll[node]=max(ll[son(node,0)],sum[son(node,0)]+dat[node]+ll[son(node,1)]); rr[node]=max(rr[son(node,1)],sum[son(node,1)]+dat[node]+rr[son(node,0)]); ma[node]=max(max(ma[son(node,0)],ma[son(node,1)]),ll[son(node,1)]+dat[node]+rr[son(node,0)]); sum[node]=sum[son(node,0)]+sum[son(node,1)]+dat[node]; } inline void addedge(int s,int f,int wh){ fa[s]=f,son(f,wh)=s; } inline void datadown(int node,int d){ sum[node]=siz[node]*d; if(d&gt;0)ll[node]=rr[node]=ma[node]=sum[node]; else ll[node]=rr[node]=ma[node]=0; dat[node]=d,tag[node]=1; } inline void reverdown(int node){ rev[node]^=1; swap(son(node,0),son(node,1)); swap(ll[node],rr[node]);//ll、rr也要交换！ } inline void pushdown(int node){ if(rev[node]){ if(son(node,0))reverdown(son(node,0)); if(son(node,1))reverdown(son(node,1)); rev[node]=0; } if(tag[node]){ if(son(node,0))datadown(son(node,0),dat[node]); if(son(node,1))datadown(son(node,1),dat[node]); tag[node]=0; } } inline void zhuan(int x){ int f=fa[x],gf=fa[f],wh=whson(x); fa[x]=gf; if(!root(f))son(gf,whson(f))=x; addedge(son(x,wh^1),f,wh); addedge(f,x,wh^1); update(f),update(x); } void splay(int x){ int top=1,y=x; st[1]=x; while(!root(y))st[++top]=y=fa[y]; while(top)pushdown(st[top--]); while(!root(x)){ if(!root(fa[x])) zhuan(whson(x)^whson(fa[x])?fa[x]:x); zhuan(x); } } void access(int x){ for(int y=0;x;y=x,x=fa[x]) splay(x),son(x,1)=y,update(x); } void makeroot(int x){ access(x),splay(x),reverdown(x); } void link(int x,int y){ makeroot(x),access(y),splay(y); fa[x]=y; } void change(int x,int y,int d){ makeroot(x),access(y),splay(y),datadown(y,d); } void Get(int x,int y){ makeroot(x),access(y),splay(y); printf(&quot;%d\\n&quot;,ma[y]); } void init(){ for(register int i=1;i&lt;=n;++i){ dat[i]=sum[i]=read(); if(dat[i]&gt;0)ll[i]=rr[i]=ma[i]=dat[i]; siz[i]=1;//初始化 } } }lct; int main(){ n=read(); lct.init(); for(register int i=1;i&lt;n;++i){ int a=read(),b=read(); lct.link(a,b); } int m=read(); while(m--){ int s=read(),x=read(),y=read(); if(s==1)lct.Get(x,y); else { int d=read(); lct.change(x,y,d); } } } 这种讲究查询顺序、信息合并的题（我知道的还有SDOI2011染色），用于树剖练手、锻炼思维很好。不过比赛遇到这种题还是写好想又好写的LCT吧。（毕竟细节写错一点就炸了）","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"LCT","slug":"LCT","permalink":"https://ctz45562.github.io/tags/LCT/"}]},{"title":"洛谷 P4332 三叉神经树","slug":"题解-洛谷-P4332-【三叉神经树】","date":"2019-02-17T02:44:17.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/02/17/题解-洛谷-P4332-【三叉神经树】/","link":"","permalink":"https://ctz45562.github.io/2019/02/17/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7-P4332-%E3%80%90%E4%B8%89%E5%8F%89%E7%A5%9E%E7%BB%8F%E6%A0%91%E3%80%91/","excerpt":"传送门 历经一下午+一晚上+半个上午终于切掉。。。 一道LCT好题，重点是维护什么信息和各种细节的处理。","text":"传送门 历经一下午+一晚上+半个上午终于切掉。。。 一道LCT好题，重点是维护什么信息和各种细节的处理。 一开始是想用LCT维护一下三个儿子，用类似于虚子树的东西更新自己。不过这样会出现一个问题： 比如说这是x、x所在的实链的splay、x的两个虚儿子，z是x的实儿子。注意在本题中，每个点必须直接由它的三个儿子更新。但是z的信息先经过了y才进一步更新了x，就会导致信息不准确。 换一种思路。先想一种暴力些的做法： 修改一个点，它的权值变了，它的父节点就有可能改变，那就向上走看一下它的父节点是否需要更新。如果父节点权值会变，那么它的祖父就有可能会变。如此一直走，直到走到根或某个祖先不会改变权值，停止。 不过，这种做法会被构造的树给卡掉（比如把非叶子节点排成一条链，复杂度就会退化成$O(mn)$。它的瓶颈就在于向上走的过程，复杂度直接由树高决定。那么如果知道每个点走到哪会停就好了。 考虑走到哪里会停，即什么样的节点不会被修改。 首先容易想到三个儿子都是同样的颜色的节点不会被更新。于是愉快地去敲代码，然而写了对拍始终不过。 还少情况。上图直观来看： 比如我要改点x，同样对k无影响。也就是说： 假设我要改一个本来为0的点，那么它的祖先中为1的点就不会被改（改0点只会让1更多，则为1的点就不可能被改了） 造个LCT，每个点维护一下深度最大的权值为0的点、为1的点、儿子是同一种权值的点，修改时打通到x的实链，根据x的权值取一下深度最大的点（假设为y），对x到y进行修改。 在维护第三种情况时我用的方法是：把0看作-1，dfs预处理好每个点权值之和（儿子为负就-1，为正就+1）。这样权值为3/-3的就是满足这个条件的点。修改链时用加法修改即可。 最后是注意细节，维护的东西比较神奇，注意好每个地方对这三个值的影响，及时修改。 时间复杂度：$O(nlog{n})*\\text{LCT巨大的常数}$ 算了虽然很丑我还是把代码放上来吧： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 1500005 #define inf 0x3f3f3f3f #define pn putchar(&#39;\\n&#39;) #define px(x) putchar(x) #define ps putchar(&#39; &#39;) #define pd puts(&quot;=====================&quot;) using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } int head[maxn],num,n,N,ans,deep[maxn]; bool vis[maxn]; struct edge{int pre,to;}e[maxn&lt;&lt;1]; inline void add(int from,int to){ e[++num].pre=head[from],head[from]=num,e[num].to=to; } struct Link_Cut_Tree{ int son[maxn][2],fa[maxn],rev[maxn],st[maxn],dat[maxn],tag[maxn]; int z[maxn],zz[maxn],o[maxn],oo[maxn],th[maxn],thr[maxn]; #define son(x,y) son[x][y] #define whson(x) (son[fa[x]][1]==x) #define root(x) (son[fa[x]][0]!=x&amp;&amp;son[fa[x]][1]!=x) inline void update(int node){ if(z[son(node,1)])z[node]=z[son(node,1)]; else if(dat[node]==-1)z[node]=node; else if(z[son(node,0)])z[node]=z[son(node,0)]; else z[node]=0; if(zz[son(node,0)])zz[node]=zz[son(node,0)]; else if(dat[node]==-1)zz[node]=node; else if(zz[son(node,1)])zz[node]=zz[son(node,1)]; else zz[node]=0; if(o[son(node,1)])o[node]=o[son(node,1)]; else if(dat[node]==1)o[node]=node; else if(o[son(node,0)])o[node]=o[son(node,0)]; else o[node]=0; if(oo[son(node,0)])oo[node]=oo[son(node,0)]; else if(dat[node]==1)oo[node]=node; else if(oo[son(node,1)])oo[node]=oo[son(node,1)]; else oo[node]=0; if(th[son(node,1)])th[node]=th[son(node,1)]; else if(dat[node]==3||dat[node]==-3)th[node]=node; else if(th[son(node,0)])th[node]=th[son(node,0)]; else th[node]=0; if(thr[son(node,0)])thr[node]=thr[son(node,0)]; else if(dat[node]==3||dat[node]==-3)thr[node]=node; else if(thr[son(node,1)])thr[node]=thr[son(node,1)]; else thr[node]=0; } inline void reverdown(int node){ rev[node]^=1; swap(son(node,0),son(node,1)); swap(z[node],zz[node]); swap(o[node],oo[node]); swap(th[node],thr[node]); } inline void datadown(int node,int d){ tag[node]+=d; dat[node]+=d; if(d&gt;0) while(d){ d-=2; swap(th[node],z[node]); swap(th[node],o[node]); } else while(d){ d+=2; swap(o[node],z[node]); swap(o[node],th[node]); } } inline void pushdown(int node){ if(rev[node]){ if(son(node,0))reverdown(son(node,0)); if(son(node,1))reverdown(son(node,1)); rev[node]=0; } if(tag[node]){ if(son(node,0))datadown(son(node,0),tag[node]); if(son(node,1))datadown(son(node,1),tag[node]); tag[node]=0; } } inline void addedge(int s,int f,int wh){ fa[s]=f,son(f,wh)=s; } inline void zhuan(int x){ int f=fa[x],gf=fa[f],wh=whson(x); fa[x]=gf; if(!root(f))son(gf,whson(f))=x; addedge(son(x,wh^1),f,wh); addedge(f,x,wh^1); update(f),update(x); } void splay(int x){ int top=1,y=x; st[1]=x; while(!root(y))st[++top]=y=fa[y]; while(top)pushdown(st[top]),update(st[top--]); while(!root(x)){ if(!root(fa[x])) whson(fa[x])^whson(x)?zhuan(fa[x]):zhuan(x); zhuan(x); } } void access(int x){ for(int y=0;x;y=x,x=fa[x]) splay(x),son(x,1)=y,update(x); } void makeroot(int x){ access(x),splay(x),reverdown(x); } void link(int x,int y){ makeroot(x),access(y),splay(y); fa[x]=y; } void change(int x,int y,int d){ makeroot(x),access(y),splay(y); datadown(y,d); } void revers(int x){ makeroot(1),access(x),splay(x); if(!th[x]&amp;&amp;((dat[x]&gt;0&amp;&amp;!z[x])||(dat[x]&lt;0&amp;&amp;!o[x]))){ ans^=1; change(1,x,dat[x]&lt;0?2:-2); } else if(th[x]&amp;&amp;((dat[x]&gt;0&amp;&amp;z[x])||(dat[x]&lt;0&amp;&amp;o[x]))){ int en=deep[th[x]]&gt;deep[dat[x]&gt;0?z[x]:o[x]]?th[x]:(dat[x]&gt;0?z[x]:o[x]); change(x,en,dat[x]&lt;0?2:-2); } else if(th[x])change(x,th[x],dat[x]&lt;0?2:-2); else change(x,dat[x]&gt;0?z[x]:o[x],dat[x]&lt;0?2:-2); } void dfs(int node){ vis[node]=1; for(register int i=head[node];i;i=e[i].pre) if(!vis[e[i].to]){ deep[e[i].to]=deep[node]+1; dfs(e[i].to),dat[node]+=dat[e[i].to]&lt;0?-1:1; link(node,e[i].to); } } }lct; int main(){ n=read(),N=3*n+1; for(register int i=1;i&lt;=n;++i) for(register int j=0;j&lt;3;++j){ int k=read(); add(i,k);add(k,i); } for(register int i=n+1;i&lt;=N;++i){ int a=read(); if(a){ lct.dat[i]=1; lct.o[i]=i; } else { lct.dat[i]=-1; lct.z[i]=i; } } lct.dfs(1); ans=(bool)(lct.dat[1]&gt;0); int m=read(); while(m--){ int x=read(); lct.revers(x); printf(&quot;%d\\n&quot;,ans); } }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"LCT","slug":"LCT","permalink":"https://ctz45562.github.io/tags/LCT/"}]},{"title":"洛谷 P3979 遥远的国度","slug":"题解-洛谷-P3979-【遥远的国度】","date":"2019-02-17T02:34:11.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/02/17/题解-洛谷-P3979-【遥远的国度】/","link":"","permalink":"https://ctz45562.github.io/2019/02/17/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7-P3979-%E3%80%90%E9%81%A5%E8%BF%9C%E7%9A%84%E5%9B%BD%E5%BA%A6%E3%80%91/","excerpt":"传送门 一道换根树剖好题，思维很巧妙。","text":"传送门 一道换根树剖好题，思维很巧妙。 去食堂时开玩笑跟机房数据结构之神说树剖可以换根，他一本正经的说：“树剖真的可以换根。”然后当晚考试就考了这道题。（一口毒奶） 本题要求:换根+链修改+子树min 换根和链修改首先可以想到LCT，然而LCT弱于维护子树，这种维护子树最值更是麻烦。 考虑树剖。换根肯定不能重构树剖。那就转化一下？ 画个图看看： 换完后长这样： （x为原树根，y为要换的根） 抽象点理解，就是把y拎了起来（可以在脑中yy一个GIF） 注意到，点1和点x子树变了，其他的都没变。这两个点都是y的祖先，也就是说原树中为y的祖先的点子树变了 抽象来说，对于某个点，y本来在它下面。现在要把在它下面的点y拎到上面去变成根，那么本来在它上面的点就要坠下去变成它的子树，而本来在它下面的点就要跑到上面去，从它的子树中分开。（可能很绕口。。。） 那它的子树变成啥了？在原树中从y向上跳，一直到它的某一个儿子，那么整棵树-这个儿子的子树=它的新子树 为什么呢？假设y向上跳到的它的儿子为z，z的子树都会跑到它的上面，而它上面的点成了它的新子树，再加上它原子树中剩下的点就是新子树 （z的子树+它原子树中不是z的子树的点+它上面的点【不是它子树中的点】=整棵树，它原子树中不是z的子树的点+它上面的点=新子树-&gt;整棵树-z的子树=它的新子树） 然后就是怎么跳了。当然可以用倍增LCA。不过树剖写都写了，怎么能不好好用用树剖呢？考虑直接跳重链（假设从x跳到y的儿子z）： 1.如果z是y的重儿子，一定会有某一时刻top[x]==top[y]（因为它们在同一条重链上），那就返回y的重儿子 2.如果z是y的轻儿子，一定会有某一时刻top[x]的父亲是y，那就返回top[x]（可以画个图理解） 这样就可以不改变树的结构换根了QwQ 最后说一下细节： 1.数据范围是小于等于$2^{31}$，等于的话会爆int啊，也不要像我一样inf只开到0x3f3f3f3f，WA调了一小时。。。 2.可以用LCA来判断是否是当前树根的祖先。而且树剖都写了，正好用树剖求LCA，省空间省时间省码量（而且据说树剖LCA比倍增常数小） 代码： #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #define maxn 100005 #define inf 0x3f3f3f3f const long long INF = 1e11; using namespace std; inline int read(){ int x=0,y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; } template&lt;class T&gt; inline T read(){ T x=0; int y=0; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar()；} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48),ch=getchar(); return y?-x:x; }//快读 int head[maxn],num; struct edge{ int pre,to; }e[maxn&lt;&lt;1]; inline void add(int from,int to){ e[++num].pre=head[from],head[from]=num,e[num].to=to; }//邻接表 long long a[maxn]; int seg[maxn],top[maxn],pos[maxn],deep[maxn],fa[maxn],son[maxn],siz[maxn],cap; //seg就是树剖第二次dfs打的标记，cap是当前首都 struct Segment_Tree{ #define ls(x) (x&lt;&lt;1) #define rs(x) (x&lt;&lt;1|1) long long dat[maxn&lt;&lt;2]; int tag[maxn&lt;&lt;2]; inline void update(int node){ dat[node]=min(dat[ls(node)],dat[rs(node)]); } inline void pushdown(int node){ dat[ls(node)]=dat[rs(node)]=dat[node]; tag[ls(node)]=tag[rs(node)]=1; tag[node]=0; } void build(int l,int r,int node){ if(l==r){ dat[node]=a[pos[l]]; return; } int mid=l+r&gt;&gt;1; build(l,mid,ls(node)); build(mid+1,r,rs(node)); update(node); } void change(int L,int R,int l,int r,int node,long long d){ if(L&lt;=l&amp;&amp;R&gt;=r){ dat[node]=d,tag[node]=1; return; } if(tag[node])pushdown(node); int mid=l+r&gt;&gt;1; if(L&lt;=mid)change(L,R,l,mid,ls(node),d); if(R&gt;mid)change(L,R,mid+1,r,rs(node),d); update(node); } long long ask(int L,int R,int l,int r,int node){ if(L&lt;=l&amp;&amp;R&gt;=r)return dat[node]; if(tag[node])pushdown(node); int mid=l+r&gt;&gt;1; long long ans=INF; if(L&lt;=mid)ans=ask(L,R,l,mid,ls(node)); if(R&gt;mid)ans=min(ans,ask(L,R,mid+1,r,rs(node))); return ans; } };//线段树 struct Tree_Chain_Spilt{ //问一句，有谁知道树剖真正的英文名是啥吗。。。我强迫症受不了啊。。。 Segment_Tree st; void dfs1(int node){ siz[node]=1; for(register int i=head[node];i;i=e[i].pre){ if(!siz[e[i].to]){ fa[e[i].to]=node; deep[e[i].to]=deep[node]+1; dfs1(e[i].to); if(siz[e[i].to]&gt;siz[son[node]])son[node]=e[i].to; siz[node]+=siz[e[i].to]; } } } void dfs2(int node){ seg[node]=++seg[0]; pos[seg[0]]=node; if(son[node]){ top[son[node]]=top[node]; dfs2(son[node]); for(register int i=head[node];i;i=e[i].pre) if(!seg[e[i].to]){ top[e[i].to]=e[i].to; dfs2(e[i].to); } } } int lca(int x,int y){ while(top[x]!=top[y]){ if(deep[top[x]]&lt;deep[top[y]])swap(x,y); x=fa[top[x]]; } return deep[x]&lt;deep[y]?x:y; }//树剖求LCA void change(int x,int y,int d){ while(top[x]!=top[y]){ if(deep[top[x]]&lt;deep[top[y]])swap(x,y); st.change(seg[top[x]],seg[x],1,seg[0],1,d); x=fa[top[x]]; } if(deep[x]&lt;deep[y])swap(x,y); st.change(seg[y],seg[x],1,seg[0],1,d); } int Get(int x,int y){ while(top[x]!=top[y]&amp;&amp;fa[top[y]]!=x)y=fa[top[y]]; if(fa[top[y]]==x)return top[y]; return son[x]; }//向上跳的函数 long long ask(int x){ if(x==cap)return st.dat[1];//注意特判查询首都 else if(lca(cap,x)==x){//用LCA判断x是否是cap的祖先 int k=Get(x,cap); long long ans=INF; if(seg[k]&gt;1)ans=st.ask(1,seg[k]-1,1,seg[0],1); if(seg[k]+siz[k]&lt;=seg[0])ans=min(ans,st.ask(seg[k]+siz[k],seg[0],1,seg[0],1)); //注意判一下seg的边界，不过好像不判也行。。 return ans; } else return st.ask(seg[x],seg[x]+siz[x]-1,1,seg[0],1); } }tcs; int main(){ int n=read(),m=read(); for(register int i=1;i&lt;n;++i){ int x=read(),y=read(); add(x,y),add(y,x); } for(register int i=1;i&lt;=n;++i) a[i]=read&lt;long long&gt;(); cap=read(); tcs.dfs1(cap); tcs.dfs2(cap); tcs.st.build(1,seg[0],1); while(m--){ int s=read(); if(s==1)cap=read(); else if(s==2){ int x=read(),y=read(); long long d=read&lt;long long&gt;(); tcs.change(x,y,d); } else { int x=read(); printf(&quot;%lld\\n&quot;,tcs.ask(x)); } } return 0; }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://ctz45562.github.io/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"线段树","slug":"线段树","permalink":"https://ctz45562.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"洛谷 P3157 CQOI2011-动态逆序对","slug":"题解-洛谷-P3157-【-CQOI2011-动态逆序对】","date":"2019-02-17T00:57:56.000Z","updated":"2020-06-21T09:41:03.000Z","comments":true,"path":"2019/02/17/题解-洛谷-P3157-【-CQOI2011-动态逆序对】/","link":"","permalink":"https://ctz45562.github.io/2019/02/17/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7-P3157-%E3%80%90-CQOI2011-%E5%8A%A8%E6%80%81%E9%80%86%E5%BA%8F%E5%AF%B9%E3%80%91/","excerpt":"传送门 蒟蒻刚开始学分块，刚从分块入门中出来。","text":"传送门 蒟蒻刚开始学分块，刚从分块入门中出来。 听机房一位数据结构大佬说这题用分块可以$n\\sqrt{n}$过，于是经历了漫长的（近一天）的思考，用了种神奇的二维树状数组+分块$O(n\\sqrt{n})$过了，好像题解里没有我这种写法来水一发 不扯了讲正题。 支持删除的逆序对，一个基本思路是先求出来一开始逆序对个数，每次删除将这个数的贡献从答案中减去。 怎么求一个数的贡献？ 一个数的贡献分两部分：前面比它大的数的个数，后面比它小的数的个数，这些都能组成逆序对。 如何维护这个贡献？ 暴力$O(n)$扫描 我们可以数列分块，每个块开一个n大小的数组$f[n]$，$f[i]$表示在这个块中小于等于i的数有几个，计算贡献时（假设这个数为i，在块p中，共有len个块)可以用类似于前缀和统计块 1~p-1的$f[n]-f[i]$（i+1~n的数的数量），再统计块p+1~len的$f[i-1]$（1~i-1的数的数量），最后对块p内的暴力统计，三部分加起来就是这个数的贡献，单次操作时间为$O(\\sqrt{n})$,空间为$O(n\\sqrt{n})$。 但是问题来了，如何修改？ 我们可以注意到，由于每删除一个数就会对这个f数组产生影响，所以必须考虑修改。 这个f数组与前缀和类似，那么前缀和支持修改？ 树状数组啊！ 把f数组改为树状数组，统计时用树状数组询问，顺带把每一个块执行add(i,-1)（相当于去掉这个数） 然后问题又双来了，这样做单次时间复杂度为$O(n\\sqrt{n} logn)$，计算器一算达到了1e8，有点悬啊。试一下果然T了。 还是放弃吧继续优化。 观察一下查询贡献的过程：统计块 1~p-1的$f[n]-f[i]$（i+1~n的数的数量），再统计块p+1~len的$f[i-1]$（1~i-1的数的数量），最后对块p内的暴力统计。 对块p暴力统计肯定没法优化了（即使优化了效果也微乎其微），重点是粗体标出的部分。 两段连续的区间？ 前缀和？ 那么再加工一下 f 数组：用f[i][j]表示前 i 个块内小于等于 j 的数的数量这样$O(\\sqrt{n}logn)$的暴力统计被优化到了$O(logn)$。 然而问题又双叒来了咋这么多问题 还是老问题，删除数伴随着 f 数组的变化， f 数组不仅第二维要支持修改，第一维也需要修改。 又是支持修改的前缀和？ 还是树状数组啊！ 于是思路来了： 开二维树状数组，第一维维护块的前缀和，第二位维护数的前缀和 块外的整块用二维树状数组$O(log(\\sqrt{n}) log n)≈O(log^2 n)$查询，块内暴力$O(\\sqrt{n})$扫描 再用树状数组改一下 时间复杂度：$O(n (\\sqrt{n} + log^2n)) ≈ O(n \\sqrt{n})$空间复杂度：$O(n\\sqrt{n})$ 除了空间压着线（125MB）效率还是不错的：不开O2 1400ms，开O2 900ms 代码： #define mian main #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #define maxn 100005 //下面是瞎define的 #define pn putchar(&#39;\\n&#39;) #define ps putchar(&#39; &#39;) #define px(x) putchar(&#39;x&#39;) #define pX(x) putchar(x) using namespace std; inline int read(){ int x=0,y=0;char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)y=1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();} return y?-x:x; }//快读 #define lowb(x) x&amp;-x int n,len; int a[maxn],be[maxn],pos[maxn]; bool dis[maxn]; //解释一下毒瘤的变量名 //a : 原数列 //be : belong , 记录每个位置属于哪个块 //pos : position , 记录每个数的位置 //dis : disappear,记录这个位置是否被删除了,用于块内的暴力统计 struct Tree_Array{ //标准的翻译:tree树,array数组,合起来tree_array树状数组(大雾 //结构体内的就是第二维的树状数组,因为二维数组难看所以开进结构体里了 int tree[maxn]; inline void add(int x,int d){ while(x&lt;=n)tree[x]+=d,x+=lowb(x); } inline int ask(int x){ int ans=0; while(x)ans+=tree[x],x-=lowb(x); return ans; } }ta[320],init; //ta:Tree_Array的缩写,就是那个二维的树状数组 //init:initialization,用于统计初始逆序对数量 //为什么我要用树状数组统计?正好写了个树状数组结构体那就用上呗(才不是我归并排序都打错了) inline void ADD(int x,int y,int d){ //x为第一维,y为第二维,d为加的数值 while(x&lt;=len)ta[x].add(y,d),x+=lowb(x); }//整个二维树状数组加 inline int ASK(int x,int y){ //同上的查询 int ans=0; while(x)ans+=ta[x].ask(y),x-=lowb(x); return ans; } int mian(){ n=read(); int m=read(),sq=sqrt(n); long long ans=0;//一定要开long long len=n/sq+(bool)(n%sq);//诡异的块的个数,好像就我这么毒瘤的写分块吧... for(register int i=1;i&lt;=n;++i) a[i]=read(),pos[a[i]]=i; for(register int i=1;i&lt;=len;++i){ int l=sq*(i-1)+1,r=min(l+sq-1,n); for(register int j=l;j&lt;=r;++j){ ans+=init.ask(n)-init.ask(a[j]); init.add(a[j],1);//前两个是统计初始逆序对的 ADD(i,a[j],1);//将前i个块的前a[j]的值+1,初始化二维树状数组 be[j]=i;//记录be数组 } } while(m--){ int k=read(); printf(&quot;%lld\\n&quot;,ans); if(be[pos[k]]&gt;1) ans-=ASK(be[pos[k]]-1,n)-ASK(be[pos[k]]-1,k); //前一部分的统计,翻译过来:块1~be[pos[k]]的小于等于n的数的个数-块1~be[pos[k]]的小于等于k的个数,即为块1~be[pos[k]]的大于k的个数 if(be[pos[k]]&lt;len) ans-=ASK(len,k-1)-ASK(be[pos[k]],k-1); //同上,块be[pos[k]]+1~len的小于k的数的个数 int r=min(be[pos[k]]*sq,n); for(register int i=sq*(be[pos[k]]-1)+1;i&lt;pos[k];++i) if(!dis[i]&amp;&amp;a[i]&gt;k)--ans; for(register int i=pos[k]+1;i&lt;=r;++i) if(!dis[i]&amp;&amp;a[i]&lt;k)--ans; //上面为块内暴力统计 ADD(be[pos[k]],k,-1); //去掉这个数在二维树状数组中的值 dis[pos[k]]=1; } }","categories":[{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"分块","slug":"分块","permalink":"https://ctz45562.github.io/tags/%E5%88%86%E5%9D%97/"},{"name":"树状数组","slug":"树状数组","permalink":"https://ctz45562.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"}]},{"title":"随机图片url整合","slug":"随机图片url整合","date":"2019-02-01T03:49:37.000Z","updated":"2021-07-01T04:31:55.409Z","comments":true,"path":"2019/02/01/随机图片url整合/","link":"","permalink":"https://ctz45562.github.io/2019/02/01/%E9%9A%8F%E6%9C%BA%E5%9B%BE%E7%89%87url%E6%95%B4%E5%90%88/","excerpt":"自己做不出来只能慢慢收集啦。。。","text":"自己做不出来只能慢慢收集啦。。。 https://acg.toubiec.cn/random.php https://api.dujin.org/pic/ https://api.ixiaowai.cn/mcapi/mcapi.php (menhera酱) https://api.ixiaowai.cn/api/api.php http://img.xjh.me/random_img.php?tctype=acg&amp;return=302 http://img.xjh.me/random_img.php?type=bg&amp;ctype=acg&amp;return=302 http://acg.bakayun.cn/randbg.php?t https://www.xwboke.cn/api/api.php https://woriqq.com/acg/img.php http://api.mtyqx.cn/tapi/random.php http://img.xjh.me/random_img.php?type=bg&amp;ctype=nature&amp;return=302 (风景) https://uploadbeta.com/api/pictures/random/ (自然) https://api.ixiaowai.cn/gqapi/gqapi.php (自然) https://v2.jinrishici.com/one.svg?font-size=50&amp;spacing=1&amp;color=purple (诗句) http://www.dmoe.cc/random.php https://acg.toubiec.cn/acgurl http://acg.yanwz.cn/ （含有四个api） https://img.paulzzh.tech/touhou/random （东方的？） http://www.dmoe.cc/random.php","categories":[{"name":"杂物","slug":"杂物","permalink":"https://ctz45562.github.io/categories/%E6%9D%82%E7%89%A9/"}],"tags":[{"name":"二次元","slug":"二次元","permalink":"https://ctz45562.github.io/tags/%E4%BA%8C%E6%AC%A1%E5%85%83/"}]},{"title":"NOIP2018 游记","slug":"noip2018游记","date":"2019-01-31T12:20:53.000Z","updated":"2021-07-19T09:13:43.545Z","comments":true,"path":"2019/01/31/noip2018游记/","link":"","permalink":"https://ctz45562.github.io/2019/01/31/noip2018%E6%B8%B8%E8%AE%B0/","excerpt":"在郑州颓废的成果。。。","text":"在郑州颓废的成果。。。 Day -45从学OI开始，我就愉悦地颓废了3个月，刚写成自己的第3个游戏感觉非常良好（？） 哦学姐来讲课了，还考了个试，然后表示四道题四脸懵逼。（T2就是个逆序对T4就是个动态逆序对现在想想当时还是太年轻） 哦$NOIP$还有一个半月了时间过的好快啊 woc我好像啥都没学啊？？ 掐指一算，除了搜索我好像啥都不会。 表面慌得一批实则心里更慌 Day -42国庆放完了。（不想开学啊啊啊啊啊啊） $loli$说快要$NOIP$了，文化课先放一放。于是感觉氛围突然紧张了起来。但就一个半月了我补啥呢？ 这时，脑中突然闪现出一个大胆的想法！ 学好DP走遍天下！ （当时真的太年轻了） 于是愉快(?)地从零开始练DP Day -rand()%41爆刷DP ing… 试着写了写去年的$NOIP$题，二百多分的样子（当时感觉还算满足），然而奶酪直接爆零感觉很方 Day -10(写DP写的肾疼后)感觉好心累，学点新东西吧 诶线段树好像很好玩的样子我来看一看 Day -1清点一下我会啥： 会写头文件、std、main函数 DP：蓝题止步，学到状压和单调队列，不会斜率优化 只会勉强打一下板子的线段树和LCA 数论：打表 图论：最短路和最小生成树板子 其他：暴力 没了？ 没了。。。 —-= Day 0上午在机房颓，本来想把跳房子套上二分切了（之前不会写二分），然后看到了生火间。 愉悦地颓了一上午。。。 下午坐车去潍坊。 $loli$：在车上别光玩手机、电脑的，这种时候再看看书，交流交流题目。。。 坐在我旁边的两位大佬（玩植物大战僵尸ing）：woc这僵尸越过我南瓜把向日葵吃了？？ 被$loli$的话振奋的我拿出手机默默补起了番 到了潍坊去抽签。好像几年来积攒着的从未显现过得欧气爆发了出来（事实证明耗这一次就一点不剩），抽到在本校考 跟HN哥和众多学长住一间宿舍，看到了学长一起犯SAO。但是实在没啥经验，原来宿舍不给电啊。。。 好在睿智的学长拿出了插座：你看这空调接着电。。。（试图把插座插上去） 恰好宿管老大爷经过。 老大爷：你们干啥呢？。。。这个功率很大的，你插上去整栋楼都着了。。。不怕一万，就怕万一。。。不要存在侥幸心理。。。（请任取方言套上去体会一下） 最终还是没有插上电。 八点半去试机，还是没啥经验，敲了个A+B，瞎调试了一下，又敲了个LCA 我还会啥？ 哦我会打线段树！ 不过因为太蒻了没打完就到点了。 回到宿舍，玩了会手机，随便翻了翻书就睡了。 Day 1去考场之前心中默念：考一道好找规律的数论。。。（因为小凯的疑惑一打表规律就出来了。。。） 进考场时扫描，扫到我口袋时哔哔地响。一掏口袋，不小心带来的饭卡。。。还有一副耳机？ woc耳机？ 监考老师：耳机是最容易怀疑的东西。。。 当时我眼前就浮现出CCF将我禁赛三年的场景。。。 然后我把耳机和饭卡放到外面就没事了（?） 给了密码“飞雪连天”，额。。。感觉很新潮啊 先看T1 这不是积木大赛吗？ 脑中又浮现出三个月前的一个场景。。。 Day -inf（刚讲完递推）我（一脸懵逼）：递推是啥？算了找些题练练吧 随手点开一道积木大赛。 根本不会做啊。。。 于是开始愉快地画图模拟。恰好$loli$经过看到我在画图。 $loli$：这是什么题啊？ 我（不知道为啥很慌）：啊啊啊。。。是这个积木大赛，那个。。递推感觉学的不大好我随便找的练练。 $loli$听完又走了。 又画了几分钟，心态十分爆炸。这题怎么这么难？ 去翻了翻题解，然后切掉了。 递推好难，心好累，不练了不练了 主要是$loli$问了我，我对这题印象很深。 诶这题忘了咋做了。。。 好像是个递推吗？ 想了大概十分钟，好像是比前一项大的积木就加上它们的差值？ 写完过了大样例。但是强迫症不允许我就这么跳过。 开始打暴力对拍，但是好像不会打暴力，连小样例都跑不动（不是跑错了，是T了。。。） 最终手造了几组数据好像没啥问题。 测一下效率吧。（心里清楚是$O(n)$的但是很不放心）开着最大数据的对拍就过了 此时过了不到一小时，开始看T2。 这是个数论？手推了一会，好像答案是原集合的子集? 又想了大概10分钟，好像这个子集要去掉能由集合中其他数组合出来的数？ 试试暴力筛？ 20分钟打了暴力过了大样例，但是复杂度过于玄学： $O(n^2 (\\sum_{i=1}^{i&lt;=n}m/a[i])/k)\\text{(k=玄学})$ (谁能告诉我这怎么算啊。。。) 一般来说跑不满，但感觉好像构造一下我就死了啊。。。 造了些最大数据跑了跑： 800 ms （还行还行） 1000+ ms （。。。可能是巧合的数据） 2000+ ms （woc什么鬼!!!∑(ﾟДﾟノ)ノ） 之后一直稳定在1000~2000ms 先放一放吧，能拿大部分分也行。 看一看T3。 读完题后：我觉得T2还能抢救一下（真香）。 试着找一找哪里拖累了效率，输出调试了一些地方。 诶这里怎么重复计算了这么多次？？ 改了一下又测了测,400~800 ms 应该能过吧。。。 还有一个小时多点，不太放心又搞数据测了测T1、T2。看到我测试T1效率的程序还在运行，上面一行行的程序运行时间还在不断显示着。顺手点了关闭。 woc关不掉！数字停了但是窗口还在！(以前做题也遇见过这种BUG，记得那个程序开了一个星期直到我重启电脑)任务管理器也关不掉！ 监考老师会帮我解决。。。吧？ 没办法了先不管了，T3暴力都还没去打。又细读了一遍题理解了题意，再看数据范围顿时倍感友好，原来部分分这么多啊。 但是我把两个样例解释搞混了，题意理解：输出最短路径长度—&gt;输出所有选出的路径长度之和。 打完各种特殊情况感觉极其良好，也快结束了，检查了一下文件名什么的，之后监考老师说：把所有其他程序关掉，仅留下文件夹打开。 。。。。 于是大胆地举起了手：老师，我这个程序。。。它。。。关不掉。。。 老师看了看我的电脑，用了我试过的一切办法——同样没关掉。 她又看了看我的对拍程序。当时我继承了之前对拍的写法，图个乐呵把输入文件起名为”shit.in” 老师（好像看到了什么）：啊，你这个只要不影响评测就行。 就走了。 （后来我再也没有用过shit.in当文件名） 出考场后交流了一番，知道T3读错了题，应该只有10分仅找一条路径的情况能过 T1真的是原题（我 抄 我 自 己） T2是个完全背包？DP白练了。。。 预计得分：$100+100+10=210$（可能T2会被卡掉一些分） 下午感觉很累，和神仙们去了趟超市买了零食，坐在小广场上看大型up主集会鸽子群，听到各种奶图论奶数论的 晚上无心学习，凑到一起玩谁是卧底（结果成了算法版谁是卧底？） 大概十一点睡下了。睡前听到学长野兽先辈论。。。 Day 2一起来就感觉没啥状态，有点昏昏沉沉的。 上了考场，看到一个人提一大兜子零食饮料（不下五包薯片三瓶饮料）的进去了，还有一个从兜里被扫出 $3$ 瓶薄荷糖和口香糖的人 额… 密码是笑书神侠。真的是缅怀金庸先生的啊 看T4。 诶图论？不对好像是棵树，好像又有不是树的（当时不知道基环树） 想到了贪心+搜索的思路，不过只能跑前60分，后面的真的不会处理。。。 而且没想到邻接矩阵存图，傻傻的用了邻接表，每次都暴力查询编号最小的点。 算了过了吧看T5 好不容易读懂题，看到数据范围 $n&lt;=8$ ，状压DP？终于到了我DP大显神威了吗？ 结果推了2小时，一直以为这就是个DP，错了是我方程有问题。 最后放弃了。而且不知为啥，我以为爆搜复杂度高到爆炸，连$2*2$都过不去,所以就没写,把样例什么的弄了上去就跳了. 就剩一小时了，有点小崩。看T6，是个动态DP？那个板子都是黑题的动态DP？ 不多想直接去拿部分分，写了个记忆化搜索，应该能过前七个点。 剩下的时间百无聊赖地检查一下程序，消磨着时光就过去了。 预计得分：$60+10+28=98$ 总得分: $210+98=308$ 拿省一有戏? 吃完午饭又颓着回了家。 下午就在家休息，结果从下午$5$点睡到了第二天早上 于是令人身(累)心(得)舒(半)畅(死)的$NOIP$二日游就结束了 Day 出成绩每个题和预料的一分不差 T1没啥说的，感觉是运气的事？ T2虽然A了，但还是有点失落没能想到背包，DP真的白练了 T3我视力差认了，而且即使读对了也拿不了很多分 T4好在邻接表没过分拖延效率，60分拿全了 T5，所有题耗时最长，思维量最大，然而是唯一一道输出样例、而且分数最低的题（真的很嘲讽啊） T6也很难受，旁边的图论大神周神也写的暴力DP 他的DP: void dp(){ ... } 拿了44分 我的: int dp(){ ... return ...; } 常数贼大，就28分。 $update$：后来想想发现其实是我$DP$写假了。。。复杂度是错的 虽说对分数比较满意，但我苦练的DP不仅没大用上，甚至拖低了分数（真的没练到家啊），有点小小的难受。 $NOIP$的感觉很快就淡了下来，又回归到了文化课与OI五五开的局面，但是同时也为了省选而把重心往OI上偏了偏（即使知道没啥希望）。 Day inf一直想写一篇$NOIP$游记，不过没有大型颓废时间过多精力去写。 我再没有写过游戏之类的，虽然也常常颓废，但还是更多去专注OI了吧（好像我现在就在颓啊。。。） $NOIP$后三个多月了，寒假之际去郑州培训。第七天晚上，一种颓废之情油然而生。 突然有了念头,就把$NOIP$游记写了吧，虽然有些晚了。 于是就有了这篇又臭又长啰里啰嗦的游记 于是我又颓了一晚上 于是你就看完了这篇游记 于是loli可能就在你身旁：又不专心了？看什么呢？","categories":[{"name":"日常","slug":"日常","permalink":"https://ctz45562.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://ctz45562.github.io/tags/OI/"},{"name":"游记","slug":"游记","permalink":"https://ctz45562.github.io/tags/%E6%B8%B8%E8%AE%B0/"}]}],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ctz45562.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"日常","slug":"日常","permalink":"https://ctz45562.github.io/categories/%E6%97%A5%E5%B8%B8/"},{"name":"杂物","slug":"杂物","permalink":"https://ctz45562.github.io/categories/%E6%9D%82%E7%89%A9/"},{"name":"动漫","slug":"动漫","permalink":"https://ctz45562.github.io/categories/%E5%8A%A8%E6%BC%AB/"},{"name":"点兔","slug":"点兔","permalink":"https://ctz45562.github.io/categories/%E7%82%B9%E5%85%94/"},{"name":"题解","slug":"题解","permalink":"https://ctz45562.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"女装","slug":"女装","permalink":"https://ctz45562.github.io/tags/%E5%A5%B3%E8%A3%85/"},{"name":"公主连结","slug":"公主连结","permalink":"https://ctz45562.github.io/tags/%E5%85%AC%E4%B8%BB%E8%BF%9E%E7%BB%93/"},{"name":"二次元","slug":"二次元","permalink":"https://ctz45562.github.io/tags/%E4%BA%8C%E6%AC%A1%E5%85%83/"},{"name":"LOL","slug":"LOL","permalink":"https://ctz45562.github.io/tags/LOL/"},{"name":"番剧","slug":"番剧","permalink":"https://ctz45562.github.io/tags/%E7%95%AA%E5%89%A7/"},{"name":"回忆录","slug":"回忆录","permalink":"https://ctz45562.github.io/tags/%E5%9B%9E%E5%BF%86%E5%BD%95/"},{"name":"日记","slug":"日记","permalink":"https://ctz45562.github.io/tags/%E6%97%A5%E8%AE%B0/"},{"name":"请问您今天要来点兔子吗","slug":"请问您今天要来点兔子吗","permalink":"https://ctz45562.github.io/tags/%E8%AF%B7%E9%97%AE%E6%82%A8%E4%BB%8A%E5%A4%A9%E8%A6%81%E6%9D%A5%E7%82%B9%E5%85%94%E5%AD%90%E5%90%97/"},{"name":"min_25筛","slug":"min-25筛","permalink":"https://ctz45562.github.io/tags/min-25%E7%AD%9B/"},{"name":"OI","slug":"OI","permalink":"https://ctz45562.github.io/tags/OI/"},{"name":"游记","slug":"游记","permalink":"https://ctz45562.github.io/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"字符串","slug":"字符串","permalink":"https://ctz45562.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"trie树","slug":"trie树","permalink":"https://ctz45562.github.io/tags/trie%E6%A0%91/"},{"name":"莫队","slug":"莫队","permalink":"https://ctz45562.github.io/tags/%E8%8E%AB%E9%98%9F/"},{"name":"动态规划","slug":"动态规划","permalink":"https://ctz45562.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"虚树","slug":"虚树","permalink":"https://ctz45562.github.io/tags/%E8%99%9A%E6%A0%91/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://ctz45562.github.io/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"换根DP","slug":"换根DP","permalink":"https://ctz45562.github.io/tags/%E6%8D%A2%E6%A0%B9DP/"},{"name":"点分治","slug":"点分治","permalink":"https://ctz45562.github.io/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"},{"name":"后缀自动机","slug":"后缀自动机","permalink":"https://ctz45562.github.io/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"KMP","slug":"KMP","permalink":"https://ctz45562.github.io/tags/KMP/"},{"name":"后缀数组","slug":"后缀数组","permalink":"https://ctz45562.github.io/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"},{"name":"ST表","slug":"ST表","permalink":"https://ctz45562.github.io/tags/ST%E8%A1%A8/"},{"name":"多项式","slug":"多项式","permalink":"https://ctz45562.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"LCT","slug":"LCT","permalink":"https://ctz45562.github.io/tags/LCT/"},{"name":"计算几何","slug":"计算几何","permalink":"https://ctz45562.github.io/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"},{"name":"blog","slug":"blog","permalink":"https://ctz45562.github.io/tags/blog/"},{"name":"Linux","slug":"Linux","permalink":"https://ctz45562.github.io/tags/Linux/"},{"name":"Vim","slug":"Vim","permalink":"https://ctz45562.github.io/tags/Vim/"},{"name":"单调栈","slug":"单调栈","permalink":"https://ctz45562.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"斜率优化","slug":"斜率优化","permalink":"https://ctz45562.github.io/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"},{"name":"决策单调性","slug":"决策单调性","permalink":"https://ctz45562.github.io/tags/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"},{"name":"FFT/NTT","slug":"FFT-NTT","permalink":"https://ctz45562.github.io/tags/FFT-NTT/"},{"name":"prufer序列","slug":"prufer序列","permalink":"https://ctz45562.github.io/tags/prufer%E5%BA%8F%E5%88%97/"},{"name":"生成函数","slug":"生成函数","permalink":"https://ctz45562.github.io/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"},{"name":"组合数学","slug":"组合数学","permalink":"https://ctz45562.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"斯特林数","slug":"斯特林数","permalink":"https://ctz45562.github.io/tags/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"},{"name":"概率期望","slug":"概率期望","permalink":"https://ctz45562.github.io/tags/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/"},{"name":"卡特兰数","slug":"卡特兰数","permalink":"https://ctz45562.github.io/tags/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/"},{"name":"图论","slug":"图论","permalink":"https://ctz45562.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"容斥","slug":"容斥","permalink":"https://ctz45562.github.io/tags/%E5%AE%B9%E6%96%A5/"},{"name":"贪心","slug":"贪心","permalink":"https://ctz45562.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"长链剖分","slug":"长链剖分","permalink":"https://ctz45562.github.io/tags/%E9%95%BF%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"K-D Tree","slug":"K-D-Tree","permalink":"https://ctz45562.github.io/tags/K-D-Tree/"},{"name":"cdq分治","slug":"cdq分治","permalink":"https://ctz45562.github.io/tags/cdq%E5%88%86%E6%B2%BB/"},{"name":"单调队列","slug":"单调队列","permalink":"https://ctz45562.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"tarjan","slug":"tarjan","permalink":"https://ctz45562.github.io/tags/tarjan/"},{"name":"2-SAT","slug":"2-SAT","permalink":"https://ctz45562.github.io/tags/2-SAT/"},{"name":"高斯消元","slug":"高斯消元","permalink":"https://ctz45562.github.io/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"},{"name":"矩阵树定理","slug":"矩阵树定理","permalink":"https://ctz45562.github.io/tags/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/"},{"name":"并查集","slug":"并查集","permalink":"https://ctz45562.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"kruskal重构树","slug":"kruskal重构树","permalink":"https://ctz45562.github.io/tags/kruskal%E9%87%8D%E6%9E%84%E6%A0%91/"},{"name":"manacher","slug":"manacher","permalink":"https://ctz45562.github.io/tags/manacher/"},{"name":"线性基","slug":"线性基","permalink":"https://ctz45562.github.io/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"},{"name":"差分约束","slug":"差分约束","permalink":"https://ctz45562.github.io/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"},{"name":"二项式反演","slug":"二项式反演","permalink":"https://ctz45562.github.io/tags/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/"},{"name":"枚举","slug":"枚举","permalink":"https://ctz45562.github.io/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"卢卡斯定理","slug":"卢卡斯定理","permalink":"https://ctz45562.github.io/tags/%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86/"},{"name":"构造","slug":"构造","permalink":"https://ctz45562.github.io/tags/%E6%9E%84%E9%80%A0/"},{"name":"哈希","slug":"哈希","permalink":"https://ctz45562.github.io/tags/%E5%93%88%E5%B8%8C/"},{"name":"二分","slug":"二分","permalink":"https://ctz45562.github.io/tags/%E4%BA%8C%E5%88%86/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"https://ctz45562.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"逆元","slug":"逆元","permalink":"https://ctz45562.github.io/tags/%E9%80%86%E5%85%83/"},{"name":"状态压缩","slug":"状态压缩","permalink":"https://ctz45562.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"},{"name":"主席树","slug":"主席树","permalink":"https://ctz45562.github.io/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"name":"最短路","slug":"最短路","permalink":"https://ctz45562.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"永远的七日之都","slug":"永远的七日之都","permalink":"https://ctz45562.github.io/tags/%E6%B0%B8%E8%BF%9C%E7%9A%84%E4%B8%83%E6%97%A5%E4%B9%8B%E9%83%BD/"},{"name":"游戏","slug":"游戏","permalink":"https://ctz45562.github.io/tags/%E6%B8%B8%E6%88%8F/"},{"name":"高维前缀和","slug":"高维前缀和","permalink":"https://ctz45562.github.io/tags/%E9%AB%98%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"https://ctz45562.github.io/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"name":"杜教筛","slug":"杜教筛","permalink":"https://ctz45562.github.io/tags/%E6%9D%9C%E6%95%99%E7%AD%9B/"},{"name":"矩阵乘法","slug":"矩阵乘法","permalink":"https://ctz45562.github.io/tags/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"},{"name":"AC自动机","slug":"AC自动机","permalink":"https://ctz45562.github.io/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"数位DP","slug":"数位DP","permalink":"https://ctz45562.github.io/tags/%E6%95%B0%E4%BD%8DDP/"},{"name":"分块","slug":"分块","permalink":"https://ctz45562.github.io/tags/%E5%88%86%E5%9D%97/"},{"name":"平衡树","slug":"平衡树","permalink":"https://ctz45562.github.io/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"},{"name":"左偏树","slug":"左偏树","permalink":"https://ctz45562.github.io/tags/%E5%B7%A6%E5%81%8F%E6%A0%91/"},{"name":"斐波那契数列","slug":"斐波那契数列","permalink":"https://ctz45562.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"},{"name":"点分树","slug":"点分树","permalink":"https://ctz45562.github.io/tags/%E7%82%B9%E5%88%86%E6%A0%91/"},{"name":"LCA","slug":"LCA","permalink":"https://ctz45562.github.io/tags/LCA/"},{"name":"线段树合并","slug":"线段树合并","permalink":"https://ctz45562.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/"},{"name":"网络流","slug":"网络流","permalink":"https://ctz45562.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"最小割","slug":"最小割","permalink":"https://ctz45562.github.io/tags/%E6%9C%80%E5%B0%8F%E5%89%B2/"},{"name":"潮学","slug":"潮学","permalink":"https://ctz45562.github.io/tags/%E6%BD%AE%E5%AD%A6/"},{"name":"线段树","slug":"线段树","permalink":"https://ctz45562.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"可持久化","slug":"可持久化","permalink":"https://ctz45562.github.io/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"},{"name":"欧拉函数","slug":"欧拉函数","permalink":"https://ctz45562.github.io/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"},{"name":"树状数组","slug":"树状数组","permalink":"https://ctz45562.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"树套树","slug":"树套树","permalink":"https://ctz45562.github.io/tags/%E6%A0%91%E5%A5%97%E6%A0%91/"},{"name":"扫描线","slug":"扫描线","permalink":"https://ctz45562.github.io/tags/%E6%89%AB%E6%8F%8F%E7%BA%BF/"},{"name":"启发式合并","slug":"启发式合并","permalink":"https://ctz45562.github.io/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"},{"name":"dsu on tree","slug":"dsu-on-tree","permalink":"https://ctz45562.github.io/tags/dsu-on-tree/"},{"name":"标记永久化","slug":"标记永久化","permalink":"https://ctz45562.github.io/tags/%E6%A0%87%E8%AE%B0%E6%B0%B8%E4%B9%85%E5%8C%96/"}]}